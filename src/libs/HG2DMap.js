var Ou = Object.defineProperty;
var Du = (s, e, t) => e in s ? Ou(s, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : s[e] = t;
var v = (s, e, t) => (Du(s, typeof e != "symbol" ? e + "" : e, t), t);
class ku {
  /**
   * @param {string} type Type.
   */
  constructor(e) {
    this.propagationStopped, this.defaultPrevented, this.type = e, this.target = null;
  }
  /**
   * Prevent default. This means that no emulated `click`, `singleclick` or `doubleclick` events
   * will be fired.
   * @api
   */
  preventDefault() {
    this.defaultPrevented = !0;
  }
  /**
   * Stop event propagation.
   * @api
   */
  stopPropagation() {
    this.propagationStopped = !0;
  }
}
const Ye = ku, Ei = {
  /**
   * Triggered when a property is changed.
   * @event module:ol/Object.ObjectEvent#propertychange
   * @api
   */
  PROPERTYCHANGE: "propertychange"
};
class Nu {
  constructor() {
    this.disposed = !1;
  }
  /**
   * Clean up.
   */
  dispose() {
    this.disposed || (this.disposed = !0, this.disposeInternal());
  }
  /**
   * Extension point for disposable objects.
   * @protected
   */
  disposeInternal() {
  }
}
const wr = Nu;
function Gu(s, e, t) {
  let i, n;
  t = t || vi;
  let r = 0, o = s.length, a = !1;
  for (; r < o; )
    i = r + (o - r >> 1), n = +t(s[i], e), n < 0 ? r = i + 1 : (o = i, a = !n);
  return a ? r : ~r;
}
function vi(s, e) {
  return s > e ? 1 : s < e ? -1 : 0;
}
function Tr(s, e, t) {
  const i = s.length;
  if (s[0] <= e)
    return 0;
  if (e <= s[i - 1])
    return i - 1;
  let n;
  if (t > 0) {
    for (n = 1; n < i; ++n)
      if (s[n] < e)
        return n - 1;
  } else if (t < 0) {
    for (n = 1; n < i; ++n)
      if (s[n] <= e)
        return n;
  } else
    for (n = 1; n < i; ++n) {
      if (s[n] == e)
        return n;
      if (s[n] < e)
        return typeof t == "function" ? t(e, s[n - 1], s[n]) > 0 ? n - 1 : n : s[n - 1] - e < e - s[n] ? n - 1 : n;
    }
  return i - 1;
}
function Uu(s, e, t) {
  for (; e < t; ) {
    const i = s[e];
    s[e] = s[t], s[t] = i, ++e, --t;
  }
}
function ae(s, e) {
  const t = Array.isArray(e) ? e : [e], i = t.length;
  for (let n = 0; n < i; n++)
    s[s.length] = t[n];
}
function xt(s, e) {
  const t = s.length;
  if (t !== e.length)
    return !1;
  for (let i = 0; i < t; i++)
    if (s[i] !== e[i])
      return !1;
  return !0;
}
function zu(s, e, t) {
  const i = e || vi;
  return s.every(function(n, r) {
    if (r === 0)
      return !0;
    const o = i(s[r - 1], n);
    return !(o > 0 || t && o === 0);
  });
}
function mt() {
  return !0;
}
function cn() {
  return !1;
}
function nn() {
}
function Bu(s) {
  let e = !1, t, i, n;
  return function() {
    const r = Array.prototype.slice.call(arguments);
    return (!e || this !== n || !xt(r, i)) && (e = !0, n = this, i = r, t = s.apply(this, arguments)), t;
  };
}
function Ti(s) {
  for (const e in s)
    delete s[e];
}
function sn(s) {
  let e;
  for (e in s)
    return !1;
  return !e;
}
class Xu extends wr {
  /**
   * @param {*} [target] Default event target for dispatched events.
   */
  constructor(e) {
    super(), this.eventTarget_ = e, this.pendingRemovals_ = null, this.dispatching_ = null, this.listeners_ = null;
  }
  /**
   * @param {string} type Type.
   * @param {import("../events.js").Listener} listener Listener.
   */
  addEventListener(e, t) {
    if (!e || !t)
      return;
    const i = this.listeners_ || (this.listeners_ = {}), n = i[e] || (i[e] = []);
    n.includes(t) || n.push(t);
  }
  /**
   * Dispatches an event and calls all listeners listening for events
   * of this type. The event parameter can either be a string or an
   * Object with a `type` property.
   *
   * @param {import("./Event.js").default|string} event Event object.
   * @return {boolean|undefined} `false` if anyone called preventDefault on the
   *     event object or if any of the listeners returned false.
   * @api
   */
  dispatchEvent(e) {
    const t = typeof e == "string", i = t ? e : e.type, n = this.listeners_ && this.listeners_[i];
    if (!n)
      return;
    const r = t ? new Ye(e) : (
      /** @type {Event} */
      e
    );
    r.target || (r.target = this.eventTarget_ || this);
    const o = this.dispatching_ || (this.dispatching_ = {}), a = this.pendingRemovals_ || (this.pendingRemovals_ = {});
    i in o || (o[i] = 0, a[i] = 0), ++o[i];
    let l;
    for (let h = 0, c = n.length; h < c; ++h)
      if ("handleEvent" in n[h] ? l = /** @type {import("../events.js").ListenerObject} */
      n[h].handleEvent(r) : l = /** @type {import("../events.js").ListenerFunction} */
      n[h].call(this, r), l === !1 || r.propagationStopped) {
        l = !1;
        break;
      }
    if (--o[i] === 0) {
      let h = a[i];
      for (delete a[i]; h--; )
        this.removeEventListener(i, nn);
      delete o[i];
    }
    return l;
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    this.listeners_ && Ti(this.listeners_);
  }
  /**
   * Get the listeners for a specified event type. Listeners are returned in the
   * order that they will be called in.
   *
   * @param {string} type Type.
   * @return {Array<import("../events.js").Listener>|undefined} Listeners.
   */
  getListeners(e) {
    return this.listeners_ && this.listeners_[e] || void 0;
  }
  /**
   * @param {string} [type] Type. If not provided,
   *     `true` will be returned if this event target has any listeners.
   * @return {boolean} Has listeners.
   */
  hasListener(e) {
    return this.listeners_ ? e ? e in this.listeners_ : Object.keys(this.listeners_).length > 0 : !1;
  }
  /**
   * @param {string} type Type.
   * @param {import("../events.js").Listener} listener Listener.
   */
  removeEventListener(e, t) {
    const i = this.listeners_ && this.listeners_[e];
    if (i) {
      const n = i.indexOf(t);
      n !== -1 && (this.pendingRemovals_ && e in this.pendingRemovals_ ? (i[n] = nn, ++this.pendingRemovals_[e]) : (i.splice(n, 1), i.length === 0 && delete this.listeners_[e]));
    }
  }
}
const es = Xu, z = {
  /**
   * Generic change event. Triggered when the revision counter is increased.
   * @event module:ol/events/Event~BaseEvent#change
   * @api
   */
  CHANGE: "change",
  /**
   * Generic error event. Triggered when an error occurs.
   * @event module:ol/events/Event~BaseEvent#error
   * @api
   */
  ERROR: "error",
  BLUR: "blur",
  CLEAR: "clear",
  CONTEXTMENU: "contextmenu",
  CLICK: "click",
  DBLCLICK: "dblclick",
  DRAGENTER: "dragenter",
  DRAGOVER: "dragover",
  DROP: "drop",
  FOCUS: "focus",
  KEYDOWN: "keydown",
  KEYPRESS: "keypress",
  LOAD: "load",
  RESIZE: "resize",
  TOUCHMOVE: "touchmove",
  WHEEL: "wheel"
};
function H(s, e, t, i, n) {
  if (i && i !== s && (t = t.bind(i)), n) {
    const o = t;
    t = function() {
      s.removeEventListener(e, t), o.apply(this, arguments);
    };
  }
  const r = {
    target: s,
    type: e,
    listener: t
  };
  return s.addEventListener(e, t), r;
}
function kn(s, e, t, i) {
  return H(s, e, t, i, !0);
}
function re(s) {
  s && s.target && (s.target.removeEventListener(s.type, s.listener), Ti(s));
}
class ts extends es {
  constructor() {
    super(), this.on = /** @type {ObservableOnSignature<import("./events").EventsKey>} */
    this.onInternal, this.once = /** @type {ObservableOnSignature<import("./events").EventsKey>} */
    this.onceInternal, this.un = /** @type {ObservableOnSignature<void>} */
    this.unInternal, this.revision_ = 0;
  }
  /**
   * Increases the revision counter and dispatches a 'change' event.
   * @api
   */
  changed() {
    ++this.revision_, this.dispatchEvent(z.CHANGE);
  }
  /**
   * Get the version number for this object.  Each time the object is modified,
   * its version number will be incremented.
   * @return {number} Revision.
   * @api
   */
  getRevision() {
    return this.revision_;
  }
  /**
   * @param {string|Array<string>} type Type.
   * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
   * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Event key.
   * @protected
   */
  onInternal(e, t) {
    if (Array.isArray(e)) {
      const i = e.length, n = new Array(i);
      for (let r = 0; r < i; ++r)
        n[r] = H(this, e[r], t);
      return n;
    }
    return H(
      this,
      /** @type {string} */
      e,
      t
    );
  }
  /**
   * @param {string|Array<string>} type Type.
   * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
   * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Event key.
   * @protected
   */
  onceInternal(e, t) {
    let i;
    if (Array.isArray(e)) {
      const n = e.length;
      i = new Array(n);
      for (let r = 0; r < n; ++r)
        i[r] = kn(this, e[r], t);
    } else
      i = kn(
        this,
        /** @type {string} */
        e,
        t
      );
    return t.ol_key = i, i;
  }
  /**
   * Unlisten for a certain type of event.
   * @param {string|Array<string>} type Type.
   * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
   * @protected
   */
  unInternal(e, t) {
    const i = (
      /** @type {Object} */
      t.ol_key
    );
    if (i)
      aa(i);
    else if (Array.isArray(e))
      for (let n = 0, r = e.length; n < r; ++n)
        this.removeEventListener(e[n], t);
    else
      this.removeEventListener(e, t);
  }
}
ts.prototype.on;
ts.prototype.once;
ts.prototype.un;
function aa(s) {
  if (Array.isArray(s))
    for (let e = 0, t = s.length; e < t; ++e)
      re(s[e]);
  else
    re(
      /** @type {import("./events.js").EventsKey} */
      s
    );
}
function X() {
  throw new Error("Unimplemented abstract method.");
}
let Wu = 0;
function B(s) {
  return s.ol_uid || (s.ol_uid = String(++Wu));
}
class gl extends Ye {
  /**
   * @param {string} type The event type.
   * @param {string} key The property name.
   * @param {*} oldValue The old value for `key`.
   */
  constructor(e, t, i) {
    super(e), this.key = t, this.oldValue = i;
  }
}
class Yu extends ts {
  /**
   * @param {Object<string, *>} [values] An object with key-value pairs.
   */
  constructor(e) {
    super(), this.on, this.once, this.un, B(this), this.values_ = null, e !== void 0 && this.setProperties(e);
  }
  /**
   * Gets a value.
   * @param {string} key Key name.
   * @return {*} Value.
   * @api
   */
  get(e) {
    let t;
    return this.values_ && this.values_.hasOwnProperty(e) && (t = this.values_[e]), t;
  }
  /**
   * Get a list of object property names.
   * @return {Array<string>} List of property names.
   * @api
   */
  getKeys() {
    return this.values_ && Object.keys(this.values_) || [];
  }
  /**
   * Get an object of all property names and values.
   * @return {Object<string, *>} Object.
   * @api
   */
  getProperties() {
    return this.values_ && Object.assign({}, this.values_) || {};
  }
  /**
   * @return {boolean} The object has properties.
   */
  hasProperties() {
    return !!this.values_;
  }
  /**
   * @param {string} key Key name.
   * @param {*} oldValue Old value.
   */
  notify(e, t) {
    let i;
    i = `change:${e}`, this.hasListener(i) && this.dispatchEvent(new gl(i, e, t)), i = Ei.PROPERTYCHANGE, this.hasListener(i) && this.dispatchEvent(new gl(i, e, t));
  }
  /**
   * @param {string} key Key name.
   * @param {import("./events.js").Listener} listener Listener.
   */
  addChangeListener(e, t) {
    this.addEventListener(`change:${e}`, t);
  }
  /**
   * @param {string} key Key name.
   * @param {import("./events.js").Listener} listener Listener.
   */
  removeChangeListener(e, t) {
    this.removeEventListener(`change:${e}`, t);
  }
  /**
   * Sets a value.
   * @param {string} key Key name.
   * @param {*} value Value.
   * @param {boolean} [silent] Update without triggering an event.
   * @api
   */
  set(e, t, i) {
    const n = this.values_ || (this.values_ = {});
    if (i)
      n[e] = t;
    else {
      const r = n[e];
      n[e] = t, r !== t && this.notify(e, r);
    }
  }
  /**
   * Sets a collection of key-value pairs.  Note that this changes any existing
   * properties and adds new ones (it does not remove any existing properties).
   * @param {Object<string, *>} values Values.
   * @param {boolean} [silent] Update without triggering an event.
   * @api
   */
  setProperties(e, t) {
    for (const i in e)
      this.set(i, e[i], t);
  }
  /**
   * Apply any properties from another object without triggering events.
   * @param {BaseObject} source The source object.
   * @protected
   */
  applyProperties(e) {
    e.values_ && Object.assign(this.values_ || (this.values_ = {}), e.values_);
  }
  /**
   * Unsets a property.
   * @param {string} key Key name.
   * @param {boolean} [silent] Unset without triggering an event.
   * @api
   */
  unset(e, t) {
    if (this.values_ && e in this.values_) {
      const i = this.values_[e];
      delete this.values_[e], sn(this.values_) && (this.values_ = null), t || this.notify(e, i);
    }
  }
}
const ht = Yu, Vu = {
  1: "The view center is not defined",
  2: "The view resolution is not defined",
  3: "The view rotation is not defined",
  4: "`image` and `src` cannot be provided at the same time",
  5: "`imgSize` must be set when `image` is provided",
  7: "`format` must be set when `url` is set",
  8: "Unknown `serverType` configured",
  9: "`url` must be configured or set using `#setUrl()`",
  10: "The default `geometryFunction` can only handle `Point` geometries",
  11: "`options.featureTypes` must be an Array",
  12: "`options.geometryName` must also be provided when `options.bbox` is set",
  13: "Invalid corner",
  14: "Invalid color",
  15: "Tried to get a value for a key that does not exist in the cache",
  16: "Tried to set a value for a key that is used already",
  17: "`resolutions` must be sorted in descending order",
  18: "Either `origin` or `origins` must be configured, never both",
  19: "Number of `tileSizes` and `resolutions` must be equal",
  20: "Number of `origins` and `resolutions` must be equal",
  22: "Either `tileSize` or `tileSizes` must be configured, never both",
  24: "Invalid extent or geometry provided as `geometry`",
  25: "Cannot fit empty extent provided as `geometry`",
  26: "Features must have an id set",
  27: "Features must have an id set",
  28: '`renderMode` must be `"hybrid"` or `"vector"`',
  30: "The passed `feature` was already added to the source",
  31: "Tried to enqueue an `element` that was already added to the queue",
  32: "Transformation matrix cannot be inverted",
  33: "Invalid units",
  34: "Invalid geometry layout",
  36: "Unknown SRS type",
  37: "Unknown geometry type found",
  38: "`styleMapValue` has an unknown type",
  39: "Unknown geometry type",
  40: "Expected `feature` to have a geometry",
  41: "Expected an `ol/style/Style` or an array of `ol/style/Style.js`",
  42: "Question unknown, the answer is 42",
  43: "Expected `layers` to be an array or a `Collection`",
  47: "Expected `controls` to be an array or an `ol/Collection`",
  48: "Expected `interactions` to be an array or an `ol/Collection`",
  49: "Expected `overlays` to be an array or an `ol/Collection`",
  50: "`options.featureTypes` should be an Array",
  51: "Either `url` or `tileJSON` options must be provided",
  52: "Unknown `serverType` configured",
  53: "Unknown `tierSizeCalculation` configured",
  55: "The {-y} placeholder requires a tile grid with extent",
  56: "mapBrowserEvent must originate from a pointer event",
  57: "At least 2 conditions are required",
  59: "Invalid command found in the PBF",
  60: "Missing or invalid `size`",
  61: "Cannot determine IIIF Image API version from provided image information JSON",
  62: "A `WebGLArrayBuffer` must either be of type `ELEMENT_ARRAY_BUFFER` or `ARRAY_BUFFER`",
  64: "Layer opacity must be a number",
  66: "`forEachFeatureAtCoordinate` cannot be used on a WebGL layer if the hit detection logic has not been enabled. This is done by providing adequate shaders using the `hitVertexShader` and `hitFragmentShader` properties of `WebGLPointsLayerRenderer`",
  67: "A layer can only be added to the map once. Use either `layer.setMap()` or `map.addLayer()`, not both",
  68: "A VectorTile source can only be rendered if it has a projection compatible with the view projection",
  69: "`width` or `height` cannot be provided together with `scale`"
};
class Zu extends Error {
  /**
   * @param {number} code Error code.
   */
  constructor(e) {
    const t = Vu[e];
    super(t), this.code = e, this.name = "AssertionError", this.message = t;
  }
}
const Lh = Zu, ve = {
  /**
   * Triggered when an item is added to the collection.
   * @event module:ol/Collection.CollectionEvent#add
   * @api
   */
  ADD: "add",
  /**
   * Triggered when an item is removed from the collection.
   * @event module:ol/Collection.CollectionEvent#remove
   * @api
   */
  REMOVE: "remove"
}, _l = {
  LENGTH: "length"
};
class Ts extends Ye {
  /**
   * @param {import("./CollectionEventType.js").default} type Type.
   * @param {T} element Element.
   * @param {number} index The index of the added or removed element.
   */
  constructor(e, t, i) {
    super(e), this.element = t, this.index = i;
  }
}
class ju extends ht {
  /**
   * @param {Array<T>} [array] Array.
   * @param {Options} [options] Collection options.
   */
  constructor(e, t) {
    if (super(), this.on, this.once, this.un, t = t || {}, this.unique_ = !!t.unique, this.array_ = e || [], this.unique_)
      for (let i = 0, n = this.array_.length; i < n; ++i)
        this.assertUnique_(this.array_[i], i);
    this.updateLength_();
  }
  /**
   * Remove all elements from the collection.
   * @api
   */
  clear() {
    for (; this.getLength() > 0; )
      this.pop();
  }
  /**
   * Add elements to the collection.  This pushes each item in the provided array
   * to the end of the collection.
   * @param {!Array<T>} arr Array.
   * @return {Collection<T>} This collection.
   * @api
   */
  extend(e) {
    for (let t = 0, i = e.length; t < i; ++t)
      this.push(e[t]);
    return this;
  }
  /**
   * Iterate over each element, calling the provided callback.
   * @param {function(T, number, Array<T>): *} f The function to call
   *     for every element. This function takes 3 arguments (the element, the
   *     index and the array). The return value is ignored.
   * @api
   */
  forEach(e) {
    const t = this.array_;
    for (let i = 0, n = t.length; i < n; ++i)
      e(t[i], i, t);
  }
  /**
   * Get a reference to the underlying Array object. Warning: if the array
   * is mutated, no events will be dispatched by the collection, and the
   * collection's "length" property won't be in sync with the actual length
   * of the array.
   * @return {!Array<T>} Array.
   * @api
   */
  getArray() {
    return this.array_;
  }
  /**
   * Get the element at the provided index.
   * @param {number} index Index.
   * @return {T} Element.
   * @api
   */
  item(e) {
    return this.array_[e];
  }
  /**
   * Get the length of this collection.
   * @return {number} The length of the array.
   * @observable
   * @api
   */
  getLength() {
    return this.get(_l.LENGTH);
  }
  /**
   * Insert an element at the provided index.
   * @param {number} index Index.
   * @param {T} elem Element.
   * @api
   */
  insertAt(e, t) {
    if (e < 0 || e > this.getLength())
      throw new Error("Index out of bounds: " + e);
    this.unique_ && this.assertUnique_(t), this.array_.splice(e, 0, t), this.updateLength_(), this.dispatchEvent(
      new Ts(ve.ADD, t, e)
    );
  }
  /**
   * Remove the last element of the collection and return it.
   * Return `undefined` if the collection is empty.
   * @return {T|undefined} Element.
   * @api
   */
  pop() {
    return this.removeAt(this.getLength() - 1);
  }
  /**
   * Insert the provided element at the end of the collection.
   * @param {T} elem Element.
   * @return {number} New length of the collection.
   * @api
   */
  push(e) {
    this.unique_ && this.assertUnique_(e);
    const t = this.getLength();
    return this.insertAt(t, e), this.getLength();
  }
  /**
   * Remove the first occurrence of an element from the collection.
   * @param {T} elem Element.
   * @return {T|undefined} The removed element or undefined if none found.
   * @api
   */
  remove(e) {
    const t = this.array_;
    for (let i = 0, n = t.length; i < n; ++i)
      if (t[i] === e)
        return this.removeAt(i);
  }
  /**
   * Remove the element at the provided index and return it.
   * Return `undefined` if the collection does not contain this index.
   * @param {number} index Index.
   * @return {T|undefined} Value.
   * @api
   */
  removeAt(e) {
    if (e < 0 || e >= this.getLength())
      return;
    const t = this.array_[e];
    return this.array_.splice(e, 1), this.updateLength_(), this.dispatchEvent(
      /** @type {CollectionEvent<T>} */
      new Ts(ve.REMOVE, t, e)
    ), t;
  }
  /**
   * Set the element at the provided index.
   * @param {number} index Index.
   * @param {T} elem Element.
   * @api
   */
  setAt(e, t) {
    const i = this.getLength();
    if (e >= i) {
      this.insertAt(e, t);
      return;
    }
    if (e < 0)
      throw new Error("Index out of bounds: " + e);
    this.unique_ && this.assertUnique_(t, e);
    const n = this.array_[e];
    this.array_[e] = t, this.dispatchEvent(
      /** @type {CollectionEvent<T>} */
      new Ts(ve.REMOVE, n, e)
    ), this.dispatchEvent(
      /** @type {CollectionEvent<T>} */
      new Ts(ve.ADD, t, e)
    );
  }
  /**
   * @private
   */
  updateLength_() {
    this.set(_l.LENGTH, this.array_.length);
  }
  /**
   * @private
   * @param {T} elem Element.
   * @param {number} [except] Optional index to ignore.
   */
  assertUnique_(e, t) {
    for (let i = 0, n = this.array_.length; i < n; ++i)
      if (this.array_[i] === e && i !== t)
        throw new Lh(58);
  }
}
const ce = ju, ei = typeof navigator < "u" && typeof navigator.userAgent < "u" ? navigator.userAgent.toLowerCase() : "", Hu = ei.includes("firefox"), Ku = ei.includes("safari") && !ei.includes("chrom"), qu = Ku && (ei.includes("version/15.4") || /cpu (os|iphone os) 15_4 like mac os x/.test(ei)), Ju = ei.includes("webkit") && !ei.includes("edge"), $u = ei.includes("macintosh"), Ah = typeof devicePixelRatio < "u" ? devicePixelRatio : 1, la = typeof WorkerGlobalScope < "u" && typeof OffscreenCanvas < "u" && self instanceof WorkerGlobalScope, Qu = typeof Image < "u" && Image.prototype.decode, Fh = function() {
  let s = !1;
  try {
    const e = Object.defineProperty({}, "passive", {
      get: function() {
        s = !0;
      }
    });
    window.addEventListener("_", null, e), window.removeEventListener("_", null, e);
  } catch {
  }
  return s;
}();
function Z(s, e) {
  if (!s)
    throw new Lh(e);
}
const ha = new Array(6);
function Se() {
  return [1, 0, 0, 1, 0, 0];
}
function Zr(s) {
  return is(s, 1, 0, 0, 1, 0, 0);
}
function Nn(s, e) {
  const t = s[0], i = s[1], n = s[2], r = s[3], o = s[4], a = s[5], l = e[0], h = e[1], c = e[2], u = e[3], d = e[4], f = e[5];
  return s[0] = t * l + n * h, s[1] = i * l + r * h, s[2] = t * c + n * u, s[3] = i * c + r * u, s[4] = t * d + n * f + o, s[5] = i * d + r * f + a, s;
}
function is(s, e, t, i, n, r, o) {
  return s[0] = e, s[1] = t, s[2] = i, s[3] = n, s[4] = r, s[5] = o, s;
}
function ed(s, e) {
  return s[0] = e[0], s[1] = e[1], s[2] = e[2], s[3] = e[3], s[4] = e[4], s[5] = e[5], s;
}
function de(s, e) {
  const t = e[0], i = e[1];
  return e[0] = s[0] * t + s[2] * i + s[4], e[1] = s[1] * t + s[3] * i + s[5], e;
}
function td(s, e) {
  const t = Math.cos(e), i = Math.sin(e);
  return Nn(s, is(ha, t, i, -i, t, 0, 0));
}
function id(s, e, t) {
  return Nn(s, is(ha, e, 0, 0, t, 0, 0));
}
function nd(s, e, t) {
  return is(s, e, 0, 0, t, 0, 0);
}
function ml(s, e, t) {
  return Nn(s, is(ha, 1, 0, 0, 1, e, t));
}
function Je(s, e, t, i, n, r, o, a) {
  const l = Math.sin(r), h = Math.cos(r);
  return s[0] = i * h, s[1] = n * l, s[2] = -i * l, s[3] = n * h, s[4] = o * i * h - a * i * l + e, s[5] = o * n * l + a * n * h + t, s;
}
function ns(s, e) {
  const t = sd(e);
  Z(t !== 0, 32);
  const i = e[0], n = e[1], r = e[2], o = e[3], a = e[4], l = e[5];
  return s[0] = o / t, s[1] = -n / t, s[2] = -r / t, s[3] = i / t, s[4] = (r * l - o * a) / t, s[5] = -(i * l - n * a) / t, s;
}
function sd(s) {
  return s[0] * s[3] - s[1] * s[2];
}
let pl;
function ca(s) {
  const e = "matrix(" + s.join(", ") + ")";
  if (la)
    return e;
  const t = pl || (pl = document.createElement("div"));
  return t.style.transform = e, t.style.transform;
}
const Te = {
  UNKNOWN: 0,
  INTERSECTING: 1,
  ABOVE: 2,
  RIGHT: 4,
  BELOW: 8,
  LEFT: 16
};
function ze(s) {
  const e = Me();
  for (let t = 0, i = s.length; t < i; ++t)
    Ln(e, s[t]);
  return e;
}
function Si(s, e, t) {
  return t ? (t[0] = s[0] - e, t[1] = s[1] - e, t[2] = s[2] + e, t[3] = s[3] + e, t) : [
    s[0] - e,
    s[1] - e,
    s[2] + e,
    s[3] + e
  ];
}
function bh(s, e) {
  return e ? (e[0] = s[0], e[1] = s[1], e[2] = s[2], e[3] = s[3], e) : s.slice();
}
function Ri(s, e, t) {
  let i, n;
  return e < s[0] ? i = s[0] - e : s[2] < e ? i = e - s[2] : i = 0, t < s[1] ? n = s[1] - t : s[3] < t ? n = t - s[3] : n = 0, i * i + n * n;
}
function ss(s, e) {
  return ua(s, e[0], e[1]);
}
function Ft(s, e) {
  return s[0] <= e[0] && e[2] <= s[2] && s[1] <= e[1] && e[3] <= s[3];
}
function ua(s, e, t) {
  return s[0] <= e && e <= s[2] && s[1] <= t && t <= s[3];
}
function Ao(s, e) {
  const t = s[0], i = s[1], n = s[2], r = s[3], o = e[0], a = e[1];
  let l = Te.UNKNOWN;
  return o < t ? l = l | Te.LEFT : o > n && (l = l | Te.RIGHT), a < i ? l = l | Te.BELOW : a > r && (l = l | Te.ABOVE), l === Te.UNKNOWN && (l = Te.INTERSECTING), l;
}
function Me() {
  return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
}
function pt(s, e, t, i, n) {
  return n ? (n[0] = s, n[1] = e, n[2] = t, n[3] = i, n) : [s, e, t, i];
}
function rs(s) {
  return pt(1 / 0, 1 / 0, -1 / 0, -1 / 0, s);
}
function Rn(s, e) {
  const t = s[0], i = s[1];
  return pt(t, i, t, i, e);
}
function Ph(s, e, t, i, n) {
  const r = rs(n);
  return Mh(r, s, e, t, i);
}
function ti(s, e) {
  return s[0] == e[0] && s[2] == e[2] && s[1] == e[1] && s[3] == e[3];
}
function In(s, e) {
  return e[0] < s[0] && (s[0] = e[0]), e[2] > s[2] && (s[2] = e[2]), e[1] < s[1] && (s[1] = e[1]), e[3] > s[3] && (s[3] = e[3]), s;
}
function Ln(s, e) {
  e[0] < s[0] && (s[0] = e[0]), e[0] > s[2] && (s[2] = e[0]), e[1] < s[1] && (s[1] = e[1]), e[1] > s[3] && (s[3] = e[1]);
}
function Mh(s, e, t, i, n) {
  for (; t < i; t += n)
    rd(s, e[t], e[t + 1]);
  return s;
}
function rd(s, e, t) {
  s[0] = Math.min(s[0], e), s[1] = Math.min(s[1], t), s[2] = Math.max(s[2], e), s[3] = Math.max(s[3], t);
}
function da(s, e) {
  let t;
  return t = e(rn(s)), t || (t = e(un(s)), t) || (t = e(os(s)), t) || (t = e(Ot(s)), t) ? t : !1;
}
function Fo(s) {
  let e = 0;
  return as(s) || (e = te(s) * Fe(s)), e;
}
function rn(s) {
  return [s[0], s[1]];
}
function un(s) {
  return [s[2], s[1]];
}
function Ne(s) {
  return [(s[0] + s[2]) / 2, (s[1] + s[3]) / 2];
}
function od(s, e) {
  let t;
  return e === "bottom-left" ? t = rn(s) : e === "bottom-right" ? t = un(s) : e === "top-left" ? t = Ot(s) : e === "top-right" ? t = os(s) : Z(!1, 13), t;
}
function bo(s, e, t, i, n) {
  const [r, o, a, l, h, c, u, d] = Po(
    s,
    e,
    t,
    i
  );
  return pt(
    Math.min(r, a, h, u),
    Math.min(o, l, c, d),
    Math.max(r, a, h, u),
    Math.max(o, l, c, d),
    n
  );
}
function Po(s, e, t, i) {
  const n = e * i[0] / 2, r = e * i[1] / 2, o = Math.cos(t), a = Math.sin(t), l = n * o, h = n * a, c = r * o, u = r * a, d = s[0], f = s[1];
  return [
    d - l + u,
    f - h - c,
    d - l - u,
    f - h + c,
    d + l - u,
    f + h + c,
    d + l + u,
    f + h - c,
    d - l + u,
    f - h - c
  ];
}
function Fe(s) {
  return s[3] - s[1];
}
function pi(s, e, t) {
  const i = t || Me();
  return Ce(s, e) ? (s[0] > e[0] ? i[0] = s[0] : i[0] = e[0], s[1] > e[1] ? i[1] = s[1] : i[1] = e[1], s[2] < e[2] ? i[2] = s[2] : i[2] = e[2], s[3] < e[3] ? i[3] = s[3] : i[3] = e[3]) : rs(i), i;
}
function Ot(s) {
  return [s[0], s[3]];
}
function os(s) {
  return [s[2], s[3]];
}
function te(s) {
  return s[2] - s[0];
}
function Ce(s, e) {
  return s[0] <= e[2] && s[2] >= e[0] && s[1] <= e[3] && s[3] >= e[1];
}
function as(s) {
  return s[2] < s[0] || s[3] < s[1];
}
function ad(s, e) {
  return e ? (e[0] = s[0], e[1] = s[1], e[2] = s[2], e[3] = s[3], e) : s;
}
function Oh(s, e) {
  const t = (s[2] - s[0]) / 2 * (e - 1), i = (s[3] - s[1]) / 2 * (e - 1);
  s[0] -= t, s[2] += t, s[1] -= i, s[3] += i;
}
function ld(s, e, t) {
  let i = !1;
  const n = Ao(s, e), r = Ao(s, t);
  if (n === Te.INTERSECTING || r === Te.INTERSECTING)
    i = !0;
  else {
    const o = s[0], a = s[1], l = s[2], h = s[3], c = e[0], u = e[1], d = t[0], f = t[1], g = (f - u) / (d - c);
    let _, m;
    r & Te.ABOVE && !(n & Te.ABOVE) && (_ = d - (f - h) / g, i = _ >= o && _ <= l), !i && r & Te.RIGHT && !(n & Te.RIGHT) && (m = f - (d - l) * g, i = m >= a && m <= h), !i && r & Te.BELOW && !(n & Te.BELOW) && (_ = d - (f - a) / g, i = _ >= o && _ <= l), !i && r & Te.LEFT && !(n & Te.LEFT) && (m = f - (d - o) * g, i = m >= a && m <= h);
  }
  return i;
}
function Dh(s, e) {
  const t = e.getExtent(), i = Ne(s);
  if (e.canWrapX() && (i[0] < t[0] || i[0] >= t[2])) {
    const n = te(t), o = Math.floor(
      (i[0] - t[0]) / n
    ) * n;
    s[0] -= o, s[2] -= o;
  }
  return s;
}
function hd(s, e) {
  if (e.canWrapX()) {
    const t = e.getExtent();
    if (!isFinite(s[0]) || !isFinite(s[2]))
      return [[t[0], s[1], t[2], s[3]]];
    Dh(s, e);
    const i = te(t);
    if (te(s) > i)
      return [[t[0], s[1], t[2], s[3]]];
    if (s[0] < t[0])
      return [
        [s[0] + i, s[1], t[2], s[3]],
        [t[0], s[1], s[2], s[3]]
      ];
    if (s[2] > t[2])
      return [
        [s[0], s[1], t[2], s[3]],
        [t[0], s[1], s[2] - i, s[3]]
      ];
  }
  return [s];
}
function _e(s, e, t) {
  return Math.min(Math.max(s, e), t);
}
function cd(s, e, t, i, n, r) {
  const o = n - t, a = r - i;
  if (o !== 0 || a !== 0) {
    const l = ((s - t) * o + (e - i) * a) / (o * o + a * a);
    l > 1 ? (t = n, i = r) : l > 0 && (t += o * l, i += a * l);
  }
  return bt(s, e, t, i);
}
function bt(s, e, t, i) {
  const n = t - s, r = i - e;
  return n * n + r * r;
}
function ud(s) {
  const e = s.length;
  for (let i = 0; i < e; i++) {
    let n = i, r = Math.abs(s[i][i]);
    for (let a = i + 1; a < e; a++) {
      const l = Math.abs(s[a][i]);
      l > r && (r = l, n = a);
    }
    if (r === 0)
      return null;
    const o = s[n];
    s[n] = s[i], s[i] = o;
    for (let a = i + 1; a < e; a++) {
      const l = -s[a][i] / s[i][i];
      for (let h = i; h < e + 1; h++)
        i == h ? s[a][h] = 0 : s[a][h] += l * s[i][h];
    }
  }
  const t = new Array(e);
  for (let i = e - 1; i >= 0; i--) {
    t[i] = s[i][e] / s[i][i];
    for (let n = i - 1; n >= 0; n--)
      s[n][e] -= s[n][i] * t[i];
  }
  return t;
}
function Qt(s) {
  return s * Math.PI / 180;
}
function yi(s, e) {
  const t = s % e;
  return t * e < 0 ? t + e : t;
}
function He(s, e, t) {
  return s + t * (e - s);
}
function Sr(s, e) {
  const t = Math.pow(10, e);
  return Math.round(s * t) / t;
}
function Ss(s, e) {
  return Math.floor(Sr(s, e));
}
function Rs(s, e) {
  return Math.ceil(Sr(s, e));
}
const dd = /^#([a-f0-9]{3}|[a-f0-9]{4}(?:[a-f0-9]{2}){0,2})$/i, fd = /^([a-z]*)$|^hsla?\(.*\)$/i;
function kh(s) {
  return typeof s == "string" ? s : Nh(s);
}
function gd(s) {
  const e = document.createElement("div");
  if (e.style.color = s, e.style.color !== "") {
    document.body.appendChild(e);
    const t = getComputedStyle(e).color;
    return document.body.removeChild(e), t;
  }
  return "";
}
const _d = function() {
  const e = {};
  let t = 0;
  return (
    /**
     * @param {string} s String.
     * @return {Color} Color.
     */
    function(i) {
      let n;
      if (e.hasOwnProperty(i))
        n = e[i];
      else {
        if (t >= 1024) {
          let r = 0;
          for (const o in e)
            r++ & 3 || (delete e[o], --t);
        }
        n = md(i), e[i] = n, ++t;
      }
      return n;
    }
  );
}();
function Gn(s) {
  return Array.isArray(s) ? s : _d(s);
}
function md(s) {
  let e, t, i, n, r;
  if (fd.exec(s) && (s = gd(s)), dd.exec(s)) {
    const o = s.length - 1;
    let a;
    o <= 4 ? a = 1 : a = 2;
    const l = o === 4 || o === 8;
    e = parseInt(s.substr(1 + 0 * a, a), 16), t = parseInt(s.substr(1 + 1 * a, a), 16), i = parseInt(s.substr(1 + 2 * a, a), 16), l ? n = parseInt(s.substr(1 + 3 * a, a), 16) : n = 255, a == 1 && (e = (e << 4) + e, t = (t << 4) + t, i = (i << 4) + i, l && (n = (n << 4) + n)), r = [e, t, i, n / 255];
  } else
    s.startsWith("rgba(") ? (r = s.slice(5, -1).split(",").map(Number), yl(r)) : s.startsWith("rgb(") ? (r = s.slice(4, -1).split(",").map(Number), r.push(1), yl(r)) : Z(!1, 14);
  return r;
}
function yl(s) {
  return s[0] = _e(s[0] + 0.5 | 0, 0, 255), s[1] = _e(s[1] + 0.5 | 0, 0, 255), s[2] = _e(s[2] + 0.5 | 0, 0, 255), s[3] = _e(s[3], 0, 1), s;
}
function Nh(s) {
  let e = s[0];
  e != (e | 0) && (e = e + 0.5 | 0);
  let t = s[1];
  t != (t | 0) && (t = t + 0.5 | 0);
  let i = s[2];
  i != (i | 0) && (i = i + 0.5 | 0);
  const n = s[3] === void 0 ? 1 : Math.round(s[3] * 100) / 100;
  return "rgba(" + e + "," + t + "," + i + "," + n + ")";
}
class pd {
  constructor() {
    this.cache_ = {}, this.cacheSize_ = 0, this.maxCacheSize_ = 32;
  }
  /**
   * FIXME empty description for jsdoc
   */
  clear() {
    this.cache_ = {}, this.cacheSize_ = 0;
  }
  /**
   * @return {boolean} Can expire cache.
   */
  canExpireCache() {
    return this.cacheSize_ > this.maxCacheSize_;
  }
  /**
   * FIXME empty description for jsdoc
   */
  expire() {
    if (this.canExpireCache()) {
      let e = 0;
      for (const t in this.cache_) {
        const i = this.cache_[t];
        !(e++ & 3) && !i.hasListener() && (delete this.cache_[t], --this.cacheSize_);
      }
    }
  }
  /**
   * @param {string} src Src.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../color.js").Color} color Color.
   * @return {import("./IconImage.js").default} Icon image.
   */
  get(e, t, i) {
    const n = xl(e, t, i);
    return n in this.cache_ ? this.cache_[n] : null;
  }
  /**
   * @param {string} src Src.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../color.js").Color} color Color.
   * @param {import("./IconImage.js").default} iconImage Icon image.
   */
  set(e, t, i, n) {
    const r = xl(e, t, i);
    this.cache_[r] = n, ++this.cacheSize_;
  }
  /**
   * Set the cache size of the icon cache. Default is `32`. Change this value when
   * your map uses more than 32 different icon images and you are not caching icon
   * styles on the application level.
   * @param {number} maxCacheSize Cache max size.
   * @api
   */
  setSize(e) {
    this.maxCacheSize_ = e, this.expire();
  }
}
function xl(s, e, t) {
  const i = t ? kh(t) : "null";
  return e + ":" + s + ":" + i;
}
const Qs = new pd(), ne = {
  OPACITY: "opacity",
  VISIBLE: "visible",
  EXTENT: "extent",
  Z_INDEX: "zIndex",
  MAX_RESOLUTION: "maxResolution",
  MIN_RESOLUTION: "minResolution",
  MAX_ZOOM: "maxZoom",
  MIN_ZOOM: "minZoom",
  SOURCE: "source",
  MAP: "map"
};
class yd extends ht {
  /**
   * @param {Options} options Layer options.
   */
  constructor(e) {
    super(), this.on, this.once, this.un, this.background_ = e.background;
    const t = Object.assign({}, e);
    typeof e.properties == "object" && (delete t.properties, Object.assign(t, e.properties)), t[ne.OPACITY] = e.opacity !== void 0 ? e.opacity : 1, Z(typeof t[ne.OPACITY] == "number", 64), t[ne.VISIBLE] = e.visible !== void 0 ? e.visible : !0, t[ne.Z_INDEX] = e.zIndex, t[ne.MAX_RESOLUTION] = e.maxResolution !== void 0 ? e.maxResolution : 1 / 0, t[ne.MIN_RESOLUTION] = e.minResolution !== void 0 ? e.minResolution : 0, t[ne.MIN_ZOOM] = e.minZoom !== void 0 ? e.minZoom : -1 / 0, t[ne.MAX_ZOOM] = e.maxZoom !== void 0 ? e.maxZoom : 1 / 0, this.className_ = t.className !== void 0 ? t.className : "ol-layer", delete t.className, this.setProperties(t), this.state_ = null;
  }
  /**
   * Get the background for this layer.
   * @return {BackgroundColor|false} Layer background.
   */
  getBackground() {
    return this.background_;
  }
  /**
   * @return {string} CSS class name.
   */
  getClassName() {
    return this.className_;
  }
  /**
   * This method is not meant to be called by layers or layer renderers because the state
   * is incorrect if the layer is included in a layer group.
   *
   * @param {boolean} [managed] Layer is managed.
   * @return {import("./Layer.js").State} Layer state.
   */
  getLayerState(e) {
    const t = this.state_ || /** @type {?} */
    {
      layer: this,
      managed: e === void 0 ? !0 : e
    }, i = this.getZIndex();
    return t.opacity = _e(Math.round(this.getOpacity() * 100) / 100, 0, 1), t.visible = this.getVisible(), t.extent = this.getExtent(), t.zIndex = i === void 0 && !t.managed ? 1 / 0 : i, t.maxResolution = this.getMaxResolution(), t.minResolution = Math.max(this.getMinResolution(), 0), t.minZoom = this.getMinZoom(), t.maxZoom = this.getMaxZoom(), this.state_ = t, t;
  }
  /**
   * @abstract
   * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be
   *     modified in place).
   * @return {Array<import("./Layer.js").default>} Array of layers.
   */
  getLayersArray(e) {
    return X();
  }
  /**
   * @abstract
   * @param {Array<import("./Layer.js").State>} [states] Optional list of layer
   *     states (to be modified in place).
   * @return {Array<import("./Layer.js").State>} List of layer states.
   */
  getLayerStatesArray(e) {
    return X();
  }
  /**
   * Return the {@link module:ol/extent~Extent extent} of the layer or `undefined` if it
   * will be visible regardless of extent.
   * @return {import("../extent.js").Extent|undefined} The layer extent.
   * @observable
   * @api
   */
  getExtent() {
    return (
      /** @type {import("../extent.js").Extent|undefined} */
      this.get(ne.EXTENT)
    );
  }
  /**
   * Return the maximum resolution of the layer.
   * @return {number} The maximum resolution of the layer.
   * @observable
   * @api
   */
  getMaxResolution() {
    return (
      /** @type {number} */
      this.get(ne.MAX_RESOLUTION)
    );
  }
  /**
   * Return the minimum resolution of the layer.
   * @return {number} The minimum resolution of the layer.
   * @observable
   * @api
   */
  getMinResolution() {
    return (
      /** @type {number} */
      this.get(ne.MIN_RESOLUTION)
    );
  }
  /**
   * Return the minimum zoom level of the layer.
   * @return {number} The minimum zoom level of the layer.
   * @observable
   * @api
   */
  getMinZoom() {
    return (
      /** @type {number} */
      this.get(ne.MIN_ZOOM)
    );
  }
  /**
   * Return the maximum zoom level of the layer.
   * @return {number} The maximum zoom level of the layer.
   * @observable
   * @api
   */
  getMaxZoom() {
    return (
      /** @type {number} */
      this.get(ne.MAX_ZOOM)
    );
  }
  /**
   * Return the opacity of the layer (between 0 and 1).
   * @return {number} The opacity of the layer.
   * @observable
   * @api
   */
  getOpacity() {
    return (
      /** @type {number} */
      this.get(ne.OPACITY)
    );
  }
  /**
   * @abstract
   * @return {import("../source/Source.js").State} Source state.
   */
  getSourceState() {
    return X();
  }
  /**
   * Return the visibility of the layer (`true` or `false`).
   * @return {boolean} The visibility of the layer.
   * @observable
   * @api
   */
  getVisible() {
    return (
      /** @type {boolean} */
      this.get(ne.VISIBLE)
    );
  }
  /**
   * Return the Z-index of the layer, which is used to order layers before
   * rendering. The default Z-index is 0.
   * @return {number} The Z-index of the layer.
   * @observable
   * @api
   */
  getZIndex() {
    return (
      /** @type {number} */
      this.get(ne.Z_INDEX)
    );
  }
  /**
   * Sets the background color.
   * @param {BackgroundColor} [background] Background color.
   */
  setBackground(e) {
    this.background_ = e, this.changed();
  }
  /**
   * Set the extent at which the layer is visible.  If `undefined`, the layer
   * will be visible at all extents.
   * @param {import("../extent.js").Extent|undefined} extent The extent of the layer.
   * @observable
   * @api
   */
  setExtent(e) {
    this.set(ne.EXTENT, e);
  }
  /**
   * Set the maximum resolution at which the layer is visible.
   * @param {number} maxResolution The maximum resolution of the layer.
   * @observable
   * @api
   */
  setMaxResolution(e) {
    this.set(ne.MAX_RESOLUTION, e);
  }
  /**
   * Set the minimum resolution at which the layer is visible.
   * @param {number} minResolution The minimum resolution of the layer.
   * @observable
   * @api
   */
  setMinResolution(e) {
    this.set(ne.MIN_RESOLUTION, e);
  }
  /**
   * Set the maximum zoom (exclusive) at which the layer is visible.
   * Note that the zoom levels for layer visibility are based on the
   * view zoom level, which may be different from a tile source zoom level.
   * @param {number} maxZoom The maximum zoom of the layer.
   * @observable
   * @api
   */
  setMaxZoom(e) {
    this.set(ne.MAX_ZOOM, e);
  }
  /**
   * Set the minimum zoom (inclusive) at which the layer is visible.
   * Note that the zoom levels for layer visibility are based on the
   * view zoom level, which may be different from a tile source zoom level.
   * @param {number} minZoom The minimum zoom of the layer.
   * @observable
   * @api
   */
  setMinZoom(e) {
    this.set(ne.MIN_ZOOM, e);
  }
  /**
   * Set the opacity of the layer, allowed values range from 0 to 1.
   * @param {number} opacity The opacity of the layer.
   * @observable
   * @api
   */
  setOpacity(e) {
    Z(typeof e == "number", 64), this.set(ne.OPACITY, e);
  }
  /**
   * Set the visibility of the layer (`true` or `false`).
   * @param {boolean} visible The visibility of the layer.
   * @observable
   * @api
   */
  setVisible(e) {
    this.set(ne.VISIBLE, e);
  }
  /**
   * Set Z-index of the layer, which is used to order layers before rendering.
   * The default Z-index is 0.
   * @param {number} zindex The z-index of the layer.
   * @observable
   * @api
   */
  setZIndex(e) {
    this.set(ne.Z_INDEX, e);
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    this.state_ && (this.state_.layer = null, this.state_ = null), super.disposeInternal();
  }
}
const Gh = yd, Xe = {
  /**
   * Triggered before a layer is rendered.
   * @event module:ol/render/Event~RenderEvent#prerender
   * @api
   */
  PRERENDER: "prerender",
  /**
   * Triggered after a layer is rendered.
   * @event module:ol/render/Event~RenderEvent#postrender
   * @api
   */
  POSTRENDER: "postrender",
  /**
   * Triggered before layers are composed.  When dispatched by the map, the event object will not have
   * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only
   * WebGL layers currently dispatch this event.
   * @event module:ol/render/Event~RenderEvent#precompose
   * @api
   */
  PRECOMPOSE: "precompose",
  /**
   * Triggered after layers are composed.  When dispatched by the map, the event object will not have
   * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only
   * WebGL layers currently dispatch this event.
   * @event module:ol/render/Event~RenderEvent#postcompose
   * @api
   */
  POSTCOMPOSE: "postcompose",
  /**
   * Triggered when rendering is complete, i.e. all sources and tiles have
   * finished loading for the current viewport, and all tiles are faded in.
   * The event object will not have a `context` set.
   * @event module:ol/render/Event~RenderEvent#rendercomplete
   * @api
   */
  RENDERCOMPLETE: "rendercomplete"
}, ge = {
  ANIMATING: 0,
  INTERACTING: 1
}, je = {
  CENTER: "center",
  RESOLUTION: "resolution",
  ROTATION: "rotation"
}, xd = 42, fa = 256, on = {
  // use the radius of the Normal sphere
  radians: 6370997 / (2 * Math.PI),
  degrees: 2 * Math.PI * 6370997 / 360,
  ft: 0.3048,
  m: 1,
  "us-ft": 1200 / 3937
};
class Ed {
  /**
   * @param {Options} options Projection options.
   */
  constructor(e) {
    this.code_ = e.code, this.units_ = /** @type {import("./Units.js").Units} */
    e.units, this.extent_ = e.extent !== void 0 ? e.extent : null, this.worldExtent_ = e.worldExtent !== void 0 ? e.worldExtent : null, this.axisOrientation_ = e.axisOrientation !== void 0 ? e.axisOrientation : "enu", this.global_ = e.global !== void 0 ? e.global : !1, this.canWrapX_ = !!(this.global_ && this.extent_), this.getPointResolutionFunc_ = e.getPointResolution, this.defaultTileGrid_ = null, this.metersPerUnit_ = e.metersPerUnit;
  }
  /**
   * @return {boolean} The projection is suitable for wrapping the x-axis
   */
  canWrapX() {
    return this.canWrapX_;
  }
  /**
   * Get the code for this projection, e.g. 'EPSG:4326'.
   * @return {string} Code.
   * @api
   */
  getCode() {
    return this.code_;
  }
  /**
   * Get the validity extent for this projection.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getExtent() {
    return this.extent_;
  }
  /**
   * Get the units of this projection.
   * @return {import("./Units.js").Units} Units.
   * @api
   */
  getUnits() {
    return this.units_;
  }
  /**
   * Get the amount of meters per unit of this projection.  If the projection is
   * not configured with `metersPerUnit` or a units identifier, the return is
   * `undefined`.
   * @return {number|undefined} Meters.
   * @api
   */
  getMetersPerUnit() {
    return this.metersPerUnit_ || on[this.units_];
  }
  /**
   * Get the world extent for this projection.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getWorldExtent() {
    return this.worldExtent_;
  }
  /**
   * Get the axis orientation of this projection.
   * Example values are:
   * enu - the default easting, northing, elevation.
   * neu - northing, easting, up - useful for "lat/long" geographic coordinates,
   *     or south orientated transverse mercator.
   * wnu - westing, northing, up - some planetary coordinate systems have
   *     "west positive" coordinate systems
   * @return {string} Axis orientation.
   * @api
   */
  getAxisOrientation() {
    return this.axisOrientation_;
  }
  /**
   * Is this projection a global projection which spans the whole world?
   * @return {boolean} Whether the projection is global.
   * @api
   */
  isGlobal() {
    return this.global_;
  }
  /**
   * Set if the projection is a global projection which spans the whole world
   * @param {boolean} global Whether the projection is global.
   * @api
   */
  setGlobal(e) {
    this.global_ = e, this.canWrapX_ = !!(e && this.extent_);
  }
  /**
   * @return {import("../tilegrid/TileGrid.js").default} The default tile grid.
   */
  getDefaultTileGrid() {
    return this.defaultTileGrid_;
  }
  /**
   * @param {import("../tilegrid/TileGrid.js").default} tileGrid The default tile grid.
   */
  setDefaultTileGrid(e) {
    this.defaultTileGrid_ = e;
  }
  /**
   * Set the validity extent for this projection.
   * @param {import("../extent.js").Extent} extent Extent.
   * @api
   */
  setExtent(e) {
    this.extent_ = e, this.canWrapX_ = !!(this.global_ && e);
  }
  /**
   * Set the world extent for this projection.
   * @param {import("../extent.js").Extent} worldExtent World extent
   *     [minlon, minlat, maxlon, maxlat].
   * @api
   */
  setWorldExtent(e) {
    this.worldExtent_ = e;
  }
  /**
   * Set the getPointResolution function (see {@link module:ol/proj.getPointResolution}
   * for this projection.
   * @param {function(number, import("../coordinate.js").Coordinate):number} func Function
   * @api
   */
  setGetPointResolution(e) {
    this.getPointResolutionFunc_ = e;
  }
  /**
   * Get the custom point resolution function for this projection (if set).
   * @return {function(number, import("../coordinate.js").Coordinate):number|undefined} The custom point
   * resolution function (if set).
   */
  getPointResolutionFunc() {
    return this.getPointResolutionFunc_;
  }
}
const er = Ed, ls = 6378137, Yi = Math.PI * ls, vd = [-Yi, -Yi, Yi, Yi], Cd = [-180, -85, 180, 85], Is = ls * Math.log(Math.tan(Math.PI / 2));
class Di extends er {
  /**
   * @param {string} code Code.
   */
  constructor(e) {
    super({
      code: e,
      units: "m",
      extent: vd,
      global: !0,
      worldExtent: Cd,
      getPointResolution: function(t, i) {
        return t / Math.cosh(i[1] / ls);
      }
    });
  }
}
const El = [
  new Di("EPSG:3857"),
  new Di("EPSG:102100"),
  new Di("EPSG:102113"),
  new Di("EPSG:900913"),
  new Di("http://www.opengis.net/def/crs/EPSG/0/3857"),
  new Di("http://www.opengis.net/gml/srs/epsg.xml#3857")
];
function wd(s, e, t) {
  const i = s.length;
  t = t > 1 ? t : 2, e === void 0 && (t > 2 ? e = s.slice() : e = new Array(i));
  for (let n = 0; n < i; n += t) {
    e[n] = Yi * s[n] / 180;
    let r = ls * Math.log(Math.tan(Math.PI * (+s[n + 1] + 90) / 360));
    r > Is ? r = Is : r < -Is && (r = -Is), e[n + 1] = r;
  }
  return e;
}
function Td(s, e, t) {
  const i = s.length;
  t = t > 1 ? t : 2, e === void 0 && (t > 2 ? e = s.slice() : e = new Array(i));
  for (let n = 0; n < i; n += t)
    e[n] = 180 * s[n] / Yi, e[n + 1] = 360 * Math.atan(Math.exp(s[n + 1] / ls)) / Math.PI - 90;
  return e;
}
const Sd = 6378137, vl = [-180, -90, 180, 90], Rd = Math.PI * Sd / 180;
class ri extends er {
  /**
   * @param {string} code Code.
   * @param {string} [axisOrientation] Axis orientation.
   */
  constructor(e, t) {
    super({
      code: e,
      units: "degrees",
      extent: vl,
      axisOrientation: t,
      global: !0,
      metersPerUnit: Rd,
      worldExtent: vl
    });
  }
}
const Cl = [
  new ri("CRS:84"),
  new ri("EPSG:4326", "neu"),
  new ri("urn:ogc:def:crs:OGC:1.3:CRS84"),
  new ri("urn:ogc:def:crs:OGC:2:84"),
  new ri("http://www.opengis.net/def/crs/OGC/1.3/CRS84"),
  new ri("http://www.opengis.net/gml/srs/epsg.xml#4326", "neu"),
  new ri("http://www.opengis.net/def/crs/EPSG/0/4326", "neu")
];
let Mo = {};
function Id(s) {
  return Mo[s] || Mo[s.replace(/urn:(x-)?ogc:def:crs:EPSG:(.*:)?(\w+)$/, "EPSG:$3")] || null;
}
function Ld(s, e) {
  Mo[s] = e;
}
let Ki = {};
function tr(s, e, t) {
  const i = s.getCode(), n = e.getCode();
  i in Ki || (Ki[i] = {}), Ki[i][n] = t;
}
function Ad(s, e) {
  let t;
  return s in Ki && e in Ki[s] && (t = Ki[s][e]), t;
}
function Uh(s, e) {
  return s[0] += +e[0], s[1] += +e[1], s;
}
function zh(s, e) {
  const t = s[0], i = s[1], n = e[0], r = e[1], o = n[0], a = n[1], l = r[0], h = r[1], c = l - o, u = h - a, d = c === 0 && u === 0 ? 0 : (c * (t - o) + u * (i - a)) / (c * c + u * u || 0);
  let f, g;
  return d <= 0 ? (f = o, g = a) : d >= 1 ? (f = l, g = h) : (f = o + d * c, g = a + d * u), [f, g];
}
function rt(s, e) {
  let t = !0;
  for (let i = s.length - 1; i >= 0; --i)
    if (s[i] != e[i]) {
      t = !1;
      break;
    }
  return t;
}
function ga(s, e) {
  const t = Math.cos(e), i = Math.sin(e), n = s[0] * t - s[1] * i, r = s[1] * t + s[0] * i;
  return s[0] = n, s[1] = r, s;
}
function Bh(s, e) {
  return s[0] *= e, s[1] *= e, s;
}
function Ci(s, e) {
  const t = s[0] - e[0], i = s[1] - e[1];
  return t * t + i * i;
}
function ir(s, e) {
  return Math.sqrt(Ci(s, e));
}
function Fd(s, e) {
  return Ci(s, zh(s, e));
}
function _a(s, e) {
  if (e.canWrapX()) {
    const t = te(e.getExtent()), i = bd(s, e, t);
    i && (s[0] -= i * t);
  }
  return s;
}
function bd(s, e, t) {
  const i = e.getExtent();
  let n = 0;
  return e.canWrapX() && (s[0] < i[0] || s[0] > i[2]) && (t = t || te(i), n = Math.floor(
    (s[0] - i[0]) / t
  )), n;
}
const ma = 63710088e-1;
function Oo(s, e, t) {
  t = t || ma;
  const i = Qt(s[1]), n = Qt(e[1]), r = (n - i) / 2, o = Qt(e[0] - s[0]) / 2, a = Math.sin(r) * Math.sin(r) + Math.sin(o) * Math.sin(o) * Math.cos(i) * Math.cos(n);
  return 2 * t * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
}
function jr(s, e) {
  let t = 0;
  for (let i = 0, n = s.length; i < n - 1; ++i)
    t += Oo(s[i], s[i + 1], e);
  return t;
}
function Xh(s, e) {
  e = e || {};
  const t = e.radius || ma, i = e.projection || "EPSG:3857", n = s.getType();
  n !== "GeometryCollection" && (s = s.clone().transform(i, "EPSG:4326"));
  let r = 0, o, a, l, h, c, u;
  switch (n) {
    case "Point":
    case "MultiPoint":
      break;
    case "LineString":
    case "LinearRing": {
      o = /** @type {import("./geom/SimpleGeometry.js").default} */
      s.getCoordinates(), r = jr(o, t);
      break;
    }
    case "MultiLineString":
    case "Polygon": {
      for (o = /** @type {import("./geom/SimpleGeometry.js").default} */
      s.getCoordinates(), l = 0, h = o.length; l < h; ++l)
        r += jr(o[l], t);
      break;
    }
    case "MultiPolygon": {
      for (o = /** @type {import("./geom/SimpleGeometry.js").default} */
      s.getCoordinates(), l = 0, h = o.length; l < h; ++l)
        for (a = o[l], c = 0, u = a.length; c < u; ++c)
          r += jr(a[c], t);
      break;
    }
    case "GeometryCollection": {
      const d = (
        /** @type {import("./geom/GeometryCollection.js").default} */
        s.getGeometries()
      );
      for (l = 0, h = d.length; l < h; ++l)
        r += Xh(d[l], e);
      break;
    }
    default:
      throw new Error("Unsupported geometry type: " + n);
  }
  return r;
}
function Ls(s, e) {
  let t = 0;
  const i = s.length;
  let n = s[i - 1][0], r = s[i - 1][1];
  for (let o = 0; o < i; o++) {
    const a = s[o][0], l = s[o][1];
    t += Qt(a - n) * (2 + Math.sin(Qt(r)) + Math.sin(Qt(l))), n = a, r = l;
  }
  return t * e * e / 2;
}
function Wh(s, e) {
  e = e || {};
  const t = e.radius || ma, i = e.projection || "EPSG:3857", n = s.getType();
  n !== "GeometryCollection" && (s = s.clone().transform(i, "EPSG:4326"));
  let r = 0, o, a, l, h, c, u;
  switch (n) {
    case "Point":
    case "MultiPoint":
    case "LineString":
    case "MultiLineString":
    case "LinearRing":
      break;
    case "Polygon": {
      for (o = /** @type {import("./geom/Polygon.js").default} */
      s.getCoordinates(), r = Math.abs(Ls(o[0], t)), l = 1, h = o.length; l < h; ++l)
        r -= Math.abs(Ls(o[l], t));
      break;
    }
    case "MultiPolygon": {
      for (o = /** @type {import("./geom/SimpleGeometry.js").default} */
      s.getCoordinates(), l = 0, h = o.length; l < h; ++l)
        for (a = o[l], r += Math.abs(Ls(a[0], t)), c = 1, u = a.length; c < u; ++c)
          r -= Math.abs(Ls(a[c], t));
      break;
    }
    case "GeometryCollection": {
      const d = (
        /** @type {import("./geom/GeometryCollection.js").default} */
        s.getGeometries()
      );
      for (l = 0, h = d.length; l < h; ++l)
        r += Wh(d[l], e);
      break;
    }
    default:
      throw new Error("Unsupported geometry type: " + n);
  }
  return r;
}
const Yh = {
  info: 1,
  warn: 2,
  error: 3,
  none: 4
};
let Pd = Yh.info;
function Vh(...s) {
  Pd > Yh.warn || console.warn(...s);
}
let Do = !0;
function Md(s) {
  Do = !(s === void 0 ? !0 : s);
}
function pa(s, e) {
  if (e !== void 0) {
    for (let t = 0, i = s.length; t < i; ++t)
      e[t] = s[t];
    e = e;
  } else
    e = s.slice();
  return e;
}
function ya(s, e) {
  if (e !== void 0 && s !== e) {
    for (let t = 0, i = s.length; t < i; ++t)
      e[t] = s[t];
    s = e;
  }
  return s;
}
function Od(s) {
  Ld(s.getCode(), s), tr(s, s, pa);
}
function Dd(s) {
  s.forEach(Od);
}
function ye(s) {
  return typeof s == "string" ? Id(
    /** @type {string} */
    s
  ) : (
    /** @type {Projection} */
    s || null
  );
}
function nr(s, e, t, i) {
  s = ye(s);
  let n;
  const r = s.getPointResolutionFunc();
  if (r) {
    if (n = r(e, t), i && i !== s.getUnits()) {
      const o = s.getMetersPerUnit();
      o && (n = n * o / on[i]);
    }
  } else {
    const o = s.getUnits();
    if (o == "degrees" && !i || i == "degrees")
      n = e;
    else {
      const a = Rr(
        s,
        ye("EPSG:4326")
      );
      if (a === ya && o !== "degrees")
        n = e * s.getMetersPerUnit();
      else {
        let h = [
          t[0] - e / 2,
          t[1],
          t[0] + e / 2,
          t[1],
          t[0],
          t[1] - e / 2,
          t[0],
          t[1] + e / 2
        ];
        h = a(h, h, 2);
        const c = Oo(h.slice(0, 2), h.slice(2, 4)), u = Oo(h.slice(4, 6), h.slice(6, 8));
        n = (c + u) / 2;
      }
      const l = i ? on[i] : s.getMetersPerUnit();
      l !== void 0 && (n /= l);
    }
  }
  return n;
}
function wl(s) {
  Dd(s), s.forEach(function(e) {
    s.forEach(function(t) {
      e !== t && tr(e, t, pa);
    });
  });
}
function kd(s, e, t, i) {
  s.forEach(function(n) {
    e.forEach(function(r) {
      tr(n, r, t), tr(r, n, i);
    });
  });
}
function xa(s, e) {
  if (s) {
    if (typeof s == "string")
      return ye(s);
  } else
    return ye(e);
  return (
    /** @type {Projection} */
    s
  );
}
function At(s, e) {
  if (s === e)
    return !0;
  const t = s.getUnits() === e.getUnits();
  return (s.getCode() === e.getCode() || Rr(s, e) === pa) && t;
}
function Rr(s, e) {
  const t = s.getCode(), i = e.getCode();
  let n = Ad(t, i);
  return n || (n = ya), n;
}
function sr(s, e) {
  const t = ye(s), i = ye(e);
  return Rr(t, i);
}
function Nd(s, e, t) {
  return sr(e, t)(s, void 0, s.length);
}
function Un(s, e) {
  return s;
}
function he(s, e) {
  return Do && !rt(s, [0, 0]) && s[0] >= -180 && s[0] <= 180 && s[1] >= -90 && s[1] <= 90 && (Do = !1, Vh(
    "Call useGeographic() from ol/proj once to work with [longitude, latitude] coordinates."
  )), s;
}
function Ea(s, e) {
  return s;
}
function gt(s, e) {
  return s;
}
function Gd() {
  wl(El), wl(Cl), kd(
    Cl,
    El,
    wd,
    Td
  );
}
Gd();
function Tl(s, e, t) {
  return (
    /**
     * @param {import("./coordinate.js").Coordinate|undefined} center Center.
     * @param {number|undefined} resolution Resolution.
     * @param {import("./size.js").Size} size Viewport size; unused if `onlyCenter` was specified.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @param {Array<number>} [centerShift] Shift between map center and viewport center.
     * @return {import("./coordinate.js").Coordinate|undefined} Center.
     */
    function(i, n, r, o, a) {
      if (!i)
        return;
      if (!n && !e)
        return i;
      const l = e ? 0 : r[0] * n, h = e ? 0 : r[1] * n, c = a ? a[0] : 0, u = a ? a[1] : 0;
      let d = s[0] + l / 2 + c, f = s[2] - l / 2 + c, g = s[1] + h / 2 + u, _ = s[3] - h / 2 + u;
      d > f && (d = (f + d) / 2, f = d), g > _ && (g = (_ + g) / 2, _ = g);
      let m = _e(i[0], d, f), p = _e(i[1], g, _);
      if (o && t && n) {
        const x = 30 * n;
        m += -x * Math.log(1 + Math.max(0, d - i[0]) / x) + x * Math.log(1 + Math.max(0, i[0] - f) / x), p += -x * Math.log(1 + Math.max(0, g - i[1]) / x) + x * Math.log(1 + Math.max(0, i[1] - _) / x);
      }
      return [m, p];
    }
  );
}
function Ud(s) {
  return s;
}
function va(s, e, t, i) {
  const n = te(e) / t[0], r = Fe(e) / t[1];
  return i ? Math.min(s, Math.max(n, r)) : Math.min(s, Math.min(n, r));
}
function Ca(s, e, t) {
  let i = Math.min(s, e);
  const n = 50;
  return i *= Math.log(1 + n * Math.max(0, s / e - 1)) / n + 1, t && (i = Math.max(i, t), i /= Math.log(1 + n * Math.max(0, t / s - 1)) / n + 1), _e(i, t / 2, e * 2);
}
function zd(s, e, t, i) {
  return e = e !== void 0 ? e : !0, /**
   * @param {number|undefined} resolution Resolution.
   * @param {number} direction Direction.
   * @param {import("./size.js").Size} size Viewport size.
   * @param {boolean} [isMoving] True if an interaction or animation is in progress.
   * @return {number|undefined} Resolution.
   */
  function(n, r, o, a) {
    if (n !== void 0) {
      const l = s[0], h = s[s.length - 1], c = t ? va(
        l,
        t,
        o,
        i
      ) : l;
      if (a)
        return e ? Ca(
          n,
          c,
          h
        ) : _e(n, h, c);
      const u = Math.min(c, n), d = Math.floor(Tr(s, u, r));
      return s[d] > c && d < s.length - 1 ? s[d + 1] : s[d];
    }
  };
}
function Bd(s, e, t, i, n, r) {
  return i = i !== void 0 ? i : !0, t = t !== void 0 ? t : 0, /**
   * @param {number|undefined} resolution Resolution.
   * @param {number} direction Direction.
   * @param {import("./size.js").Size} size Viewport size.
   * @param {boolean} [isMoving] True if an interaction or animation is in progress.
   * @return {number|undefined} Resolution.
   */
  function(o, a, l, h) {
    if (o !== void 0) {
      const c = n ? va(
        e,
        n,
        l,
        r
      ) : e;
      if (h)
        return i ? Ca(
          o,
          c,
          t
        ) : _e(o, t, c);
      const u = 1e-9, d = Math.ceil(
        Math.log(e / c) / Math.log(s) - u
      ), f = -a * (0.5 - u) + 0.5, g = Math.min(c, o), _ = Math.floor(
        Math.log(e / g) / Math.log(s) + f
      ), m = Math.max(d, _), p = e / Math.pow(s, m);
      return _e(p, t, c);
    }
  };
}
function Sl(s, e, t, i, n) {
  return t = t !== void 0 ? t : !0, /**
   * @param {number|undefined} resolution Resolution.
   * @param {number} direction Direction.
   * @param {import("./size.js").Size} size Viewport size.
   * @param {boolean} [isMoving] True if an interaction or animation is in progress.
   * @return {number|undefined} Resolution.
   */
  function(r, o, a, l) {
    if (r !== void 0) {
      const h = i ? va(
        s,
        i,
        a,
        n
      ) : s;
      return !t || !l ? _e(r, e, h) : Ca(
        r,
        h,
        e
      );
    }
  };
}
function wa(s) {
  if (s !== void 0)
    return 0;
}
function Rl(s) {
  if (s !== void 0)
    return s;
}
function Xd(s) {
  const e = 2 * Math.PI / s;
  return (
    /**
     * @param {number|undefined} rotation Rotation.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Rotation.
     */
    function(t, i) {
      if (i)
        return t;
      if (t !== void 0)
        return t = Math.floor(t / e + 0.5) * e, t;
    }
  );
}
function Wd(s) {
  return s = s || Qt(5), /**
   * @param {number|undefined} rotation Rotation.
   * @param {boolean} [isMoving] True if an interaction or animation is in progress.
   * @return {number|undefined} Rotation.
   */
  function(e, t) {
    if (t)
      return e;
    if (e !== void 0)
      return Math.abs(e) <= s ? 0 : e;
  };
}
function Zh(s) {
  return Math.pow(s, 3);
}
function dn(s) {
  return 1 - Zh(1 - s);
}
function Yd(s) {
  return 3 * s * s - 2 * s * s * s;
}
function Vd(s) {
  return s;
}
function xi(s, e, t, i, n, r) {
  r = r || [];
  let o = 0;
  for (let a = e; a < t; a += i) {
    const l = s[a], h = s[a + 1];
    r[o++] = n[0] * l + n[2] * h + n[4], r[o++] = n[1] * l + n[3] * h + n[5];
  }
  return r && r.length != o && (r.length = o), r;
}
function Ta(s, e, t, i, n, r, o) {
  o = o || [];
  const a = Math.cos(n), l = Math.sin(n), h = r[0], c = r[1];
  let u = 0;
  for (let d = e; d < t; d += i) {
    const f = s[d] - h, g = s[d + 1] - c;
    o[u++] = h + f * a - g * l, o[u++] = c + f * l + g * a;
    for (let _ = d + 2; _ < d + i; ++_)
      o[u++] = s[_];
  }
  return o && o.length != u && (o.length = u), o;
}
function Zd(s, e, t, i, n, r, o, a) {
  a = a || [];
  const l = o[0], h = o[1];
  let c = 0;
  for (let u = e; u < t; u += i) {
    const d = s[u] - l, f = s[u + 1] - h;
    a[c++] = l + n * d, a[c++] = h + r * f;
    for (let g = u + 2; g < u + i; ++g)
      a[c++] = s[g];
  }
  return a && a.length != c && (a.length = c), a;
}
function jh(s, e, t, i, n, r, o) {
  o = o || [];
  let a = 0;
  for (let l = e; l < t; l += i) {
    o[a++] = s[l] + n, o[a++] = s[l + 1] + r;
    for (let h = l + 2; h < l + i; ++h)
      o[a++] = s[h];
  }
  return o && o.length != a && (o.length = a), o;
}
const Il = Se();
class jd extends ht {
  constructor() {
    super(), this.extent_ = Me(), this.extentRevision_ = -1, this.simplifiedGeometryMaxMinSquaredTolerance = 0, this.simplifiedGeometryRevision = 0, this.simplifyTransformedInternal = Bu(function(e, t, i) {
      if (!i)
        return this.getSimplifiedGeometry(t);
      const n = this.clone();
      return n.applyTransform(i), n.getSimplifiedGeometry(t);
    });
  }
  /**
   * Get a transformed and simplified version of the geometry.
   * @abstract
   * @param {number} squaredTolerance Squared tolerance.
   * @param {import("../proj.js").TransformFunction} [transform] Optional transform function.
   * @return {Geometry} Simplified geometry.
   */
  simplifyTransformed(e, t) {
    return this.simplifyTransformedInternal(
      this.getRevision(),
      e,
      t
    );
  }
  /**
   * Make a complete copy of the geometry.
   * @abstract
   * @return {!Geometry} Clone.
   */
  clone() {
    return X();
  }
  /**
   * @abstract
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(e, t, i, n) {
    return X();
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */
  containsXY(e, t) {
    const i = this.getClosestPoint([e, t]);
    return i[0] === e && i[1] === t;
  }
  /**
   * Return the closest point of the geometry to the passed point as
   * {@link module:ol/coordinate~Coordinate coordinate}.
   * @param {import("../coordinate.js").Coordinate} point Point.
   * @param {import("../coordinate.js").Coordinate} [closestPoint] Closest point.
   * @return {import("../coordinate.js").Coordinate} Closest point.
   * @api
   */
  getClosestPoint(e, t) {
    return t = t || [NaN, NaN], this.closestPointXY(e[0], e[1], t, 1 / 0), t;
  }
  /**
   * Returns true if this geometry includes the specified coordinate. If the
   * coordinate is on the boundary of the geometry, returns false.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @return {boolean} Contains coordinate.
   * @api
   */
  intersectsCoordinate(e) {
    return this.containsXY(e[0], e[1]);
  }
  /**
   * @abstract
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */
  computeExtent(e) {
    return X();
  }
  /**
   * Get the extent of the geometry.
   * @param {import("../extent.js").Extent} [extent] Extent.
   * @return {import("../extent.js").Extent} extent Extent.
   * @api
   */
  getExtent(e) {
    if (this.extentRevision_ != this.getRevision()) {
      const t = this.computeExtent(this.extent_);
      (isNaN(t[0]) || isNaN(t[1])) && rs(t), this.extentRevision_ = this.getRevision();
    }
    return ad(this.extent_, e);
  }
  /**
   * Rotate the geometry around a given coordinate. This modifies the geometry
   * coordinates in place.
   * @abstract
   * @param {number} angle Rotation angle in radians.
   * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
   * @api
   */
  rotate(e, t) {
    X();
  }
  /**
   * Scale the geometry (with an optional origin).  This modifies the geometry
   * coordinates in place.
   * @abstract
   * @param {number} sx The scaling factor in the x-direction.
   * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
   * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
   *     of the geometry extent).
   * @api
   */
  scale(e, t, i) {
    X();
  }
  /**
   * Create a simplified version of this geometry.  For linestrings, this uses
   * the [Douglas Peucker](https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm)
   * algorithm.  For polygons, a quantization-based
   * simplification is used to preserve topology.
   * @param {number} tolerance The tolerance distance for simplification.
   * @return {Geometry} A new, simplified version of the original geometry.
   * @api
   */
  simplify(e) {
    return this.getSimplifiedGeometry(e * e);
  }
  /**
   * Create a simplified version of this geometry using the Douglas Peucker
   * algorithm.
   * See https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm.
   * @abstract
   * @param {number} squaredTolerance Squared tolerance.
   * @return {Geometry} Simplified geometry.
   */
  getSimplifiedGeometry(e) {
    return X();
  }
  /**
   * Get the type of this geometry.
   * @abstract
   * @return {Type} Geometry type.
   */
  getType() {
    return X();
  }
  /**
   * Apply a transform function to the coordinates of the geometry.
   * The geometry is modified in place.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   * @abstract
   * @param {import("../proj.js").TransformFunction} transformFn Transform function.
   * Called with a flat array of geometry coordinates.
   */
  applyTransform(e) {
    X();
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @abstract
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   */
  intersectsExtent(e) {
    return X();
  }
  /**
   * Translate the geometry.  This modifies the geometry coordinates in place.  If
   * instead you want a new geometry, first `clone()` this geometry.
   * @abstract
   * @param {number} deltaX Delta X.
   * @param {number} deltaY Delta Y.
   * @api
   */
  translate(e, t) {
    X();
  }
  /**
   * Transform each coordinate of the geometry from one coordinate reference
   * system to another. The geometry is modified in place.
   * For example, a line will be transformed to a line and a circle to a circle.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   *
   * @param {import("../proj.js").ProjectionLike} source The current projection.  Can be a
   *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
   * @param {import("../proj.js").ProjectionLike} destination The desired projection.  Can be a
   *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
   * @return {Geometry} This geometry.  Note that original geometry is
   *     modified in place.
   * @api
   */
  transform(e, t) {
    const i = ye(e), n = i.getUnits() == "tile-pixels" ? function(r, o, a) {
      const l = i.getExtent(), h = i.getWorldExtent(), c = Fe(h) / Fe(l);
      return Je(
        Il,
        h[0],
        h[3],
        c,
        -c,
        0,
        0,
        0
      ), xi(
        r,
        0,
        r.length,
        a,
        Il,
        o
      ), sr(i, t)(
        r,
        o,
        a
      );
    } : sr(i, t);
    return this.applyTransform(n), this;
  }
}
const Hh = jd;
class Hd extends Hh {
  constructor() {
    super(), this.layout = "XY", this.stride = 2, this.flatCoordinates = null;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */
  computeExtent(e) {
    return Ph(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      e
    );
  }
  /**
   * @abstract
   * @return {Array<*> | null} Coordinates.
   */
  getCoordinates() {
    return X();
  }
  /**
   * Return the first coordinate of the geometry.
   * @return {import("../coordinate.js").Coordinate} First coordinate.
   * @api
   */
  getFirstCoordinate() {
    return this.flatCoordinates.slice(0, this.stride);
  }
  /**
   * @return {Array<number>} Flat coordinates.
   */
  getFlatCoordinates() {
    return this.flatCoordinates;
  }
  /**
   * Return the last coordinate of the geometry.
   * @return {import("../coordinate.js").Coordinate} Last point.
   * @api
   */
  getLastCoordinate() {
    return this.flatCoordinates.slice(
      this.flatCoordinates.length - this.stride
    );
  }
  /**
   * Return the {@link import("./Geometry.js").GeometryLayout layout} of the geometry.
   * @return {import("./Geometry.js").GeometryLayout} Layout.
   * @api
   */
  getLayout() {
    return this.layout;
  }
  /**
   * Create a simplified version of this geometry using the Douglas Peucker algorithm.
   * @param {number} squaredTolerance Squared tolerance.
   * @return {SimpleGeometry} Simplified geometry.
   */
  getSimplifiedGeometry(e) {
    if (this.simplifiedGeometryRevision !== this.getRevision() && (this.simplifiedGeometryMaxMinSquaredTolerance = 0, this.simplifiedGeometryRevision = this.getRevision()), e < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && e <= this.simplifiedGeometryMaxMinSquaredTolerance)
      return this;
    const t = this.getSimplifiedGeometryInternal(e);
    return t.getFlatCoordinates().length < this.flatCoordinates.length ? t : (this.simplifiedGeometryMaxMinSquaredTolerance = e, this);
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {SimpleGeometry} Simplified geometry.
   * @protected
   */
  getSimplifiedGeometryInternal(e) {
    return this;
  }
  /**
   * @return {number} Stride.
   */
  getStride() {
    return this.stride;
  }
  /**
   * @param {import("./Geometry.js").GeometryLayout} layout Layout.
   * @param {Array<number>} flatCoordinates Flat coordinates.
   */
  setFlatCoordinates(e, t) {
    this.stride = rr(e), this.layout = e, this.flatCoordinates = t;
  }
  /**
   * @abstract
   * @param {!Array<*>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  setCoordinates(e, t) {
    X();
  }
  /**
   * @param {import("./Geometry.js").GeometryLayout|undefined} layout Layout.
   * @param {Array<*>} coordinates Coordinates.
   * @param {number} nesting Nesting.
   * @protected
   */
  setLayout(e, t, i) {
    let n;
    if (e)
      n = rr(e);
    else {
      for (let r = 0; r < i; ++r) {
        if (t.length === 0) {
          this.layout = "XY", this.stride = 2;
          return;
        }
        t = /** @type {Array} */
        t[0];
      }
      n = t.length, e = Kd(n);
    }
    this.layout = e, this.stride = n;
  }
  /**
   * Apply a transform function to the coordinates of the geometry.
   * The geometry is modified in place.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   * @param {import("../proj.js").TransformFunction} transformFn Transform function.
   * Called with a flat array of geometry coordinates.
   * @api
   */
  applyTransform(e) {
    this.flatCoordinates && (e(this.flatCoordinates, this.flatCoordinates, this.stride), this.changed());
  }
  /**
   * Rotate the geometry around a given coordinate. This modifies the geometry
   * coordinates in place.
   * @param {number} angle Rotation angle in counter-clockwise radians.
   * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
   * @api
   */
  rotate(e, t) {
    const i = this.getFlatCoordinates();
    if (i) {
      const n = this.getStride();
      Ta(
        i,
        0,
        i.length,
        n,
        e,
        t,
        i
      ), this.changed();
    }
  }
  /**
   * Scale the geometry (with an optional origin).  This modifies the geometry
   * coordinates in place.
   * @param {number} sx The scaling factor in the x-direction.
   * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
   * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
   *     of the geometry extent).
   * @api
   */
  scale(e, t, i) {
    t === void 0 && (t = e), i || (i = Ne(this.getExtent()));
    const n = this.getFlatCoordinates();
    if (n) {
      const r = this.getStride();
      Zd(
        n,
        0,
        n.length,
        r,
        e,
        t,
        i,
        n
      ), this.changed();
    }
  }
  /**
   * Translate the geometry.  This modifies the geometry coordinates in place.  If
   * instead you want a new geometry, first `clone()` this geometry.
   * @param {number} deltaX Delta X.
   * @param {number} deltaY Delta Y.
   * @api
   */
  translate(e, t) {
    const i = this.getFlatCoordinates();
    if (i) {
      const n = this.getStride();
      jh(
        i,
        0,
        i.length,
        n,
        e,
        t,
        i
      ), this.changed();
    }
  }
}
function Kd(s) {
  let e;
  return s == 2 ? e = "XY" : s == 3 ? e = "XYZ" : s == 4 && (e = "XYZM"), /** @type {import("./Geometry.js").GeometryLayout} */
  e;
}
function rr(s) {
  let e;
  return s == "XY" ? e = 2 : s == "XYZ" || s == "XYM" ? e = 3 : s == "XYZM" && (e = 4), /** @type {number} */
  e;
}
function qd(s, e, t) {
  const i = s.getFlatCoordinates();
  if (!i)
    return null;
  const n = s.getStride();
  return xi(
    i,
    0,
    i.length,
    n,
    e,
    t
  );
}
const ni = Hd;
function Ll(s, e, t, i, n, r, o) {
  const a = s[e], l = s[e + 1], h = s[t] - a, c = s[t + 1] - l;
  let u;
  if (h === 0 && c === 0)
    u = e;
  else {
    const d = ((n - a) * h + (r - l) * c) / (h * h + c * c);
    if (d > 1)
      u = t;
    else if (d > 0) {
      for (let f = 0; f < i; ++f)
        o[f] = He(
          s[e + f],
          s[t + f],
          d
        );
      o.length = i;
      return;
    } else
      u = e;
  }
  for (let d = 0; d < i; ++d)
    o[d] = s[u + d];
  o.length = i;
}
function Sa(s, e, t, i, n) {
  let r = s[e], o = s[e + 1];
  for (e += i; e < t; e += i) {
    const a = s[e], l = s[e + 1], h = bt(r, o, a, l);
    h > n && (n = h), r = a, o = l;
  }
  return n;
}
function Ra(s, e, t, i, n) {
  for (let r = 0, o = t.length; r < o; ++r) {
    const a = t[r];
    n = Sa(s, e, a, i, n), e = a;
  }
  return n;
}
function Jd(s, e, t, i, n) {
  for (let r = 0, o = t.length; r < o; ++r) {
    const a = t[r];
    n = Ra(s, e, a, i, n), e = a[a.length - 1];
  }
  return n;
}
function Ia(s, e, t, i, n, r, o, a, l, h, c) {
  if (e == t)
    return h;
  let u, d;
  if (n === 0) {
    if (d = bt(
      o,
      a,
      s[e],
      s[e + 1]
    ), d < h) {
      for (u = 0; u < i; ++u)
        l[u] = s[e + u];
      return l.length = i, d;
    }
    return h;
  }
  c = c || [NaN, NaN];
  let f = e + i;
  for (; f < t; )
    if (Ll(
      s,
      f - i,
      f,
      i,
      o,
      a,
      c
    ), d = bt(o, a, c[0], c[1]), d < h) {
      for (h = d, u = 0; u < i; ++u)
        l[u] = c[u];
      l.length = i, f += i;
    } else
      f += i * Math.max(
        (Math.sqrt(d) - Math.sqrt(h)) / n | 0,
        1
      );
  if (r && (Ll(
    s,
    t - i,
    e,
    i,
    o,
    a,
    c
  ), d = bt(o, a, c[0], c[1]), d < h)) {
    for (h = d, u = 0; u < i; ++u)
      l[u] = c[u];
    l.length = i;
  }
  return h;
}
function La(s, e, t, i, n, r, o, a, l, h, c) {
  c = c || [NaN, NaN];
  for (let u = 0, d = t.length; u < d; ++u) {
    const f = t[u];
    h = Ia(
      s,
      e,
      f,
      i,
      n,
      r,
      o,
      a,
      l,
      h,
      c
    ), e = f;
  }
  return h;
}
function $d(s, e, t, i, n, r, o, a, l, h, c) {
  c = c || [NaN, NaN];
  for (let u = 0, d = t.length; u < d; ++u) {
    const f = t[u];
    h = La(
      s,
      e,
      f,
      i,
      n,
      r,
      o,
      a,
      l,
      h,
      c
    ), e = f[f.length - 1];
  }
  return h;
}
function Kh(s, e, t, i) {
  for (let n = 0, r = t.length; n < r; ++n)
    s[e++] = t[n];
  return e;
}
function Ir(s, e, t, i) {
  for (let n = 0, r = t.length; n < r; ++n) {
    const o = t[n];
    for (let a = 0; a < i; ++a)
      s[e++] = o[a];
  }
  return e;
}
function Aa(s, e, t, i, n) {
  n = n || [];
  let r = 0;
  for (let o = 0, a = t.length; o < a; ++o) {
    const l = Ir(
      s,
      e,
      t[o],
      i
    );
    n[r++] = l, e = l;
  }
  return n.length = r, n;
}
function Qd(s, e, t, i, n) {
  n = n || [];
  let r = 0;
  for (let o = 0, a = t.length; o < a; ++o) {
    const l = Aa(
      s,
      e,
      t[o],
      i,
      n[r]
    );
    l.length === 0 && (l[0] = e), n[r++] = l, e = l[l.length - 1];
  }
  return n.length = r, n;
}
function Fa(s, e, t, i, n, r, o) {
  const a = (t - e) / i;
  if (a < 3) {
    for (; e < t; e += i)
      r[o++] = s[e], r[o++] = s[e + 1];
    return o;
  }
  const l = new Array(a);
  l[0] = 1, l[a - 1] = 1;
  const h = [e, t - i];
  let c = 0;
  for (; h.length > 0; ) {
    const u = h.pop(), d = h.pop();
    let f = 0;
    const g = s[d], _ = s[d + 1], m = s[u], p = s[u + 1];
    for (let x = d + i; x < u; x += i) {
      const y = s[x], E = s[x + 1], C = cd(y, E, g, _, m, p);
      C > f && (c = x, f = C);
    }
    f > n && (l[(c - e) / i] = 1, d + i < c && h.push(d, c), c + i < u && h.push(c, u));
  }
  for (let u = 0; u < a; ++u)
    l[u] && (r[o++] = s[e + u * i], r[o++] = s[e + u * i + 1]);
  return o;
}
function ef(s, e, t, i, n, r, o, a) {
  for (let l = 0, h = t.length; l < h; ++l) {
    const c = t[l];
    o = Fa(
      s,
      e,
      c,
      i,
      n,
      r,
      o
    ), a.push(o), e = c;
  }
  return o;
}
function li(s, e) {
  return e * Math.round(s / e);
}
function tf(s, e, t, i, n, r, o) {
  if (e == t)
    return o;
  let a = li(s[e], n), l = li(s[e + 1], n);
  e += i, r[o++] = a, r[o++] = l;
  let h, c;
  do
    if (h = li(s[e], n), c = li(s[e + 1], n), e += i, e == t)
      return r[o++] = h, r[o++] = c, o;
  while (h == a && c == l);
  for (; e < t; ) {
    const u = li(s[e], n), d = li(s[e + 1], n);
    if (e += i, u == h && d == c)
      continue;
    const f = h - a, g = c - l, _ = u - a, m = d - l;
    if (f * m == g * _ && (f < 0 && _ < f || f == _ || f > 0 && _ > f) && (g < 0 && m < g || g == m || g > 0 && m > g)) {
      h = u, c = d;
      continue;
    }
    r[o++] = h, r[o++] = c, a = h, l = c, h = u, c = d;
  }
  return r[o++] = h, r[o++] = c, o;
}
function qh(s, e, t, i, n, r, o, a) {
  for (let l = 0, h = t.length; l < h; ++l) {
    const c = t[l];
    o = tf(
      s,
      e,
      c,
      i,
      n,
      r,
      o
    ), a.push(o), e = c;
  }
  return o;
}
function nf(s, e, t, i, n, r, o, a) {
  for (let l = 0, h = t.length; l < h; ++l) {
    const c = t[l], u = [];
    o = qh(
      s,
      e,
      c,
      i,
      n,
      r,
      o,
      u
    ), a.push(u), e = c[c.length - 1];
  }
  return o;
}
function qt(s, e, t, i, n) {
  n = n !== void 0 ? n : [];
  let r = 0;
  for (let o = e; o < t; o += i)
    n[r++] = s.slice(o, o + i);
  return n.length = r, n;
}
function zn(s, e, t, i, n) {
  n = n !== void 0 ? n : [];
  let r = 0;
  for (let o = 0, a = t.length; o < a; ++o) {
    const l = t[o];
    n[r++] = qt(
      s,
      e,
      l,
      i,
      n[r]
    ), e = l;
  }
  return n.length = r, n;
}
function ko(s, e, t, i, n) {
  n = n !== void 0 ? n : [];
  let r = 0;
  for (let o = 0, a = t.length; o < a; ++o) {
    const l = t[o];
    n[r++] = l.length === 1 && l[0] === e ? [] : zn(
      s,
      e,
      l,
      i,
      n[r]
    ), e = l[l.length - 1];
  }
  return n.length = r, n;
}
function Jh(s, e, t, i) {
  let n = 0, r = s[t - i], o = s[t - i + 1];
  for (; e < t; e += i) {
    const a = s[e], l = s[e + 1];
    n += o * a - r * l, r = a, o = l;
  }
  return n / 2;
}
function $h(s, e, t, i) {
  let n = 0;
  for (let r = 0, o = t.length; r < o; ++r) {
    const a = t[r];
    n += Jh(s, e, a, i), e = a;
  }
  return n;
}
function sf(s, e, t, i) {
  let n = 0;
  for (let r = 0, o = t.length; r < o; ++r) {
    const a = t[r];
    n += $h(s, e, a, i), e = a[a.length - 1];
  }
  return n;
}
class or extends ni {
  /**
   * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `layout` are also accepted.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  constructor(e, t) {
    super(), this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, t !== void 0 && !Array.isArray(e[0]) ? this.setFlatCoordinates(
      t,
      /** @type {Array<number>} */
      e
    ) : this.setCoordinates(
      /** @type {Array<import("../coordinate.js").Coordinate>} */
      e,
      t
    );
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!LinearRing} Clone.
   * @api
   */
  clone() {
    return new or(this.flatCoordinates.slice(), this.layout);
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(e, t, i, n) {
    return n < Ri(this.getExtent(), e, t) ? n : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(
      Sa(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride,
        0
      )
    ), this.maxDeltaRevision_ = this.getRevision()), Ia(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      this.maxDelta_,
      !0,
      e,
      t,
      i,
      n
    ));
  }
  /**
   * Return the area of the linear ring on projected plane.
   * @return {number} Area (on projected plane).
   * @api
   */
  getArea() {
    return Jh(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride
    );
  }
  /**
   * Return the coordinates of the linear ring.
   * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
   * @api
   */
  getCoordinates() {
    return qt(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride
    );
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {LinearRing} Simplified LinearRing.
   * @protected
   */
  getSimplifiedGeometryInternal(e) {
    const t = [];
    return t.length = Fa(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      e,
      t,
      0
    ), new or(t, "XY");
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return "LinearRing";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(e) {
    return !1;
  }
  /**
   * Set the coordinates of the linear ring.
   * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCoordinates(e, t) {
    this.setLayout(t, e, 1), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = Ir(
      this.flatCoordinates,
      0,
      e,
      this.stride
    ), this.changed();
  }
}
const Al = or;
let rf = class Qh extends ni {
  /**
   * @param {import("../coordinate.js").Coordinate} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  constructor(e, t) {
    super(), this.setCoordinates(e, t);
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!Point} Clone.
   * @api
   */
  clone() {
    const e = new Qh(this.flatCoordinates.slice(), this.layout);
    return e.applyProperties(this), e;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(e, t, i, n) {
    const r = this.flatCoordinates, o = bt(
      e,
      t,
      r[0],
      r[1]
    );
    if (o < n) {
      const a = this.stride;
      for (let l = 0; l < a; ++l)
        i[l] = r[l];
      return i.length = a, o;
    }
    return n;
  }
  /**
   * Return the coordinate of the point.
   * @return {import("../coordinate.js").Coordinate} Coordinates.
   * @api
   */
  getCoordinates() {
    return this.flatCoordinates ? this.flatCoordinates.slice() : [];
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */
  computeExtent(e) {
    return Rn(this.flatCoordinates, e);
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return "Point";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(e) {
    return ua(e, this.flatCoordinates[0], this.flatCoordinates[1]);
  }
  /**
   * @param {!Array<*>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCoordinates(e, t) {
    this.setLayout(t, e, 0), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = Kh(
      this.flatCoordinates,
      0,
      e,
      this.stride
    ), this.changed();
  }
};
const Ee = rf;
function of(s, e, t, i, n) {
  return !da(
    n,
    /**
     * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
     * @return {boolean} Contains (x, y).
     */
    function(o) {
      return !hi(
        s,
        e,
        t,
        i,
        o[0],
        o[1]
      );
    }
  );
}
function hi(s, e, t, i, n, r) {
  let o = 0, a = s[t - i], l = s[t - i + 1];
  for (; e < t; e += i) {
    const h = s[e], c = s[e + 1];
    l <= r ? c > r && (h - a) * (r - l) - (n - a) * (c - l) > 0 && o++ : c <= r && (h - a) * (r - l) - (n - a) * (c - l) < 0 && o--, a = h, l = c;
  }
  return o !== 0;
}
function ba(s, e, t, i, n, r) {
  if (t.length === 0 || !hi(s, e, t[0], i, n, r))
    return !1;
  for (let o = 1, a = t.length; o < a; ++o)
    if (hi(s, t[o - 1], t[o], i, n, r))
      return !1;
  return !0;
}
function af(s, e, t, i, n, r) {
  if (t.length === 0)
    return !1;
  for (let o = 0, a = t.length; o < a; ++o) {
    const l = t[o];
    if (ba(s, e, l, i, n, r))
      return !0;
    e = l[l.length - 1];
  }
  return !1;
}
function ec(s, e, t, i, n, r, o) {
  let a, l, h, c, u, d, f;
  const g = n[r + 1], _ = [];
  for (let x = 0, y = t.length; x < y; ++x) {
    const E = t[x];
    for (c = s[E - i], d = s[E - i + 1], a = e; a < E; a += i)
      u = s[a], f = s[a + 1], (g <= d && f <= g || d <= g && g <= f) && (h = (g - d) / (f - d) * (u - c) + c, _.push(h)), c = u, d = f;
  }
  let m = NaN, p = -1 / 0;
  for (_.sort(vi), c = _[0], a = 1, l = _.length; a < l; ++a) {
    u = _[a];
    const x = Math.abs(u - c);
    x > p && (h = (c + u) / 2, ba(s, e, t, i, h, g) && (m = h, p = x)), c = u;
  }
  return isNaN(m) && (m = n[r]), o ? (o.push(m, g, p), o) : [m, g, p];
}
function lf(s, e, t, i, n) {
  let r = [];
  for (let o = 0, a = t.length; o < a; ++o) {
    const l = t[o];
    r = ec(
      s,
      e,
      l,
      i,
      n,
      2 * o,
      r
    ), e = l[l.length - 1];
  }
  return r;
}
function tc(s, e, t, i, n) {
  let r;
  for (e += i; e < t; e += i)
    if (r = n(
      s.slice(e - i, e),
      s.slice(e, e + i)
    ), r)
      return r;
  return !1;
}
function Lr(s, e, t, i, n) {
  const r = Mh(
    Me(),
    s,
    e,
    t,
    i
  );
  return Ce(n, r) ? Ft(n, r) || r[0] >= n[0] && r[2] <= n[2] || r[1] >= n[1] && r[3] <= n[3] ? !0 : tc(
    s,
    e,
    t,
    i,
    /**
     * @param {import("../../coordinate.js").Coordinate} point1 Start point.
     * @param {import("../../coordinate.js").Coordinate} point2 End point.
     * @return {boolean} `true` if the segment and the extent intersect,
     *     `false` otherwise.
     */
    function(o, a) {
      return ld(n, o, a);
    }
  ) : !1;
}
function hf(s, e, t, i, n) {
  for (let r = 0, o = t.length; r < o; ++r) {
    if (Lr(s, e, t[r], i, n))
      return !0;
    e = t[r];
  }
  return !1;
}
function ic(s, e, t, i, n) {
  return !!(Lr(s, e, t, i, n) || hi(
    s,
    e,
    t,
    i,
    n[0],
    n[1]
  ) || hi(
    s,
    e,
    t,
    i,
    n[0],
    n[3]
  ) || hi(
    s,
    e,
    t,
    i,
    n[2],
    n[1]
  ) || hi(
    s,
    e,
    t,
    i,
    n[2],
    n[3]
  ));
}
function nc(s, e, t, i, n) {
  if (!ic(s, e, t[0], i, n))
    return !1;
  if (t.length === 1)
    return !0;
  for (let r = 1, o = t.length; r < o; ++r)
    if (of(
      s,
      t[r - 1],
      t[r],
      i,
      n
    ) && !Lr(
      s,
      t[r - 1],
      t[r],
      i,
      n
    ))
      return !1;
  return !0;
}
function cf(s, e, t, i, n) {
  for (let r = 0, o = t.length; r < o; ++r) {
    const a = t[r];
    if (nc(s, e, a, i, n))
      return !0;
    e = a[a.length - 1];
  }
  return !1;
}
function uf(s, e, t, i) {
  for (; e < t - i; ) {
    for (let n = 0; n < i; ++n) {
      const r = s[e + n];
      s[e + n] = s[t - i + n], s[t - i + n] = r;
    }
    e += i, t -= i;
  }
}
function sc(s, e, t, i) {
  let n = 0, r = s[t - i], o = s[t - i + 1];
  for (; e < t; e += i) {
    const a = s[e], l = s[e + 1];
    n += (a - r) * (l + o), r = a, o = l;
  }
  return n === 0 ? void 0 : n > 0;
}
function rc(s, e, t, i, n) {
  n = n !== void 0 ? n : !1;
  for (let r = 0, o = t.length; r < o; ++r) {
    const a = t[r], l = sc(
      s,
      e,
      a,
      i
    );
    if (r === 0) {
      if (n && l || !n && !l)
        return !1;
    } else if (n && !l || !n && l)
      return !1;
    e = a;
  }
  return !0;
}
function df(s, e, t, i, n) {
  for (let r = 0, o = t.length; r < o; ++r) {
    const a = t[r];
    if (!rc(s, e, a, i, n))
      return !1;
    a.length && (e = a[a.length - 1]);
  }
  return !0;
}
function No(s, e, t, i, n) {
  n = n !== void 0 ? n : !1;
  for (let r = 0, o = t.length; r < o; ++r) {
    const a = t[r], l = sc(
      s,
      e,
      a,
      i
    );
    (r === 0 ? n && l || !n && !l : n && !l || !n && l) && uf(s, e, a, i), e = a;
  }
  return e;
}
function Fl(s, e, t, i, n) {
  for (let r = 0, o = t.length; r < o; ++r)
    e = No(
      s,
      e,
      t[r],
      i,
      n
    );
  return e;
}
let Pa = class Go extends ni {
  /**
   * @param {!Array<Array<import("../coordinate.js").Coordinate>>|!Array<number>} coordinates
   *     Array of linear rings that define the polygon. The first linear ring of the
   *     array defines the outer-boundary or surface of the polygon. Each subsequent
   *     linear ring defines a hole in the surface of the polygon. A linear ring is
   *     an array of vertices' coordinates where the first coordinate and the last are
   *     equivalent. (For internal use, flat coordinates in combination with
   *     `layout` and `ends` are also accepted.)
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @param {Array<number>} [ends] Ends (for internal use with flat coordinates).
   */
  constructor(e, t, i) {
    super(), this.ends_ = [], this.flatInteriorPointRevision_ = -1, this.flatInteriorPoint_ = null, this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, this.orientedRevision_ = -1, this.orientedFlatCoordinates_ = null, t !== void 0 && i ? (this.setFlatCoordinates(
      t,
      /** @type {Array<number>} */
      e
    ), this.ends_ = i) : this.setCoordinates(
      /** @type {Array<Array<import("../coordinate.js").Coordinate>>} */
      e,
      t
    );
  }
  /**
   * Append the passed linear ring to this polygon.
   * @param {LinearRing} linearRing Linear ring.
   * @api
   */
  appendLinearRing(e) {
    this.flatCoordinates ? ae(this.flatCoordinates, e.getFlatCoordinates()) : this.flatCoordinates = e.getFlatCoordinates().slice(), this.ends_.push(this.flatCoordinates.length), this.changed();
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!Polygon} Clone.
   * @api
   */
  clone() {
    const e = new Go(
      this.flatCoordinates.slice(),
      this.layout,
      this.ends_.slice()
    );
    return e.applyProperties(this), e;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(e, t, i, n) {
    return n < Ri(this.getExtent(), e, t) ? n : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(
      Ra(
        this.flatCoordinates,
        0,
        this.ends_,
        this.stride,
        0
      )
    ), this.maxDeltaRevision_ = this.getRevision()), La(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      this.maxDelta_,
      !0,
      e,
      t,
      i,
      n
    ));
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */
  containsXY(e, t) {
    return ba(
      this.getOrientedFlatCoordinates(),
      0,
      this.ends_,
      this.stride,
      e,
      t
    );
  }
  /**
   * Return the area of the polygon on projected plane.
   * @return {number} Area (on projected plane).
   * @api
   */
  getArea() {
    return $h(
      this.getOrientedFlatCoordinates(),
      0,
      this.ends_,
      this.stride
    );
  }
  /**
   * Get the coordinate array for this geometry.  This array has the structure
   * of a GeoJSON coordinate array for polygons.
   *
   * @param {boolean} [right] Orient coordinates according to the right-hand
   *     rule (counter-clockwise for exterior and clockwise for interior rings).
   *     If `false`, coordinates will be oriented according to the left-hand rule
   *     (clockwise for exterior and counter-clockwise for interior rings).
   *     By default, coordinate orientation will depend on how the geometry was
   *     constructed.
   * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.
   * @api
   */
  getCoordinates(e) {
    let t;
    return e !== void 0 ? (t = this.getOrientedFlatCoordinates().slice(), No(t, 0, this.ends_, this.stride, e)) : t = this.flatCoordinates, zn(t, 0, this.ends_, this.stride);
  }
  /**
   * @return {Array<number>} Ends.
   */
  getEnds() {
    return this.ends_;
  }
  /**
   * @return {Array<number>} Interior point.
   */
  getFlatInteriorPoint() {
    if (this.flatInteriorPointRevision_ != this.getRevision()) {
      const e = Ne(this.getExtent());
      this.flatInteriorPoint_ = ec(
        this.getOrientedFlatCoordinates(),
        0,
        this.ends_,
        this.stride,
        e,
        0
      ), this.flatInteriorPointRevision_ = this.getRevision();
    }
    return this.flatInteriorPoint_;
  }
  /**
   * Return an interior point of the polygon.
   * @return {Point} Interior point as XYM coordinate, where M is the
   * length of the horizontal intersection that the point belongs to.
   * @api
   */
  getInteriorPoint() {
    return new Ee(this.getFlatInteriorPoint(), "XYM");
  }
  /**
   * Return the number of rings of the polygon,  this includes the exterior
   * ring and any interior rings.
   *
   * @return {number} Number of rings.
   * @api
   */
  getLinearRingCount() {
    return this.ends_.length;
  }
  /**
   * Return the Nth linear ring of the polygon geometry. Return `null` if the
   * given index is out of range.
   * The exterior linear ring is available at index `0` and the interior rings
   * at index `1` and beyond.
   *
   * @param {number} index Index.
   * @return {LinearRing|null} Linear ring.
   * @api
   */
  getLinearRing(e) {
    return e < 0 || this.ends_.length <= e ? null : new Al(
      this.flatCoordinates.slice(
        e === 0 ? 0 : this.ends_[e - 1],
        this.ends_[e]
      ),
      this.layout
    );
  }
  /**
   * Return the linear rings of the polygon.
   * @return {Array<LinearRing>} Linear rings.
   * @api
   */
  getLinearRings() {
    const e = this.layout, t = this.flatCoordinates, i = this.ends_, n = [];
    let r = 0;
    for (let o = 0, a = i.length; o < a; ++o) {
      const l = i[o], h = new Al(
        t.slice(r, l),
        e
      );
      n.push(h), r = l;
    }
    return n;
  }
  /**
   * @return {Array<number>} Oriented flat coordinates.
   */
  getOrientedFlatCoordinates() {
    if (this.orientedRevision_ != this.getRevision()) {
      const e = this.flatCoordinates;
      rc(e, 0, this.ends_, this.stride) ? this.orientedFlatCoordinates_ = e : (this.orientedFlatCoordinates_ = e.slice(), this.orientedFlatCoordinates_.length = No(
        this.orientedFlatCoordinates_,
        0,
        this.ends_,
        this.stride
      )), this.orientedRevision_ = this.getRevision();
    }
    return this.orientedFlatCoordinates_;
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {Polygon} Simplified Polygon.
   * @protected
   */
  getSimplifiedGeometryInternal(e) {
    const t = [], i = [];
    return t.length = qh(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      Math.sqrt(e),
      t,
      0,
      i
    ), new Go(t, "XY", i);
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return "Polygon";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(e) {
    return nc(
      this.getOrientedFlatCoordinates(),
      0,
      this.ends_,
      this.stride,
      e
    );
  }
  /**
   * Set the coordinates of the polygon.
   * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCoordinates(e, t) {
    this.setLayout(t, e, 2), this.flatCoordinates || (this.flatCoordinates = []);
    const i = Aa(
      this.flatCoordinates,
      0,
      e,
      this.stride,
      this.ends_
    );
    this.flatCoordinates.length = i.length === 0 ? 0 : i[i.length - 1], this.changed();
  }
};
const We = Pa;
function ci(s) {
  const e = s[0], t = s[1], i = s[2], n = s[3], r = [
    e,
    t,
    e,
    n,
    i,
    n,
    i,
    t,
    e,
    t
  ];
  return new Pa(r, "XY", [r.length]);
}
function ff(s, e, t) {
  e = e || 32;
  const i = s.getStride(), n = s.getLayout(), r = s.getCenter(), o = i * (e + 1), a = new Array(o);
  for (let c = 0; c < o; c += i) {
    a[c] = 0, a[c + 1] = 0;
    for (let u = 2; u < i; u++)
      a[c + u] = r[u];
  }
  const l = [a.length], h = new Pa(a, n, l);
  return oc(h, r, s.getRadius(), t), h;
}
function oc(s, e, t, i) {
  const n = s.getFlatCoordinates(), r = s.getStride(), o = n.length / r - 1, a = i || 0;
  for (let l = 0; l <= o; ++l) {
    const h = l * r, c = a + yi(l, o) * 2 * Math.PI / o;
    n[h] = e[0] + t * Math.cos(c), n[h + 1] = e[1] + t * Math.sin(c);
  }
  s.changed();
}
const Hr = 0;
class gf extends ht {
  /**
   * @param {ViewOptions} [options] View options.
   */
  constructor(e) {
    super(), this.on, this.once, this.un, e = Object.assign({}, e), this.hints_ = [0, 0], this.animations_ = [], this.updateAnimationKey_, this.projection_ = xa(e.projection, "EPSG:3857"), this.viewportSize_ = [100, 100], this.targetCenter_ = null, this.targetResolution_, this.targetRotation_, this.nextCenter_ = null, this.nextResolution_, this.nextRotation_, this.cancelAnchor_ = void 0, e.projection && Md(), e.center && (e.center = he(e.center, this.projection_)), e.extent && (e.extent = gt(e.extent, this.projection_)), this.applyOptions_(e);
  }
  /**
   * Set up the view with the given options.
   * @param {ViewOptions} options View options.
   */
  applyOptions_(e) {
    const t = Object.assign({}, e);
    for (const a in je)
      delete t[a];
    this.setProperties(t, !0);
    const i = mf(e);
    this.maxResolution_ = i.maxResolution, this.minResolution_ = i.minResolution, this.zoomFactor_ = i.zoomFactor, this.resolutions_ = e.resolutions, this.padding_ = e.padding, this.minZoom_ = i.minZoom;
    const n = _f(e), r = i.constraint, o = pf(e);
    this.constraints_ = {
      center: n,
      resolution: r,
      rotation: o
    }, this.setRotation(e.rotation !== void 0 ? e.rotation : 0), this.setCenterInternal(
      e.center !== void 0 ? e.center : null
    ), e.resolution !== void 0 ? this.setResolution(e.resolution) : e.zoom !== void 0 && this.setZoom(e.zoom);
  }
  /**
   * Padding (in css pixels).
   * If the map viewport is partially covered with other content (overlays) along
   * its edges, this setting allows to shift the center of the viewport away from that
   * content. The order of the values in the array is top, right, bottom, left.
   * The default is no padding, which is equivalent to `[0, 0, 0, 0]`.
   * @type {Array<number>|undefined}
   * @api
   */
  get padding() {
    return this.padding_;
  }
  set padding(e) {
    let t = this.padding_;
    this.padding_ = e;
    const i = this.getCenterInternal();
    if (i) {
      const n = e || [0, 0, 0, 0];
      t = t || [0, 0, 0, 0];
      const r = this.getResolution(), o = r / 2 * (n[3] - t[3] + t[1] - n[1]), a = r / 2 * (n[0] - t[0] + t[2] - n[2]);
      this.setCenterInternal([i[0] + o, i[1] - a]);
    }
  }
  /**
   * Get an updated version of the view options used to construct the view.  The
   * current resolution (or zoom), center, and rotation are applied to any stored
   * options.  The provided options can be used to apply new min/max zoom or
   * resolution limits.
   * @param {ViewOptions} newOptions New options to be applied.
   * @return {ViewOptions} New options updated with the current view state.
   */
  getUpdatedOptions_(e) {
    const t = this.getProperties();
    return t.resolution !== void 0 ? t.resolution = this.getResolution() : t.zoom = this.getZoom(), t.center = this.getCenterInternal(), t.rotation = this.getRotation(), Object.assign({}, t, e);
  }
  /**
   * Animate the view.  The view's center, zoom (or resolution), and rotation
   * can be animated for smooth transitions between view states.  For example,
   * to animate the view to a new zoom level:
   *
   *     view.animate({zoom: view.getZoom() + 1});
   *
   * By default, the animation lasts one second and uses in-and-out easing.  You
   * can customize this behavior by including `duration` (in milliseconds) and
   * `easing` options (see {@link module:ol/easing}).
   *
   * To chain together multiple animations, call the method with multiple
   * animation objects.  For example, to first zoom and then pan:
   *
   *     view.animate({zoom: 10}, {center: [0, 0]});
   *
   * If you provide a function as the last argument to the animate method, it
   * will get called at the end of an animation series.  The callback will be
   * called with `true` if the animation series completed on its own or `false`
   * if it was cancelled.
   *
   * Animations are cancelled by user interactions (e.g. dragging the map) or by
   * calling `view.setCenter()`, `view.setResolution()`, or `view.setRotation()`
   * (or another method that calls one of these).
   *
   * @param {...(AnimationOptions|function(boolean): void)} var_args Animation
   *     options.  Multiple animations can be run in series by passing multiple
   *     options objects.  To run multiple animations in parallel, call the method
   *     multiple times.  An optional callback can be provided as a final
   *     argument.  The callback will be called with a boolean indicating whether
   *     the animation completed without being cancelled.
   * @api
   */
  animate(e) {
    this.isDef() && !this.getAnimating() && this.resolveConstraints(0);
    const t = new Array(arguments.length);
    for (let i = 0; i < t.length; ++i) {
      let n = arguments[i];
      n.center && (n = Object.assign({}, n), n.center = he(
        n.center,
        this.getProjection()
      )), n.anchor && (n = Object.assign({}, n), n.anchor = he(
        n.anchor,
        this.getProjection()
      )), t[i] = n;
    }
    this.animateInternal.apply(this, t);
  }
  /**
   * @param {...(AnimationOptions|function(boolean): void)} var_args Animation options.
   */
  animateInternal(e) {
    let t = arguments.length, i;
    t > 1 && typeof arguments[t - 1] == "function" && (i = arguments[t - 1], --t);
    let n = 0;
    for (; n < t && !this.isDef(); ++n) {
      const c = arguments[n];
      c.center && this.setCenterInternal(c.center), c.zoom !== void 0 ? this.setZoom(c.zoom) : c.resolution && this.setResolution(c.resolution), c.rotation !== void 0 && this.setRotation(c.rotation);
    }
    if (n === t) {
      i && As(i, !0);
      return;
    }
    let r = Date.now(), o = this.targetCenter_.slice(), a = this.targetResolution_, l = this.targetRotation_;
    const h = [];
    for (; n < t; ++n) {
      const c = (
        /** @type {AnimationOptions} */
        arguments[n]
      ), u = {
        start: r,
        complete: !1,
        anchor: c.anchor,
        duration: c.duration !== void 0 ? c.duration : 1e3,
        easing: c.easing || Yd,
        callback: i
      };
      if (c.center && (u.sourceCenter = o, u.targetCenter = c.center.slice(), o = u.targetCenter), c.zoom !== void 0 ? (u.sourceResolution = a, u.targetResolution = this.getResolutionForZoom(c.zoom), a = u.targetResolution) : c.resolution && (u.sourceResolution = a, u.targetResolution = c.resolution, a = u.targetResolution), c.rotation !== void 0) {
        u.sourceRotation = l;
        const d = yi(c.rotation - l + Math.PI, 2 * Math.PI) - Math.PI;
        u.targetRotation = l + d, l = u.targetRotation;
      }
      yf(u) ? u.complete = !0 : r += u.duration, h.push(u);
    }
    this.animations_.push(h), this.setHint(ge.ANIMATING, 1), this.updateAnimations_();
  }
  /**
   * Determine if the view is being animated.
   * @return {boolean} The view is being animated.
   * @api
   */
  getAnimating() {
    return this.hints_[ge.ANIMATING] > 0;
  }
  /**
   * Determine if the user is interacting with the view, such as panning or zooming.
   * @return {boolean} The view is being interacted with.
   * @api
   */
  getInteracting() {
    return this.hints_[ge.INTERACTING] > 0;
  }
  /**
   * Cancel any ongoing animations.
   * @api
   */
  cancelAnimations() {
    this.setHint(ge.ANIMATING, -this.hints_[ge.ANIMATING]);
    let e;
    for (let t = 0, i = this.animations_.length; t < i; ++t) {
      const n = this.animations_[t];
      if (n[0].callback && As(n[0].callback, !1), !e)
        for (let r = 0, o = n.length; r < o; ++r) {
          const a = n[r];
          if (!a.complete) {
            e = a.anchor;
            break;
          }
        }
    }
    this.animations_.length = 0, this.cancelAnchor_ = e, this.nextCenter_ = null, this.nextResolution_ = NaN, this.nextRotation_ = NaN;
  }
  /**
   * Update all animations.
   */
  updateAnimations_() {
    if (this.updateAnimationKey_ !== void 0 && (cancelAnimationFrame(this.updateAnimationKey_), this.updateAnimationKey_ = void 0), !this.getAnimating())
      return;
    const e = Date.now();
    let t = !1;
    for (let i = this.animations_.length - 1; i >= 0; --i) {
      const n = this.animations_[i];
      let r = !0;
      for (let o = 0, a = n.length; o < a; ++o) {
        const l = n[o];
        if (l.complete)
          continue;
        const h = e - l.start;
        let c = l.duration > 0 ? h / l.duration : 1;
        c >= 1 ? (l.complete = !0, c = 1) : r = !1;
        const u = l.easing(c);
        if (l.sourceCenter) {
          const d = l.sourceCenter[0], f = l.sourceCenter[1], g = l.targetCenter[0], _ = l.targetCenter[1];
          this.nextCenter_ = l.targetCenter;
          const m = d + u * (g - d), p = f + u * (_ - f);
          this.targetCenter_ = [m, p];
        }
        if (l.sourceResolution && l.targetResolution) {
          const d = u === 1 ? l.targetResolution : l.sourceResolution + u * (l.targetResolution - l.sourceResolution);
          if (l.anchor) {
            const f = this.getViewportSize_(this.getRotation()), g = this.constraints_.resolution(
              d,
              0,
              f,
              !0
            );
            this.targetCenter_ = this.calculateCenterZoom(
              g,
              l.anchor
            );
          }
          this.nextResolution_ = l.targetResolution, this.targetResolution_ = d, this.applyTargetState_(!0);
        }
        if (l.sourceRotation !== void 0 && l.targetRotation !== void 0) {
          const d = u === 1 ? yi(l.targetRotation + Math.PI, 2 * Math.PI) - Math.PI : l.sourceRotation + u * (l.targetRotation - l.sourceRotation);
          if (l.anchor) {
            const f = this.constraints_.rotation(
              d,
              !0
            );
            this.targetCenter_ = this.calculateCenterRotate(
              f,
              l.anchor
            );
          }
          this.nextRotation_ = l.targetRotation, this.targetRotation_ = d;
        }
        if (this.applyTargetState_(!0), t = !0, !l.complete)
          break;
      }
      if (r) {
        this.animations_[i] = null, this.setHint(ge.ANIMATING, -1), this.nextCenter_ = null, this.nextResolution_ = NaN, this.nextRotation_ = NaN;
        const o = n[0].callback;
        o && As(o, !0);
      }
    }
    this.animations_ = this.animations_.filter(Boolean), t && this.updateAnimationKey_ === void 0 && (this.updateAnimationKey_ = requestAnimationFrame(
      this.updateAnimations_.bind(this)
    ));
  }
  /**
   * @param {number} rotation Target rotation.
   * @param {import("./coordinate.js").Coordinate} anchor Rotation anchor.
   * @return {import("./coordinate.js").Coordinate|undefined} Center for rotation and anchor.
   */
  calculateCenterRotate(e, t) {
    let i;
    const n = this.getCenterInternal();
    return n !== void 0 && (i = [n[0] - t[0], n[1] - t[1]], ga(i, e - this.getRotation()), Uh(i, t)), i;
  }
  /**
   * @param {number} resolution Target resolution.
   * @param {import("./coordinate.js").Coordinate} anchor Zoom anchor.
   * @return {import("./coordinate.js").Coordinate|undefined} Center for resolution and anchor.
   */
  calculateCenterZoom(e, t) {
    let i;
    const n = this.getCenterInternal(), r = this.getResolution();
    if (n !== void 0 && r !== void 0) {
      const o = t[0] - e * (t[0] - n[0]) / r, a = t[1] - e * (t[1] - n[1]) / r;
      i = [o, a];
    }
    return i;
  }
  /**
   * Returns the current viewport size.
   * @private
   * @param {number} [rotation] Take into account the rotation of the viewport when giving the size
   * @return {import("./size.js").Size} Viewport size or `[100, 100]` when no viewport is found.
   */
  getViewportSize_(e) {
    const t = this.viewportSize_;
    if (e) {
      const i = t[0], n = t[1];
      return [
        Math.abs(i * Math.cos(e)) + Math.abs(n * Math.sin(e)),
        Math.abs(i * Math.sin(e)) + Math.abs(n * Math.cos(e))
      ];
    }
    return t;
  }
  /**
   * Stores the viewport size on the view. The viewport size is not read every time from the DOM
   * to avoid performance hit and layout reflow.
   * This should be done on map size change.
   * Note: the constraints are not resolved during an animation to avoid stopping it
   * @param {import("./size.js").Size} [size] Viewport size; if undefined, [100, 100] is assumed
   */
  setViewportSize(e) {
    this.viewportSize_ = Array.isArray(e) ? e.slice() : [100, 100], this.getAnimating() || this.resolveConstraints(0);
  }
  /**
   * Get the view center.
   * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
   * @observable
   * @api
   */
  getCenter() {
    const e = this.getCenterInternal();
    return e && Un(e, this.getProjection());
  }
  /**
   * Get the view center without transforming to user projection.
   * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
   */
  getCenterInternal() {
    return (
      /** @type {import("./coordinate.js").Coordinate|undefined} */
      this.get(je.CENTER)
    );
  }
  /**
   * @return {Constraints} Constraints.
   */
  getConstraints() {
    return this.constraints_;
  }
  /**
   * @return {boolean} Resolution constraint is set
   */
  getConstrainResolution() {
    return this.get("constrainResolution");
  }
  /**
   * @param {Array<number>} [hints] Destination array.
   * @return {Array<number>} Hint.
   */
  getHints(e) {
    return e !== void 0 ? (e[0] = this.hints_[0], e[1] = this.hints_[1], e) : this.hints_.slice();
  }
  /**
   * Calculate the extent for the current view state and the passed size.
   * The size is the pixel dimensions of the box into which the calculated extent
   * should fit. In most cases you want to get the extent of the entire map,
   * that is `map.getSize()`.
   * @param {import("./size.js").Size} [size] Box pixel size. If not provided, the size
   * of the map that uses this view will be used.
   * @return {import("./extent.js").Extent} Extent.
   * @api
   */
  calculateExtent(e) {
    const t = this.calculateExtentInternal(e);
    return Ea(t, this.getProjection());
  }
  /**
   * @param {import("./size.js").Size} [size] Box pixel size. If not provided,
   * the map's last known viewport size will be used.
   * @return {import("./extent.js").Extent} Extent.
   */
  calculateExtentInternal(e) {
    e = e || this.getViewportSizeMinusPadding_();
    const t = (
      /** @type {!import("./coordinate.js").Coordinate} */
      this.getCenterInternal()
    );
    Z(t, 1);
    const i = (
      /** @type {!number} */
      this.getResolution()
    );
    Z(i !== void 0, 2);
    const n = (
      /** @type {!number} */
      this.getRotation()
    );
    return Z(n !== void 0, 3), bo(t, i, n, e);
  }
  /**
   * Get the maximum resolution of the view.
   * @return {number} The maximum resolution of the view.
   * @api
   */
  getMaxResolution() {
    return this.maxResolution_;
  }
  /**
   * Get the minimum resolution of the view.
   * @return {number} The minimum resolution of the view.
   * @api
   */
  getMinResolution() {
    return this.minResolution_;
  }
  /**
   * Get the maximum zoom level for the view.
   * @return {number} The maximum zoom level.
   * @api
   */
  getMaxZoom() {
    return (
      /** @type {number} */
      this.getZoomForResolution(this.minResolution_)
    );
  }
  /**
   * Set a new maximum zoom level for the view.
   * @param {number} zoom The maximum zoom level.
   * @api
   */
  setMaxZoom(e) {
    this.applyOptions_(this.getUpdatedOptions_({ maxZoom: e }));
  }
  /**
   * Get the minimum zoom level for the view.
   * @return {number} The minimum zoom level.
   * @api
   */
  getMinZoom() {
    return (
      /** @type {number} */
      this.getZoomForResolution(this.maxResolution_)
    );
  }
  /**
   * Set a new minimum zoom level for the view.
   * @param {number} zoom The minimum zoom level.
   * @api
   */
  setMinZoom(e) {
    this.applyOptions_(this.getUpdatedOptions_({ minZoom: e }));
  }
  /**
   * Set whether the view should allow intermediary zoom levels.
   * @param {boolean} enabled Whether the resolution is constrained.
   * @api
   */
  setConstrainResolution(e) {
    this.applyOptions_(this.getUpdatedOptions_({ constrainResolution: e }));
  }
  /**
   * Get the view projection.
   * @return {import("./proj/Projection.js").default} The projection of the view.
   * @api
   */
  getProjection() {
    return this.projection_;
  }
  /**
   * Get the view resolution.
   * @return {number|undefined} The resolution of the view.
   * @observable
   * @api
   */
  getResolution() {
    return (
      /** @type {number|undefined} */
      this.get(je.RESOLUTION)
    );
  }
  /**
   * Get the resolutions for the view. This returns the array of resolutions
   * passed to the constructor of the View, or undefined if none were given.
   * @return {Array<number>|undefined} The resolutions of the view.
   * @api
   */
  getResolutions() {
    return this.resolutions_;
  }
  /**
   * Get the resolution for a provided extent (in map units) and size (in pixels).
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {import("./size.js").Size} [size] Box pixel size.
   * @return {number} The resolution at which the provided extent will render at
   *     the given size.
   * @api
   */
  getResolutionForExtent(e, t) {
    return this.getResolutionForExtentInternal(
      gt(e, this.getProjection()),
      t
    );
  }
  /**
   * Get the resolution for a provided extent (in map units) and size (in pixels).
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {import("./size.js").Size} [size] Box pixel size.
   * @return {number} The resolution at which the provided extent will render at
   *     the given size.
   */
  getResolutionForExtentInternal(e, t) {
    t = t || this.getViewportSizeMinusPadding_();
    const i = te(e) / t[0], n = Fe(e) / t[1];
    return Math.max(i, n);
  }
  /**
   * Return a function that returns a value between 0 and 1 for a
   * resolution. Exponential scaling is assumed.
   * @param {number} [power] Power.
   * @return {function(number): number} Resolution for value function.
   */
  getResolutionForValueFunction(e) {
    e = e || 2;
    const t = this.getConstrainedResolution(this.maxResolution_), i = this.minResolution_, n = Math.log(t / i) / Math.log(e);
    return (
      /**
       * @param {number} value Value.
       * @return {number} Resolution.
       */
      function(r) {
        return t / Math.pow(e, r * n);
      }
    );
  }
  /**
   * Get the view rotation.
   * @return {number} The rotation of the view in radians.
   * @observable
   * @api
   */
  getRotation() {
    return (
      /** @type {number} */
      this.get(je.ROTATION)
    );
  }
  /**
   * Return a function that returns a resolution for a value between
   * 0 and 1. Exponential scaling is assumed.
   * @param {number} [power] Power.
   * @return {function(number): number} Value for resolution function.
   */
  getValueForResolutionFunction(e) {
    const t = Math.log(e || 2), i = this.getConstrainedResolution(this.maxResolution_), n = this.minResolution_, r = Math.log(i / n) / t;
    return (
      /**
       * @param {number} resolution Resolution.
       * @return {number} Value.
       */
      function(o) {
        return Math.log(i / o) / t / r;
      }
    );
  }
  /**
   * Returns the size of the viewport minus padding.
   * @private
   * @param {number} [rotation] Take into account the rotation of the viewport when giving the size
   * @return {import("./size.js").Size} Viewport size reduced by the padding.
   */
  getViewportSizeMinusPadding_(e) {
    let t = this.getViewportSize_(e);
    const i = this.padding_;
    return i && (t = [
      t[0] - i[1] - i[3],
      t[1] - i[0] - i[2]
    ]), t;
  }
  /**
   * @return {State} View state.
   */
  getState() {
    const e = this.getProjection(), t = this.getResolution(), i = this.getRotation();
    let n = (
      /** @type {import("./coordinate.js").Coordinate} */
      this.getCenterInternal()
    );
    const r = this.padding_;
    if (r) {
      const o = this.getViewportSizeMinusPadding_();
      n = Kr(
        n,
        this.getViewportSize_(),
        [o[0] / 2 + r[3], o[1] / 2 + r[0]],
        t,
        i
      );
    }
    return {
      center: n.slice(0),
      projection: e !== void 0 ? e : null,
      resolution: t,
      nextCenter: this.nextCenter_,
      nextResolution: this.nextResolution_,
      nextRotation: this.nextRotation_,
      rotation: i,
      zoom: this.getZoom()
    };
  }
  /**
   * @return {ViewStateAndExtent} Like `FrameState`, but just `viewState` and `extent`.
   */
  getViewStateAndExtent() {
    return {
      viewState: this.getState(),
      extent: this.calculateExtent()
    };
  }
  /**
   * Get the current zoom level. This method may return non-integer zoom levels
   * if the view does not constrain the resolution, or if an interaction or
   * animation is underway.
   * @return {number|undefined} Zoom.
   * @api
   */
  getZoom() {
    let e;
    const t = this.getResolution();
    return t !== void 0 && (e = this.getZoomForResolution(t)), e;
  }
  /**
   * Get the zoom level for a resolution.
   * @param {number} resolution The resolution.
   * @return {number|undefined} The zoom level for the provided resolution.
   * @api
   */
  getZoomForResolution(e) {
    let t = this.minZoom_ || 0, i, n;
    if (this.resolutions_) {
      const r = Tr(this.resolutions_, e, 1);
      t = r, i = this.resolutions_[r], r == this.resolutions_.length - 1 ? n = 2 : n = i / this.resolutions_[r + 1];
    } else
      i = this.maxResolution_, n = this.zoomFactor_;
    return t + Math.log(i / e) / Math.log(n);
  }
  /**
   * Get the resolution for a zoom level.
   * @param {number} zoom Zoom level.
   * @return {number} The view resolution for the provided zoom level.
   * @api
   */
  getResolutionForZoom(e) {
    if (this.resolutions_) {
      if (this.resolutions_.length <= 1)
        return 0;
      const t = _e(
        Math.floor(e),
        0,
        this.resolutions_.length - 2
      ), i = this.resolutions_[t] / this.resolutions_[t + 1];
      return this.resolutions_[t] / Math.pow(i, _e(e - t, 0, 1));
    }
    return this.maxResolution_ / Math.pow(this.zoomFactor_, e - this.minZoom_);
  }
  /**
   * Fit the given geometry or extent based on the given map size and border.
   * The size is pixel dimensions of the box to fit the extent into.
   * In most cases you will want to use the map size, that is `map.getSize()`.
   * Takes care of the map angle.
   * @param {import("./geom/SimpleGeometry.js").default|import("./extent.js").Extent} geometryOrExtent The geometry or
   *     extent to fit the view to.
   * @param {FitOptions} [options] Options.
   * @api
   */
  fit(e, t) {
    let i;
    if (Z(
      Array.isArray(e) || typeof /** @type {?} */
      e.getSimplifiedGeometry == "function",
      24
    ), Array.isArray(e)) {
      Z(!as(e), 25);
      const n = gt(e, this.getProjection());
      i = ci(n);
    } else if (e.getType() === "Circle") {
      const n = gt(
        e.getExtent(),
        this.getProjection()
      );
      i = ci(n), i.rotate(this.getRotation(), Ne(n));
    } else
      i = e;
    this.fitInternal(i, t);
  }
  /**
   * Calculate rotated extent
   * @param {import("./geom/SimpleGeometry.js").default} geometry The geometry.
   * @return {import("./extent").Extent} The rotated extent for the geometry.
   */
  rotatedExtentForGeometry(e) {
    const t = this.getRotation(), i = Math.cos(t), n = Math.sin(-t), r = e.getFlatCoordinates(), o = e.getStride();
    let a = 1 / 0, l = 1 / 0, h = -1 / 0, c = -1 / 0;
    for (let u = 0, d = r.length; u < d; u += o) {
      const f = r[u] * i - r[u + 1] * n, g = r[u] * n + r[u + 1] * i;
      a = Math.min(a, f), l = Math.min(l, g), h = Math.max(h, f), c = Math.max(c, g);
    }
    return [a, l, h, c];
  }
  /**
   * @param {import("./geom/SimpleGeometry.js").default} geometry The geometry.
   * @param {FitOptions} [options] Options.
   */
  fitInternal(e, t) {
    t = t || {};
    let i = t.size;
    i || (i = this.getViewportSizeMinusPadding_());
    const n = t.padding !== void 0 ? t.padding : [0, 0, 0, 0], r = t.nearest !== void 0 ? t.nearest : !1;
    let o;
    t.minResolution !== void 0 ? o = t.minResolution : t.maxZoom !== void 0 ? o = this.getResolutionForZoom(t.maxZoom) : o = 0;
    const a = this.rotatedExtentForGeometry(e);
    let l = this.getResolutionForExtentInternal(a, [
      i[0] - n[1] - n[3],
      i[1] - n[0] - n[2]
    ]);
    l = isNaN(l) ? o : Math.max(l, o), l = this.getConstrainedResolution(l, r ? 0 : 1);
    const h = this.getRotation(), c = Math.sin(h), u = Math.cos(h), d = Ne(a);
    d[0] += (n[1] - n[3]) / 2 * l, d[1] += (n[0] - n[2]) / 2 * l;
    const f = d[0] * u - d[1] * c, g = d[1] * u + d[0] * c, _ = this.getConstrainedCenter([f, g], l), m = t.callback ? t.callback : nn;
    t.duration !== void 0 ? this.animateInternal(
      {
        resolution: l,
        center: _,
        duration: t.duration,
        easing: t.easing
      },
      m
    ) : (this.targetResolution_ = l, this.targetCenter_ = _, this.applyTargetState_(!1, !0), As(m, !0));
  }
  /**
   * Center on coordinate and view position.
   * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("./size.js").Size} size Box pixel size.
   * @param {import("./pixel.js").Pixel} position Position on the view to center on.
   * @api
   */
  centerOn(e, t, i) {
    this.centerOnInternal(
      he(e, this.getProjection()),
      t,
      i
    );
  }
  /**
   * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("./size.js").Size} size Box pixel size.
   * @param {import("./pixel.js").Pixel} position Position on the view to center on.
   */
  centerOnInternal(e, t, i) {
    this.setCenterInternal(
      Kr(
        e,
        t,
        i,
        this.getResolution(),
        this.getRotation()
      )
    );
  }
  /**
   * Calculates the shift between map and viewport center.
   * @param {import("./coordinate.js").Coordinate} center Center.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @param {import("./size.js").Size} size Size.
   * @return {Array<number>|undefined} Center shift.
   */
  calculateCenterShift(e, t, i, n) {
    let r;
    const o = this.padding_;
    if (o && e) {
      const a = this.getViewportSizeMinusPadding_(-i), l = Kr(
        e,
        n,
        [a[0] / 2 + o[3], a[1] / 2 + o[0]],
        t,
        i
      );
      r = [
        e[0] - l[0],
        e[1] - l[1]
      ];
    }
    return r;
  }
  /**
   * @return {boolean} Is defined.
   */
  isDef() {
    return !!this.getCenterInternal() && this.getResolution() !== void 0;
  }
  /**
   * Adds relative coordinates to the center of the view. Any extent constraint will apply.
   * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
   * @api
   */
  adjustCenter(e) {
    const t = Un(this.targetCenter_, this.getProjection());
    this.setCenter([
      t[0] + e[0],
      t[1] + e[1]
    ]);
  }
  /**
   * Adds relative coordinates to the center of the view. Any extent constraint will apply.
   * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
   */
  adjustCenterInternal(e) {
    const t = this.targetCenter_;
    this.setCenterInternal([
      t[0] + e[0],
      t[1] + e[1]
    ]);
  }
  /**
   * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
   * constraint will apply.
   * @param {number} ratio The ratio to apply on the view resolution.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   * @api
   */
  adjustResolution(e, t) {
    t = t && he(t, this.getProjection()), this.adjustResolutionInternal(e, t);
  }
  /**
   * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
   * constraint will apply.
   * @param {number} ratio The ratio to apply on the view resolution.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   */
  adjustResolutionInternal(e, t) {
    const i = this.getAnimating() || this.getInteracting(), n = this.getViewportSize_(this.getRotation()), r = this.constraints_.resolution(
      this.targetResolution_ * e,
      0,
      n,
      i
    );
    t && (this.targetCenter_ = this.calculateCenterZoom(r, t)), this.targetResolution_ *= e, this.applyTargetState_();
  }
  /**
   * Adds a value to the view zoom level, optionally using an anchor. Any resolution
   * constraint will apply.
   * @param {number} delta Relative value to add to the zoom level.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   * @api
   */
  adjustZoom(e, t) {
    this.adjustResolution(Math.pow(this.zoomFactor_, -e), t);
  }
  /**
   * Adds a value to the view rotation, optionally using an anchor. Any rotation
   * constraint will apply.
   * @param {number} delta Relative value to add to the zoom rotation, in radians.
   * @param {import("./coordinate.js").Coordinate} [anchor] The rotation center.
   * @api
   */
  adjustRotation(e, t) {
    t && (t = he(t, this.getProjection())), this.adjustRotationInternal(e, t);
  }
  /**
   * @param {number} delta Relative value to add to the zoom rotation, in radians.
   * @param {import("./coordinate.js").Coordinate} [anchor] The rotation center.
   */
  adjustRotationInternal(e, t) {
    const i = this.getAnimating() || this.getInteracting(), n = this.constraints_.rotation(
      this.targetRotation_ + e,
      i
    );
    t && (this.targetCenter_ = this.calculateCenterRotate(n, t)), this.targetRotation_ += e, this.applyTargetState_();
  }
  /**
   * Set the center of the current view. Any extent constraint will apply.
   * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
   * @observable
   * @api
   */
  setCenter(e) {
    this.setCenterInternal(
      e && he(e, this.getProjection())
    );
  }
  /**
   * Set the center using the view projection (not the user projection).
   * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
   */
  setCenterInternal(e) {
    this.targetCenter_ = e, this.applyTargetState_();
  }
  /**
   * @param {import("./ViewHint.js").default} hint Hint.
   * @param {number} delta Delta.
   * @return {number} New value.
   */
  setHint(e, t) {
    return this.hints_[e] += t, this.changed(), this.hints_[e];
  }
  /**
   * Set the resolution for this view. Any resolution constraint will apply.
   * @param {number|undefined} resolution The resolution of the view.
   * @observable
   * @api
   */
  setResolution(e) {
    this.targetResolution_ = e, this.applyTargetState_();
  }
  /**
   * Set the rotation for this view. Any rotation constraint will apply.
   * @param {number} rotation The rotation of the view in radians.
   * @observable
   * @api
   */
  setRotation(e) {
    this.targetRotation_ = e, this.applyTargetState_();
  }
  /**
   * Zoom to a specific zoom level. Any resolution constrain will apply.
   * @param {number} zoom Zoom level.
   * @api
   */
  setZoom(e) {
    this.setResolution(this.getResolutionForZoom(e));
  }
  /**
   * Recompute rotation/resolution/center based on target values.
   * Note: we have to compute rotation first, then resolution and center considering that
   * parameters can influence one another in case a view extent constraint is present.
   * @param {boolean} [doNotCancelAnims] Do not cancel animations.
   * @param {boolean} [forceMoving] Apply constraints as if the view is moving.
   * @private
   */
  applyTargetState_(e, t) {
    const i = this.getAnimating() || this.getInteracting() || t, n = this.constraints_.rotation(
      this.targetRotation_,
      i
    ), r = this.getViewportSize_(n), o = this.constraints_.resolution(
      this.targetResolution_,
      0,
      r,
      i
    ), a = this.constraints_.center(
      this.targetCenter_,
      o,
      r,
      i,
      this.calculateCenterShift(
        this.targetCenter_,
        o,
        n,
        r
      )
    );
    this.get(je.ROTATION) !== n && this.set(je.ROTATION, n), this.get(je.RESOLUTION) !== o && (this.set(je.RESOLUTION, o), this.set("zoom", this.getZoom(), !0)), (!a || !this.get(je.CENTER) || !rt(this.get(je.CENTER), a)) && this.set(je.CENTER, a), this.getAnimating() && !e && this.cancelAnimations(), this.cancelAnchor_ = void 0;
  }
  /**
   * If any constraints need to be applied, an animation will be triggered.
   * This is typically done on interaction end.
   * Note: calling this with a duration of 0 will apply the constrained values straight away,
   * without animation.
   * @param {number} [duration] The animation duration in ms.
   * @param {number} [resolutionDirection] Which direction to zoom.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   */
  resolveConstraints(e, t, i) {
    e = e !== void 0 ? e : 200;
    const n = t || 0, r = this.constraints_.rotation(this.targetRotation_), o = this.getViewportSize_(r), a = this.constraints_.resolution(
      this.targetResolution_,
      n,
      o
    ), l = this.constraints_.center(
      this.targetCenter_,
      a,
      o,
      !1,
      this.calculateCenterShift(
        this.targetCenter_,
        a,
        r,
        o
      )
    );
    if (e === 0 && !this.cancelAnchor_) {
      this.targetResolution_ = a, this.targetRotation_ = r, this.targetCenter_ = l, this.applyTargetState_();
      return;
    }
    i = i || (e === 0 ? this.cancelAnchor_ : void 0), this.cancelAnchor_ = void 0, (this.getResolution() !== a || this.getRotation() !== r || !this.getCenterInternal() || !rt(this.getCenterInternal(), l)) && (this.getAnimating() && this.cancelAnimations(), this.animateInternal({
      rotation: r,
      center: l,
      resolution: a,
      duration: e,
      easing: dn,
      anchor: i
    }));
  }
  /**
   * Notify the View that an interaction has started.
   * The view state will be resolved to a stable one if needed
   * (depending on its constraints).
   * @api
   */
  beginInteraction() {
    this.resolveConstraints(0), this.setHint(ge.INTERACTING, 1);
  }
  /**
   * Notify the View that an interaction has ended. The view state will be resolved
   * to a stable one if needed (depending on its constraints).
   * @param {number} [duration] Animation duration in ms.
   * @param {number} [resolutionDirection] Which direction to zoom.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   * @api
   */
  endInteraction(e, t, i) {
    i = i && he(i, this.getProjection()), this.endInteractionInternal(e, t, i);
  }
  /**
   * Notify the View that an interaction has ended. The view state will be resolved
   * to a stable one if needed (depending on its constraints).
   * @param {number} [duration] Animation duration in ms.
   * @param {number} [resolutionDirection] Which direction to zoom.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   */
  endInteractionInternal(e, t, i) {
    this.getInteracting() && (this.setHint(ge.INTERACTING, -1), this.resolveConstraints(e, t, i));
  }
  /**
   * Get a valid position for the view center according to the current constraints.
   * @param {import("./coordinate.js").Coordinate|undefined} targetCenter Target center position.
   * @param {number} [targetResolution] Target resolution. If not supplied, the current one will be used.
   * This is useful to guess a valid center position at a different zoom level.
   * @return {import("./coordinate.js").Coordinate|undefined} Valid center position.
   */
  getConstrainedCenter(e, t) {
    const i = this.getViewportSize_(this.getRotation());
    return this.constraints_.center(
      e,
      t || this.getResolution(),
      i
    );
  }
  /**
   * Get a valid zoom level according to the current view constraints.
   * @param {number|undefined} targetZoom Target zoom.
   * @param {number} [direction=0] Indicate which resolution should be used
   * by a renderer if the view resolution does not match any resolution of the tile source.
   * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
   * will be used. If -1, the nearest higher resolution will be used.
   * @return {number|undefined} Valid zoom level.
   */
  getConstrainedZoom(e, t) {
    const i = this.getResolutionForZoom(e);
    return this.getZoomForResolution(
      this.getConstrainedResolution(i, t)
    );
  }
  /**
   * Get a valid resolution according to the current view constraints.
   * @param {number|undefined} targetResolution Target resolution.
   * @param {number} [direction=0] Indicate which resolution should be used
   * by a renderer if the view resolution does not match any resolution of the tile source.
   * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
   * will be used. If -1, the nearest higher resolution will be used.
   * @return {number|undefined} Valid resolution.
   */
  getConstrainedResolution(e, t) {
    t = t || 0;
    const i = this.getViewportSize_(this.getRotation());
    return this.constraints_.resolution(e, t, i);
  }
}
function As(s, e) {
  setTimeout(function() {
    s(e);
  }, 0);
}
function _f(s) {
  if (s.extent !== void 0) {
    const t = s.smoothExtentConstraint !== void 0 ? s.smoothExtentConstraint : !0;
    return Tl(s.extent, s.constrainOnlyCenter, t);
  }
  const e = xa(s.projection, "EPSG:3857");
  if (s.multiWorld !== !0 && e.isGlobal()) {
    const t = e.getExtent().slice();
    return t[0] = -1 / 0, t[2] = 1 / 0, Tl(t, !1, !1);
  }
  return Ud;
}
function mf(s) {
  let e, t, i, o = s.minZoom !== void 0 ? s.minZoom : Hr, a = s.maxZoom !== void 0 ? s.maxZoom : 28;
  const l = s.zoomFactor !== void 0 ? s.zoomFactor : 2, h = s.multiWorld !== void 0 ? s.multiWorld : !1, c = s.smoothResolutionConstraint !== void 0 ? s.smoothResolutionConstraint : !0, u = s.showFullExtent !== void 0 ? s.showFullExtent : !1, d = xa(s.projection, "EPSG:3857"), f = d.getExtent();
  let g = s.constrainOnlyCenter, _ = s.extent;
  if (!h && !_ && d.isGlobal() && (g = !1, _ = f), s.resolutions !== void 0) {
    const m = s.resolutions;
    t = m[o], i = m[a] !== void 0 ? m[a] : m[m.length - 1], s.constrainResolution ? e = zd(
      m,
      c,
      !g && _,
      u
    ) : e = Sl(
      t,
      i,
      c,
      !g && _,
      u
    );
  } else {
    const p = (f ? Math.max(te(f), Fe(f)) : (
      // use an extent that can fit the whole world if need be
      360 * on.degrees / d.getMetersPerUnit()
    )) / fa / Math.pow(2, Hr), x = p / Math.pow(2, 28 - Hr);
    t = s.maxResolution, t !== void 0 ? o = 0 : t = p / Math.pow(l, o), i = s.minResolution, i === void 0 && (s.maxZoom !== void 0 ? s.maxResolution !== void 0 ? i = t / Math.pow(l, a) : i = p / Math.pow(l, a) : i = x), a = o + Math.floor(
      Math.log(t / i) / Math.log(l)
    ), i = t / Math.pow(l, a - o), s.constrainResolution ? e = Bd(
      l,
      t,
      i,
      c,
      !g && _,
      u
    ) : e = Sl(
      t,
      i,
      c,
      !g && _,
      u
    );
  }
  return {
    constraint: e,
    maxResolution: t,
    minResolution: i,
    minZoom: o,
    zoomFactor: l
  };
}
function pf(s) {
  if (s.enableRotation !== void 0 ? s.enableRotation : !0) {
    const t = s.constrainRotation;
    return t === void 0 || t === !0 ? Wd() : t === !1 ? Rl : typeof t == "number" ? Xd(t) : Rl;
  }
  return wa;
}
function yf(s) {
  return !(s.sourceCenter && s.targetCenter && !rt(s.sourceCenter, s.targetCenter) || s.sourceResolution !== s.targetResolution || s.sourceRotation !== s.targetRotation);
}
function Kr(s, e, t, i, n) {
  const r = Math.cos(-n);
  let o = Math.sin(-n), a = s[0] * r - s[1] * o, l = s[1] * r + s[0] * o;
  a += (e[0] / 2 - t[0]) * i, l += (t[1] - e[1] / 2) * i, o = -o;
  const h = a * r - l * o, c = l * r + a * o;
  return [h, c];
}
const Pe = gf;
class xf extends Gh {
  /**
   * @param {Options<SourceType>} options Layer options.
   */
  constructor(e) {
    const t = Object.assign({}, e);
    delete t.source, super(t), this.on, this.once, this.un, this.mapPrecomposeKey_ = null, this.mapRenderKey_ = null, this.sourceChangeKey_ = null, this.renderer_ = null, this.sourceReady_ = !1, this.rendered = !1, e.render && (this.render = e.render), e.map && this.setMap(e.map), this.addChangeListener(
      ne.SOURCE,
      this.handleSourcePropertyChange_
    );
    const i = e.source ? (
      /** @type {SourceType} */
      e.source
    ) : null;
    this.setSource(i);
  }
  /**
   * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be modified in place).
   * @return {Array<import("./Layer.js").default>} Array of layers.
   */
  getLayersArray(e) {
    return e = e || [], e.push(this), e;
  }
  /**
   * @param {Array<import("./Layer.js").State>} [states] Optional list of layer states (to be modified in place).
   * @return {Array<import("./Layer.js").State>} List of layer states.
   */
  getLayerStatesArray(e) {
    return e = e || [], e.push(this.getLayerState()), e;
  }
  /**
   * Get the layer source.
   * @return {SourceType|null} The layer source (or `null` if not yet set).
   * @observable
   * @api
   */
  getSource() {
    return (
      /** @type {SourceType} */
      this.get(ne.SOURCE) || null
    );
  }
  /**
   * @return {SourceType|null} The source being rendered.
   */
  getRenderSource() {
    return this.getSource();
  }
  /**
   * @return {import("../source/Source.js").State} Source state.
   */
  getSourceState() {
    const e = this.getSource();
    return e ? e.getState() : "undefined";
  }
  /**
   * @private
   */
  handleSourceChange_() {
    this.changed(), !(this.sourceReady_ || this.getSource().getState() !== "ready") && (this.sourceReady_ = !0, this.dispatchEvent("sourceready"));
  }
  /**
   * @private
   */
  handleSourcePropertyChange_() {
    this.sourceChangeKey_ && (re(this.sourceChangeKey_), this.sourceChangeKey_ = null), this.sourceReady_ = !1;
    const e = this.getSource();
    e && (this.sourceChangeKey_ = H(
      e,
      z.CHANGE,
      this.handleSourceChange_,
      this
    ), e.getState() === "ready" && (this.sourceReady_ = !0, setTimeout(() => {
      this.dispatchEvent("sourceready");
    }, 0))), this.changed();
  }
  /**
   * @param {import("../pixel").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with
   * an array of features.
   */
  getFeatures(e) {
    return this.renderer_ ? this.renderer_.getFeatures(e) : Promise.resolve([]);
  }
  /**
   * @param {import("../pixel").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
   */
  getData(e) {
    return !this.renderer_ || !this.rendered ? null : this.renderer_.getData(e);
  }
  /**
   * The layer is visible in the given view, i.e. within its min/max resolution or zoom and
   * extent, and `getVisible()` is `true`.
   * @param {View|import("../View.js").ViewStateAndExtent} view View or {@link import("../Map.js").FrameState}.
   * @return {boolean} The layer is visible in the current view.
   * @api
   */
  isVisible(e) {
    let t;
    e instanceof Pe ? t = {
      viewState: e.getState(),
      extent: e.calculateExtent()
    } : t = e;
    const i = this.getExtent();
    return this.getVisible() && Ma(this.getLayerState(), t.viewState) && (!i || Ce(i, t.extent));
  }
  /**
   * Get the attributions of the source of this layer for the given view.
   * @param {View|import("../View.js").ViewStateAndExtent} view View or  {@link import("../Map.js").FrameState}.
   * @return {Array<string>} Attributions for this layer at the given view.
   * @api
   */
  getAttributions(e) {
    if (!this.isVisible(e))
      return [];
    let t;
    const i = this.getSource();
    if (i && (t = i.getAttributions()), !t)
      return [];
    const n = e instanceof Pe ? e.getViewStateAndExtent() : e;
    let r = t(n);
    return Array.isArray(r) || (r = [r]), r;
  }
  /**
   * In charge to manage the rendering of the layer. One layer type is
   * bounded with one layer renderer.
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target which the renderer may (but need not) use
   * for rendering its content.
   * @return {HTMLElement} The rendered element.
   */
  render(e, t) {
    const i = this.getRenderer();
    if (i.prepareFrame(e))
      return this.rendered = !0, i.renderFrame(e, t);
  }
  /**
   * Called when a layer is not visible during a map render.
   */
  unrender() {
    this.rendered = !1;
  }
  /**
   * For use inside the library only.
   * @param {import("../Map.js").default|null} map Map.
   */
  setMapInternal(e) {
    e || this.unrender(), this.set(ne.MAP, e);
  }
  /**
   * For use inside the library only.
   * @return {import("../Map.js").default|null} Map.
   */
  getMapInternal() {
    return this.get(ne.MAP);
  }
  /**
   * Sets the layer to be rendered on top of other layers on a map. The map will
   * not manage this layer in its layers collection. This
   * is useful for temporary layers. To remove an unmanaged layer from the map,
   * use `#setMap(null)`.
   *
   * To add the layer to a map and have it managed by the map, use
   * {@link module:ol/Map~Map#addLayer} instead.
   * @param {import("../Map.js").default|null} map Map.
   * @api
   */
  setMap(e) {
    this.mapPrecomposeKey_ && (re(this.mapPrecomposeKey_), this.mapPrecomposeKey_ = null), e || this.changed(), this.mapRenderKey_ && (re(this.mapRenderKey_), this.mapRenderKey_ = null), e && (this.mapPrecomposeKey_ = H(
      e,
      Xe.PRECOMPOSE,
      function(t) {
        const n = /** @type {import("../render/Event.js").default} */ t.frameState.layerStatesArray, r = this.getLayerState(!1);
        Z(
          !n.some(function(o) {
            return o.layer === r.layer;
          }),
          67
        ), n.push(r);
      },
      this
    ), this.mapRenderKey_ = H(this, z.CHANGE, e.render, e), this.changed());
  }
  /**
   * Set the layer source.
   * @param {SourceType|null} source The layer source.
   * @observable
   * @api
   */
  setSource(e) {
    this.set(ne.SOURCE, e);
  }
  /**
   * Get the renderer for this layer.
   * @return {RendererType|null} The layer renderer.
   */
  getRenderer() {
    return this.renderer_ || (this.renderer_ = this.createRenderer()), this.renderer_;
  }
  /**
   * @return {boolean} The layer has a renderer.
   */
  hasRenderer() {
    return !!this.renderer_;
  }
  /**
   * Create a renderer for this layer.
   * @return {RendererType} A layer renderer.
   * @protected
   */
  createRenderer() {
    return null;
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    this.renderer_ && (this.renderer_.dispose(), delete this.renderer_), this.setSource(null), super.disposeInternal();
  }
}
function Ma(s, e) {
  if (!s.visible)
    return !1;
  const t = e.resolution;
  if (t < s.minResolution || t >= s.maxResolution)
    return !1;
  const i = e.zoom;
  return i > s.minZoom && i <= s.maxZoom;
}
const hs = xf;
class Ef extends wr {
  /**
   * @param {import("../Map.js").default} map Map.
   */
  constructor(e) {
    super(), this.map_ = e;
  }
  /**
   * @abstract
   * @param {import("../render/EventType.js").default} type Event type.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */
  dispatchRenderEvent(e, t) {
    X();
  }
  /**
   * @param {import("../Map.js").FrameState} frameState FrameState.
   * @protected
   */
  calculateMatrices2D(e) {
    const t = e.viewState, i = e.coordinateToPixelTransform, n = e.pixelToCoordinateTransform;
    Je(
      i,
      e.size[0] / 2,
      e.size[1] / 2,
      1 / t.resolution,
      -1 / t.resolution,
      -t.rotation,
      -t.center[0],
      -t.center[1]
    ), ns(n, i);
  }
  /**
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../Map.js").FrameState} frameState FrameState.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {boolean} checkWrapped Check for wrapped geometries.
   * @param {import("./vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {S} thisArg Value to use as `this` when executing `callback`.
   * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter
   *     function, only layers which are visible and for which this function
   *     returns `true` will be tested for features.  By default, all visible
   *     layers will be tested.
   * @param {U} thisArg2 Value to use as `this` when executing `layerFilter`.
   * @return {T|undefined} Callback result.
   * @template S,T,U
   */
  forEachFeatureAtCoordinate(e, t, i, n, r, o, a, l) {
    let h;
    const c = t.viewState;
    function u(E, C, T, w) {
      return r.call(o, C, E ? T : null, w);
    }
    const d = c.projection, f = _a(e.slice(), d), g = [[0, 0]];
    if (d.canWrapX() && n) {
      const E = d.getExtent(), C = te(E);
      g.push([-C, 0], [C, 0]);
    }
    const _ = t.layerStatesArray, m = _.length, p = (
      /** @type {Array<HitMatch<T>>} */
      []
    ), x = [];
    for (let E = 0; E < g.length; E++)
      for (let C = m - 1; C >= 0; --C) {
        const T = _[C], w = T.layer;
        if (w.hasRenderer() && Ma(T, c) && a.call(l, w)) {
          const L = w.getRenderer(), I = w.getSource();
          if (L && I) {
            const S = I.getWrapX() ? f : e, Y = u.bind(
              null,
              T.managed
            );
            x[0] = S[0] + g[E][0], x[1] = S[1] + g[E][1], h = L.forEachFeatureAtCoordinate(
              x,
              t,
              i,
              Y,
              p
            );
          }
          if (h)
            return h;
        }
      }
    if (p.length === 0)
      return;
    const y = 1 / p.length;
    return p.forEach((E, C) => E.distanceSq += C * y), p.sort((E, C) => E.distanceSq - C.distanceSq), p.some((E) => h = E.callback(E.feature, E.layer, E.geometry)), h;
  }
  /**
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../Map.js").FrameState} frameState FrameState.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {boolean} checkWrapped Check for wrapped geometries.
   * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter
   *     function, only layers which are visible and for which this function
   *     returns `true` will be tested for features.  By default, all visible
   *     layers will be tested.
   * @param {U} thisArg Value to use as `this` when executing `layerFilter`.
   * @return {boolean} Is there a feature at the given coordinate?
   * @template U
   */
  hasFeatureAtCoordinate(e, t, i, n, r, o) {
    return this.forEachFeatureAtCoordinate(
      e,
      t,
      i,
      n,
      mt,
      this,
      r,
      o
    ) !== void 0;
  }
  /**
   * @return {import("../Map.js").default} Map.
   */
  getMap() {
    return this.map_;
  }
  /**
   * Render.
   * @abstract
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   */
  renderFrame(e) {
    X();
  }
  /**
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @protected
   */
  scheduleExpireIconCache(e) {
    Qs.canExpireCache() && e.postRenderFunctions.push(vf);
  }
}
function vf(s, e) {
  Qs.expire();
}
const Cf = Ef;
class wf extends Ye {
  /**
   * @param {import("./EventType.js").default} type Type.
   * @param {import("../transform.js").Transform} [inversePixelTransform] Transform for
   *     CSS pixels to rendered pixels.
   * @param {import("../Map.js").FrameState} [frameState] Frame state.
   * @param {?(CanvasRenderingContext2D|WebGLRenderingContext)} [context] Context.
   */
  constructor(e, t, i, n) {
    super(e), this.inversePixelTransform = t, this.frameState = i, this.context = n;
  }
}
const An = wf, Fs = "ol-hidden", Tf = "ol-selectable", Ii = "ol-unselectable", bl = "ol-unsupported", cs = "ol-control", ar = "ol-collapsed", Sf = new RegExp(
  [
    "^\\s*(?=(?:(?:[-a-z]+\\s*){0,2}(italic|oblique))?)",
    "(?=(?:(?:[-a-z]+\\s*){0,2}(small-caps))?)",
    "(?=(?:(?:[-a-z]+\\s*){0,2}(bold(?:er)?|lighter|[1-9]00 ))?)",
    "(?:(?:normal|\\1|\\2|\\3)\\s*){0,3}((?:xx?-)?",
    "(?:small|large)|medium|smaller|larger|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx]))",
    "(?:\\s*\\/\\s*(normal|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx])?))",
    `?\\s*([-,\\"\\'\\sa-z]+?)\\s*$`
  ].join(""),
  "i"
), Pl = [
  "style",
  "variant",
  "weight",
  "size",
  "lineHeight",
  "family"
], ac = function(s) {
  const e = s.match(Sf);
  if (!e)
    return null;
  const t = (
    /** @type {FontParameters} */
    {
      lineHeight: "normal",
      size: "1.2em",
      style: "normal",
      weight: "normal",
      variant: "normal"
    }
  );
  for (let i = 0, n = Pl.length; i < n; ++i) {
    const r = e[i + 1];
    r !== void 0 && (t[Pl[i]] = r);
  }
  return t.families = t.family.split(/,\s?/), t;
};
function Re(s, e, t, i) {
  let n;
  return t && t.length ? n = t.shift() : la ? n = new OffscreenCanvas(s || 300, e || 300) : n = document.createElement("canvas"), s && (n.width = s), e && (n.height = e), /** @type {CanvasRenderingContext2D} */
  n.getContext("2d", i);
}
function Ar(s) {
  const e = s.canvas;
  e.width = 1, e.height = 1, s.clearRect(0, 0, 1, 1);
}
function Rf(s) {
  let e = s.offsetWidth;
  const t = getComputedStyle(s);
  return e += parseInt(t.marginLeft, 10) + parseInt(t.marginRight, 10), e;
}
function If(s) {
  let e = s.offsetHeight;
  const t = getComputedStyle(s);
  return e += parseInt(t.marginTop, 10) + parseInt(t.marginBottom, 10), e;
}
function an(s, e) {
  const t = e.parentNode;
  t && t.replaceChild(s, e);
}
function lr(s) {
  return s && s.parentNode ? s.parentNode.removeChild(s) : null;
}
function lc(s) {
  for (; s.lastChild; )
    s.removeChild(s.lastChild);
}
function Lf(s, e) {
  const t = s.childNodes;
  for (let i = 0; ; ++i) {
    const n = t[i], r = e[i];
    if (!n && !r)
      break;
    if (n !== r) {
      if (!n) {
        s.appendChild(r);
        continue;
      }
      if (!r) {
        s.removeChild(n), --i;
        continue;
      }
      s.insertBefore(r, n);
    }
  }
}
const hc = "10px sans-serif", Pt = "#000", hr = "round", Bn = [], Xn = 0, ln = "round", Wn = 10, Yn = "#000", Vn = "center", cr = "middle", ui = [0, 0, 0, 0], Zn = 1, It = new ht();
let zi = null, Uo;
const zo = {}, Af = function() {
  const e = "32px ", t = ["monospace", "serif"], i = t.length, n = "wmytzilWMYTZIL@#/&?$%10";
  let r, o;
  function a(h, c, u) {
    let d = !0;
    for (let f = 0; f < i; ++f) {
      const g = t[f];
      if (o = ur(
        h + " " + c + " " + e + g,
        n
      ), u != g) {
        const _ = ur(
          h + " " + c + " " + e + u + "," + g,
          n
        );
        d = d && _ != o;
      }
    }
    return !!d;
  }
  function l() {
    let h = !0;
    const c = It.getKeys();
    for (let u = 0, d = c.length; u < d; ++u) {
      const f = c[u];
      It.get(f) < 100 && (a.apply(this, f.split(`
`)) ? (Ti(zo), zi = null, Uo = void 0, It.set(f, 100)) : (It.set(f, It.get(f) + 1, !0), h = !1));
    }
    h && (clearInterval(r), r = void 0);
  }
  return function(h) {
    const c = ac(h);
    if (!c)
      return;
    const u = c.families;
    for (let d = 0, f = u.length; d < f; ++d) {
      const g = u[d], _ = c.style + `
` + c.weight + `
` + g;
      It.get(_) === void 0 && (It.set(_, 100, !0), a(c.style, c.weight, g) || (It.set(_, 0, !0), r === void 0 && (r = setInterval(l, 32))));
    }
  };
}(), Ff = function() {
  let s;
  return function(e) {
    let t = zo[e];
    if (t == null) {
      if (la) {
        const i = ac(e), n = cc(e, "Žg");
        t = (isNaN(Number(i.lineHeight)) ? 1.2 : Number(i.lineHeight)) * (n.actualBoundingBoxAscent + n.actualBoundingBoxDescent);
      } else
        s || (s = document.createElement("div"), s.innerHTML = "M", s.style.minHeight = "0", s.style.maxHeight = "none", s.style.height = "auto", s.style.padding = "0", s.style.border = "none", s.style.position = "absolute", s.style.display = "block", s.style.left = "-99999px"), s.style.font = e, document.body.appendChild(s), t = s.offsetHeight, document.body.removeChild(s);
      zo[e] = t;
    }
    return t;
  };
}();
function cc(s, e) {
  return zi || (zi = Re(1, 1)), s != Uo && (zi.font = s, Uo = zi.font), zi.measureText(e);
}
function ur(s, e) {
  return cc(s, e).width;
}
function Ml(s, e, t) {
  if (e in t)
    return t[e];
  const i = e.split(`
`).reduce((n, r) => Math.max(n, ur(s, r)), 0);
  return t[e] = i, i;
}
function bf(s, e) {
  const t = [], i = [], n = [];
  let r = 0, o = 0, a = 0, l = 0;
  for (let h = 0, c = e.length; h <= c; h += 2) {
    const u = e[h];
    if (u === `
` || h === c) {
      r = Math.max(r, o), n.push(o), o = 0, a += l;
      continue;
    }
    const d = e[h + 1] || s.font, f = ur(d, u);
    t.push(f), o += f;
    const g = Ff(d);
    i.push(g), l = Math.max(l, g);
  }
  return { width: r, height: a, widths: t, heights: i, lineWidths: n };
}
function Pf(s, e, t, i, n, r, o, a, l, h, c) {
  s.save(), t !== 1 && (s.globalAlpha *= t), e && s.setTransform.apply(s, e), /** @type {*} */
  i.contextInstructions ? (s.translate(l, h), s.scale(c[0], c[1]), Mf(
    /** @type {Label} */
    i,
    s
  )) : c[0] < 0 || c[1] < 0 ? (s.translate(l, h), s.scale(c[0], c[1]), s.drawImage(
    /** @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} */
    i,
    n,
    r,
    o,
    a,
    0,
    0,
    o,
    a
  )) : s.drawImage(
    /** @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} */
    i,
    n,
    r,
    o,
    a,
    l,
    h,
    o * c[0],
    a * c[1]
  ), s.restore();
}
function Mf(s, e) {
  const t = s.contextInstructions;
  for (let i = 0, n = t.length; i < n; i += 2)
    Array.isArray(t[i + 1]) ? e[t[i]].apply(
      e,
      t[i + 1]
    ) : e[t[i]] = t[i + 1];
}
class Of extends Cf {
  /**
   * @param {import("../Map.js").default} map Map.
   */
  constructor(e) {
    super(e), this.fontChangeListenerKey_ = H(
      It,
      Ei.PROPERTYCHANGE,
      e.redrawText.bind(e)
    ), this.element_ = document.createElement("div");
    const t = this.element_.style;
    t.position = "absolute", t.width = "100%", t.height = "100%", t.zIndex = "0", this.element_.className = Ii + " ol-layers";
    const i = e.getViewport();
    i.insertBefore(this.element_, i.firstChild || null), this.children_ = [], this.renderedVisible_ = !0;
  }
  /**
   * @param {import("../render/EventType.js").default} type Event type.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */
  dispatchRenderEvent(e, t) {
    const i = this.getMap();
    if (i.hasListener(e)) {
      const n = new An(e, void 0, t);
      i.dispatchEvent(n);
    }
  }
  disposeInternal() {
    re(this.fontChangeListenerKey_), this.element_.parentNode.removeChild(this.element_), super.disposeInternal();
  }
  /**
   * Render.
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   */
  renderFrame(e) {
    if (!e) {
      this.renderedVisible_ && (this.element_.style.display = "none", this.renderedVisible_ = !1);
      return;
    }
    this.calculateMatrices2D(e), this.dispatchRenderEvent(Xe.PRECOMPOSE, e);
    const t = e.layerStatesArray.sort(function(o, a) {
      return o.zIndex - a.zIndex;
    }), i = e.viewState;
    this.children_.length = 0;
    const n = [];
    let r = null;
    for (let o = 0, a = t.length; o < a; ++o) {
      const l = t[o];
      e.layerIndex = o;
      const h = l.layer, c = h.getSourceState();
      if (!Ma(l, i) || c != "ready" && c != "undefined") {
        h.unrender();
        continue;
      }
      const u = h.render(e, r);
      u && (u !== r && (this.children_.push(u), r = u), "getDeclutter" in h && n.push(
        /** @type {import("../layer/BaseVector.js").default} */
        h
      ));
    }
    for (let o = n.length - 1; o >= 0; --o)
      n[o].renderDeclutter(e);
    Lf(this.element_, this.children_), this.dispatchRenderEvent(Xe.POSTCOMPOSE, e), this.renderedVisible_ || (this.element_.style.display = "", this.renderedVisible_ = !0), this.scheduleExpireIconCache(e);
  }
}
const Df = Of;
class Ht extends Ye {
  /**
   * @param {EventType} type The event type.
   * @param {BaseLayer} layer The layer.
   */
  constructor(e, t) {
    super(e), this.layer = t;
  }
}
const qr = {
  LAYERS: "layers"
};
class Oa extends Gh {
  /**
   * @param {Options} [options] Layer options.
   */
  constructor(e) {
    e = e || {};
    const t = (
      /** @type {Options} */
      Object.assign({}, e)
    );
    delete t.layers;
    let i = e.layers;
    super(t), this.on, this.once, this.un, this.layersListenerKeys_ = [], this.listenerKeys_ = {}, this.addChangeListener(qr.LAYERS, this.handleLayersChanged_), i ? Array.isArray(i) ? i = new ce(i.slice(), { unique: !0 }) : Z(typeof /** @type {?} */
    i.getArray == "function", 43) : i = new ce(void 0, { unique: !0 }), this.setLayers(i);
  }
  /**
   * @private
   */
  handleLayerChange_() {
    this.changed();
  }
  /**
   * @private
   */
  handleLayersChanged_() {
    this.layersListenerKeys_.forEach(re), this.layersListenerKeys_.length = 0;
    const e = this.getLayers();
    this.layersListenerKeys_.push(
      H(e, ve.ADD, this.handleLayersAdd_, this),
      H(e, ve.REMOVE, this.handleLayersRemove_, this)
    );
    for (const i in this.listenerKeys_)
      this.listenerKeys_[i].forEach(re);
    Ti(this.listenerKeys_);
    const t = e.getArray();
    for (let i = 0, n = t.length; i < n; i++) {
      const r = t[i];
      this.registerLayerListeners_(r), this.dispatchEvent(new Ht("addlayer", r));
    }
    this.changed();
  }
  /**
   * @param {BaseLayer} layer The layer.
   */
  registerLayerListeners_(e) {
    const t = [
      H(
        e,
        Ei.PROPERTYCHANGE,
        this.handleLayerChange_,
        this
      ),
      H(e, z.CHANGE, this.handleLayerChange_, this)
    ];
    e instanceof Oa && t.push(
      H(e, "addlayer", this.handleLayerGroupAdd_, this),
      H(e, "removelayer", this.handleLayerGroupRemove_, this)
    ), this.listenerKeys_[B(e)] = t;
  }
  /**
   * @param {GroupEvent} event The layer group event.
   */
  handleLayerGroupAdd_(e) {
    this.dispatchEvent(new Ht("addlayer", e.layer));
  }
  /**
   * @param {GroupEvent} event The layer group event.
   */
  handleLayerGroupRemove_(e) {
    this.dispatchEvent(new Ht("removelayer", e.layer));
  }
  /**
   * @param {import("../Collection.js").CollectionEvent<import("./Base.js").default>} collectionEvent CollectionEvent.
   * @private
   */
  handleLayersAdd_(e) {
    const t = e.element;
    this.registerLayerListeners_(t), this.dispatchEvent(new Ht("addlayer", t)), this.changed();
  }
  /**
   * @param {import("../Collection.js").CollectionEvent<import("./Base.js").default>} collectionEvent CollectionEvent.
   * @private
   */
  handleLayersRemove_(e) {
    const t = e.element, i = B(t);
    this.listenerKeys_[i].forEach(re), delete this.listenerKeys_[i], this.dispatchEvent(new Ht("removelayer", t)), this.changed();
  }
  /**
   * Returns the {@link module:ol/Collection~Collection collection} of {@link module:ol/layer/Layer~Layer layers}
   * in this group.
   * @return {!Collection<import("./Base.js").default>} Collection of
   *   {@link module:ol/layer/Base~BaseLayer layers} that are part of this group.
   * @observable
   * @api
   */
  getLayers() {
    return (
      /** @type {!Collection<import("./Base.js").default>} */
      this.get(qr.LAYERS)
    );
  }
  /**
   * Set the {@link module:ol/Collection~Collection collection} of {@link module:ol/layer/Layer~Layer layers}
   * in this group.
   * @param {!Collection<import("./Base.js").default>} layers Collection of
   *   {@link module:ol/layer/Base~BaseLayer layers} that are part of this group.
   * @observable
   * @api
   */
  setLayers(e) {
    const t = this.getLayers();
    if (t) {
      const i = t.getArray();
      for (let n = 0, r = i.length; n < r; ++n)
        this.dispatchEvent(new Ht("removelayer", i[n]));
    }
    this.set(qr.LAYERS, e);
  }
  /**
   * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be modified in place).
   * @return {Array<import("./Layer.js").default>} Array of layers.
   */
  getLayersArray(e) {
    return e = e !== void 0 ? e : [], this.getLayers().forEach(function(t) {
      t.getLayersArray(e);
    }), e;
  }
  /**
   * Get the layer states list and use this groups z-index as the default
   * for all layers in this and nested groups, if it is unset at this point.
   * If dest is not provided and this group's z-index is undefined
   * 0 is used a the default z-index.
   * @param {Array<import("./Layer.js").State>} [dest] Optional list
   * of layer states (to be modified in place).
   * @return {Array<import("./Layer.js").State>} List of layer states.
   */
  getLayerStatesArray(e) {
    const t = e !== void 0 ? e : [], i = t.length;
    this.getLayers().forEach(function(o) {
      o.getLayerStatesArray(t);
    });
    const n = this.getLayerState();
    let r = n.zIndex;
    !e && n.zIndex === void 0 && (r = 0);
    for (let o = i, a = t.length; o < a; o++) {
      const l = t[o];
      l.opacity *= n.opacity, l.visible = l.visible && n.visible, l.maxResolution = Math.min(
        l.maxResolution,
        n.maxResolution
      ), l.minResolution = Math.max(
        l.minResolution,
        n.minResolution
      ), l.minZoom = Math.max(l.minZoom, n.minZoom), l.maxZoom = Math.min(l.maxZoom, n.maxZoom), n.extent !== void 0 && (l.extent !== void 0 ? l.extent = pi(
        l.extent,
        n.extent
      ) : l.extent = n.extent), l.zIndex === void 0 && (l.zIndex = r);
    }
    return t;
  }
  /**
   * @return {import("../source/Source.js").State} Source state.
   */
  getSourceState() {
    return "ready";
  }
}
const Fr = Oa;
class kf extends Ye {
  /**
   * @param {string} type Event type.
   * @param {import("./Map.js").default} map Map.
   * @param {?import("./Map.js").FrameState} [frameState] Frame state.
   */
  constructor(e, t, i) {
    super(e), this.map = t, this.frameState = i !== void 0 ? i : null;
  }
}
const Bi = kf;
class Nf extends Bi {
  /**
   * @param {string} type Event type.
   * @param {import("./Map.js").default} map Map.
   * @param {EVENT} originalEvent Original event.
   * @param {boolean} [dragging] Is the map currently being dragged?
   * @param {import("./Map.js").FrameState} [frameState] Frame state.
   * @param {Array<PointerEvent>} [activePointers] Active pointers.
   */
  constructor(e, t, i, n, r, o) {
    super(e, t, r), this.originalEvent = i, this.pixel_ = null, this.coordinate_ = null, this.dragging = n !== void 0 ? n : !1, this.activePointers = o;
  }
  /**
   * The map pixel relative to the viewport corresponding to the original event.
   * @type {import("./pixel.js").Pixel}
   * @api
   */
  get pixel() {
    return this.pixel_ || (this.pixel_ = this.map.getEventPixel(this.originalEvent)), this.pixel_;
  }
  set pixel(e) {
    this.pixel_ = e;
  }
  /**
   * The coordinate corresponding to the original browser event.  This will be in the user
   * projection if one is set.  Otherwise it will be in the view projection.
   * @type {import("./coordinate.js").Coordinate}
   * @api
   */
  get coordinate() {
    return this.coordinate_ || (this.coordinate_ = this.map.getCoordinateFromPixel(this.pixel)), this.coordinate_;
  }
  set coordinate(e) {
    this.coordinate_ = e;
  }
  /**
   * Prevents the default browser action.
   * See https://developer.mozilla.org/en-US/docs/Web/API/event.preventDefault.
   * @api
   */
  preventDefault() {
    super.preventDefault(), "preventDefault" in this.originalEvent && this.originalEvent.preventDefault();
  }
  /**
   * Prevents further propagation of the current event.
   * See https://developer.mozilla.org/en-US/docs/Web/API/event.stopPropagation.
   * @api
   */
  stopPropagation() {
    super.stopPropagation(), "stopPropagation" in this.originalEvent && this.originalEvent.stopPropagation();
  }
}
const Lt = Nf, J = {
  /**
   * A true single click with no dragging and no double click. Note that this
   * event is delayed by 250 ms to ensure that it is not a double click.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#singleclick
   * @api
   */
  SINGLECLICK: "singleclick",
  /**
   * A click with no dragging. A double click will fire two of this.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#click
   * @api
   */
  CLICK: z.CLICK,
  /**
   * A true double click, with no dragging.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#dblclick
   * @api
   */
  DBLCLICK: z.DBLCLICK,
  /**
   * Triggered when a pointer is dragged.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointerdrag
   * @api
   */
  POINTERDRAG: "pointerdrag",
  /**
   * Triggered when a pointer is moved. Note that on touch devices this is
   * triggered when the map is panned, so is not the same as mousemove.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointermove
   * @api
   */
  POINTERMOVE: "pointermove",
  POINTERDOWN: "pointerdown",
  POINTERUP: "pointerup",
  POINTEROVER: "pointerover",
  POINTEROUT: "pointerout",
  POINTERENTER: "pointerenter",
  POINTERLEAVE: "pointerleave",
  POINTERCANCEL: "pointercancel"
}, jn = {
  POINTERMOVE: "pointermove",
  POINTERDOWN: "pointerdown",
  POINTERUP: "pointerup",
  POINTEROVER: "pointerover",
  POINTEROUT: "pointerout",
  POINTERENTER: "pointerenter",
  POINTERLEAVE: "pointerleave",
  POINTERCANCEL: "pointercancel"
};
class Gf extends es {
  /**
   * @param {import("./Map.js").default} map The map with the viewport to listen to events on.
   * @param {number} [moveTolerance] The minimal distance the pointer must travel to trigger a move.
   */
  constructor(e, t) {
    super(e), this.map_ = e, this.clickTimeoutId_, this.emulateClicks_ = !1, this.dragging_ = !1, this.dragListenerKeys_ = [], this.moveTolerance_ = t === void 0 ? 1 : t, this.down_ = null;
    const i = this.map_.getViewport();
    this.activePointers_ = [], this.trackedTouches_ = {}, this.element_ = i, this.pointerdownListenerKey_ = H(
      i,
      jn.POINTERDOWN,
      this.handlePointerDown_,
      this
    ), this.originalPointerMoveEvent_, this.relayedListenerKey_ = H(
      i,
      jn.POINTERMOVE,
      this.relayMoveEvent_,
      this
    ), this.boundHandleTouchMove_ = this.handleTouchMove_.bind(this), this.element_.addEventListener(
      z.TOUCHMOVE,
      this.boundHandleTouchMove_,
      Fh ? { passive: !1 } : !1
    );
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  emulateClick_(e) {
    let t = new Lt(
      J.CLICK,
      this.map_,
      e
    );
    this.dispatchEvent(t), this.clickTimeoutId_ !== void 0 ? (clearTimeout(this.clickTimeoutId_), this.clickTimeoutId_ = void 0, t = new Lt(
      J.DBLCLICK,
      this.map_,
      e
    ), this.dispatchEvent(t)) : this.clickTimeoutId_ = setTimeout(() => {
      this.clickTimeoutId_ = void 0;
      const i = new Lt(
        J.SINGLECLICK,
        this.map_,
        e
      );
      this.dispatchEvent(i);
    }, 250);
  }
  /**
   * Keeps track on how many pointers are currently active.
   *
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  updateActivePointers_(e) {
    const t = e, i = t.pointerId;
    if (t.type == J.POINTERUP || t.type == J.POINTERCANCEL) {
      delete this.trackedTouches_[i];
      for (const n in this.trackedTouches_)
        if (this.trackedTouches_[n].target !== t.target) {
          delete this.trackedTouches_[n];
          break;
        }
    } else
      (t.type == J.POINTERDOWN || t.type == J.POINTERMOVE) && (this.trackedTouches_[i] = t);
    this.activePointers_ = Object.values(this.trackedTouches_);
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  handlePointerUp_(e) {
    this.updateActivePointers_(e);
    const t = new Lt(
      J.POINTERUP,
      this.map_,
      e,
      void 0,
      void 0,
      this.activePointers_
    );
    this.dispatchEvent(t), this.emulateClicks_ && !t.defaultPrevented && !this.dragging_ && this.isMouseActionButton_(e) && this.emulateClick_(this.down_), this.activePointers_.length === 0 && (this.dragListenerKeys_.forEach(re), this.dragListenerKeys_.length = 0, this.dragging_ = !1, this.down_ = null);
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @return {boolean} If the left mouse button was pressed.
   * @private
   */
  isMouseActionButton_(e) {
    return e.button === 0;
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  handlePointerDown_(e) {
    this.emulateClicks_ = this.activePointers_.length === 0, this.updateActivePointers_(e);
    const t = new Lt(
      J.POINTERDOWN,
      this.map_,
      e,
      void 0,
      void 0,
      this.activePointers_
    );
    if (this.dispatchEvent(t), this.down_ = new PointerEvent(e.type, e), Object.defineProperty(this.down_, "target", {
      writable: !1,
      value: e.target
    }), this.dragListenerKeys_.length === 0) {
      const i = this.map_.getOwnerDocument();
      this.dragListenerKeys_.push(
        H(
          i,
          J.POINTERMOVE,
          this.handlePointerMove_,
          this
        ),
        H(i, J.POINTERUP, this.handlePointerUp_, this),
        /* Note that the listener for `pointercancel is set up on
         * `pointerEventHandler_` and not `documentPointerEventHandler_` like
         * the `pointerup` and `pointermove` listeners.
         *
         * The reason for this is the following: `TouchSource.vacuumTouches_()`
         * issues `pointercancel` events, when there was no `touchend` for a
         * `touchstart`. Now, let's say a first `touchstart` is registered on
         * `pointerEventHandler_`. The `documentPointerEventHandler_` is set up.
         * But `documentPointerEventHandler_` doesn't know about the first
         * `touchstart`. If there is no `touchend` for the `touchstart`, we can
         * only receive a `touchcancel` from `pointerEventHandler_`, because it is
         * only registered there.
         */
        H(
          this.element_,
          J.POINTERCANCEL,
          this.handlePointerUp_,
          this
        )
      ), this.element_.getRootNode && this.element_.getRootNode() !== i && this.dragListenerKeys_.push(
        H(
          this.element_.getRootNode(),
          J.POINTERUP,
          this.handlePointerUp_,
          this
        )
      );
    }
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  handlePointerMove_(e) {
    if (this.isMoving_(e)) {
      this.updateActivePointers_(e), this.dragging_ = !0;
      const t = new Lt(
        J.POINTERDRAG,
        this.map_,
        e,
        this.dragging_,
        void 0,
        this.activePointers_
      );
      this.dispatchEvent(t);
    }
  }
  /**
   * Wrap and relay a pointermove event.
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  relayMoveEvent_(e) {
    this.originalPointerMoveEvent_ = e;
    const t = !!(this.down_ && this.isMoving_(e));
    this.dispatchEvent(
      new Lt(
        J.POINTERMOVE,
        this.map_,
        e,
        t
      )
    );
  }
  /**
   * Flexible handling of a `touch-action: none` css equivalent: because calling
   * `preventDefault()` on a `pointermove` event does not stop native page scrolling
   * and zooming, we also listen for `touchmove` and call `preventDefault()` on it
   * when an interaction (currently `DragPan` handles the event.
   * @param {TouchEvent} event Event.
   * @private
   */
  handleTouchMove_(e) {
    const t = this.originalPointerMoveEvent_;
    (!t || t.defaultPrevented) && (typeof e.cancelable != "boolean" || e.cancelable === !0) && e.preventDefault();
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @return {boolean} Is moving.
   * @private
   */
  isMoving_(e) {
    return this.dragging_ || Math.abs(e.clientX - this.down_.clientX) > this.moveTolerance_ || Math.abs(e.clientY - this.down_.clientY) > this.moveTolerance_;
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    this.relayedListenerKey_ && (re(this.relayedListenerKey_), this.relayedListenerKey_ = null), this.element_.removeEventListener(
      z.TOUCHMOVE,
      this.boundHandleTouchMove_
    ), this.pointerdownListenerKey_ && (re(this.pointerdownListenerKey_), this.pointerdownListenerKey_ = null), this.dragListenerKeys_.forEach(re), this.dragListenerKeys_.length = 0, this.element_ = null, super.disposeInternal();
  }
}
const Uf = Gf, dt = {
  /**
   * Triggered after a map frame is rendered.
   * @event module:ol/MapEvent~MapEvent#postrender
   * @api
   */
  POSTRENDER: "postrender",
  /**
   * Triggered when the map starts moving.
   * @event module:ol/MapEvent~MapEvent#movestart
   * @api
   */
  MOVESTART: "movestart",
  /**
   * Triggered after the map is moved.
   * @event module:ol/MapEvent~MapEvent#moveend
   * @api
   */
  MOVEEND: "moveend",
  /**
   * Triggered when loading of additional map data (tiles, images, features) starts.
   * @event module:ol/MapEvent~MapEvent#loadstart
   * @api
   */
  LOADSTART: "loadstart",
  /**
   * Triggered when loading of additional map data has completed.
   * @event module:ol/MapEvent~MapEvent#loadend
   * @api
   */
  LOADEND: "loadend"
}, pe = {
  LAYERGROUP: "layergroup",
  SIZE: "size",
  TARGET: "target",
  VIEW: "view"
}, dr = 1 / 0;
class zf {
  /**
   * @param {function(T): number} priorityFunction Priority function.
   * @param {function(T): string} keyFunction Key function.
   */
  constructor(e, t) {
    this.priorityFunction_ = e, this.keyFunction_ = t, this.elements_ = [], this.priorities_ = [], this.queuedElements_ = {};
  }
  /**
   * FIXME empty description for jsdoc
   */
  clear() {
    this.elements_.length = 0, this.priorities_.length = 0, Ti(this.queuedElements_);
  }
  /**
   * Remove and return the highest-priority element. O(log N).
   * @return {T} Element.
   */
  dequeue() {
    const e = this.elements_, t = this.priorities_, i = e[0];
    e.length == 1 ? (e.length = 0, t.length = 0) : (e[0] = e.pop(), t[0] = t.pop(), this.siftUp_(0));
    const n = this.keyFunction_(i);
    return delete this.queuedElements_[n], i;
  }
  /**
   * Enqueue an element. O(log N).
   * @param {T} element Element.
   * @return {boolean} The element was added to the queue.
   */
  enqueue(e) {
    Z(!(this.keyFunction_(e) in this.queuedElements_), 31);
    const t = this.priorityFunction_(e);
    return t != dr ? (this.elements_.push(e), this.priorities_.push(t), this.queuedElements_[this.keyFunction_(e)] = !0, this.siftDown_(0, this.elements_.length - 1), !0) : !1;
  }
  /**
   * @return {number} Count.
   */
  getCount() {
    return this.elements_.length;
  }
  /**
   * Gets the index of the left child of the node at the given index.
   * @param {number} index The index of the node to get the left child for.
   * @return {number} The index of the left child.
   * @private
   */
  getLeftChildIndex_(e) {
    return e * 2 + 1;
  }
  /**
   * Gets the index of the right child of the node at the given index.
   * @param {number} index The index of the node to get the right child for.
   * @return {number} The index of the right child.
   * @private
   */
  getRightChildIndex_(e) {
    return e * 2 + 2;
  }
  /**
   * Gets the index of the parent of the node at the given index.
   * @param {number} index The index of the node to get the parent for.
   * @return {number} The index of the parent.
   * @private
   */
  getParentIndex_(e) {
    return e - 1 >> 1;
  }
  /**
   * Make this a heap. O(N).
   * @private
   */
  heapify_() {
    let e;
    for (e = (this.elements_.length >> 1) - 1; e >= 0; e--)
      this.siftUp_(e);
  }
  /**
   * @return {boolean} Is empty.
   */
  isEmpty() {
    return this.elements_.length === 0;
  }
  /**
   * @param {string} key Key.
   * @return {boolean} Is key queued.
   */
  isKeyQueued(e) {
    return e in this.queuedElements_;
  }
  /**
   * @param {T} element Element.
   * @return {boolean} Is queued.
   */
  isQueued(e) {
    return this.isKeyQueued(this.keyFunction_(e));
  }
  /**
   * @param {number} index The index of the node to move down.
   * @private
   */
  siftUp_(e) {
    const t = this.elements_, i = this.priorities_, n = t.length, r = t[e], o = i[e], a = e;
    for (; e < n >> 1; ) {
      const l = this.getLeftChildIndex_(e), h = this.getRightChildIndex_(e), c = h < n && i[h] < i[l] ? h : l;
      t[e] = t[c], i[e] = i[c], e = c;
    }
    t[e] = r, i[e] = o, this.siftDown_(a, e);
  }
  /**
   * @param {number} startIndex The index of the root.
   * @param {number} index The index of the node to move up.
   * @private
   */
  siftDown_(e, t) {
    const i = this.elements_, n = this.priorities_, r = i[t], o = n[t];
    for (; t > e; ) {
      const a = this.getParentIndex_(t);
      if (n[a] > o)
        i[t] = i[a], n[t] = n[a], t = a;
      else
        break;
    }
    i[t] = r, n[t] = o;
  }
  /**
   * FIXME empty description for jsdoc
   */
  reprioritize() {
    const e = this.priorityFunction_, t = this.elements_, i = this.priorities_;
    let n = 0;
    const r = t.length;
    let o, a, l;
    for (a = 0; a < r; ++a)
      o = t[a], l = e(o), l == dr ? delete this.queuedElements_[this.keyFunction_(o)] : (i[n] = l, t[n++] = o);
    t.length = n, i.length = n, this.heapify_();
  }
}
const Bf = zf, G = {
  IDLE: 0,
  LOADING: 1,
  LOADED: 2,
  /**
   * Indicates that tile loading failed
   * @type {number}
   */
  ERROR: 3,
  EMPTY: 4
};
class Xf extends Bf {
  /**
   * @param {PriorityFunction} tilePriorityFunction Tile priority function.
   * @param {function(): ?} tileChangeCallback Function called on each tile change event.
   */
  constructor(e, t) {
    super(
      /**
       * @param {Array} element Element.
       * @return {number} Priority.
       */
      function(i) {
        return e.apply(null, i);
      },
      /**
       * @param {Array} element Element.
       * @return {string} Key.
       */
      function(i) {
        return (
          /** @type {import("./Tile.js").default} */
          i[0].getKey()
        );
      }
    ), this.boundHandleTileChange_ = this.handleTileChange.bind(this), this.tileChangeCallback_ = t, this.tilesLoading_ = 0, this.tilesLoadingKeys_ = {};
  }
  /**
   * @param {Array} element Element.
   * @return {boolean} The element was added to the queue.
   */
  enqueue(e) {
    const t = super.enqueue(e);
    return t && e[0].addEventListener(z.CHANGE, this.boundHandleTileChange_), t;
  }
  /**
   * @return {number} Number of tiles loading.
   */
  getTilesLoading() {
    return this.tilesLoading_;
  }
  /**
   * @param {import("./events/Event.js").default} event Event.
   * @protected
   */
  handleTileChange(e) {
    const t = (
      /** @type {import("./Tile.js").default} */
      e.target
    ), i = t.getState();
    if (i === G.LOADED || i === G.ERROR || i === G.EMPTY) {
      i !== G.ERROR && t.removeEventListener(z.CHANGE, this.boundHandleTileChange_);
      const n = t.getKey();
      n in this.tilesLoadingKeys_ && (delete this.tilesLoadingKeys_[n], --this.tilesLoading_), this.tileChangeCallback_();
    }
  }
  /**
   * @param {number} maxTotalLoading Maximum number tiles to load simultaneously.
   * @param {number} maxNewLoads Maximum number of new tiles to load.
   */
  loadMoreTiles(e, t) {
    let i = 0, n, r, o;
    for (; this.tilesLoading_ < e && i < t && this.getCount() > 0; )
      r = /** @type {import("./Tile.js").default} */
      this.dequeue()[0], o = r.getKey(), n = r.getState(), n === G.IDLE && !(o in this.tilesLoadingKeys_) && (this.tilesLoadingKeys_[o] = !0, ++this.tilesLoading_, ++i, r.load());
  }
}
const Wf = Xf;
function Yf(s, e, t, i, n) {
  if (!s || !(t in s.wantedTiles) || !s.wantedTiles[t][e.getKey()])
    return dr;
  const r = s.viewState.center, o = i[0] - r[0], a = i[1] - r[1];
  return 65536 * Math.log(n) + Math.sqrt(o * o + a * a) / n;
}
class Vf extends ht {
  /**
   * @param {Options} options Control options.
   */
  constructor(e) {
    super();
    const t = e.element;
    t && !e.target && !t.style.pointerEvents && (t.style.pointerEvents = "auto"), this.element = t || null, this.target_ = null, this.map_ = null, this.listenerKeys = [], e.render && (this.render = e.render), e.target && this.setTarget(e.target);
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    lr(this.element), super.disposeInternal();
  }
  /**
   * Get the map associated with this control.
   * @return {import("../Map.js").default|null} Map.
   * @api
   */
  getMap() {
    return this.map_;
  }
  /**
   * Remove the control from its current map and attach it to the new map.
   * Pass `null` to just remove the control from the current map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default|null} map Map.
   * @api
   */
  setMap(e) {
    this.map_ && lr(this.element);
    for (let t = 0, i = this.listenerKeys.length; t < i; ++t)
      re(this.listenerKeys[t]);
    this.listenerKeys.length = 0, this.map_ = e, e && ((this.target_ ? this.target_ : e.getOverlayContainerStopEvent()).appendChild(this.element), this.render !== nn && this.listenerKeys.push(
      H(e, dt.POSTRENDER, this.render, this)
    ), e.render());
  }
  /**
   * Renders the control.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @api
   */
  render(e) {
  }
  /**
   * This function is used to set a target element for the control. It has no
   * effect if it is called after the control has been added to the map (i.e.
   * after `setMap` is called on the control). If no `target` is set in the
   * options passed to the control constructor and if `setTarget` is not called
   * then the control is added to the map's overlay container.
   * @param {HTMLElement|string} target Target.
   * @api
   */
  setTarget(e) {
    this.target_ = typeof e == "string" ? document.getElementById(e) : e;
  }
}
const Li = Vf;
class Zf extends Li {
  /**
   * @param {Options} [options] Attribution options.
   */
  constructor(e) {
    e = e || {}, super({
      element: document.createElement("div"),
      render: e.render,
      target: e.target
    }), this.ulElement_ = document.createElement("ul"), this.collapsed_ = e.collapsed !== void 0 ? e.collapsed : !0, this.userCollapsed_ = this.collapsed_, this.overrideCollapsible_ = e.collapsible !== void 0, this.collapsible_ = e.collapsible !== void 0 ? e.collapsible : !0, this.collapsible_ || (this.collapsed_ = !1);
    const t = e.className !== void 0 ? e.className : "ol-attribution", i = e.tipLabel !== void 0 ? e.tipLabel : "Attributions", n = e.expandClassName !== void 0 ? e.expandClassName : t + "-expand", r = e.collapseLabel !== void 0 ? e.collapseLabel : "›", o = e.collapseClassName !== void 0 ? e.collapseClassName : t + "-collapse";
    typeof r == "string" ? (this.collapseLabel_ = document.createElement("span"), this.collapseLabel_.textContent = r, this.collapseLabel_.className = o) : this.collapseLabel_ = r;
    const a = e.label !== void 0 ? e.label : "i";
    typeof a == "string" ? (this.label_ = document.createElement("span"), this.label_.textContent = a, this.label_.className = n) : this.label_ = a;
    const l = this.collapsible_ && !this.collapsed_ ? this.collapseLabel_ : this.label_;
    this.toggleButton_ = document.createElement("button"), this.toggleButton_.setAttribute("type", "button"), this.toggleButton_.setAttribute("aria-expanded", String(!this.collapsed_)), this.toggleButton_.title = i, this.toggleButton_.appendChild(l), this.toggleButton_.addEventListener(
      z.CLICK,
      this.handleClick_.bind(this),
      !1
    );
    const h = t + " " + Ii + " " + cs + (this.collapsed_ && this.collapsible_ ? " " + ar : "") + (this.collapsible_ ? "" : " ol-uncollapsible"), c = this.element;
    c.className = h, c.appendChild(this.toggleButton_), c.appendChild(this.ulElement_), this.renderedAttributions_ = [], this.renderedVisible_ = !0;
  }
  /**
   * Collect a list of visible attributions and set the collapsible state.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @return {Array<string>} Attributions.
   * @private
   */
  collectSourceAttributions_(e) {
    const t = Array.from(
      new Set(
        this.getMap().getAllLayers().flatMap((n) => n.getAttributions(e))
      )
    ), i = !this.getMap().getAllLayers().some(
      (n) => n.getSource() && n.getSource().getAttributionsCollapsible() === !1
    );
    return this.overrideCollapsible_ || this.setCollapsible(i), t;
  }
  /**
   * @private
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   */
  updateElement_(e) {
    if (!e) {
      this.renderedVisible_ && (this.element.style.display = "none", this.renderedVisible_ = !1);
      return;
    }
    const t = this.collectSourceAttributions_(e), i = t.length > 0;
    if (this.renderedVisible_ != i && (this.element.style.display = i ? "" : "none", this.renderedVisible_ = i), !xt(t, this.renderedAttributions_)) {
      lc(this.ulElement_);
      for (let n = 0, r = t.length; n < r; ++n) {
        const o = document.createElement("li");
        o.innerHTML = t[n], this.ulElement_.appendChild(o);
      }
      this.renderedAttributions_ = t;
    }
  }
  /**
   * @param {MouseEvent} event The event to handle
   * @private
   */
  handleClick_(e) {
    e.preventDefault(), this.handleToggle_(), this.userCollapsed_ = this.collapsed_;
  }
  /**
   * @private
   */
  handleToggle_() {
    this.element.classList.toggle(ar), this.collapsed_ ? an(this.collapseLabel_, this.label_) : an(this.label_, this.collapseLabel_), this.collapsed_ = !this.collapsed_, this.toggleButton_.setAttribute("aria-expanded", String(!this.collapsed_));
  }
  /**
   * Return `true` if the attribution is collapsible, `false` otherwise.
   * @return {boolean} True if the widget is collapsible.
   * @api
   */
  getCollapsible() {
    return this.collapsible_;
  }
  /**
   * Set whether the attribution should be collapsible.
   * @param {boolean} collapsible True if the widget is collapsible.
   * @api
   */
  setCollapsible(e) {
    this.collapsible_ !== e && (this.collapsible_ = e, this.element.classList.toggle("ol-uncollapsible"), this.userCollapsed_ && this.handleToggle_());
  }
  /**
   * Collapse or expand the attribution according to the passed parameter. Will
   * not do anything if the attribution isn't collapsible or if the current
   * collapsed state is already the one requested.
   * @param {boolean} collapsed True if the widget is collapsed.
   * @api
   */
  setCollapsed(e) {
    this.userCollapsed_ = e, !(!this.collapsible_ || this.collapsed_ === e) && this.handleToggle_();
  }
  /**
   * Return `true` when the attribution is currently collapsed or `false`
   * otherwise.
   * @return {boolean} True if the widget is collapsed.
   * @api
   */
  getCollapsed() {
    return this.collapsed_;
  }
  /**
   * Update the attribution element.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @override
   */
  render(e) {
    this.updateElement_(e.frameState);
  }
}
const jf = Zf;
class Hf extends Li {
  /**
   * @param {Options} [options] Rotate options.
   */
  constructor(e) {
    e = e || {}, super({
      element: document.createElement("div"),
      render: e.render,
      target: e.target
    });
    const t = e.className !== void 0 ? e.className : "ol-rotate", i = e.label !== void 0 ? e.label : "⇧", n = e.compassClassName !== void 0 ? e.compassClassName : "ol-compass";
    this.label_ = null, typeof i == "string" ? (this.label_ = document.createElement("span"), this.label_.className = n, this.label_.textContent = i) : (this.label_ = i, this.label_.classList.add(n));
    const r = e.tipLabel ? e.tipLabel : "Reset rotation", o = document.createElement("button");
    o.className = t + "-reset", o.setAttribute("type", "button"), o.title = r, o.appendChild(this.label_), o.addEventListener(
      z.CLICK,
      this.handleClick_.bind(this),
      !1
    );
    const a = t + " " + Ii + " " + cs, l = this.element;
    l.className = a, l.appendChild(o), this.callResetNorth_ = e.resetNorth ? e.resetNorth : void 0, this.duration_ = e.duration !== void 0 ? e.duration : 250, this.autoHide_ = e.autoHide !== void 0 ? e.autoHide : !0, this.rotation_ = void 0, this.autoHide_ && this.element.classList.add(Fs);
  }
  /**
   * @param {MouseEvent} event The event to handle
   * @private
   */
  handleClick_(e) {
    e.preventDefault(), this.callResetNorth_ !== void 0 ? this.callResetNorth_() : this.resetNorth_();
  }
  /**
   * @private
   */
  resetNorth_() {
    const t = this.getMap().getView();
    if (!t)
      return;
    const i = t.getRotation();
    i !== void 0 && (this.duration_ > 0 && i % (2 * Math.PI) !== 0 ? t.animate({
      rotation: 0,
      duration: this.duration_,
      easing: dn
    }) : t.setRotation(0));
  }
  /**
   * Update the rotate control element.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @override
   */
  render(e) {
    const t = e.frameState;
    if (!t)
      return;
    const i = t.viewState.rotation;
    if (i != this.rotation_) {
      const n = "rotate(" + i + "rad)";
      if (this.autoHide_) {
        const r = this.element.classList.contains(Fs);
        !r && i === 0 ? this.element.classList.add(Fs) : r && i !== 0 && this.element.classList.remove(Fs);
      }
      this.label_.style.transform = n;
    }
    this.rotation_ = i;
  }
}
const Kf = Hf;
class qf extends Li {
  /**
   * @param {Options} [options] Zoom options.
   */
  constructor(e) {
    e = e || {}, super({
      element: document.createElement("div"),
      target: e.target
    });
    const t = e.className !== void 0 ? e.className : "ol-zoom", i = e.delta !== void 0 ? e.delta : 1, n = e.zoomInClassName !== void 0 ? e.zoomInClassName : t + "-in", r = e.zoomOutClassName !== void 0 ? e.zoomOutClassName : t + "-out", o = e.zoomInLabel !== void 0 ? e.zoomInLabel : "+", a = e.zoomOutLabel !== void 0 ? e.zoomOutLabel : "–", l = e.zoomInTipLabel !== void 0 ? e.zoomInTipLabel : "Zoom in", h = e.zoomOutTipLabel !== void 0 ? e.zoomOutTipLabel : "Zoom out", c = document.createElement("button");
    c.className = n, c.setAttribute("type", "button"), c.title = l, c.appendChild(
      typeof o == "string" ? document.createTextNode(o) : o
    ), c.addEventListener(
      z.CLICK,
      this.handleClick_.bind(this, i),
      !1
    );
    const u = document.createElement("button");
    u.className = r, u.setAttribute("type", "button"), u.title = h, u.appendChild(
      typeof a == "string" ? document.createTextNode(a) : a
    ), u.addEventListener(
      z.CLICK,
      this.handleClick_.bind(this, -i),
      !1
    );
    const d = t + " " + Ii + " " + cs, f = this.element;
    f.className = d, f.appendChild(c), f.appendChild(u), this.duration_ = e.duration !== void 0 ? e.duration : 250;
  }
  /**
   * @param {number} delta Zoom delta.
   * @param {MouseEvent} event The event to handle
   * @private
   */
  handleClick_(e, t) {
    t.preventDefault(), this.zoomByDelta_(e);
  }
  /**
   * @param {number} delta Zoom delta.
   * @private
   */
  zoomByDelta_(e) {
    const i = this.getMap().getView();
    if (!i)
      return;
    const n = i.getZoom();
    if (n !== void 0) {
      const r = i.getConstrainedZoom(n + e);
      this.duration_ > 0 ? (i.getAnimating() && i.cancelAnimations(), i.animate({
        zoom: r,
        duration: this.duration_,
        easing: dn
      })) : i.setZoom(r);
    }
  }
}
const Jf = qf;
function $f(s) {
  s = s || {};
  const e = new ce();
  return (s.zoom !== void 0 ? s.zoom : !0) && e.push(new Jf(s.zoomOptions)), (s.rotate !== void 0 ? s.rotate : !0) && e.push(new Kf(s.rotateOptions)), (s.attribution !== void 0 ? s.attribution : !0) && e.push(new jf(s.attributionOptions)), e;
}
const fr = {
  ACTIVE: "active"
};
class Qf extends ht {
  /**
   * @param {InteractionOptions} [options] Options.
   */
  constructor(e) {
    super(), this.on, this.once, this.un, e && e.handleEvent && (this.handleEvent = e.handleEvent), this.map_ = null, this.setActive(!0);
  }
  /**
   * Return whether the interaction is currently active.
   * @return {boolean} `true` if the interaction is active, `false` otherwise.
   * @observable
   * @api
   */
  getActive() {
    return (
      /** @type {boolean} */
      this.get(fr.ACTIVE)
    );
  }
  /**
   * Get the map associated with this interaction.
   * @return {import("../Map.js").default|null} Map.
   * @api
   */
  getMap() {
    return this.map_;
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event}.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @api
   */
  handleEvent(e) {
    return !0;
  }
  /**
   * Activate or deactivate the interaction.
   * @param {boolean} active Active.
   * @observable
   * @api
   */
  setActive(e) {
    this.set(fr.ACTIVE, e);
  }
  /**
   * Remove the interaction from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default|null} map Map.
   */
  setMap(e) {
    this.map_ = e;
  }
}
function eg(s, e, t) {
  const i = s.getCenterInternal();
  if (i) {
    const n = [i[0] + e[0], i[1] + e[1]];
    s.animateInternal({
      duration: t !== void 0 ? t : 250,
      easing: Vd,
      center: s.getConstrainedCenter(n)
    });
  }
}
function Da(s, e, t, i) {
  const n = s.getZoom();
  if (n === void 0)
    return;
  const r = s.getConstrainedZoom(n + e), o = s.getResolutionForZoom(r);
  s.getAnimating() && s.cancelAnimations(), s.animate({
    resolution: o,
    anchor: t,
    duration: i !== void 0 ? i : 250,
    easing: dn
  });
}
const fn = Qf;
class tg extends fn {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    super(), e = e || {}, this.delta_ = e.delta ? e.delta : 1, this.duration_ = e.duration !== void 0 ? e.duration : 250;
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} (if it was a
   * doubleclick) and eventually zooms the map.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   */
  handleEvent(e) {
    let t = !1;
    if (e.type == J.DBLCLICK) {
      const i = (
        /** @type {MouseEvent} */
        e.originalEvent
      ), n = e.map, r = e.coordinate, o = i.shiftKey ? -this.delta_ : this.delta_, a = n.getView();
      Da(a, o, r, this.duration_), i.preventDefault(), t = !0;
    }
    return !t;
  }
}
const ig = tg;
class ng extends fn {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {}, super(
      /** @type {import("./Interaction.js").InteractionOptions} */
      e
    ), e.handleDownEvent && (this.handleDownEvent = e.handleDownEvent), e.handleDragEvent && (this.handleDragEvent = e.handleDragEvent), e.handleMoveEvent && (this.handleMoveEvent = e.handleMoveEvent), e.handleUpEvent && (this.handleUpEvent = e.handleUpEvent), e.stopDown && (this.stopDown = e.stopDown), this.handlingDownUpSequence = !1, this.targetPointers = [];
  }
  /**
   * Returns the current number of pointers involved in the interaction,
   * e.g. `2` when two fingers are used.
   * @return {number} The number of pointers.
   * @api
   */
  getPointerCount() {
    return this.targetPointers.length;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @protected
   */
  handleDownEvent(e) {
    return !1;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @protected
   */
  handleDragEvent(e) {
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may call into
   * other functions, if event sequences like e.g. 'drag' or 'down-up' etc. are
   * detected.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @api
   */
  handleEvent(e) {
    if (!e.originalEvent)
      return !0;
    let t = !1;
    if (this.updateTrackedPointers_(e), this.handlingDownUpSequence) {
      if (e.type == J.POINTERDRAG)
        this.handleDragEvent(e), e.originalEvent.preventDefault();
      else if (e.type == J.POINTERUP) {
        const i = this.handleUpEvent(e);
        this.handlingDownUpSequence = i && this.targetPointers.length > 0;
      }
    } else if (e.type == J.POINTERDOWN) {
      const i = this.handleDownEvent(e);
      this.handlingDownUpSequence = i, t = this.stopDown(i);
    } else
      e.type == J.POINTERMOVE && this.handleMoveEvent(e);
    return !t;
  }
  /**
   * Handle pointer move events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @protected
   */
  handleMoveEvent(e) {
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @protected
   */
  handleUpEvent(e) {
    return !1;
  }
  /**
   * This function is used to determine if "down" events should be propagated
   * to other interactions or should be stopped.
   * @param {boolean} handled Was the event handled by the interaction?
   * @return {boolean} Should the `down` event be stopped?
   */
  stopDown(e) {
    return e;
  }
  /**
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @private
   */
  updateTrackedPointers_(e) {
    e.activePointers && (this.targetPointers = e.activePointers);
  }
}
function ka(s) {
  const e = s.length;
  let t = 0, i = 0;
  for (let n = 0; n < e; n++)
    t += s[n].clientX, i += s[n].clientY;
  return { clientX: t / e, clientY: i / e };
}
const Dt = ng;
function Bo(s) {
  const e = arguments;
  return function(t) {
    let i = !0;
    for (let n = 0, r = e.length; n < r && (i = i && e[n](t), !!i); ++n)
      ;
    return i;
  };
}
const uc = function(s) {
  const e = (
    /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
    s.originalEvent
  );
  return e.altKey && !(e.metaKey || e.ctrlKey) && !e.shiftKey;
}, sg = function(s) {
  const e = (
    /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
    s.originalEvent
  );
  return e.altKey && !(e.metaKey || e.ctrlKey) && e.shiftKey;
}, rg = function(s) {
  const e = s.map.getTargetElement(), t = s.map.getOwnerDocument().activeElement;
  return e.contains(t);
}, dc = function(s) {
  return s.map.getTargetElement().hasAttribute("tabindex") ? rg(s) : !0;
}, Hn = mt, fc = function(s) {
  const e = (
    /** @type {MouseEvent} */
    s.originalEvent
  );
  return e.button == 0 && !(Ju && $u && e.ctrlKey);
}, Xo = cn, gc = function(s) {
  return s.type == J.SINGLECLICK;
}, Na = function(s) {
  const e = (
    /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
    s.originalEvent
  );
  return !e.altKey && !(e.metaKey || e.ctrlKey) && !e.shiftKey;
}, Ga = function(s) {
  const e = (
    /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
    s.originalEvent
  );
  return !e.altKey && !(e.metaKey || e.ctrlKey) && e.shiftKey;
}, _c = function(s) {
  const e = (
    /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
    s.originalEvent
  ), t = (
    /** @type {Element} */
    e.target.tagName
  );
  return t !== "INPUT" && t !== "SELECT" && t !== "TEXTAREA" && // `isContentEditable` is only available on `HTMLElement`, but it may also be a
  // different type like `SVGElement`.
  // @ts-ignore
  !e.target.isContentEditable;
}, Jr = function(s) {
  const e = (
    /** @type {import("../MapBrowserEvent").default} */
    s.originalEvent
  );
  return Z(e !== void 0, 56), e.pointerType == "mouse";
}, mc = function(s) {
  const e = (
    /** @type {import("../MapBrowserEvent").default} */
    s.originalEvent
  );
  return Z(e !== void 0, 56), e.isPrimary && e.button === 0;
};
class og extends Dt {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    super({
      stopDown: cn
    }), e = e || {}, this.kinetic_ = e.kinetic, this.lastCentroid = null, this.lastPointersCount_, this.panning_ = !1;
    const t = e.condition ? e.condition : Bo(Na, mc);
    this.condition_ = e.onFocusOnly ? Bo(dc, t) : t, this.noKinetic_ = !1;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */
  handleDragEvent(e) {
    const t = e.map;
    this.panning_ || (this.panning_ = !0, t.getView().beginInteraction());
    const i = this.targetPointers, n = t.getEventPixel(ka(i));
    if (i.length == this.lastPointersCount_) {
      if (this.kinetic_ && this.kinetic_.update(n[0], n[1]), this.lastCentroid) {
        const r = [
          this.lastCentroid[0] - n[0],
          n[1] - this.lastCentroid[1]
        ], a = e.map.getView();
        Bh(r, a.getResolution()), ga(r, a.getRotation()), a.adjustCenterInternal(r);
      }
    } else
      this.kinetic_ && this.kinetic_.begin();
    this.lastCentroid = n, this.lastPointersCount_ = i.length, e.originalEvent.preventDefault();
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleUpEvent(e) {
    const t = e.map, i = t.getView();
    if (this.targetPointers.length === 0) {
      if (!this.noKinetic_ && this.kinetic_ && this.kinetic_.end()) {
        const n = this.kinetic_.getDistance(), r = this.kinetic_.getAngle(), o = i.getCenterInternal(), a = t.getPixelFromCoordinateInternal(o), l = t.getCoordinateFromPixelInternal([
          a[0] - n * Math.cos(r),
          a[1] - n * Math.sin(r)
        ]);
        i.animateInternal({
          center: i.getConstrainedCenter(l),
          duration: 500,
          easing: dn
        });
      }
      return this.panning_ && (this.panning_ = !1, i.endInteraction()), !1;
    }
    return this.kinetic_ && this.kinetic_.begin(), this.lastCentroid = null, !0;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleDownEvent(e) {
    if (this.targetPointers.length > 0 && this.condition_(e)) {
      const i = e.map.getView();
      return this.lastCentroid = null, i.getAnimating() && i.cancelAnimations(), this.kinetic_ && this.kinetic_.begin(), this.noKinetic_ = this.targetPointers.length > 1, !0;
    }
    return !1;
  }
}
const pc = og;
let ag = class extends Dt {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {}, super({
      stopDown: cn
    }), this.condition_ = e.condition ? e.condition : sg, this.lastAngle_ = void 0, this.duration_ = e.duration !== void 0 ? e.duration : 250;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */
  handleDragEvent(e) {
    if (!Jr(e))
      return;
    const t = e.map, i = t.getView();
    if (i.getConstraints().rotation === wa)
      return;
    const n = t.getSize(), r = e.pixel, o = Math.atan2(n[1] / 2 - r[1], r[0] - n[0] / 2);
    if (this.lastAngle_ !== void 0) {
      const a = o - this.lastAngle_;
      i.adjustRotationInternal(-a);
    }
    this.lastAngle_ = o;
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleUpEvent(e) {
    return Jr(e) ? (e.map.getView().endInteraction(this.duration_), !1) : !0;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleDownEvent(e) {
    return Jr(e) && fc(e) && this.condition_(e) ? (e.map.getView().beginInteraction(), this.lastAngle_ = void 0, !0) : !1;
  }
};
const yc = ag;
class lg extends wr {
  /**
   * @param {string} className CSS class name.
   */
  constructor(e) {
    super(), this.geometry_ = null, this.element_ = document.createElement("div"), this.element_.style.position = "absolute", this.element_.style.pointerEvents = "auto", this.element_.className = "ol-box " + e, this.map_ = null, this.startPixel_ = null, this.endPixel_ = null;
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    this.setMap(null);
  }
  /**
   * @private
   */
  render_() {
    const e = this.startPixel_, t = this.endPixel_, i = "px", n = this.element_.style;
    n.left = Math.min(e[0], t[0]) + i, n.top = Math.min(e[1], t[1]) + i, n.width = Math.abs(t[0] - e[0]) + i, n.height = Math.abs(t[1] - e[1]) + i;
  }
  /**
   * @param {import("../Map.js").default|null} map Map.
   */
  setMap(e) {
    if (this.map_) {
      this.map_.getOverlayContainer().removeChild(this.element_);
      const t = this.element_.style;
      t.left = "inherit", t.top = "inherit", t.width = "inherit", t.height = "inherit";
    }
    this.map_ = e, this.map_ && this.map_.getOverlayContainer().appendChild(this.element_);
  }
  /**
   * @param {import("../pixel.js").Pixel} startPixel Start pixel.
   * @param {import("../pixel.js").Pixel} endPixel End pixel.
   */
  setPixels(e, t) {
    this.startPixel_ = e, this.endPixel_ = t, this.createOrUpdateGeometry(), this.render_();
  }
  /**
   * Creates or updates the cached geometry.
   */
  createOrUpdateGeometry() {
    const e = this.startPixel_, t = this.endPixel_, n = [
      e,
      [e[0], t[1]],
      t,
      [t[0], e[1]]
    ].map(
      this.map_.getCoordinateFromPixelInternal,
      this.map_
    );
    n[4] = n[0].slice(), this.geometry_ ? this.geometry_.setCoordinates([n]) : this.geometry_ = new We([n]);
  }
  /**
   * @return {import("../geom/Polygon.js").default} Geometry.
   */
  getGeometry() {
    return this.geometry_;
  }
}
const hg = lg, bs = {
  /**
   * Triggered upon drag box start.
   * @event DragBoxEvent#boxstart
   * @api
   */
  BOXSTART: "boxstart",
  /**
   * Triggered on drag when box is active.
   * @event DragBoxEvent#boxdrag
   * @api
   */
  BOXDRAG: "boxdrag",
  /**
   * Triggered upon drag box end.
   * @event DragBoxEvent#boxend
   * @api
   */
  BOXEND: "boxend",
  /**
   * Triggered upon drag box canceled.
   * @event DragBoxEvent#boxcancel
   * @api
   */
  BOXCANCEL: "boxcancel"
};
class $r extends Ye {
  /**
   * @param {string} type The event type.
   * @param {import("../coordinate.js").Coordinate} coordinate The event coordinate.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Originating event.
   */
  constructor(e, t, i) {
    super(e), this.coordinate = t, this.mapBrowserEvent = i;
  }
}
class cg extends Dt {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    super(), this.on, this.once, this.un, e = e || {}, this.box_ = new hg(e.className || "ol-dragbox"), this.minArea_ = e.minArea !== void 0 ? e.minArea : 64, e.onBoxEnd && (this.onBoxEnd = e.onBoxEnd), this.startPixel_ = null, this.condition_ = e.condition ? e.condition : fc, this.boxEndCondition_ = e.boxEndCondition ? e.boxEndCondition : this.defaultBoxEndCondition;
  }
  /**
   * The default condition for determining whether the boxend event
   * should fire.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent The originating MapBrowserEvent
   *     leading to the box end.
   * @param {import("../pixel.js").Pixel} startPixel The starting pixel of the box.
   * @param {import("../pixel.js").Pixel} endPixel The end pixel of the box.
   * @return {boolean} Whether or not the boxend condition should be fired.
   */
  defaultBoxEndCondition(e, t, i) {
    const n = i[0] - t[0], r = i[1] - t[1];
    return n * n + r * r >= this.minArea_;
  }
  /**
   * Returns geometry of last drawn box.
   * @return {import("../geom/Polygon.js").default} Geometry.
   * @api
   */
  getGeometry() {
    return this.box_.getGeometry();
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */
  handleDragEvent(e) {
    this.box_.setPixels(this.startPixel_, e.pixel), this.dispatchEvent(
      new $r(
        bs.BOXDRAG,
        e.coordinate,
        e
      )
    );
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleUpEvent(e) {
    this.box_.setMap(null);
    const t = this.boxEndCondition_(
      e,
      this.startPixel_,
      e.pixel
    );
    return t && this.onBoxEnd(e), this.dispatchEvent(
      new $r(
        t ? bs.BOXEND : bs.BOXCANCEL,
        e.coordinate,
        e
      )
    ), !1;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleDownEvent(e) {
    return this.condition_(e) ? (this.startPixel_ = e.pixel, this.box_.setMap(e.map), this.box_.setPixels(this.startPixel_, this.startPixel_), this.dispatchEvent(
      new $r(
        bs.BOXSTART,
        e.coordinate,
        e
      )
    ), !0) : !1;
  }
  /**
   * Function to execute just before `onboxend` is fired
   * @param {import("../MapBrowserEvent.js").default} event Event.
   */
  onBoxEnd(e) {
  }
}
const ug = cg;
class dg extends ug {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {};
    const t = e.condition ? e.condition : Ga;
    super({
      condition: t,
      className: e.className || "ol-dragzoom",
      minArea: e.minArea
    }), this.duration_ = e.duration !== void 0 ? e.duration : 200, this.out_ = e.out !== void 0 ? e.out : !1;
  }
  /**
   * Function to execute just before `onboxend` is fired
   * @param {import("../MapBrowserEvent.js").default} event Event.
   */
  onBoxEnd(e) {
    const i = (
      /** @type {!import("../View.js").default} */
      this.getMap().getView()
    );
    let n = this.getGeometry();
    if (this.out_) {
      const r = i.rotatedExtentForGeometry(n), o = i.getResolutionForExtentInternal(r), a = i.getResolution() / o;
      n = n.clone(), n.scale(a * a);
    }
    i.fitInternal(n, {
      duration: this.duration_,
      easing: dn
    });
  }
}
const fg = dg, oi = {
  LEFT: 37,
  UP: 38,
  RIGHT: 39,
  DOWN: 40
};
class gg extends fn {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    super(), e = e || {}, this.defaultCondition_ = function(t) {
      return Na(t) && _c(t);
    }, this.condition_ = e.condition !== void 0 ? e.condition : this.defaultCondition_, this.duration_ = e.duration !== void 0 ? e.duration : 100, this.pixelDelta_ = e.pixelDelta !== void 0 ? e.pixelDelta : 128;
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} if it was a
   * `KeyEvent`, and decides the direction to pan to (if an arrow key was
   * pressed).
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   */
  handleEvent(e) {
    let t = !1;
    if (e.type == z.KEYDOWN) {
      const i = (
        /** @type {KeyboardEvent} */
        e.originalEvent
      ), n = i.keyCode;
      if (this.condition_(e) && (n == oi.DOWN || n == oi.LEFT || n == oi.RIGHT || n == oi.UP)) {
        const o = e.map.getView(), a = o.getResolution() * this.pixelDelta_;
        let l = 0, h = 0;
        n == oi.DOWN ? h = -a : n == oi.LEFT ? l = -a : n == oi.RIGHT ? l = a : h = a;
        const c = [l, h];
        ga(c, o.getRotation()), eg(o, c, this.duration_), i.preventDefault(), t = !0;
      }
    }
    return !t;
  }
}
const _g = gg;
class mg extends fn {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    super(), e = e || {}, this.condition_ = e.condition ? e.condition : _c, this.delta_ = e.delta ? e.delta : 1, this.duration_ = e.duration !== void 0 ? e.duration : 100;
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} if it was a
   * `KeyEvent`, and decides whether to zoom in or out (depending on whether the
   * key pressed was '+' or '-').
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   */
  handleEvent(e) {
    let t = !1;
    if (e.type == z.KEYDOWN || e.type == z.KEYPRESS) {
      const i = (
        /** @type {KeyboardEvent} */
        e.originalEvent
      ), n = i.key;
      if (this.condition_(e) && (n === "+" || n === "-")) {
        const r = e.map, o = n === "+" ? this.delta_ : -this.delta_, a = r.getView();
        Da(a, o, void 0, this.duration_), i.preventDefault(), t = !0;
      }
    }
    return !t;
  }
}
const pg = mg;
class yg {
  /**
   * @param {number} decay Rate of decay (must be negative).
   * @param {number} minVelocity Minimum velocity (pixels/millisecond).
   * @param {number} delay Delay to consider to calculate the kinetic
   *     initial values (milliseconds).
   */
  constructor(e, t, i) {
    this.decay_ = e, this.minVelocity_ = t, this.delay_ = i, this.points_ = [], this.angle_ = 0, this.initialVelocity_ = 0;
  }
  /**
   * FIXME empty description for jsdoc
   */
  begin() {
    this.points_.length = 0, this.angle_ = 0, this.initialVelocity_ = 0;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   */
  update(e, t) {
    this.points_.push(e, t, Date.now());
  }
  /**
   * @return {boolean} Whether we should do kinetic animation.
   */
  end() {
    if (this.points_.length < 6)
      return !1;
    const e = Date.now() - this.delay_, t = this.points_.length - 3;
    if (this.points_[t + 2] < e)
      return !1;
    let i = t - 3;
    for (; i > 0 && this.points_[i + 2] > e; )
      i -= 3;
    const n = this.points_[t + 2] - this.points_[i + 2];
    if (n < 1e3 / 60)
      return !1;
    const r = this.points_[t] - this.points_[i], o = this.points_[t + 1] - this.points_[i + 1];
    return this.angle_ = Math.atan2(o, r), this.initialVelocity_ = Math.sqrt(r * r + o * o) / n, this.initialVelocity_ > this.minVelocity_;
  }
  /**
   * @return {number} Total distance travelled (pixels).
   */
  getDistance() {
    return (this.minVelocity_ - this.initialVelocity_) / this.decay_;
  }
  /**
   * @return {number} Angle of the kinetic panning animation (radians).
   */
  getAngle() {
    return this.angle_;
  }
}
const xg = yg;
class Eg extends fn {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {}, super(
      /** @type {import("./Interaction.js").InteractionOptions} */
      e
    ), this.totalDelta_ = 0, this.lastDelta_ = 0, this.maxDelta_ = e.maxDelta !== void 0 ? e.maxDelta : 1, this.duration_ = e.duration !== void 0 ? e.duration : 250, this.timeout_ = e.timeout !== void 0 ? e.timeout : 80, this.useAnchor_ = e.useAnchor !== void 0 ? e.useAnchor : !0, this.constrainResolution_ = e.constrainResolution !== void 0 ? e.constrainResolution : !1;
    const t = e.condition ? e.condition : Hn;
    this.condition_ = e.onFocusOnly ? Bo(dc, t) : t, this.lastAnchor_ = null, this.startTime_ = void 0, this.timeoutId_, this.mode_ = void 0, this.trackpadEventGap_ = 400, this.trackpadTimeoutId_, this.deltaPerZoom_ = 300;
  }
  /**
   * @private
   */
  endInteraction_() {
    this.trackpadTimeoutId_ = void 0;
    const e = this.getMap();
    if (!e)
      return;
    e.getView().endInteraction(
      void 0,
      this.lastDelta_ ? this.lastDelta_ > 0 ? 1 : -1 : 0,
      this.lastAnchor_
    );
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} (if it was a mousewheel-event) and eventually
   * zooms the map.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   */
  handleEvent(e) {
    if (!this.condition_(e) || e.type !== z.WHEEL)
      return !0;
    const i = e.map, n = (
      /** @type {WheelEvent} */
      e.originalEvent
    );
    n.preventDefault(), this.useAnchor_ && (this.lastAnchor_ = e.coordinate);
    let r;
    if (e.type == z.WHEEL && (r = n.deltaY, Hu && n.deltaMode === WheelEvent.DOM_DELTA_PIXEL && (r /= Ah), n.deltaMode === WheelEvent.DOM_DELTA_LINE && (r *= 40)), r === 0)
      return !1;
    this.lastDelta_ = r;
    const o = Date.now();
    this.startTime_ === void 0 && (this.startTime_ = o), (!this.mode_ || o - this.startTime_ > this.trackpadEventGap_) && (this.mode_ = Math.abs(r) < 4 ? "trackpad" : "wheel");
    const a = i.getView();
    if (this.mode_ === "trackpad" && !(a.getConstrainResolution() || this.constrainResolution_))
      return this.trackpadTimeoutId_ ? clearTimeout(this.trackpadTimeoutId_) : (a.getAnimating() && a.cancelAnimations(), a.beginInteraction()), this.trackpadTimeoutId_ = setTimeout(
        this.endInteraction_.bind(this),
        this.timeout_
      ), a.adjustZoom(-r / this.deltaPerZoom_, this.lastAnchor_), this.startTime_ = o, !1;
    this.totalDelta_ += r;
    const l = Math.max(this.timeout_ - (o - this.startTime_), 0);
    return clearTimeout(this.timeoutId_), this.timeoutId_ = setTimeout(
      this.handleWheelZoom_.bind(this, i),
      l
    ), !1;
  }
  /**
   * @private
   * @param {import("../Map.js").default} map Map.
   */
  handleWheelZoom_(e) {
    const t = e.getView();
    t.getAnimating() && t.cancelAnimations();
    let i = -_e(
      this.totalDelta_,
      -this.maxDelta_ * this.deltaPerZoom_,
      this.maxDelta_ * this.deltaPerZoom_
    ) / this.deltaPerZoom_;
    (t.getConstrainResolution() || this.constrainResolution_) && (i = i ? i > 0 ? 1 : -1 : 0), Da(t, i, this.lastAnchor_, this.duration_), this.mode_ = void 0, this.totalDelta_ = 0, this.lastAnchor_ = null, this.startTime_ = void 0, this.timeoutId_ = void 0;
  }
  /**
   * Enable or disable using the mouse's location as an anchor when zooming
   * @param {boolean} useAnchor true to zoom to the mouse's location, false
   * to zoom to the center of the map
   * @api
   */
  setMouseAnchor(e) {
    this.useAnchor_ = e, e || (this.lastAnchor_ = null);
  }
}
const xc = Eg;
class vg extends Dt {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {};
    const t = (
      /** @type {import("./Pointer.js").Options} */
      e
    );
    t.stopDown || (t.stopDown = cn), super(t), this.anchor_ = null, this.lastAngle_ = void 0, this.rotating_ = !1, this.rotationDelta_ = 0, this.threshold_ = e.threshold !== void 0 ? e.threshold : 0.3, this.duration_ = e.duration !== void 0 ? e.duration : 250;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */
  handleDragEvent(e) {
    let t = 0;
    const i = this.targetPointers[0], n = this.targetPointers[1], r = Math.atan2(
      n.clientY - i.clientY,
      n.clientX - i.clientX
    );
    if (this.lastAngle_ !== void 0) {
      const l = r - this.lastAngle_;
      this.rotationDelta_ += l, !this.rotating_ && Math.abs(this.rotationDelta_) > this.threshold_ && (this.rotating_ = !0), t = l;
    }
    this.lastAngle_ = r;
    const o = e.map, a = o.getView();
    a.getConstraints().rotation !== wa && (this.anchor_ = o.getCoordinateFromPixelInternal(
      o.getEventPixel(ka(this.targetPointers))
    ), this.rotating_ && (o.render(), a.adjustRotationInternal(t, this.anchor_)));
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleUpEvent(e) {
    return this.targetPointers.length < 2 ? (e.map.getView().endInteraction(this.duration_), !1) : !0;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleDownEvent(e) {
    if (this.targetPointers.length >= 2) {
      const t = e.map;
      return this.anchor_ = null, this.lastAngle_ = void 0, this.rotating_ = !1, this.rotationDelta_ = 0, this.handlingDownUpSequence || t.getView().beginInteraction(), !0;
    }
    return !1;
  }
}
const Cg = vg;
class wg extends Dt {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {};
    const t = (
      /** @type {import("./Pointer.js").Options} */
      e
    );
    t.stopDown || (t.stopDown = cn), super(t), this.anchor_ = null, this.duration_ = e.duration !== void 0 ? e.duration : 400, this.lastDistance_ = void 0, this.lastScaleDelta_ = 1;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */
  handleDragEvent(e) {
    let t = 1;
    const i = this.targetPointers[0], n = this.targetPointers[1], r = i.clientX - n.clientX, o = i.clientY - n.clientY, a = Math.sqrt(r * r + o * o);
    this.lastDistance_ !== void 0 && (t = this.lastDistance_ / a), this.lastDistance_ = a;
    const l = e.map, h = l.getView();
    t != 1 && (this.lastScaleDelta_ = t), this.anchor_ = l.getCoordinateFromPixelInternal(
      l.getEventPixel(ka(this.targetPointers))
    ), l.render(), h.adjustResolutionInternal(t, this.anchor_);
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleUpEvent(e) {
    if (this.targetPointers.length < 2) {
      const i = e.map.getView(), n = this.lastScaleDelta_ > 1 ? 1 : -1;
      return i.endInteraction(this.duration_, n), !1;
    }
    return !0;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleDownEvent(e) {
    if (this.targetPointers.length >= 2) {
      const t = e.map;
      return this.anchor_ = null, this.lastDistance_ = void 0, this.lastScaleDelta_ = 1, this.handlingDownUpSequence || t.getView().beginInteraction(), !0;
    }
    return !1;
  }
}
const Tg = wg;
function Ec(s) {
  s = s || {};
  const e = new ce(), t = new xg(-5e-3, 0.05, 100);
  return (s.altShiftDragRotate !== void 0 ? s.altShiftDragRotate : !0) && e.push(new yc()), (s.doubleClickZoom !== void 0 ? s.doubleClickZoom : !0) && e.push(
    new ig({
      delta: s.zoomDelta,
      duration: s.zoomDuration
    })
  ), (s.dragPan !== void 0 ? s.dragPan : !0) && e.push(
    new pc({
      onFocusOnly: s.onFocusOnly,
      kinetic: t
    })
  ), (s.pinchRotate !== void 0 ? s.pinchRotate : !0) && e.push(new Cg()), (s.pinchZoom !== void 0 ? s.pinchZoom : !0) && e.push(
    new Tg({
      duration: s.zoomDuration
    })
  ), (s.keyboard !== void 0 ? s.keyboard : !0) && (e.push(new _g()), e.push(
    new pg({
      delta: s.zoomDelta,
      duration: s.zoomDuration
    })
  )), (s.mouseWheelZoom !== void 0 ? s.mouseWheelZoom : !0) && e.push(
    new xc({
      onFocusOnly: s.onFocusOnly,
      duration: s.zoomDuration
    })
  ), (s.shiftDragZoom !== void 0 ? s.shiftDragZoom : !0) && e.push(
    new fg({
      duration: s.zoomDuration
    })
  ), e;
}
function Ol(s) {
  return s[0] > 0 && s[1] > 0;
}
function Sg(s, e, t) {
  return t === void 0 && (t = [0, 0]), t[0] = s[0] * e + 0.5 | 0, t[1] = s[1] * e + 0.5 | 0, t;
}
function Ke(s, e) {
  return Array.isArray(s) ? s : (e === void 0 ? e = [s, s] : (e[0] = s, e[1] = s), e);
}
function vc(s) {
  if (s instanceof hs) {
    s.setMapInternal(null);
    return;
  }
  s instanceof Fr && s.getLayers().forEach(vc);
}
function Cc(s, e) {
  if (s instanceof hs) {
    s.setMapInternal(e);
    return;
  }
  if (s instanceof Fr) {
    const t = s.getLayers().getArray();
    for (let i = 0, n = t.length; i < n; ++i)
      Cc(t[i], e);
  }
}
let Rg = class extends ht {
  /**
   * @param {MapOptions} [options] Map options.
   */
  constructor(e) {
    super(), e = e || {}, this.on, this.once, this.un;
    const t = Ig(e);
    this.renderComplete_, this.loaded_ = !0, this.boundHandleBrowserEvent_ = this.handleBrowserEvent.bind(this), this.maxTilesLoading_ = e.maxTilesLoading !== void 0 ? e.maxTilesLoading : 16, this.pixelRatio_ = e.pixelRatio !== void 0 ? e.pixelRatio : Ah, this.postRenderTimeoutHandle_, this.animationDelayKey_, this.animationDelay_ = this.animationDelay_.bind(this), this.coordinateToPixelTransform_ = Se(), this.pixelToCoordinateTransform_ = Se(), this.frameIndex_ = 0, this.frameState_ = null, this.previousExtent_ = null, this.viewPropertyListenerKey_ = null, this.viewChangeListenerKey_ = null, this.layerGroupPropertyListenerKeys_ = null, this.viewport_ = document.createElement("div"), this.viewport_.className = "ol-viewport" + ("ontouchstart" in window ? " ol-touch" : ""), this.viewport_.style.position = "relative", this.viewport_.style.overflow = "hidden", this.viewport_.style.width = "100%", this.viewport_.style.height = "100%", this.overlayContainer_ = document.createElement("div"), this.overlayContainer_.style.position = "absolute", this.overlayContainer_.style.zIndex = "0", this.overlayContainer_.style.width = "100%", this.overlayContainer_.style.height = "100%", this.overlayContainer_.style.pointerEvents = "none", this.overlayContainer_.className = "ol-overlaycontainer", this.viewport_.appendChild(this.overlayContainer_), this.overlayContainerStopEvent_ = document.createElement("div"), this.overlayContainerStopEvent_.style.position = "absolute", this.overlayContainerStopEvent_.style.zIndex = "0", this.overlayContainerStopEvent_.style.width = "100%", this.overlayContainerStopEvent_.style.height = "100%", this.overlayContainerStopEvent_.style.pointerEvents = "none", this.overlayContainerStopEvent_.className = "ol-overlaycontainer-stopevent", this.viewport_.appendChild(this.overlayContainerStopEvent_), this.mapBrowserEventHandler_ = null, this.moveTolerance_ = e.moveTolerance, this.keyboardEventTarget_ = t.keyboardEventTarget, this.targetChangeHandlerKeys_ = null, this.targetElement_ = null, this.resizeObserver_ = new ResizeObserver(() => this.updateSize()), this.controls = t.controls || $f(), this.interactions = t.interactions || Ec({
      onFocusOnly: !0
    }), this.overlays_ = t.overlays, this.overlayIdIndex_ = {}, this.renderer_ = null, this.postRenderFunctions_ = [], this.tileQueue_ = new Wf(
      this.getTilePriority.bind(this),
      this.handleTileChange_.bind(this)
    ), this.addChangeListener(
      pe.LAYERGROUP,
      this.handleLayerGroupChanged_
    ), this.addChangeListener(pe.VIEW, this.handleViewChanged_), this.addChangeListener(pe.SIZE, this.handleSizeChanged_), this.addChangeListener(pe.TARGET, this.handleTargetChanged_), this.setProperties(t.values);
    const i = this;
    e.view && !(e.view instanceof Pe) && e.view.then(function(n) {
      i.setView(new Pe(n));
    }), this.controls.addEventListener(
      ve.ADD,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./control/Control.js").default>} event CollectionEvent
       */
      (n) => {
        n.element.setMap(this);
      }
    ), this.controls.addEventListener(
      ve.REMOVE,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./control/Control.js").default>} event CollectionEvent.
       */
      (n) => {
        n.element.setMap(null);
      }
    ), this.interactions.addEventListener(
      ve.ADD,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./interaction/Interaction.js").default>} event CollectionEvent.
       */
      (n) => {
        n.element.setMap(this);
      }
    ), this.interactions.addEventListener(
      ve.REMOVE,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./interaction/Interaction.js").default>} event CollectionEvent.
       */
      (n) => {
        n.element.setMap(null);
      }
    ), this.overlays_.addEventListener(
      ve.ADD,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./Overlay.js").default>} event CollectionEvent.
       */
      (n) => {
        this.addOverlayInternal_(n.element);
      }
    ), this.overlays_.addEventListener(
      ve.REMOVE,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./Overlay.js").default>} event CollectionEvent.
       */
      (n) => {
        const r = n.element.getId();
        r !== void 0 && delete this.overlayIdIndex_[r.toString()], n.element.setMap(null);
      }
    ), this.controls.forEach(
      /**
       * @param {import("./control/Control.js").default} control Control.
       */
      (n) => {
        n.setMap(this);
      }
    ), this.interactions.forEach(
      /**
       * @param {import("./interaction/Interaction.js").default} interaction Interaction.
       */
      (n) => {
        n.setMap(this);
      }
    ), this.overlays_.forEach(this.addOverlayInternal_.bind(this));
  }
  /**
   * Add the given control to the map.
   * @param {import("./control/Control.js").default} control Control.
   * @api
   */
  addControl(e) {
    this.getControls().push(e);
  }
  /**
   * Add the given interaction to the map. If you want to add an interaction
   * at another point of the collection use `getInteractions()` and the methods
   * available on {@link module:ol/Collection~Collection}. This can be used to
   * stop the event propagation from the handleEvent function. The interactions
   * get to handle the events in the reverse order of this collection.
   * @param {import("./interaction/Interaction.js").default} interaction Interaction to add.
   * @api
   */
  addInteraction(e) {
    this.getInteractions().push(e);
  }
  /**
   * Adds the given layer to the top of this map. If you want to add a layer
   * elsewhere in the stack, use `getLayers()` and the methods available on
   * {@link module:ol/Collection~Collection}.
   * @param {import("./layer/Base.js").default} layer Layer.
   * @api
   */
  addLayer(e) {
    this.getLayerGroup().getLayers().push(e);
  }
  /**
   * @param {import("./layer/Group.js").GroupEvent} event The layer add event.
   * @private
   */
  handleLayerAdd_(e) {
    Cc(e.layer, this);
  }
  /**
   * Add the given overlay to the map.
   * @param {import("./Overlay.js").default} overlay Overlay.
   * @api
   */
  addOverlay(e) {
    this.getOverlays().push(e);
  }
  /**
   * This deals with map's overlay collection changes.
   * @param {import("./Overlay.js").default} overlay Overlay.
   * @private
   */
  addOverlayInternal_(e) {
    const t = e.getId();
    t !== void 0 && (this.overlayIdIndex_[t.toString()] = e), e.setMap(this);
  }
  /**
   *
   * Clean up.
   */
  disposeInternal() {
    this.controls.clear(), this.interactions.clear(), this.overlays_.clear(), this.resizeObserver_.disconnect(), this.setTarget(null), super.disposeInternal();
  }
  /**
   * Detect features that intersect a pixel on the viewport, and execute a
   * callback with each intersecting feature. Layers included in the detection can
   * be configured through the `layerFilter` option in `options`.
   * @param {import("./pixel.js").Pixel} pixel Pixel.
   * @param {function(import("./Feature.js").FeatureLike, import("./layer/Layer.js").default<import("./source/Source").default>, import("./geom/SimpleGeometry.js").default): T} callback Feature callback. The callback will be
   *     called with two arguments. The first argument is one
   *     {@link module:ol/Feature~Feature feature} or
   *     {@link module:ol/render/Feature~RenderFeature render feature} at the pixel, the second is
   *     the {@link module:ol/layer/Layer~Layer layer} of the feature and will be null for
   *     unmanaged layers. To stop detection, callback functions can return a
   *     truthy value.
   * @param {AtPixelOptions} [options] Optional options.
   * @return {T|undefined} Callback result, i.e. the return value of last
   * callback execution, or the first truthy callback return value.
   * @template T
   * @api
   */
  forEachFeatureAtPixel(e, t, i) {
    if (!this.frameState_ || !this.renderer_)
      return;
    const n = this.getCoordinateFromPixelInternal(e);
    i = i !== void 0 ? i : {};
    const r = i.hitTolerance !== void 0 ? i.hitTolerance : 0, o = i.layerFilter !== void 0 ? i.layerFilter : mt, a = i.checkWrapped !== !1;
    return this.renderer_.forEachFeatureAtCoordinate(
      n,
      this.frameState_,
      r,
      a,
      t,
      null,
      o,
      null
    );
  }
  /**
   * Get all features that intersect a pixel on the viewport.
   * @param {import("./pixel.js").Pixel} pixel Pixel.
   * @param {AtPixelOptions} [options] Optional options.
   * @return {Array<import("./Feature.js").FeatureLike>} The detected features or
   * an empty array if none were found.
   * @api
   */
  getFeaturesAtPixel(e, t) {
    const i = [];
    return this.forEachFeatureAtPixel(
      e,
      function(n) {
        i.push(n);
      },
      t
    ), i;
  }
  /**
   * Get all layers from all layer groups.
   * @return {Array<import("./layer/Layer.js").default>} Layers.
   * @api
   */
  getAllLayers() {
    const e = [];
    function t(i) {
      i.forEach(function(n) {
        n instanceof Fr ? t(n.getLayers()) : e.push(n);
      });
    }
    return t(this.getLayers()), e;
  }
  /**
   * Detect if features intersect a pixel on the viewport. Layers included in the
   * detection can be configured through the `layerFilter` option.
   * @param {import("./pixel.js").Pixel} pixel Pixel.
   * @param {AtPixelOptions} [options] Optional options.
   * @return {boolean} Is there a feature at the given pixel?
   * @api
   */
  hasFeatureAtPixel(e, t) {
    if (!this.frameState_ || !this.renderer_)
      return !1;
    const i = this.getCoordinateFromPixelInternal(e);
    t = t !== void 0 ? t : {};
    const n = t.layerFilter !== void 0 ? t.layerFilter : mt, r = t.hitTolerance !== void 0 ? t.hitTolerance : 0, o = t.checkWrapped !== !1;
    return this.renderer_.hasFeatureAtCoordinate(
      i,
      this.frameState_,
      r,
      o,
      n,
      null
    );
  }
  /**
   * Returns the coordinate in user projection for a browser event.
   * @param {MouseEvent} event Event.
   * @return {import("./coordinate.js").Coordinate} Coordinate.
   * @api
   */
  getEventCoordinate(e) {
    return this.getCoordinateFromPixel(this.getEventPixel(e));
  }
  /**
   * Returns the coordinate in view projection for a browser event.
   * @param {MouseEvent} event Event.
   * @return {import("./coordinate.js").Coordinate} Coordinate.
   */
  getEventCoordinateInternal(e) {
    return this.getCoordinateFromPixelInternal(this.getEventPixel(e));
  }
  /**
   * Returns the map pixel position for a browser event relative to the viewport.
   * @param {UIEvent|{clientX: number, clientY: number}} event Event.
   * @return {import("./pixel.js").Pixel} Pixel.
   * @api
   */
  getEventPixel(e) {
    const i = this.viewport_.getBoundingClientRect(), n = this.getSize(), r = i.width / n[0], o = i.height / n[1], a = (
      //FIXME Are we really calling this with a TouchEvent anywhere?
      "changedTouches" in e ? (
        /** @type {TouchEvent} */
        e.changedTouches[0]
      ) : (
        /** @type {MouseEvent} */
        e
      )
    );
    return [
      (a.clientX - i.left) / r,
      (a.clientY - i.top) / o
    ];
  }
  /**
   * Get the target in which this map is rendered.
   * Note that this returns what is entered as an option or in setTarget:
   * if that was an element, it returns an element; if a string, it returns that.
   * @return {HTMLElement|string|undefined} The Element or id of the Element that the
   *     map is rendered in.
   * @observable
   * @api
   */
  getTarget() {
    return (
      /** @type {HTMLElement|string|undefined} */
      this.get(pe.TARGET)
    );
  }
  /**
   * Get the DOM element into which this map is rendered. In contrast to
   * `getTarget` this method always return an `Element`, or `null` if the
   * map has no target.
   * @return {HTMLElement} The element that the map is rendered in.
   * @api
   */
  getTargetElement() {
    return this.targetElement_;
  }
  /**
   * Get the coordinate for a given pixel.  This returns a coordinate in the
   * user projection.
   * @param {import("./pixel.js").Pixel} pixel Pixel position in the map viewport.
   * @return {import("./coordinate.js").Coordinate} The coordinate for the pixel position.
   * @api
   */
  getCoordinateFromPixel(e) {
    return Un(
      this.getCoordinateFromPixelInternal(e),
      this.getView().getProjection()
    );
  }
  /**
   * Get the coordinate for a given pixel.  This returns a coordinate in the
   * map view projection.
   * @param {import("./pixel.js").Pixel} pixel Pixel position in the map viewport.
   * @return {import("./coordinate.js").Coordinate} The coordinate for the pixel position.
   */
  getCoordinateFromPixelInternal(e) {
    const t = this.frameState_;
    return t ? de(t.pixelToCoordinateTransform, e.slice()) : null;
  }
  /**
   * Get the map controls. Modifying this collection changes the controls
   * associated with the map.
   * @return {Collection<import("./control/Control.js").default>} Controls.
   * @api
   */
  getControls() {
    return this.controls;
  }
  /**
   * Get the map overlays. Modifying this collection changes the overlays
   * associated with the map.
   * @return {Collection<import("./Overlay.js").default>} Overlays.
   * @api
   */
  getOverlays() {
    return this.overlays_;
  }
  /**
   * Get an overlay by its identifier (the value returned by overlay.getId()).
   * Note that the index treats string and numeric identifiers as the same. So
   * `map.getOverlayById(2)` will return an overlay with id `'2'` or `2`.
   * @param {string|number} id Overlay identifier.
   * @return {import("./Overlay.js").default} Overlay.
   * @api
   */
  getOverlayById(e) {
    const t = this.overlayIdIndex_[e.toString()];
    return t !== void 0 ? t : null;
  }
  /**
   * Get the map interactions. Modifying this collection changes the interactions
   * associated with the map.
   *
   * Interactions are used for e.g. pan, zoom and rotate.
   * @return {Collection<import("./interaction/Interaction.js").default>} Interactions.
   * @api
   */
  getInteractions() {
    return this.interactions;
  }
  /**
   * Get the layergroup associated with this map.
   * @return {LayerGroup} A layer group containing the layers in this map.
   * @observable
   * @api
   */
  getLayerGroup() {
    return (
      /** @type {LayerGroup} */
      this.get(pe.LAYERGROUP)
    );
  }
  /**
   * Clear any existing layers and add layers to the map.
   * @param {Array<import("./layer/Base.js").default>|Collection<import("./layer/Base.js").default>} layers The layers to be added to the map.
   * @api
   */
  setLayers(e) {
    const t = this.getLayerGroup();
    if (e instanceof ce) {
      t.setLayers(e);
      return;
    }
    const i = t.getLayers();
    i.clear(), i.extend(e);
  }
  /**
   * Get the collection of layers associated with this map.
   * @return {!Collection<import("./layer/Base.js").default>} Layers.
   * @api
   */
  getLayers() {
    return this.getLayerGroup().getLayers();
  }
  /**
   * @return {boolean} Layers have sources that are still loading.
   */
  getLoadingOrNotReady() {
    const e = this.getLayerGroup().getLayerStatesArray();
    for (let t = 0, i = e.length; t < i; ++t) {
      const n = e[t];
      if (!n.visible)
        continue;
      const r = n.layer.getRenderer();
      if (r && !r.ready)
        return !0;
      const o = n.layer.getSource();
      if (o && o.loading)
        return !0;
    }
    return !1;
  }
  /**
   * Get the pixel for a coordinate.  This takes a coordinate in the user
   * projection and returns the corresponding pixel.
   * @param {import("./coordinate.js").Coordinate} coordinate A map coordinate.
   * @return {import("./pixel.js").Pixel} A pixel position in the map viewport.
   * @api
   */
  getPixelFromCoordinate(e) {
    const t = he(
      e,
      this.getView().getProjection()
    );
    return this.getPixelFromCoordinateInternal(t);
  }
  /**
   * Get the pixel for a coordinate.  This takes a coordinate in the map view
   * projection and returns the corresponding pixel.
   * @param {import("./coordinate.js").Coordinate} coordinate A map coordinate.
   * @return {import("./pixel.js").Pixel} A pixel position in the map viewport.
   */
  getPixelFromCoordinateInternal(e) {
    const t = this.frameState_;
    return t ? de(
      t.coordinateToPixelTransform,
      e.slice(0, 2)
    ) : null;
  }
  /**
   * Get the map renderer.
   * @return {import("./renderer/Map.js").default|null} Renderer
   */
  getRenderer() {
    return this.renderer_;
  }
  /**
   * Get the size of this map.
   * @return {import("./size.js").Size|undefined} The size in pixels of the map in the DOM.
   * @observable
   * @api
   */
  getSize() {
    return (
      /** @type {import("./size.js").Size|undefined} */
      this.get(pe.SIZE)
    );
  }
  /**
   * Get the view associated with this map. A view manages properties such as
   * center and resolution.
   * @return {View} The view that controls this map.
   * @observable
   * @api
   */
  getView() {
    return (
      /** @type {View} */
      this.get(pe.VIEW)
    );
  }
  /**
   * Get the element that serves as the map viewport.
   * @return {HTMLElement} Viewport.
   * @api
   */
  getViewport() {
    return this.viewport_;
  }
  /**
   * Get the element that serves as the container for overlays.  Elements added to
   * this container will let mousedown and touchstart events through to the map,
   * so clicks and gestures on an overlay will trigger {@link module:ol/MapBrowserEvent~MapBrowserEvent}
   * events.
   * @return {!HTMLElement} The map's overlay container.
   */
  getOverlayContainer() {
    return this.overlayContainer_;
  }
  /**
   * Get the element that serves as a container for overlays that don't allow
   * event propagation. Elements added to this container won't let mousedown and
   * touchstart events through to the map, so clicks and gestures on an overlay
   * don't trigger any {@link module:ol/MapBrowserEvent~MapBrowserEvent}.
   * @return {!HTMLElement} The map's overlay container that stops events.
   */
  getOverlayContainerStopEvent() {
    return this.overlayContainerStopEvent_;
  }
  /**
   * @return {!Document} The document where the map is displayed.
   */
  getOwnerDocument() {
    const e = this.getTargetElement();
    return e ? e.ownerDocument : document;
  }
  /**
   * @param {import("./Tile.js").default} tile Tile.
   * @param {string} tileSourceKey Tile source key.
   * @param {import("./coordinate.js").Coordinate} tileCenter Tile center.
   * @param {number} tileResolution Tile resolution.
   * @return {number} Tile priority.
   */
  getTilePriority(e, t, i, n) {
    return Yf(
      this.frameState_,
      e,
      t,
      i,
      n
    );
  }
  /**
   * @param {UIEvent} browserEvent Browser event.
   * @param {string} [type] Type.
   */
  handleBrowserEvent(e, t) {
    t = t || e.type;
    const i = new Lt(t, this, e);
    this.handleMapBrowserEvent(i);
  }
  /**
   * @param {MapBrowserEvent} mapBrowserEvent The event to handle.
   */
  handleMapBrowserEvent(e) {
    if (!this.frameState_)
      return;
    const t = (
      /** @type {PointerEvent} */
      e.originalEvent
    ), i = t.type;
    if (i === jn.POINTERDOWN || i === z.WHEEL || i === z.KEYDOWN) {
      const n = this.getOwnerDocument(), r = this.viewport_.getRootNode ? this.viewport_.getRootNode() : n, o = (
        /** @type {Node} */
        t.target
      );
      if (
        // Abort if the target is a child of the container for elements whose events are not meant
        // to be handled by map interactions.
        this.overlayContainerStopEvent_.contains(o) || // Abort if the event target is a child of the container that is no longer in the page.
        // It's possible for the target to no longer be in the page if it has been removed in an
        // event listener, this might happen in a Control that recreates it's content based on
        // user interaction either manually or via a render in something like https://reactjs.org/
        !(r === n ? n.documentElement : r).contains(o)
      )
        return;
    }
    if (e.frameState = this.frameState_, this.dispatchEvent(e) !== !1) {
      const n = this.getInteractions().getArray().slice();
      for (let r = n.length - 1; r >= 0; r--) {
        const o = n[r];
        if (o.getMap() !== this || !o.getActive() || !this.getTargetElement())
          continue;
        if (!o.handleEvent(e) || e.propagationStopped)
          break;
      }
    }
  }
  /**
   * @protected
   */
  handlePostRender() {
    const e = this.frameState_, t = this.tileQueue_;
    if (!t.isEmpty()) {
      let n = this.maxTilesLoading_, r = n;
      if (e) {
        const o = e.viewHints;
        if (o[ge.ANIMATING] || o[ge.INTERACTING]) {
          const a = Date.now() - e.time > 8;
          n = a ? 0 : 8, r = a ? 0 : 2;
        }
      }
      t.getTilesLoading() < n && (t.reprioritize(), t.loadMoreTiles(n, r));
    }
    e && this.renderer_ && !e.animate && (this.renderComplete_ === !0 ? (this.hasListener(Xe.RENDERCOMPLETE) && this.renderer_.dispatchRenderEvent(
      Xe.RENDERCOMPLETE,
      e
    ), this.loaded_ === !1 && (this.loaded_ = !0, this.dispatchEvent(
      new Bi(dt.LOADEND, this, e)
    ))) : this.loaded_ === !0 && (this.loaded_ = !1, this.dispatchEvent(
      new Bi(dt.LOADSTART, this, e)
    )));
    const i = this.postRenderFunctions_;
    for (let n = 0, r = i.length; n < r; ++n)
      i[n](this, e);
    i.length = 0;
  }
  /**
   * @private
   */
  handleSizeChanged_() {
    this.getView() && !this.getView().getAnimating() && this.getView().resolveConstraints(0), this.render();
  }
  /**
   * @private
   */
  handleTargetChanged_() {
    if (this.mapBrowserEventHandler_) {
      for (let i = 0, n = this.targetChangeHandlerKeys_.length; i < n; ++i)
        re(this.targetChangeHandlerKeys_[i]);
      this.targetChangeHandlerKeys_ = null, this.viewport_.removeEventListener(
        z.CONTEXTMENU,
        this.boundHandleBrowserEvent_
      ), this.viewport_.removeEventListener(
        z.WHEEL,
        this.boundHandleBrowserEvent_
      ), this.mapBrowserEventHandler_.dispose(), this.mapBrowserEventHandler_ = null, lr(this.viewport_);
    }
    if (this.targetElement_) {
      this.resizeObserver_.unobserve(this.targetElement_);
      const i = this.targetElement_.getRootNode();
      i instanceof ShadowRoot && this.resizeObserver_.unobserve(i.host);
    }
    const e = this.getTarget(), t = typeof e == "string" ? document.getElementById(e) : e;
    if (this.targetElement_ = t, !t)
      this.renderer_ && (clearTimeout(this.postRenderTimeoutHandle_), this.postRenderTimeoutHandle_ = void 0, this.postRenderFunctions_.length = 0, this.renderer_.dispose(), this.renderer_ = null), this.animationDelayKey_ && (cancelAnimationFrame(this.animationDelayKey_), this.animationDelayKey_ = void 0);
    else {
      t.appendChild(this.viewport_), this.renderer_ || (this.renderer_ = new Df(this)), this.mapBrowserEventHandler_ = new Uf(
        this,
        this.moveTolerance_
      );
      for (const r in J)
        this.mapBrowserEventHandler_.addEventListener(
          J[r],
          this.handleMapBrowserEvent.bind(this)
        );
      this.viewport_.addEventListener(
        z.CONTEXTMENU,
        this.boundHandleBrowserEvent_,
        !1
      ), this.viewport_.addEventListener(
        z.WHEEL,
        this.boundHandleBrowserEvent_,
        Fh ? { passive: !1 } : !1
      );
      const i = this.keyboardEventTarget_ ? this.keyboardEventTarget_ : t;
      this.targetChangeHandlerKeys_ = [
        H(
          i,
          z.KEYDOWN,
          this.handleBrowserEvent,
          this
        ),
        H(
          i,
          z.KEYPRESS,
          this.handleBrowserEvent,
          this
        )
      ];
      const n = t.getRootNode();
      n instanceof ShadowRoot && this.resizeObserver_.observe(n.host), this.resizeObserver_.observe(t);
    }
    this.updateSize();
  }
  /**
   * @private
   */
  handleTileChange_() {
    this.render();
  }
  /**
   * @private
   */
  handleViewPropertyChanged_() {
    this.render();
  }
  /**
   * @private
   */
  handleViewChanged_() {
    this.viewPropertyListenerKey_ && (re(this.viewPropertyListenerKey_), this.viewPropertyListenerKey_ = null), this.viewChangeListenerKey_ && (re(this.viewChangeListenerKey_), this.viewChangeListenerKey_ = null);
    const e = this.getView();
    e && (this.updateViewportSize_(), this.viewPropertyListenerKey_ = H(
      e,
      Ei.PROPERTYCHANGE,
      this.handleViewPropertyChanged_,
      this
    ), this.viewChangeListenerKey_ = H(
      e,
      z.CHANGE,
      this.handleViewPropertyChanged_,
      this
    ), e.resolveConstraints(0)), this.render();
  }
  /**
   * @private
   */
  handleLayerGroupChanged_() {
    this.layerGroupPropertyListenerKeys_ && (this.layerGroupPropertyListenerKeys_.forEach(re), this.layerGroupPropertyListenerKeys_ = null);
    const e = this.getLayerGroup();
    e && (this.handleLayerAdd_(new Ht("addlayer", e)), this.layerGroupPropertyListenerKeys_ = [
      H(e, Ei.PROPERTYCHANGE, this.render, this),
      H(e, z.CHANGE, this.render, this),
      H(e, "addlayer", this.handleLayerAdd_, this),
      H(e, "removelayer", this.handleLayerRemove_, this)
    ]), this.render();
  }
  /**
   * @return {boolean} Is rendered.
   */
  isRendered() {
    return !!this.frameState_;
  }
  /**
   * @private
   */
  animationDelay_() {
    this.animationDelayKey_ = void 0, this.renderFrame_(Date.now());
  }
  /**
   * Requests an immediate render in a synchronous manner.
   * @api
   */
  renderSync() {
    this.animationDelayKey_ && cancelAnimationFrame(this.animationDelayKey_), this.animationDelay_();
  }
  /**
   * Redraws all text after new fonts have loaded
   */
  redrawText() {
    const e = this.getLayerGroup().getLayerStatesArray();
    for (let t = 0, i = e.length; t < i; ++t) {
      const n = e[t].layer;
      n.hasRenderer() && n.getRenderer().handleFontsChanged();
    }
  }
  /**
   * Request a map rendering (at the next animation frame).
   * @api
   */
  render() {
    this.renderer_ && this.animationDelayKey_ === void 0 && (this.animationDelayKey_ = requestAnimationFrame(this.animationDelay_));
  }
  /**
   * Remove the given control from the map.
   * @param {import("./control/Control.js").default} control Control.
   * @return {import("./control/Control.js").default|undefined} The removed control (or undefined
   *     if the control was not found).
   * @api
   */
  removeControl(e) {
    return this.getControls().remove(e);
  }
  /**
   * Remove the given interaction from the map.
   * @param {import("./interaction/Interaction.js").default} interaction Interaction to remove.
   * @return {import("./interaction/Interaction.js").default|undefined} The removed interaction (or
   *     undefined if the interaction was not found).
   * @api
   */
  removeInteraction(e) {
    return this.getInteractions().remove(e);
  }
  /**
   * Removes the given layer from the map.
   * @param {import("./layer/Base.js").default} layer Layer.
   * @return {import("./layer/Base.js").default|undefined} The removed layer (or undefined if the
   *     layer was not found).
   * @api
   */
  removeLayer(e) {
    return this.getLayerGroup().getLayers().remove(e);
  }
  /**
   * @param {import("./layer/Group.js").GroupEvent} event The layer remove event.
   * @private
   */
  handleLayerRemove_(e) {
    vc(e.layer);
  }
  /**
   * Remove the given overlay from the map.
   * @param {import("./Overlay.js").default} overlay Overlay.
   * @return {import("./Overlay.js").default|undefined} The removed overlay (or undefined
   *     if the overlay was not found).
   * @api
   */
  removeOverlay(e) {
    return this.getOverlays().remove(e);
  }
  /**
   * @param {number} time Time.
   * @private
   */
  renderFrame_(e) {
    const t = this.getSize(), i = this.getView(), n = this.frameState_;
    let r = null;
    if (t !== void 0 && Ol(t) && i && i.isDef()) {
      const o = i.getHints(
        this.frameState_ ? this.frameState_.viewHints : void 0
      ), a = i.getState();
      if (r = {
        animate: !1,
        coordinateToPixelTransform: this.coordinateToPixelTransform_,
        declutterTree: null,
        extent: bo(
          a.center,
          a.resolution,
          a.rotation,
          t
        ),
        index: this.frameIndex_++,
        layerIndex: 0,
        layerStatesArray: this.getLayerGroup().getLayerStatesArray(),
        pixelRatio: this.pixelRatio_,
        pixelToCoordinateTransform: this.pixelToCoordinateTransform_,
        postRenderFunctions: [],
        size: t,
        tileQueue: this.tileQueue_,
        time: e,
        usedTiles: {},
        viewState: a,
        viewHints: o,
        wantedTiles: {},
        mapId: B(this),
        renderTargets: {}
      }, a.nextCenter && a.nextResolution) {
        const l = isNaN(a.nextRotation) ? a.rotation : a.nextRotation;
        r.nextExtent = bo(
          a.nextCenter,
          a.nextResolution,
          l,
          t
        );
      }
    }
    this.frameState_ = r, this.renderer_.renderFrame(r), r && (r.animate && this.render(), Array.prototype.push.apply(
      this.postRenderFunctions_,
      r.postRenderFunctions
    ), n && (!this.previousExtent_ || !as(this.previousExtent_) && !ti(r.extent, this.previousExtent_)) && (this.dispatchEvent(
      new Bi(dt.MOVESTART, this, n)
    ), this.previousExtent_ = rs(this.previousExtent_)), this.previousExtent_ && !r.viewHints[ge.ANIMATING] && !r.viewHints[ge.INTERACTING] && !ti(r.extent, this.previousExtent_) && (this.dispatchEvent(
      new Bi(dt.MOVEEND, this, r)
    ), bh(r.extent, this.previousExtent_))), this.dispatchEvent(new Bi(dt.POSTRENDER, this, r)), this.renderComplete_ = this.hasListener(dt.LOADSTART) || this.hasListener(dt.LOADEND) || this.hasListener(Xe.RENDERCOMPLETE) ? !this.tileQueue_.getTilesLoading() && !this.tileQueue_.getCount() && !this.getLoadingOrNotReady() : void 0, this.postRenderTimeoutHandle_ || (this.postRenderTimeoutHandle_ = setTimeout(() => {
      this.postRenderTimeoutHandle_ = void 0, this.handlePostRender();
    }, 0));
  }
  /**
   * Sets the layergroup of this map.
   * @param {LayerGroup} layerGroup A layer group containing the layers in this map.
   * @observable
   * @api
   */
  setLayerGroup(e) {
    const t = this.getLayerGroup();
    t && this.handleLayerRemove_(new Ht("removelayer", t)), this.set(pe.LAYERGROUP, e);
  }
  /**
   * Set the size of this map.
   * @param {import("./size.js").Size|undefined} size The size in pixels of the map in the DOM.
   * @observable
   * @api
   */
  setSize(e) {
    this.set(pe.SIZE, e);
  }
  /**
   * Set the target element to render this map into.
   * @param {HTMLElement|string} [target] The Element or id of the Element
   *     that the map is rendered in.
   * @observable
   * @api
   */
  setTarget(e) {
    this.set(pe.TARGET, e);
  }
  /**
   * Set the view for this map.
   * @param {View|Promise<import("./View.js").ViewOptions>} view The view that controls this map.
   * It is also possible to pass a promise that resolves to options for constructing a view.  This
   * alternative allows view properties to be resolved by sources or other components that load
   * view-related metadata.
   * @observable
   * @api
   */
  setView(e) {
    if (!e || e instanceof Pe) {
      this.set(pe.VIEW, e);
      return;
    }
    this.set(pe.VIEW, new Pe());
    const t = this;
    e.then(function(i) {
      t.setView(new Pe(i));
    });
  }
  /**
   * Force a recalculation of the map viewport size.  This should be called when
   * third-party code changes the size of the map viewport.
   * @api
   */
  updateSize() {
    const e = this.getTargetElement();
    let t;
    if (e) {
      const n = getComputedStyle(e), r = e.offsetWidth - parseFloat(n.borderLeftWidth) - parseFloat(n.paddingLeft) - parseFloat(n.paddingRight) - parseFloat(n.borderRightWidth), o = e.offsetHeight - parseFloat(n.borderTopWidth) - parseFloat(n.paddingTop) - parseFloat(n.paddingBottom) - parseFloat(n.borderBottomWidth);
      !isNaN(r) && !isNaN(o) && (t = [r, o], !Ol(t) && (e.offsetWidth || e.offsetHeight || e.getClientRects().length) && Vh(
        "No map visible because the map container's width or height are 0."
      ));
    }
    const i = this.getSize();
    t && (!i || !xt(t, i)) && (this.setSize(t), this.updateViewportSize_());
  }
  /**
   * Recomputes the viewport size and save it on the view object (if any)
   * @private
   */
  updateViewportSize_() {
    const e = this.getView();
    if (e) {
      let t;
      const i = getComputedStyle(this.viewport_);
      i.width && i.height && (t = [
        parseInt(i.width, 10),
        parseInt(i.height, 10)
      ]), e.setViewportSize(t);
    }
  }
};
function Ig(s) {
  let e = null;
  s.keyboardEventTarget !== void 0 && (e = typeof s.keyboardEventTarget == "string" ? document.getElementById(s.keyboardEventTarget) : s.keyboardEventTarget);
  const t = {}, i = s.layers && typeof /** @type {?} */
  s.layers.getLayers == "function" ? (
    /** @type {LayerGroup} */
    s.layers
  ) : new Fr({
    layers: (
      /** @type {Collection<import("./layer/Base.js").default>|Array<import("./layer/Base.js").default>} */
      s.layers
    )
  });
  t[pe.LAYERGROUP] = i, t[pe.TARGET] = s.target, t[pe.VIEW] = s.view instanceof Pe ? s.view : new Pe();
  let n;
  s.controls !== void 0 && (Array.isArray(s.controls) ? n = new ce(s.controls.slice()) : (Z(
    typeof /** @type {?} */
    s.controls.getArray == "function",
    47
  ), n = s.controls));
  let r;
  s.interactions !== void 0 && (Array.isArray(s.interactions) ? r = new ce(s.interactions.slice()) : (Z(
    typeof /** @type {?} */
    s.interactions.getArray == "function",
    48
  ), r = s.interactions));
  let o;
  return s.overlays !== void 0 ? Array.isArray(s.overlays) ? o = new ce(s.overlays.slice()) : (Z(
    typeof /** @type {?} */
    s.overlays.getArray == "function",
    49
  ), o = s.overlays) : o = new ce(), {
    controls: n,
    interactions: r,
    keyboardEventTarget: e,
    overlays: o,
    values: t
  };
}
const wc = Rg;
function Lg(s, e, t, i, n) {
  Tc(s, e, t || 0, i || s.length - 1, n || Ag);
}
function Tc(s, e, t, i, n) {
  for (; i > t; ) {
    if (i - t > 600) {
      var r = i - t + 1, o = e - t + 1, a = Math.log(r), l = 0.5 * Math.exp(2 * a / 3), h = 0.5 * Math.sqrt(a * l * (r - l) / r) * (o - r / 2 < 0 ? -1 : 1), c = Math.max(t, Math.floor(e - o * l / r + h)), u = Math.min(i, Math.floor(e + (r - o) * l / r + h));
      Tc(s, e, c, u, n);
    }
    var d = s[e], f = t, g = i;
    for (En(s, t, e), n(s[i], d) > 0 && En(s, t, i); f < g; ) {
      for (En(s, f, g), f++, g--; n(s[f], d) < 0; )
        f++;
      for (; n(s[g], d) > 0; )
        g--;
    }
    n(s[t], d) === 0 ? En(s, t, g) : (g++, En(s, g, i)), g <= e && (t = g + 1), e <= g && (i = g - 1);
  }
}
function En(s, e, t) {
  var i = s[e];
  s[e] = s[t], s[t] = i;
}
function Ag(s, e) {
  return s < e ? -1 : s > e ? 1 : 0;
}
let Ua = class {
  constructor(e = 9) {
    this._maxEntries = Math.max(4, e), this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4)), this.clear();
  }
  all() {
    return this._all(this.data, []);
  }
  search(e) {
    let t = this.data;
    const i = [];
    if (!Ms(e, t))
      return i;
    const n = this.toBBox, r = [];
    for (; t; ) {
      for (let o = 0; o < t.children.length; o++) {
        const a = t.children[o], l = t.leaf ? n(a) : a;
        Ms(e, l) && (t.leaf ? i.push(a) : eo(e, l) ? this._all(a, i) : r.push(a));
      }
      t = r.pop();
    }
    return i;
  }
  collides(e) {
    let t = this.data;
    if (!Ms(e, t))
      return !1;
    const i = [];
    for (; t; ) {
      for (let n = 0; n < t.children.length; n++) {
        const r = t.children[n], o = t.leaf ? this.toBBox(r) : r;
        if (Ms(e, o)) {
          if (t.leaf || eo(e, o))
            return !0;
          i.push(r);
        }
      }
      t = i.pop();
    }
    return !1;
  }
  load(e) {
    if (!(e && e.length))
      return this;
    if (e.length < this._minEntries) {
      for (let i = 0; i < e.length; i++)
        this.insert(e[i]);
      return this;
    }
    let t = this._build(e.slice(), 0, e.length - 1, 0);
    if (!this.data.children.length)
      this.data = t;
    else if (this.data.height === t.height)
      this._splitRoot(this.data, t);
    else {
      if (this.data.height < t.height) {
        const i = this.data;
        this.data = t, t = i;
      }
      this._insert(t, this.data.height - t.height - 1, !0);
    }
    return this;
  }
  insert(e) {
    return e && this._insert(e, this.data.height - 1), this;
  }
  clear() {
    return this.data = Xi([]), this;
  }
  remove(e, t) {
    if (!e)
      return this;
    let i = this.data;
    const n = this.toBBox(e), r = [], o = [];
    let a, l, h;
    for (; i || r.length; ) {
      if (i || (i = r.pop(), l = r[r.length - 1], a = o.pop(), h = !0), i.leaf) {
        const c = Fg(e, i.children, t);
        if (c !== -1)
          return i.children.splice(c, 1), r.push(i), this._condense(r), this;
      }
      !h && !i.leaf && eo(i, n) ? (r.push(i), o.push(a), a = 0, l = i, i = i.children[0]) : l ? (a++, i = l.children[a], h = !1) : i = null;
    }
    return this;
  }
  toBBox(e) {
    return e;
  }
  compareMinX(e, t) {
    return e.minX - t.minX;
  }
  compareMinY(e, t) {
    return e.minY - t.minY;
  }
  toJSON() {
    return this.data;
  }
  fromJSON(e) {
    return this.data = e, this;
  }
  _all(e, t) {
    const i = [];
    for (; e; )
      e.leaf ? t.push(...e.children) : i.push(...e.children), e = i.pop();
    return t;
  }
  _build(e, t, i, n) {
    const r = i - t + 1;
    let o = this._maxEntries, a;
    if (r <= o)
      return a = Xi(e.slice(t, i + 1)), ki(a, this.toBBox), a;
    n || (n = Math.ceil(Math.log(r) / Math.log(o)), o = Math.ceil(r / Math.pow(o, n - 1))), a = Xi([]), a.leaf = !1, a.height = n;
    const l = Math.ceil(r / o), h = l * Math.ceil(Math.sqrt(o));
    Dl(e, t, i, h, this.compareMinX);
    for (let c = t; c <= i; c += h) {
      const u = Math.min(c + h - 1, i);
      Dl(e, c, u, l, this.compareMinY);
      for (let d = c; d <= u; d += l) {
        const f = Math.min(d + l - 1, u);
        a.children.push(this._build(e, d, f, n - 1));
      }
    }
    return ki(a, this.toBBox), a;
  }
  _chooseSubtree(e, t, i, n) {
    for (; n.push(t), !(t.leaf || n.length - 1 === i); ) {
      let r = 1 / 0, o = 1 / 0, a;
      for (let l = 0; l < t.children.length; l++) {
        const h = t.children[l], c = Qr(h), u = Mg(e, h) - c;
        u < o ? (o = u, r = c < r ? c : r, a = h) : u === o && c < r && (r = c, a = h);
      }
      t = a || t.children[0];
    }
    return t;
  }
  _insert(e, t, i) {
    const n = i ? e : this.toBBox(e), r = [], o = this._chooseSubtree(n, this.data, t, r);
    for (o.children.push(e), Tn(o, n); t >= 0 && r[t].children.length > this._maxEntries; )
      this._split(r, t), t--;
    this._adjustParentBBoxes(n, r, t);
  }
  // split overflowed node into two
  _split(e, t) {
    const i = e[t], n = i.children.length, r = this._minEntries;
    this._chooseSplitAxis(i, r, n);
    const o = this._chooseSplitIndex(i, r, n), a = Xi(i.children.splice(o, i.children.length - o));
    a.height = i.height, a.leaf = i.leaf, ki(i, this.toBBox), ki(a, this.toBBox), t ? e[t - 1].children.push(a) : this._splitRoot(i, a);
  }
  _splitRoot(e, t) {
    this.data = Xi([e, t]), this.data.height = e.height + 1, this.data.leaf = !1, ki(this.data, this.toBBox);
  }
  _chooseSplitIndex(e, t, i) {
    let n, r = 1 / 0, o = 1 / 0;
    for (let a = t; a <= i - t; a++) {
      const l = wn(e, 0, a, this.toBBox), h = wn(e, a, i, this.toBBox), c = Og(l, h), u = Qr(l) + Qr(h);
      c < r ? (r = c, n = a, o = u < o ? u : o) : c === r && u < o && (o = u, n = a);
    }
    return n || i - t;
  }
  // sorts node children by the best axis for split
  _chooseSplitAxis(e, t, i) {
    const n = e.leaf ? this.compareMinX : bg, r = e.leaf ? this.compareMinY : Pg, o = this._allDistMargin(e, t, i, n), a = this._allDistMargin(e, t, i, r);
    o < a && e.children.sort(n);
  }
  // total margin of all possible split distributions where each node is at least m full
  _allDistMargin(e, t, i, n) {
    e.children.sort(n);
    const r = this.toBBox, o = wn(e, 0, t, r), a = wn(e, i - t, i, r);
    let l = Ps(o) + Ps(a);
    for (let h = t; h < i - t; h++) {
      const c = e.children[h];
      Tn(o, e.leaf ? r(c) : c), l += Ps(o);
    }
    for (let h = i - t - 1; h >= t; h--) {
      const c = e.children[h];
      Tn(a, e.leaf ? r(c) : c), l += Ps(a);
    }
    return l;
  }
  _adjustParentBBoxes(e, t, i) {
    for (let n = i; n >= 0; n--)
      Tn(t[n], e);
  }
  _condense(e) {
    for (let t = e.length - 1, i; t >= 0; t--)
      e[t].children.length === 0 ? t > 0 ? (i = e[t - 1].children, i.splice(i.indexOf(e[t]), 1)) : this.clear() : ki(e[t], this.toBBox);
  }
};
function Fg(s, e, t) {
  if (!t)
    return e.indexOf(s);
  for (let i = 0; i < e.length; i++)
    if (t(s, e[i]))
      return i;
  return -1;
}
function ki(s, e) {
  wn(s, 0, s.children.length, e, s);
}
function wn(s, e, t, i, n) {
  n || (n = Xi(null)), n.minX = 1 / 0, n.minY = 1 / 0, n.maxX = -1 / 0, n.maxY = -1 / 0;
  for (let r = e; r < t; r++) {
    const o = s.children[r];
    Tn(n, s.leaf ? i(o) : o);
  }
  return n;
}
function Tn(s, e) {
  return s.minX = Math.min(s.minX, e.minX), s.minY = Math.min(s.minY, e.minY), s.maxX = Math.max(s.maxX, e.maxX), s.maxY = Math.max(s.maxY, e.maxY), s;
}
function bg(s, e) {
  return s.minX - e.minX;
}
function Pg(s, e) {
  return s.minY - e.minY;
}
function Qr(s) {
  return (s.maxX - s.minX) * (s.maxY - s.minY);
}
function Ps(s) {
  return s.maxX - s.minX + (s.maxY - s.minY);
}
function Mg(s, e) {
  return (Math.max(e.maxX, s.maxX) - Math.min(e.minX, s.minX)) * (Math.max(e.maxY, s.maxY) - Math.min(e.minY, s.minY));
}
function Og(s, e) {
  const t = Math.max(s.minX, e.minX), i = Math.max(s.minY, e.minY), n = Math.min(s.maxX, e.maxX), r = Math.min(s.maxY, e.maxY);
  return Math.max(0, n - t) * Math.max(0, r - i);
}
function eo(s, e) {
  return s.minX <= e.minX && s.minY <= e.minY && e.maxX <= s.maxX && e.maxY <= s.maxY;
}
function Ms(s, e) {
  return e.minX <= s.maxX && e.minY <= s.maxY && e.maxX >= s.minX && e.maxY >= s.minY;
}
function Xi(s) {
  return {
    children: s,
    height: 1,
    leaf: !0,
    minX: 1 / 0,
    minY: 1 / 0,
    maxX: -1 / 0,
    maxY: -1 / 0
  };
}
function Dl(s, e, t, i, n) {
  const r = [e, t];
  for (; r.length; ) {
    if (t = r.pop(), e = r.pop(), t - e <= i)
      continue;
    const o = e + Math.ceil((t - e) / i / 2) * i;
    Lg(s, o, e, t, n), r.push(e, o, o, t);
  }
}
const k = {
  IDLE: 0,
  LOADING: 1,
  LOADED: 2,
  ERROR: 3,
  EMPTY: 4
};
class za {
  /**
   * @param {Options} options Options.
   */
  constructor(e) {
    this.opacity_ = e.opacity, this.rotateWithView_ = e.rotateWithView, this.rotation_ = e.rotation, this.scale_ = e.scale, this.scaleArray_ = Ke(e.scale), this.displacement_ = e.displacement, this.declutterMode_ = e.declutterMode;
  }
  /**
   * Clones the style.
   * @return {ImageStyle} The cloned style.
   * @api
   */
  clone() {
    const e = this.getScale();
    return new za({
      opacity: this.getOpacity(),
      scale: Array.isArray(e) ? e.slice() : e,
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      displacement: this.getDisplacement().slice(),
      declutterMode: this.getDeclutterMode()
    });
  }
  /**
   * Get the symbolizer opacity.
   * @return {number} Opacity.
   * @api
   */
  getOpacity() {
    return this.opacity_;
  }
  /**
   * Determine whether the symbolizer rotates with the map.
   * @return {boolean} Rotate with map.
   * @api
   */
  getRotateWithView() {
    return this.rotateWithView_;
  }
  /**
   * Get the symoblizer rotation.
   * @return {number} Rotation.
   * @api
   */
  getRotation() {
    return this.rotation_;
  }
  /**
   * Get the symbolizer scale.
   * @return {number|import("../size.js").Size} Scale.
   * @api
   */
  getScale() {
    return this.scale_;
  }
  /**
   * Get the symbolizer scale array.
   * @return {import("../size.js").Size} Scale array.
   */
  getScaleArray() {
    return this.scaleArray_;
  }
  /**
   * Get the displacement of the shape
   * @return {Array<number>} Shape's center displacement
   * @api
   */
  getDisplacement() {
    return this.displacement_;
  }
  /**
   * Get the declutter mode of the shape
   * @return {"declutter"|"obstacle"|"none"|undefined} Shape's declutter mode
   * @api
   */
  getDeclutterMode() {
    return this.declutterMode_;
  }
  /**
   * Get the anchor point in pixels. The anchor determines the center point for the
   * symbolizer.
   * @abstract
   * @return {Array<number>} Anchor.
   */
  getAnchor() {
    return X();
  }
  /**
   * Get the image element for the symbolizer.
   * @abstract
   * @param {number} pixelRatio Pixel ratio.
   * @return {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} Image element.
   */
  getImage(e) {
    return X();
  }
  /**
   * @abstract
   * @return {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} Image element.
   */
  getHitDetectionImage() {
    return X();
  }
  /**
   * Get the image pixel ratio.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Pixel ratio.
   */
  getPixelRatio(e) {
    return 1;
  }
  /**
   * @abstract
   * @return {import("../ImageState.js").default} Image state.
   */
  getImageState() {
    return X();
  }
  /**
   * @abstract
   * @return {import("../size.js").Size} Image size.
   */
  getImageSize() {
    return X();
  }
  /**
   * Get the origin of the symbolizer.
   * @abstract
   * @return {Array<number>} Origin.
   */
  getOrigin() {
    return X();
  }
  /**
   * Get the size of the symbolizer (in pixels).
   * @abstract
   * @return {import("../size.js").Size} Size.
   */
  getSize() {
    return X();
  }
  /**
   * Set the displacement.
   *
   * @param {Array<number>} displacement Displacement.
   * @api
   */
  setDisplacement(e) {
    this.displacement_ = e;
  }
  /**
   * Set the opacity.
   *
   * @param {number} opacity Opacity.
   * @api
   */
  setOpacity(e) {
    this.opacity_ = e;
  }
  /**
   * Set whether to rotate the style with the view.
   *
   * @param {boolean} rotateWithView Rotate with map.
   * @api
   */
  setRotateWithView(e) {
    this.rotateWithView_ = e;
  }
  /**
   * Set the rotation.
   *
   * @param {number} rotation Rotation.
   * @api
   */
  setRotation(e) {
    this.rotation_ = e;
  }
  /**
   * Set the scale.
   *
   * @param {number|import("../size.js").Size} scale Scale.
   * @api
   */
  setScale(e) {
    this.scale_ = e, this.scaleArray_ = Ke(e);
  }
  /**
   * @abstract
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */
  listenImageChange(e) {
    X();
  }
  /**
   * Load not yet loaded URI.
   * @abstract
   */
  load() {
    X();
  }
  /**
   * @abstract
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */
  unlistenImageChange(e) {
    X();
  }
}
const Sc = za;
function _t(s) {
  return Array.isArray(s) ? Nh(s) : s;
}
class Ba extends Sc {
  /**
   * @param {Options} options Options.
   */
  constructor(e) {
    const t = e.rotateWithView !== void 0 ? e.rotateWithView : !1;
    super({
      opacity: 1,
      rotateWithView: t,
      rotation: e.rotation !== void 0 ? e.rotation : 0,
      scale: e.scale !== void 0 ? e.scale : 1,
      displacement: e.displacement !== void 0 ? e.displacement : [0, 0],
      declutterMode: e.declutterMode
    }), this.canvas_ = void 0, this.hitDetectionCanvas_ = null, this.fill_ = e.fill !== void 0 ? e.fill : null, this.origin_ = [0, 0], this.points_ = e.points, this.radius_ = e.radius !== void 0 ? e.radius : e.radius1, this.radius2_ = e.radius2, this.angle_ = e.angle !== void 0 ? e.angle : 0, this.stroke_ = e.stroke !== void 0 ? e.stroke : null, this.size_ = null, this.renderOptions_ = null, this.render();
  }
  /**
   * Clones the style.
   * @return {RegularShape} The cloned style.
   * @api
   */
  clone() {
    const e = this.getScale(), t = new Ba({
      fill: this.getFill() ? this.getFill().clone() : void 0,
      points: this.getPoints(),
      radius: this.getRadius(),
      radius2: this.getRadius2(),
      angle: this.getAngle(),
      stroke: this.getStroke() ? this.getStroke().clone() : void 0,
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      scale: Array.isArray(e) ? e.slice() : e,
      displacement: this.getDisplacement().slice(),
      declutterMode: this.getDeclutterMode()
    });
    return t.setOpacity(this.getOpacity()), t;
  }
  /**
   * Get the anchor point in pixels. The anchor determines the center point for the
   * symbolizer.
   * @return {Array<number>} Anchor.
   * @api
   */
  getAnchor() {
    const e = this.size_;
    if (!e)
      return null;
    const t = this.getDisplacement(), i = this.getScaleArray();
    return [
      e[0] / 2 - t[0] / i[0],
      e[1] / 2 + t[1] / i[1]
    ];
  }
  /**
   * Get the angle used in generating the shape.
   * @return {number} Shape's rotation in radians.
   * @api
   */
  getAngle() {
    return this.angle_;
  }
  /**
   * Get the fill style for the shape.
   * @return {import("./Fill.js").default} Fill style.
   * @api
   */
  getFill() {
    return this.fill_;
  }
  /**
   * Set the fill style.
   * @param {import("./Fill.js").default} fill Fill style.
   * @api
   */
  setFill(e) {
    this.fill_ = e, this.render();
  }
  /**
   * @return {HTMLCanvasElement} Image element.
   */
  getHitDetectionImage() {
    return this.hitDetectionCanvas_ || this.createHitDetectionCanvas_(this.renderOptions_), this.hitDetectionCanvas_;
  }
  /**
   * Get the image icon.
   * @param {number} pixelRatio Pixel ratio.
   * @return {HTMLCanvasElement} Image or Canvas element.
   * @api
   */
  getImage(e) {
    let t = this.canvas_[e];
    if (!t) {
      const i = this.renderOptions_, n = Re(
        i.size * e,
        i.size * e
      );
      this.draw_(i, n, e), t = n.canvas, this.canvas_[e] = t;
    }
    return t;
  }
  /**
   * Get the image pixel ratio.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Pixel ratio.
   */
  getPixelRatio(e) {
    return e;
  }
  /**
   * @return {import("../size.js").Size} Image size.
   */
  getImageSize() {
    return this.size_;
  }
  /**
   * @return {import("../ImageState.js").default} Image state.
   */
  getImageState() {
    return k.LOADED;
  }
  /**
   * Get the origin of the symbolizer.
   * @return {Array<number>} Origin.
   * @api
   */
  getOrigin() {
    return this.origin_;
  }
  /**
   * Get the number of points for generating the shape.
   * @return {number} Number of points for stars and regular polygons.
   * @api
   */
  getPoints() {
    return this.points_;
  }
  /**
   * Get the (primary) radius for the shape.
   * @return {number} Radius.
   * @api
   */
  getRadius() {
    return this.radius_;
  }
  /**
   * Get the secondary radius for the shape.
   * @return {number|undefined} Radius2.
   * @api
   */
  getRadius2() {
    return this.radius2_;
  }
  /**
   * Get the size of the symbolizer (in pixels).
   * @return {import("../size.js").Size} Size.
   * @api
   */
  getSize() {
    return this.size_;
  }
  /**
   * Get the stroke style for the shape.
   * @return {import("./Stroke.js").default} Stroke style.
   * @api
   */
  getStroke() {
    return this.stroke_;
  }
  /**
   * Set the stroke style.
   * @param {import("./Stroke.js").default} stroke Stroke style.
   * @api
   */
  setStroke(e) {
    this.stroke_ = e, this.render();
  }
  /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */
  listenImageChange(e) {
  }
  /**
   * Load not yet loaded URI.
   */
  load() {
  }
  /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */
  unlistenImageChange(e) {
  }
  /**
   * Calculate additional canvas size needed for the miter.
   * @param {string} lineJoin Line join
   * @param {number} strokeWidth Stroke width
   * @param {number} miterLimit Miter limit
   * @return {number} Additional canvas size needed
   * @private
   */
  calculateLineJoinSize_(e, t, i) {
    if (t === 0 || this.points_ === 1 / 0 || e !== "bevel" && e !== "miter")
      return t;
    let n = this.radius_, r = this.radius2_ === void 0 ? n : this.radius2_;
    if (n < r) {
      const T = n;
      n = r, r = T;
    }
    const o = this.radius2_ === void 0 ? this.points_ : this.points_ * 2, a = 2 * Math.PI / o, l = r * Math.sin(a), h = Math.sqrt(r * r - l * l), c = n - h, u = Math.sqrt(l * l + c * c), d = u / l;
    if (e === "miter" && d <= i)
      return d * t;
    const f = t / 2 / d, g = t / 2 * (c / u), m = Math.sqrt((n + f) * (n + f) + g * g) - n;
    if (this.radius2_ === void 0 || e === "bevel")
      return m * 2;
    const p = n * Math.sin(a), x = Math.sqrt(n * n - p * p), y = r - x, C = Math.sqrt(p * p + y * y) / p;
    if (C <= i) {
      const T = C * t / 2 - r - n;
      return 2 * Math.max(m, T);
    }
    return m * 2;
  }
  /**
   * @return {RenderOptions}  The render options
   * @protected
   */
  createRenderOptions() {
    let e = ln, t = 0, i = null, n = 0, r, o = 0;
    this.stroke_ && (r = this.stroke_.getColor(), r === null && (r = Yn), r = _t(r), o = this.stroke_.getWidth(), o === void 0 && (o = Zn), i = this.stroke_.getLineDash(), n = this.stroke_.getLineDashOffset(), e = this.stroke_.getLineJoin(), e === void 0 && (e = ln), t = this.stroke_.getMiterLimit(), t === void 0 && (t = Wn));
    const a = this.calculateLineJoinSize_(e, o, t), l = Math.max(this.radius_, this.radius2_ || 0), h = Math.ceil(2 * l + a);
    return {
      strokeStyle: r,
      strokeWidth: o,
      size: h,
      lineDash: i,
      lineDashOffset: n,
      lineJoin: e,
      miterLimit: t
    };
  }
  /**
   * @protected
   */
  render() {
    this.renderOptions_ = this.createRenderOptions();
    const e = this.renderOptions_.size;
    this.canvas_ = {}, this.size_ = [e, e];
  }
  /**
   * @private
   * @param {RenderOptions} renderOptions Render options.
   * @param {CanvasRenderingContext2D} context The rendering context.
   * @param {number} pixelRatio The pixel ratio.
   */
  draw_(e, t, i) {
    if (t.scale(i, i), t.translate(e.size / 2, e.size / 2), this.createPath_(t), this.fill_) {
      let n = this.fill_.getColor();
      n === null && (n = Pt), t.fillStyle = _t(n), t.fill();
    }
    this.stroke_ && (t.strokeStyle = e.strokeStyle, t.lineWidth = e.strokeWidth, e.lineDash && (t.setLineDash(e.lineDash), t.lineDashOffset = e.lineDashOffset), t.lineJoin = e.lineJoin, t.miterLimit = e.miterLimit, t.stroke());
  }
  /**
   * @private
   * @param {RenderOptions} renderOptions Render options.
   */
  createHitDetectionCanvas_(e) {
    if (this.fill_) {
      let t = this.fill_.getColor(), i = 0;
      if (typeof t == "string" && (t = Gn(t)), t === null ? i = 1 : Array.isArray(t) && (i = t.length === 4 ? t[3] : 1), i === 0) {
        const n = Re(
          e.size,
          e.size
        );
        this.hitDetectionCanvas_ = n.canvas, this.drawHitDetectionCanvas_(e, n);
      }
    }
    this.hitDetectionCanvas_ || (this.hitDetectionCanvas_ = this.getImage(1));
  }
  /**
   * @private
   * @param {CanvasRenderingContext2D} context The context to draw in.
   */
  createPath_(e) {
    let t = this.points_;
    const i = this.radius_;
    if (t === 1 / 0)
      e.arc(0, 0, i, 0, 2 * Math.PI);
    else {
      const n = this.radius2_ === void 0 ? i : this.radius2_;
      this.radius2_ !== void 0 && (t *= 2);
      const r = this.angle_ - Math.PI / 2, o = 2 * Math.PI / t;
      for (let a = 0; a < t; a++) {
        const l = r + a * o, h = a % 2 === 0 ? i : n;
        e.lineTo(h * Math.cos(l), h * Math.sin(l));
      }
      e.closePath();
    }
  }
  /**
   * @private
   * @param {RenderOptions} renderOptions Render options.
   * @param {CanvasRenderingContext2D} context The context.
   */
  drawHitDetectionCanvas_(e, t) {
    t.translate(e.size / 2, e.size / 2), this.createPath_(t), t.fillStyle = Pt, t.fill(), this.stroke_ && (t.strokeStyle = e.strokeStyle, t.lineWidth = e.strokeWidth, e.lineDash && (t.setLineDash(e.lineDash), t.lineDashOffset = e.lineDashOffset), t.lineJoin = e.lineJoin, t.miterLimit = e.miterLimit, t.stroke());
  }
}
const Fn = Ba;
class Xa extends Fn {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || { radius: 5 }, super({
      points: 1 / 0,
      fill: e.fill,
      radius: e.radius,
      stroke: e.stroke,
      scale: e.scale !== void 0 ? e.scale : 1,
      rotation: e.rotation !== void 0 ? e.rotation : 0,
      rotateWithView: e.rotateWithView !== void 0 ? e.rotateWithView : !1,
      displacement: e.displacement !== void 0 ? e.displacement : [0, 0],
      declutterMode: e.declutterMode
    });
  }
  /**
   * Clones the style.
   * @return {CircleStyle} The cloned style.
   * @api
   */
  clone() {
    const e = this.getScale(), t = new Xa({
      fill: this.getFill() ? this.getFill().clone() : void 0,
      stroke: this.getStroke() ? this.getStroke().clone() : void 0,
      radius: this.getRadius(),
      scale: Array.isArray(e) ? e.slice() : e,
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      displacement: this.getDisplacement().slice(),
      declutterMode: this.getDeclutterMode()
    });
    return t.setOpacity(this.getOpacity()), t;
  }
  /**
   * Set the circle radius.
   *
   * @param {number} radius Circle radius.
   * @api
   */
  setRadius(e) {
    this.radius_ = e, this.render();
  }
}
const qi = Xa;
class Wa {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {}, this.color_ = e.color !== void 0 ? e.color : null;
  }
  /**
   * Clones the style. The color is not cloned if it is an {@link module:ol/colorlike~ColorLike}.
   * @return {Fill} The cloned style.
   * @api
   */
  clone() {
    const e = this.getColor();
    return new Wa({
      color: Array.isArray(e) ? e.slice() : e || void 0
    });
  }
  /**
   * Get the fill color.
   * @return {import("../color.js").Color|import("../colorlike.js").ColorLike|null} Color.
   * @api
   */
  getColor() {
    return this.color_;
  }
  /**
   * Set the color.
   *
   * @param {import("../color.js").Color|import("../colorlike.js").ColorLike|null} color Color.
   * @api
   */
  setColor(e) {
    this.color_ = e;
  }
}
const N = Wa;
class Ya {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {}, this.color_ = e.color !== void 0 ? e.color : null, this.lineCap_ = e.lineCap, this.lineDash_ = e.lineDash !== void 0 ? e.lineDash : null, this.lineDashOffset_ = e.lineDashOffset, this.lineJoin_ = e.lineJoin, this.miterLimit_ = e.miterLimit, this.width_ = e.width;
  }
  /**
   * Clones the style.
   * @return {Stroke} The cloned style.
   * @api
   */
  clone() {
    const e = this.getColor();
    return new Ya({
      color: Array.isArray(e) ? e.slice() : e || void 0,
      lineCap: this.getLineCap(),
      lineDash: this.getLineDash() ? this.getLineDash().slice() : void 0,
      lineDashOffset: this.getLineDashOffset(),
      lineJoin: this.getLineJoin(),
      miterLimit: this.getMiterLimit(),
      width: this.getWidth()
    });
  }
  /**
   * Get the stroke color.
   * @return {import("../color.js").Color|import("../colorlike.js").ColorLike} Color.
   * @api
   */
  getColor() {
    return this.color_;
  }
  /**
   * Get the line cap type for the stroke.
   * @return {CanvasLineCap|undefined} Line cap.
   * @api
   */
  getLineCap() {
    return this.lineCap_;
  }
  /**
   * Get the line dash style for the stroke.
   * @return {Array<number>|null} Line dash.
   * @api
   */
  getLineDash() {
    return this.lineDash_;
  }
  /**
   * Get the line dash offset for the stroke.
   * @return {number|undefined} Line dash offset.
   * @api
   */
  getLineDashOffset() {
    return this.lineDashOffset_;
  }
  /**
   * Get the line join type for the stroke.
   * @return {CanvasLineJoin|undefined} Line join.
   * @api
   */
  getLineJoin() {
    return this.lineJoin_;
  }
  /**
   * Get the miter limit for the stroke.
   * @return {number|undefined} Miter limit.
   * @api
   */
  getMiterLimit() {
    return this.miterLimit_;
  }
  /**
   * Get the stroke width.
   * @return {number|undefined} Width.
   * @api
   */
  getWidth() {
    return this.width_;
  }
  /**
   * Set the color.
   *
   * @param {import("../color.js").Color|import("../colorlike.js").ColorLike} color Color.
   * @api
   */
  setColor(e) {
    this.color_ = e;
  }
  /**
   * Set the line cap.
   *
   * @param {CanvasLineCap|undefined} lineCap Line cap.
   * @api
   */
  setLineCap(e) {
    this.lineCap_ = e;
  }
  /**
   * Set the line dash.
   *
   * @param {Array<number>|null} lineDash Line dash.
   * @api
   */
  setLineDash(e) {
    this.lineDash_ = e;
  }
  /**
   * Set the line dash offset.
   *
   * @param {number|undefined} lineDashOffset Line dash offset.
   * @api
   */
  setLineDashOffset(e) {
    this.lineDashOffset_ = e;
  }
  /**
   * Set the line join.
   *
   * @param {CanvasLineJoin|undefined} lineJoin Line join.
   * @api
   */
  setLineJoin(e) {
    this.lineJoin_ = e;
  }
  /**
   * Set the miter limit.
   *
   * @param {number|undefined} miterLimit Miter limit.
   * @api
   */
  setMiterLimit(e) {
    this.miterLimit_ = e;
  }
  /**
   * Set the width.
   *
   * @param {number|undefined} width Width.
   * @api
   */
  setWidth(e) {
    this.width_ = e;
  }
}
const K = Ya;
class Jt {
  /**
   * @param {Options} [options] Style options.
   */
  constructor(e) {
    e = e || {}, this.geometry_ = null, this.geometryFunction_ = kl, e.geometry !== void 0 && this.setGeometry(e.geometry), this.fill_ = e.fill !== void 0 ? e.fill : null, this.image_ = e.image !== void 0 ? e.image : null, this.renderer_ = e.renderer !== void 0 ? e.renderer : null, this.hitDetectionRenderer_ = e.hitDetectionRenderer !== void 0 ? e.hitDetectionRenderer : null, this.stroke_ = e.stroke !== void 0 ? e.stroke : null, this.text_ = e.text !== void 0 ? e.text : null, this.zIndex_ = e.zIndex;
  }
  /**
   * Clones the style.
   * @return {Style} The cloned style.
   * @api
   */
  clone() {
    let e = this.getGeometry();
    return e && typeof e == "object" && (e = /** @type {import("../geom/Geometry.js").default} */
    e.clone()), new Jt({
      geometry: e,
      fill: this.getFill() ? this.getFill().clone() : void 0,
      image: this.getImage() ? this.getImage().clone() : void 0,
      renderer: this.getRenderer(),
      stroke: this.getStroke() ? this.getStroke().clone() : void 0,
      text: this.getText() ? this.getText().clone() : void 0,
      zIndex: this.getZIndex()
    });
  }
  /**
   * Get the custom renderer function that was configured with
   * {@link #setRenderer} or the `renderer` constructor option.
   * @return {RenderFunction|null} Custom renderer function.
   * @api
   */
  getRenderer() {
    return this.renderer_;
  }
  /**
   * Sets a custom renderer function for this style. When set, `fill`, `stroke`
   * and `image` options of the style will be ignored.
   * @param {RenderFunction|null} renderer Custom renderer function.
   * @api
   */
  setRenderer(e) {
    this.renderer_ = e;
  }
  /**
   * Sets a custom renderer function for this style used
   * in hit detection.
   * @param {RenderFunction|null} renderer Custom renderer function.
   * @api
   */
  setHitDetectionRenderer(e) {
    this.hitDetectionRenderer_ = e;
  }
  /**
   * Get the custom renderer function that was configured with
   * {@link #setHitDetectionRenderer} or the `hitDetectionRenderer` constructor option.
   * @return {RenderFunction|null} Custom renderer function.
   * @api
   */
  getHitDetectionRenderer() {
    return this.hitDetectionRenderer_;
  }
  /**
   * Get the geometry to be rendered.
   * @return {string|import("../geom/Geometry.js").default|GeometryFunction}
   * Feature property or geometry or function that returns the geometry that will
   * be rendered with this style.
   * @api
   */
  getGeometry() {
    return this.geometry_;
  }
  /**
   * Get the function used to generate a geometry for rendering.
   * @return {!GeometryFunction} Function that is called with a feature
   * and returns the geometry to render instead of the feature's geometry.
   * @api
   */
  getGeometryFunction() {
    return this.geometryFunction_;
  }
  /**
   * Get the fill style.
   * @return {import("./Fill.js").default} Fill style.
   * @api
   */
  getFill() {
    return this.fill_;
  }
  /**
   * Set the fill style.
   * @param {import("./Fill.js").default} fill Fill style.
   * @api
   */
  setFill(e) {
    this.fill_ = e;
  }
  /**
   * Get the image style.
   * @return {import("./Image.js").default} Image style.
   * @api
   */
  getImage() {
    return this.image_;
  }
  /**
   * Set the image style.
   * @param {import("./Image.js").default} image Image style.
   * @api
   */
  setImage(e) {
    this.image_ = e;
  }
  /**
   * Get the stroke style.
   * @return {import("./Stroke.js").default} Stroke style.
   * @api
   */
  getStroke() {
    return this.stroke_;
  }
  /**
   * Set the stroke style.
   * @param {import("./Stroke.js").default} stroke Stroke style.
   * @api
   */
  setStroke(e) {
    this.stroke_ = e;
  }
  /**
   * Get the text style.
   * @return {import("./Text.js").default} Text style.
   * @api
   */
  getText() {
    return this.text_;
  }
  /**
   * Set the text style.
   * @param {import("./Text.js").default} text Text style.
   * @api
   */
  setText(e) {
    this.text_ = e;
  }
  /**
   * Get the z-index for the style.
   * @return {number|undefined} ZIndex.
   * @api
   */
  getZIndex() {
    return this.zIndex_;
  }
  /**
   * Set a geometry that is rendered instead of the feature's geometry.
   *
   * @param {string|import("../geom/Geometry.js").default|GeometryFunction} geometry
   *     Feature property or geometry or function returning a geometry to render
   *     for this style.
   * @api
   */
  setGeometry(e) {
    typeof e == "function" ? this.geometryFunction_ = e : typeof e == "string" ? this.geometryFunction_ = function(t) {
      return (
        /** @type {import("../geom/Geometry.js").default} */
        t.get(e)
      );
    } : e ? e !== void 0 && (this.geometryFunction_ = function() {
      return (
        /** @type {import("../geom/Geometry.js").default} */
        e
      );
    }) : this.geometryFunction_ = kl, this.geometry_ = e;
  }
  /**
   * Set the z-index.
   *
   * @param {number|undefined} zIndex ZIndex.
   * @api
   */
  setZIndex(e) {
    this.zIndex_ = e;
  }
}
function Dg(s) {
  let e;
  if (typeof s == "function")
    e = s;
  else {
    let t;
    Array.isArray(s) ? t = s : (Z(typeof /** @type {?} */
    s.getZIndex == "function", 41), t = [
      /** @type {Style} */
      s
    ]), e = function() {
      return t;
    };
  }
  return e;
}
let to = null;
function kg(s, e) {
  if (!to) {
    const t = new N({
      color: "rgba(255,255,255,0.4)"
    }), i = new K({
      color: "#3399CC",
      width: 1.25
    });
    to = [
      new Jt({
        image: new qi({
          fill: t,
          stroke: i,
          radius: 5
        }),
        fill: t,
        stroke: i
      })
    ];
  }
  return to;
}
function Va() {
  const s = {}, e = [255, 255, 255, 1], t = [0, 153, 255, 1], i = 3;
  return s.Polygon = [
    new Jt({
      fill: new N({
        color: [255, 255, 255, 0.5]
      })
    })
  ], s.MultiPolygon = s.Polygon, s.LineString = [
    new Jt({
      stroke: new K({
        color: e,
        width: i + 2
      })
    }),
    new Jt({
      stroke: new K({
        color: t,
        width: i
      })
    })
  ], s.MultiLineString = s.LineString, s.Circle = s.Polygon.concat(s.LineString), s.Point = [
    new Jt({
      image: new qi({
        radius: i * 2,
        fill: new N({
          color: t
        }),
        stroke: new K({
          color: e,
          width: i / 2
        })
      }),
      zIndex: 1 / 0
    })
  ], s.MultiPoint = s.Point, s.GeometryCollection = s.Polygon.concat(
    s.LineString,
    s.Point
  ), s;
}
function kl(s) {
  return s.getGeometry();
}
const se = Jt;
class Ng extends es {
  /**
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {number|undefined} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("./ImageState.js").default} state State.
   */
  constructor(e, t, i, n) {
    super(), this.extent = e, this.pixelRatio_ = i, this.resolution = t, this.state = n;
  }
  /**
   * @protected
   */
  changed() {
    this.dispatchEvent(z.CHANGE);
  }
  /**
   * @return {import("./extent.js").Extent} Extent.
   */
  getExtent() {
    return this.extent;
  }
  /**
   * @abstract
   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
   */
  getImage() {
    return X();
  }
  /**
   * @return {number} PixelRatio.
   */
  getPixelRatio() {
    return this.pixelRatio_;
  }
  /**
   * @return {number} Resolution.
   */
  getResolution() {
    return (
      /** @type {number} */
      this.resolution
    );
  }
  /**
   * @return {import("./ImageState.js").default} State.
   */
  getState() {
    return this.state;
  }
  /**
   * Load not yet loaded URI.
   * @abstract
   */
  load() {
    X();
  }
}
const Za = Ng;
class Gg extends Za {
  /**
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {number|undefined} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {string} src Image source URI.
   * @param {?string} crossOrigin Cross origin.
   * @param {LoadFunction} imageLoadFunction Image load function.
   * @param {CanvasRenderingContext2D} [context] Canvas context. When provided, the image will be
   *    drawn into the context's canvas, and `getImage()` will return the canvas once the image
   *    has finished loading.
   */
  constructor(e, t, i, n, r, o, a) {
    super(e, t, i, k.IDLE), this.src_ = n, this.image_ = new Image(), r !== null && (this.image_.crossOrigin = r), this.context_ = a, this.unlisten_ = null, this.state = k.IDLE, this.imageLoadFunction_ = o;
  }
  /**
   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
   * @api
   */
  getImage() {
    if (this.state == k.LOADED && this.context_ && !(this.image_ instanceof HTMLCanvasElement)) {
      const e = this.context_.canvas;
      e.width = this.image_.width, e.height = this.image_.height, this.context_.drawImage(this.image_, 0, 0), this.image_ = this.context_.canvas;
    }
    return this.image_;
  }
  /**
   * Tracks loading or read errors.
   *
   * @private
   */
  handleImageError_() {
    this.state = k.ERROR, this.unlistenImage_(), this.changed();
  }
  /**
   * Tracks successful image load.
   *
   * @private
   */
  handleImageLoad_() {
    this.resolution === void 0 && (this.resolution = Fe(this.extent) / this.image_.height), this.state = k.LOADED, this.unlistenImage_(), this.changed();
  }
  /**
   * Load the image or retry if loading previously failed.
   * Loading is taken care of by the tile queue, and calling this method is
   * only needed for preloading or for reloading in case of an error.
   * @api
   */
  load() {
    (this.state == k.IDLE || this.state == k.ERROR) && (this.state = k.LOADING, this.changed(), this.imageLoadFunction_(this, this.src_), this.unlisten_ = ja(
      this.image_,
      this.handleImageLoad_.bind(this),
      this.handleImageError_.bind(this)
    ));
  }
  /**
   * @param {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} image Image.
   */
  setImage(e) {
    this.image_ = e, this.resolution = Fe(this.extent) / this.image_.height;
  }
  /**
   * Discards event handlers which listen for load completion or errors.
   *
   * @private
   */
  unlistenImage_() {
    this.unlisten_ && (this.unlisten_(), this.unlisten_ = null);
  }
}
function ja(s, e, t) {
  const i = (
    /** @type {HTMLImageElement} */
    s
  );
  let n = !0, r = !1, o = !1;
  const a = [
    kn(i, z.LOAD, function() {
      o = !0, r || e();
    })
  ];
  return i.src && Qu ? (r = !0, i.decode().then(function() {
    n && e();
  }).catch(function(l) {
    n && (o ? e() : t());
  })) : a.push(kn(i, z.ERROR, t)), function() {
    n = !1, a.forEach(re);
  };
}
const Ug = Gg;
let vn = null;
class zg extends es {
  /**
   * @param {HTMLImageElement|HTMLCanvasElement} image Image.
   * @param {string|undefined} src Src.
   * @param {import("../size.js").Size} size Size.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../ImageState.js").default} imageState Image state.
   * @param {import("../color.js").Color} color Color.
   */
  constructor(e, t, i, n, r, o) {
    super(), this.hitDetectionImage_ = null, this.image_ = e, this.crossOrigin_ = n, this.canvas_ = {}, this.color_ = o, this.unlisten_ = null, this.imageState_ = r, this.size_ = i, this.src_ = t, this.tainted_;
  }
  /**
   * @private
   */
  initializeImage_() {
    this.image_ = new Image(), this.crossOrigin_ !== null && (this.image_.crossOrigin = this.crossOrigin_);
  }
  /**
   * @private
   * @return {boolean} The image canvas is tainted.
   */
  isTainted_() {
    if (this.tainted_ === void 0 && this.imageState_ === k.LOADED) {
      vn || (vn = Re(1, 1, void 0, {
        willReadFrequently: !0
      })), vn.drawImage(this.image_, 0, 0);
      try {
        vn.getImageData(0, 0, 1, 1), this.tainted_ = !1;
      } catch {
        vn = null, this.tainted_ = !0;
      }
    }
    return this.tainted_ === !0;
  }
  /**
   * @private
   */
  dispatchChangeEvent_() {
    this.dispatchEvent(z.CHANGE);
  }
  /**
   * @private
   */
  handleImageError_() {
    this.imageState_ = k.ERROR, this.unlistenImage_(), this.dispatchChangeEvent_();
  }
  /**
   * @private
   */
  handleImageLoad_() {
    this.imageState_ = k.LOADED, this.size_ ? (this.image_.width = this.size_[0], this.image_.height = this.size_[1]) : this.size_ = [this.image_.width, this.image_.height], this.unlistenImage_(), this.dispatchChangeEvent_();
  }
  /**
   * @param {number} pixelRatio Pixel ratio.
   * @return {HTMLImageElement|HTMLCanvasElement} Image or Canvas element.
   */
  getImage(e) {
    return this.image_ || this.initializeImage_(), this.replaceColor_(e), this.canvas_[e] ? this.canvas_[e] : this.image_;
  }
  /**
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Image or Canvas element.
   */
  getPixelRatio(e) {
    return this.replaceColor_(e), this.canvas_[e] ? e : 1;
  }
  /**
   * @return {import("../ImageState.js").default} Image state.
   */
  getImageState() {
    return this.imageState_;
  }
  /**
   * @return {HTMLImageElement|HTMLCanvasElement} Image element.
   */
  getHitDetectionImage() {
    if (this.image_ || this.initializeImage_(), !this.hitDetectionImage_)
      if (this.isTainted_()) {
        const e = this.size_[0], t = this.size_[1], i = Re(e, t);
        i.fillRect(0, 0, e, t), this.hitDetectionImage_ = i.canvas;
      } else
        this.hitDetectionImage_ = this.image_;
    return this.hitDetectionImage_;
  }
  /**
   * Get the size of the icon (in pixels).
   * @return {import("../size.js").Size} Image size.
   */
  getSize() {
    return this.size_;
  }
  /**
   * @return {string|undefined} Image src.
   */
  getSrc() {
    return this.src_;
  }
  /**
   * Load not yet loaded URI.
   */
  load() {
    if (this.imageState_ === k.IDLE) {
      this.image_ || this.initializeImage_(), this.imageState_ = k.LOADING;
      try {
        this.image_.src = this.src_;
      } catch {
        this.handleImageError_();
      }
      this.unlisten_ = ja(
        this.image_,
        this.handleImageLoad_.bind(this),
        this.handleImageError_.bind(this)
      );
    }
  }
  /**
   * @param {number} pixelRatio Pixel ratio.
   * @private
   */
  replaceColor_(e) {
    if (!this.color_ || this.canvas_[e] || this.imageState_ !== k.LOADED)
      return;
    const t = this.image_, i = document.createElement("canvas");
    i.width = Math.ceil(t.width * e), i.height = Math.ceil(t.height * e);
    const n = i.getContext("2d");
    n.scale(e, e), n.drawImage(t, 0, 0), n.globalCompositeOperation = "multiply", n.fillStyle = kh(this.color_), n.fillRect(0, 0, i.width / e, i.height / e), n.globalCompositeOperation = "destination-in", n.drawImage(t, 0, 0), this.canvas_[e] = i;
  }
  /**
   * Discards event handlers which listen for load completion or errors.
   *
   * @private
   */
  unlistenImage_() {
    this.unlisten_ && (this.unlisten_(), this.unlisten_ = null);
  }
}
function Bg(s, e, t, i, n, r) {
  let o = Qs.get(e, i, r);
  return o || (o = new zg(s, e, t, i, n, r), Qs.set(e, i, r, o)), o;
}
class Ha extends Sc {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {};
    const t = e.opacity !== void 0 ? e.opacity : 1, i = e.rotation !== void 0 ? e.rotation : 0, n = e.scale !== void 0 ? e.scale : 1, r = e.rotateWithView !== void 0 ? e.rotateWithView : !1;
    super({
      opacity: t,
      rotation: i,
      scale: n,
      displacement: e.displacement !== void 0 ? e.displacement : [0, 0],
      rotateWithView: r,
      declutterMode: e.declutterMode
    }), this.anchor_ = e.anchor !== void 0 ? e.anchor : [0.5, 0.5], this.normalizedAnchor_ = null, this.anchorOrigin_ = e.anchorOrigin !== void 0 ? e.anchorOrigin : "top-left", this.anchorXUnits_ = e.anchorXUnits !== void 0 ? e.anchorXUnits : "fraction", this.anchorYUnits_ = e.anchorYUnits !== void 0 ? e.anchorYUnits : "fraction", this.crossOrigin_ = e.crossOrigin !== void 0 ? e.crossOrigin : null;
    const o = e.img !== void 0 ? e.img : null;
    this.imgSize_ = e.imgSize;
    let a = e.src;
    Z(!(a !== void 0 && o), 4), Z(!o || o && this.imgSize_, 5), (a === void 0 || a.length === 0) && o && (a = /** @type {HTMLImageElement} */
    o.src || B(o)), Z(a !== void 0 && a.length > 0, 6), Z(
      !((e.width !== void 0 || e.height !== void 0) && e.scale !== void 0),
      69
    );
    const l = e.src !== void 0 ? k.IDLE : k.LOADED;
    if (this.color_ = e.color !== void 0 ? Gn(e.color) : null, this.iconImage_ = Bg(
      o,
      /** @type {string} */
      a,
      this.imgSize_ !== void 0 ? this.imgSize_ : null,
      this.crossOrigin_,
      l,
      this.color_
    ), this.offset_ = e.offset !== void 0 ? e.offset : [0, 0], this.offsetOrigin_ = e.offsetOrigin !== void 0 ? e.offsetOrigin : "top-left", this.origin_ = null, this.size_ = e.size !== void 0 ? e.size : null, this.width_ = e.width, this.height_ = e.height, this.width_ !== void 0 || this.height_ !== void 0) {
      const h = this.getImage(1), c = () => {
        this.updateScaleFromWidthAndHeight(this.width_, this.height_);
      };
      h.width > 0 ? this.updateScaleFromWidthAndHeight(this.width_, this.height_) : h.addEventListener("load", c);
    }
  }
  /**
   * Clones the style. The underlying Image/HTMLCanvasElement is not cloned.
   * @return {Icon} The cloned style.
   * @api
   */
  clone() {
    let e = this.getScale();
    return e = Array.isArray(e) ? e.slice() : e, (this.width_ !== void 0 || this.height_ !== void 0) && (e = void 0), new Ha({
      anchor: this.anchor_.slice(),
      anchorOrigin: this.anchorOrigin_,
      anchorXUnits: this.anchorXUnits_,
      anchorYUnits: this.anchorYUnits_,
      color: this.color_ && this.color_.slice ? this.color_.slice() : this.color_ || void 0,
      crossOrigin: this.crossOrigin_,
      imgSize: this.imgSize_,
      offset: this.offset_.slice(),
      offsetOrigin: this.offsetOrigin_,
      opacity: this.getOpacity(),
      rotateWithView: this.getRotateWithView(),
      rotation: this.getRotation(),
      scale: e,
      size: this.size_ !== null ? this.size_.slice() : void 0,
      src: this.getSrc(),
      displacement: this.getDisplacement().slice(),
      declutterMode: this.getDeclutterMode(),
      width: this.width_,
      height: this.height_
    });
  }
  /**
   * Set the scale of the Icon by calculating it from given width and height and the
   * width and height of the image.
   *
   * @private
   * @param {number} width The width.
   * @param {number} height The height.
   */
  updateScaleFromWidthAndHeight(e, t) {
    const i = this.getImage(1);
    e !== void 0 && t !== void 0 ? super.setScale([e / i.width, t / i.height]) : e !== void 0 ? super.setScale([e / i.width, e / i.width]) : t !== void 0 ? super.setScale([t / i.height, t / i.height]) : super.setScale([1, 1]);
  }
  /**
   * Get the anchor point in pixels. The anchor determines the center point for the
   * symbolizer.
   * @return {Array<number>} Anchor.
   * @api
   */
  getAnchor() {
    let e = this.normalizedAnchor_;
    if (!e) {
      e = this.anchor_;
      const n = this.getSize();
      if (this.anchorXUnits_ == "fraction" || this.anchorYUnits_ == "fraction") {
        if (!n)
          return null;
        e = this.anchor_.slice(), this.anchorXUnits_ == "fraction" && (e[0] *= n[0]), this.anchorYUnits_ == "fraction" && (e[1] *= n[1]);
      }
      if (this.anchorOrigin_ != "top-left") {
        if (!n)
          return null;
        e === this.anchor_ && (e = this.anchor_.slice()), (this.anchorOrigin_ == "top-right" || this.anchorOrigin_ == "bottom-right") && (e[0] = -e[0] + n[0]), (this.anchorOrigin_ == "bottom-left" || this.anchorOrigin_ == "bottom-right") && (e[1] = -e[1] + n[1]);
      }
      this.normalizedAnchor_ = e;
    }
    const t = this.getDisplacement(), i = this.getScaleArray();
    return [
      e[0] - t[0] / i[0],
      e[1] + t[1] / i[1]
    ];
  }
  /**
   * Set the anchor point. The anchor determines the center point for the
   * symbolizer.
   *
   * @param {Array<number>} anchor Anchor.
   * @api
   */
  setAnchor(e) {
    this.anchor_ = e, this.normalizedAnchor_ = null;
  }
  /**
   * Get the icon color.
   * @return {import("../color.js").Color} Color.
   * @api
   */
  getColor() {
    return this.color_;
  }
  /**
   * Get the image icon.
   * @param {number} pixelRatio Pixel ratio.
   * @return {HTMLImageElement|HTMLCanvasElement} Image or Canvas element.
   * @api
   */
  getImage(e) {
    return this.iconImage_.getImage(e);
  }
  /**
   * Get the pixel ratio.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} The pixel ratio of the image.
   * @api
   */
  getPixelRatio(e) {
    return this.iconImage_.getPixelRatio(e);
  }
  /**
   * @return {import("../size.js").Size} Image size.
   */
  getImageSize() {
    return this.iconImage_.getSize();
  }
  /**
   * @return {import("../ImageState.js").default} Image state.
   */
  getImageState() {
    return this.iconImage_.getImageState();
  }
  /**
   * @return {HTMLImageElement|HTMLCanvasElement} Image element.
   */
  getHitDetectionImage() {
    return this.iconImage_.getHitDetectionImage();
  }
  /**
   * Get the origin of the symbolizer.
   * @return {Array<number>} Origin.
   * @api
   */
  getOrigin() {
    if (this.origin_)
      return this.origin_;
    let e = this.offset_;
    if (this.offsetOrigin_ != "top-left") {
      const t = this.getSize(), i = this.iconImage_.getSize();
      if (!t || !i)
        return null;
      e = e.slice(), (this.offsetOrigin_ == "top-right" || this.offsetOrigin_ == "bottom-right") && (e[0] = i[0] - t[0] - e[0]), (this.offsetOrigin_ == "bottom-left" || this.offsetOrigin_ == "bottom-right") && (e[1] = i[1] - t[1] - e[1]);
    }
    return this.origin_ = e, this.origin_;
  }
  /**
   * Get the image URL.
   * @return {string|undefined} Image src.
   * @api
   */
  getSrc() {
    return this.iconImage_.getSrc();
  }
  /**
   * Get the size of the icon (in pixels).
   * @return {import("../size.js").Size} Image size.
   * @api
   */
  getSize() {
    return this.size_ ? this.size_ : this.iconImage_.getSize();
  }
  /**
   * Get the width of the icon (in pixels).
   * @return {number} Icon width (in pixels).
   * @api
   */
  getWidth() {
    return this.width_;
  }
  /**
   * Get the height of the icon (in pixels).
   * @return {number} Icon height (in pixels).
   * @api
   */
  getHeight() {
    return this.height_;
  }
  /**
   * Set the width of the icon in pixels.
   *
   * @param {number} width The width to set.
   */
  setWidth(e) {
    this.width_ = e, this.updateScaleFromWidthAndHeight(e, this.height_);
  }
  /**
   * Set the height of the icon in pixels.
   *
   * @param {number} height The height to set.
   */
  setHeight(e) {
    this.height_ = e, this.updateScaleFromWidthAndHeight(this.width_, e);
  }
  /**
   * Set the scale and updates the width and height correspondingly.
   *
   * @param {number|import("../size.js").Size} scale Scale.
   * @override
   * @api
   */
  setScale(e) {
    super.setScale(e);
    const t = this.getImage(1);
    if (t) {
      const i = Array.isArray(e) ? e[0] : e;
      i !== void 0 && (this.width_ = i * t.width);
      const n = Array.isArray(e) ? e[1] : e;
      n !== void 0 && (this.height_ = n * t.height);
    }
  }
  /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */
  listenImageChange(e) {
    this.iconImage_.addEventListener(z.CHANGE, e);
  }
  /**
   * Load not yet loaded URI.
   * When rendering a feature with an icon style, the vector renderer will
   * automatically call this method. However, you might want to call this
   * method yourself for preloading or other purposes.
   * @api
   */
  load() {
    this.iconImage_.load();
  }
  /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */
  unlistenImageChange(e) {
    this.iconImage_.removeEventListener(z.CHANGE, e);
  }
}
const tt = Ha, Xg = "#333";
class Ka {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {}, this.font_ = e.font, this.rotation_ = e.rotation, this.rotateWithView_ = e.rotateWithView, this.scale_ = e.scale, this.scaleArray_ = Ke(e.scale !== void 0 ? e.scale : 1), this.text_ = e.text, this.textAlign_ = e.textAlign, this.justify_ = e.justify, this.repeat_ = e.repeat, this.textBaseline_ = e.textBaseline, this.fill_ = e.fill !== void 0 ? e.fill : new N({ color: Xg }), this.maxAngle_ = e.maxAngle !== void 0 ? e.maxAngle : Math.PI / 4, this.placement_ = e.placement !== void 0 ? e.placement : "point", this.overflow_ = !!e.overflow, this.stroke_ = e.stroke !== void 0 ? e.stroke : null, this.offsetX_ = e.offsetX !== void 0 ? e.offsetX : 0, this.offsetY_ = e.offsetY !== void 0 ? e.offsetY : 0, this.backgroundFill_ = e.backgroundFill ? e.backgroundFill : null, this.backgroundStroke_ = e.backgroundStroke ? e.backgroundStroke : null, this.padding_ = e.padding === void 0 ? null : e.padding;
  }
  /**
   * Clones the style.
   * @return {Text} The cloned style.
   * @api
   */
  clone() {
    const e = this.getScale();
    return new Ka({
      font: this.getFont(),
      placement: this.getPlacement(),
      repeat: this.getRepeat(),
      maxAngle: this.getMaxAngle(),
      overflow: this.getOverflow(),
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      scale: Array.isArray(e) ? e.slice() : e,
      text: this.getText(),
      textAlign: this.getTextAlign(),
      justify: this.getJustify(),
      textBaseline: this.getTextBaseline(),
      fill: this.getFill() ? this.getFill().clone() : void 0,
      stroke: this.getStroke() ? this.getStroke().clone() : void 0,
      offsetX: this.getOffsetX(),
      offsetY: this.getOffsetY(),
      backgroundFill: this.getBackgroundFill() ? this.getBackgroundFill().clone() : void 0,
      backgroundStroke: this.getBackgroundStroke() ? this.getBackgroundStroke().clone() : void 0,
      padding: this.getPadding() || void 0
    });
  }
  /**
   * Get the `overflow` configuration.
   * @return {boolean} Let text overflow the length of the path they follow.
   * @api
   */
  getOverflow() {
    return this.overflow_;
  }
  /**
   * Get the font name.
   * @return {string|undefined} Font.
   * @api
   */
  getFont() {
    return this.font_;
  }
  /**
   * Get the maximum angle between adjacent characters.
   * @return {number} Angle in radians.
   * @api
   */
  getMaxAngle() {
    return this.maxAngle_;
  }
  /**
   * Get the label placement.
   * @return {TextPlacement} Text placement.
   * @api
   */
  getPlacement() {
    return this.placement_;
  }
  /**
   * Get the repeat interval of the text.
   * @return {number|undefined} Repeat interval in pixels.
   * @api
   */
  getRepeat() {
    return this.repeat_;
  }
  /**
   * Get the x-offset for the text.
   * @return {number} Horizontal text offset.
   * @api
   */
  getOffsetX() {
    return this.offsetX_;
  }
  /**
   * Get the y-offset for the text.
   * @return {number} Vertical text offset.
   * @api
   */
  getOffsetY() {
    return this.offsetY_;
  }
  /**
   * Get the fill style for the text.
   * @return {import("./Fill.js").default} Fill style.
   * @api
   */
  getFill() {
    return this.fill_;
  }
  /**
   * Determine whether the text rotates with the map.
   * @return {boolean|undefined} Rotate with map.
   * @api
   */
  getRotateWithView() {
    return this.rotateWithView_;
  }
  /**
   * Get the text rotation.
   * @return {number|undefined} Rotation.
   * @api
   */
  getRotation() {
    return this.rotation_;
  }
  /**
   * Get the text scale.
   * @return {number|import("../size.js").Size|undefined} Scale.
   * @api
   */
  getScale() {
    return this.scale_;
  }
  /**
   * Get the symbolizer scale array.
   * @return {import("../size.js").Size} Scale array.
   */
  getScaleArray() {
    return this.scaleArray_;
  }
  /**
   * Get the stroke style for the text.
   * @return {import("./Stroke.js").default} Stroke style.
   * @api
   */
  getStroke() {
    return this.stroke_;
  }
  /**
   * Get the text to be rendered.
   * @return {string|Array<string>|undefined} Text.
   * @api
   */
  getText() {
    return this.text_;
  }
  /**
   * Get the text alignment.
   * @return {CanvasTextAlign|undefined} Text align.
   * @api
   */
  getTextAlign() {
    return this.textAlign_;
  }
  /**
   * Get the justification.
   * @return {TextJustify|undefined} Justification.
   * @api
   */
  getJustify() {
    return this.justify_;
  }
  /**
   * Get the text baseline.
   * @return {CanvasTextBaseline|undefined} Text baseline.
   * @api
   */
  getTextBaseline() {
    return this.textBaseline_;
  }
  /**
   * Get the background fill style for the text.
   * @return {import("./Fill.js").default} Fill style.
   * @api
   */
  getBackgroundFill() {
    return this.backgroundFill_;
  }
  /**
   * Get the background stroke style for the text.
   * @return {import("./Stroke.js").default} Stroke style.
   * @api
   */
  getBackgroundStroke() {
    return this.backgroundStroke_;
  }
  /**
   * Get the padding for the text.
   * @return {Array<number>|null} Padding.
   * @api
   */
  getPadding() {
    return this.padding_;
  }
  /**
   * Set the `overflow` property.
   *
   * @param {boolean} overflow Let text overflow the path that it follows.
   * @api
   */
  setOverflow(e) {
    this.overflow_ = e;
  }
  /**
   * Set the font.
   *
   * @param {string|undefined} font Font.
   * @api
   */
  setFont(e) {
    this.font_ = e;
  }
  /**
   * Set the maximum angle between adjacent characters.
   *
   * @param {number} maxAngle Angle in radians.
   * @api
   */
  setMaxAngle(e) {
    this.maxAngle_ = e;
  }
  /**
   * Set the x offset.
   *
   * @param {number} offsetX Horizontal text offset.
   * @api
   */
  setOffsetX(e) {
    this.offsetX_ = e;
  }
  /**
   * Set the y offset.
   *
   * @param {number} offsetY Vertical text offset.
   * @api
   */
  setOffsetY(e) {
    this.offsetY_ = e;
  }
  /**
   * Set the text placement.
   *
   * @param {TextPlacement} placement Placement.
   * @api
   */
  setPlacement(e) {
    this.placement_ = e;
  }
  /**
   * Set the repeat interval of the text.
   * @param {number|undefined} [repeat] Repeat interval in pixels.
   * @api
   */
  setRepeat(e) {
    this.repeat_ = e;
  }
  /**
   * Set whether to rotate the text with the view.
   *
   * @param {boolean} rotateWithView Rotate with map.
   * @api
   */
  setRotateWithView(e) {
    this.rotateWithView_ = e;
  }
  /**
   * Set the fill.
   *
   * @param {import("./Fill.js").default} fill Fill style.
   * @api
   */
  setFill(e) {
    this.fill_ = e;
  }
  /**
   * Set the rotation.
   *
   * @param {number|undefined} rotation Rotation.
   * @api
   */
  setRotation(e) {
    this.rotation_ = e;
  }
  /**
   * Set the scale.
   *
   * @param {number|import("../size.js").Size|undefined} scale Scale.
   * @api
   */
  setScale(e) {
    this.scale_ = e, this.scaleArray_ = Ke(e !== void 0 ? e : 1);
  }
  /**
   * Set the stroke.
   *
   * @param {import("./Stroke.js").default} stroke Stroke style.
   * @api
   */
  setStroke(e) {
    this.stroke_ = e;
  }
  /**
   * Set the text.
   *
   * @param {string|Array<string>|undefined} text Text.
   * @api
   */
  setText(e) {
    this.text_ = e;
  }
  /**
   * Set the text alignment.
   *
   * @param {CanvasTextAlign|undefined} textAlign Text align.
   * @api
   */
  setTextAlign(e) {
    this.textAlign_ = e;
  }
  /**
   * Set the justification.
   *
   * @param {TextJustify|undefined} justify Justification.
   * @api
   */
  setJustify(e) {
    this.justify_ = e;
  }
  /**
   * Set the text baseline.
   *
   * @param {CanvasTextBaseline|undefined} textBaseline Text baseline.
   * @api
   */
  setTextBaseline(e) {
    this.textBaseline_ = e;
  }
  /**
   * Set the background fill.
   *
   * @param {import("./Fill.js").default} fill Fill style.
   * @api
   */
  setBackgroundFill(e) {
    this.backgroundFill_ = e;
  }
  /**
   * Set the background stroke.
   *
   * @param {import("./Stroke.js").default} stroke Stroke style.
   * @api
   */
  setBackgroundStroke(e) {
    this.backgroundStroke_ = e;
  }
  /**
   * Set the padding (`[top, right, bottom, left]`).
   *
   * @param {Array<number>|null} padding Padding.
   * @api
   */
  setPadding(e) {
    this.padding_ = e;
  }
}
const De = Ka;
function Nl(s) {
  return new se({
    fill: Kn(s, ""),
    stroke: qn(s, ""),
    text: Wg(s),
    image: Yg(s)
  });
}
function Kn(s, e) {
  const t = s[e + "fill-color"];
  if (t)
    return new N({ color: t });
}
function qn(s, e) {
  const t = s[e + "stroke-width"], i = s[e + "stroke-color"];
  if (!(!t && !i))
    return new K({
      width: t,
      color: i,
      lineCap: s[e + "stroke-line-cap"],
      lineJoin: s[e + "stroke-line-join"],
      lineDash: s[e + "stroke-line-dash"],
      lineDashOffset: s[e + "stroke-line-dash-offset"],
      miterLimit: s[e + "stroke-miter-limit"]
    });
}
function Wg(s) {
  const e = s["text-value"];
  return e ? new De({
    text: e,
    font: s["text-font"],
    maxAngle: s["text-max-angle"],
    offsetX: s["text-offset-x"],
    offsetY: s["text-offset-y"],
    overflow: s["text-overflow"],
    placement: s["text-placement"],
    repeat: s["text-repeat"],
    scale: s["text-scale"],
    rotateWithView: s["text-rotate-with-view"],
    rotation: s["text-rotation"],
    textAlign: s["text-align"],
    justify: s["text-justify"],
    textBaseline: s["text-baseline"],
    padding: s["text-padding"],
    fill: Kn(s, "text-"),
    backgroundFill: Kn(s, "text-background-"),
    stroke: qn(s, "text-"),
    backgroundStroke: qn(s, "text-background-")
  }) : void 0;
}
function Yg(s) {
  const e = s["icon-src"], t = s["icon-img"];
  if (e || t)
    return new tt({
      src: e,
      img: t,
      imgSize: s["icon-img-size"],
      anchor: s["icon-anchor"],
      anchorOrigin: s["icon-anchor-origin"],
      anchorXUnits: s["icon-anchor-x-units"],
      anchorYUnits: s["icon-anchor-y-units"],
      color: s["icon-color"],
      crossOrigin: s["icon-cross-origin"],
      offset: s["icon-offset"],
      displacement: s["icon-displacement"],
      opacity: s["icon-opacity"],
      scale: s["icon-scale"],
      rotation: s["icon-rotation"],
      rotateWithView: s["icon-rotate-with-view"],
      size: s["icon-size"],
      declutterMode: s["icon-declutter-mode"]
    });
  const i = s["shape-points"];
  if (i) {
    const r = "shape-";
    return new Fn({
      points: i,
      fill: Kn(s, r),
      stroke: qn(s, r),
      radius: s["shape-radius"],
      radius1: s["shape-radius1"],
      radius2: s["shape-radius2"],
      angle: s["shape-angle"],
      displacement: s["shape-displacement"],
      rotation: s["shape-rotation"],
      rotateWithView: s["shape-rotate-with-view"],
      scale: s["shape-scale"],
      declutterMode: s["shape-declutter-mode"]
    });
  }
  const n = s["circle-radius"];
  if (n) {
    const r = "circle-";
    return new qi({
      radius: n,
      fill: Kn(s, r),
      stroke: qn(s, r),
      displacement: s["circle-displacement"],
      scale: s["circle-scale"],
      rotation: s["circle-rotation"],
      rotateWithView: s["circle-rotate-with-view"],
      declutterMode: s["circle-declutter-mode"]
    });
  }
}
const Gl = {
  RENDER_ORDER: "renderOrder"
};
class Vg extends hs {
  /**
   * @param {Options<VectorSourceType>} [options] Options.
   */
  constructor(e) {
    e = e || {};
    const t = Object.assign({}, e);
    delete t.style, delete t.renderBuffer, delete t.updateWhileAnimating, delete t.updateWhileInteracting, super(t), this.declutter_ = e.declutter !== void 0 ? e.declutter : !1, this.renderBuffer_ = e.renderBuffer !== void 0 ? e.renderBuffer : 100, this.style_ = null, this.styleFunction_ = void 0, this.setStyle(e.style), this.updateWhileAnimating_ = e.updateWhileAnimating !== void 0 ? e.updateWhileAnimating : !1, this.updateWhileInteracting_ = e.updateWhileInteracting !== void 0 ? e.updateWhileInteracting : !1;
  }
  /**
   * @return {boolean} Declutter.
   */
  getDeclutter() {
    return this.declutter_;
  }
  /**
   * Get the topmost feature that intersects the given pixel on the viewport. Returns a promise
   * that resolves with an array of features. The array will either contain the topmost feature
   * when a hit was detected, or it will be empty.
   *
   * The hit detection algorithm used for this method is optimized for performance, but is less
   * accurate than the one used in [map.getFeaturesAtPixel()]{@link import("../Map.js").default#getFeaturesAtPixel}.
   * Text is not considered, and icons are only represented by their bounding box instead of the exact
   * image.
   *
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with an array of features.
   * @api
   */
  getFeatures(e) {
    return super.getFeatures(e);
  }
  /**
   * @return {number|undefined} Render buffer.
   */
  getRenderBuffer() {
    return this.renderBuffer_;
  }
  /**
   * @return {function(import("../Feature.js").default, import("../Feature.js").default): number|null|undefined} Render
   *     order.
   */
  getRenderOrder() {
    return (
      /** @type {import("../render.js").OrderFunction|null|undefined} */
      this.get(Gl.RENDER_ORDER)
    );
  }
  /**
   * Get the style for features.  This returns whatever was passed to the `style`
   * option at construction or to the `setStyle` method.
   * @return {import("../style/Style.js").StyleLike|null|undefined} Layer style.
   * @api
   */
  getStyle() {
    return this.style_;
  }
  /**
   * Get the style function.
   * @return {import("../style/Style.js").StyleFunction|undefined} Layer style function.
   * @api
   */
  getStyleFunction() {
    return this.styleFunction_;
  }
  /**
   * @return {boolean} Whether the rendered layer should be updated while
   *     animating.
   */
  getUpdateWhileAnimating() {
    return this.updateWhileAnimating_;
  }
  /**
   * @return {boolean} Whether the rendered layer should be updated while
   *     interacting.
   */
  getUpdateWhileInteracting() {
    return this.updateWhileInteracting_;
  }
  /**
   * Render declutter items for this layer
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */
  renderDeclutter(e) {
    e.declutterTree || (e.declutterTree = new Ua(9)), this.getRenderer().renderDeclutter(e);
  }
  /**
   * @param {import("../render.js").OrderFunction|null|undefined} renderOrder
   *     Render order.
   */
  setRenderOrder(e) {
    this.set(Gl.RENDER_ORDER, e);
  }
  /**
   * Set the style for features.  This can be a single style object, an array
   * of styles, or a function that takes a feature and resolution and returns
   * an array of styles. If set to `null`, the layer has no style (a `null` style),
   * so only features that have their own styles will be rendered in the layer. Call
   * `setStyle()` without arguments to reset to the default style. See
   * [the ol/style/Style module]{@link module:ol/style/Style~Style} for information on the default style.
   *
   * If your layer has a static style, you can use "flat" style object literals instead of
   * using the `Style` and symbolizer constructors (`Fill`, `Stroke`, etc.).  See the documentation
   * for the [flat style types]{@link module:ol/style/flat~FlatStyle} to see what properties are supported.
   *
   * @param {import("../style/Style.js").StyleLike|import("../style/flat.js").FlatStyleLike|null} [style] Layer style.
   * @api
   */
  setStyle(e) {
    let t;
    if (e === void 0)
      t = kg;
    else if (e === null)
      t = null;
    else if (typeof e == "function")
      t = e;
    else if (e instanceof se)
      t = e;
    else if (Array.isArray(e)) {
      const i = e.length, n = new Array(i);
      for (let r = 0; r < i; ++r) {
        const o = e[r];
        o instanceof se ? n[r] = o : n[r] = Nl(o);
      }
      t = n;
    } else
      t = Nl(e);
    this.style_ = t, this.styleFunction_ = e === null ? void 0 : Dg(this.style_), this.changed();
  }
}
const br = Vg;
class Zg extends ts {
  /**
   * @param {LayerType} layer Layer.
   */
  constructor(e) {
    super(), this.ready = !0, this.boundHandleImageChange_ = this.handleImageChange_.bind(this), this.layer_ = e, this.declutterExecutorGroup = null;
  }
  /**
   * Asynchronous layer level hit detection.
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with
   * an array of features.
   */
  getFeatures(e) {
    return X();
  }
  /**
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
   */
  getData(e) {
    return null;
  }
  /**
   * Determine whether render should be called.
   * @abstract
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */
  prepareFrame(e) {
    return X();
  }
  /**
   * Render the layer.
   * @abstract
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target that may be used to render content to.
   * @return {HTMLElement} The rendered element.
   */
  renderFrame(e, t) {
    return X();
  }
  /**
   * @param {Object<number, Object<string, import("../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.
   * @param {number} zoom Zoom level.
   * @param {import("../Tile.js").default} tile Tile.
   * @return {boolean|void} If `false`, the tile will not be considered loaded.
   */
  loadedTileCallback(e, t, i) {
    e[t] || (e[t] = {}), e[t][i.tileCoord.toString()] = i;
  }
  /**
   * Create a function that adds loaded tiles to the tile lookup.
   * @param {import("../source/Tile.js").default} source Tile source.
   * @param {import("../proj/Projection.js").default} projection Projection of the tiles.
   * @param {Object<number, Object<string, import("../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.
   * @return {function(number, import("../TileRange.js").default):boolean} A function that can be
   *     called with a zoom level and a tile range to add loaded tiles to the lookup.
   * @protected
   */
  createLoadedTileFinder(e, t, i) {
    return (
      /**
       * @param {number} zoom Zoom level.
       * @param {import("../TileRange.js").default} tileRange Tile range.
       * @return {boolean} The tile range is fully loaded.
       */
      (n, r) => {
        const o = this.loadedTileCallback.bind(this, i, n);
        return e.forEachLoadedTile(t, n, r, o);
      }
    );
  }
  /**
   * @abstract
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {import("./vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {Array<import("./Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
   * @return {T|undefined} Callback result.
   * @template T
   */
  forEachFeatureAtCoordinate(e, t, i, n, r) {
  }
  /**
   * @return {LayerType} Layer.
   */
  getLayer() {
    return this.layer_;
  }
  /**
   * Perform action necessary to get the layer rendered after new fonts have loaded
   * @abstract
   */
  handleFontsChanged() {
  }
  /**
   * Handle changes in image state.
   * @param {import("../events/Event.js").default} event Image change event.
   * @private
   */
  handleImageChange_(e) {
    /** @type {import("../Image.js").default} */
    e.target.getState() === k.LOADED && this.renderIfReadyAndVisible();
  }
  /**
   * Load the image if not already loaded, and register the image change
   * listener if needed.
   * @param {import("../ImageBase.js").default} image Image.
   * @return {boolean} `true` if the image is already loaded, `false` otherwise.
   * @protected
   */
  loadImage(e) {
    let t = e.getState();
    return t != k.LOADED && t != k.ERROR && e.addEventListener(z.CHANGE, this.boundHandleImageChange_), t == k.IDLE && (e.load(), t = e.getState()), t == k.LOADED;
  }
  /**
   * @protected
   */
  renderIfReadyAndVisible() {
    const e = this.getLayer();
    e && e.getVisible() && e.getSourceState() === "ready" && e.changed();
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    delete this.layer_, super.disposeInternal();
  }
}
const Rc = Zg, Ul = [];
let Wi = null;
function jg() {
  Wi = Re(1, 1, void 0, {
    willReadFrequently: !0
  });
}
class Hg extends Rc {
  /**
   * @param {LayerType} layer Layer.
   */
  constructor(e) {
    super(e), this.container = null, this.renderedResolution, this.tempTransform = Se(), this.pixelTransform = Se(), this.inversePixelTransform = Se(), this.context = null, this.containerReused = !1, this.pixelContext_ = null, this.frameState = null;
  }
  /**
   * @param {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} image Image.
   * @param {number} col The column index.
   * @param {number} row The row index.
   * @return {Uint8ClampedArray|null} The image data.
   */
  getImageData(e, t, i) {
    Wi || jg(), Wi.clearRect(0, 0, 1, 1);
    let n;
    try {
      Wi.drawImage(e, t, i, 1, 1, 0, 0, 1, 1), n = Wi.getImageData(0, 0, 1, 1).data;
    } catch {
      return Wi = null, null;
    }
    return n;
  }
  /**
   * @param {import('../../Map.js').FrameState} frameState Frame state.
   * @return {string} Background color.
   */
  getBackground(e) {
    let i = this.getLayer().getBackground();
    return typeof i == "function" && (i = i(e.viewState.resolution)), i || void 0;
  }
  /**
   * Get a rendering container from an existing target, if compatible.
   * @param {HTMLElement} target Potential render target.
   * @param {string} transform CSS Transform.
   * @param {string} [backgroundColor] Background color.
   */
  useContainer(e, t, i) {
    const n = this.getLayer().getClassName();
    let r, o;
    if (e && e.className === n && (!i || e && e.style.backgroundColor && xt(
      Gn(e.style.backgroundColor),
      Gn(i)
    ))) {
      const a = e.firstElementChild;
      a instanceof HTMLCanvasElement && (o = a.getContext("2d"));
    }
    if (o && o.canvas.style.transform === t ? (this.container = e, this.context = o, this.containerReused = !0) : this.containerReused && (this.container = null, this.context = null, this.containerReused = !1), !this.container) {
      r = document.createElement("div"), r.className = n;
      let a = r.style;
      a.position = "absolute", a.width = "100%", a.height = "100%", o = Re();
      const l = o.canvas;
      r.appendChild(l), a = l.style, a.position = "absolute", a.left = "0", a.transformOrigin = "top left", this.container = r, this.context = o;
    }
    !this.containerReused && i && !this.container.style.backgroundColor && (this.container.style.backgroundColor = i);
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {import("../../extent.js").Extent} extent Clip extent.
   * @protected
   */
  clipUnrotated(e, t, i) {
    const n = Ot(i), r = os(i), o = un(i), a = rn(i);
    de(t.coordinateToPixelTransform, n), de(t.coordinateToPixelTransform, r), de(t.coordinateToPixelTransform, o), de(t.coordinateToPixelTransform, a);
    const l = this.inversePixelTransform;
    de(l, n), de(l, r), de(l, o), de(l, a), e.save(), e.beginPath(), e.moveTo(Math.round(n[0]), Math.round(n[1])), e.lineTo(Math.round(r[0]), Math.round(r[1])), e.lineTo(Math.round(o[0]), Math.round(o[1])), e.lineTo(Math.round(a[0]), Math.round(a[1])), e.clip();
  }
  /**
   * @param {import("../../render/EventType.js").default} type Event type.
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @private
   */
  dispatchRenderEvent_(e, t, i) {
    const n = this.getLayer();
    if (n.hasListener(e)) {
      const r = new An(
        e,
        this.inversePixelTransform,
        i,
        t
      );
      n.dispatchEvent(r);
    }
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @protected
   */
  preRender(e, t) {
    this.frameState = t, this.dispatchRenderEvent_(Xe.PRERENDER, e, t);
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @protected
   */
  postRender(e, t) {
    this.dispatchRenderEvent_(Xe.POSTRENDER, e, t);
  }
  /**
   * Creates a transform for rendering to an element that will be rotated after rendering.
   * @param {import("../../coordinate.js").Coordinate} center Center.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @param {number} pixelRatio Pixel ratio.
   * @param {number} width Width of the rendered element (in pixels).
   * @param {number} height Height of the rendered element (in pixels).
   * @param {number} offsetX Offset on the x-axis in view coordinates.
   * @protected
   * @return {!import("../../transform.js").Transform} Transform.
   */
  getRenderTransform(e, t, i, n, r, o, a) {
    const l = r / 2, h = o / 2, c = n / t, u = -c, d = -e[0] + a, f = -e[1];
    return Je(
      this.tempTransform,
      l,
      h,
      c,
      u,
      -i,
      d,
      f
    );
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    delete this.frameState, super.disposeInternal();
  }
}
const qa = Hg;
class Kg extends qa {
  /**
   * @param {import("../../layer/Image.js").default} imageLayer Image layer.
   */
  constructor(e) {
    super(e), this.image_ = null;
  }
  /**
   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
   */
  getImage() {
    return this.image_ ? this.image_.getImage() : null;
  }
  /**
   * Determine whether render should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */
  prepareFrame(e) {
    const t = e.layerStatesArray[e.layerIndex], i = e.pixelRatio, n = e.viewState, r = n.resolution, o = this.getLayer().getSource(), a = e.viewHints;
    let l = e.extent;
    if (t.extent !== void 0 && (l = pi(
      l,
      gt(t.extent, n.projection)
    )), !a[ge.ANIMATING] && !a[ge.INTERACTING] && !as(l))
      if (o) {
        const h = n.projection, c = o.getImage(
          l,
          r,
          i,
          h
        );
        c && (this.loadImage(c) ? this.image_ = c : c.getState() === k.EMPTY && (this.image_ = null));
      } else
        this.image_ = null;
    return !!this.image_;
  }
  /**
   * @param {import("../../pixel.js").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray} Data at the pixel location.
   */
  getData(e) {
    const t = this.frameState;
    if (!t)
      return null;
    const i = this.getLayer(), n = de(
      t.pixelToCoordinateTransform,
      e.slice()
    ), r = i.getExtent();
    if (r && !ss(r, n))
      return null;
    const o = this.image_.getExtent(), a = this.getImage(), l = te(o), h = Math.floor(
      a.width * ((n[0] - o[0]) / l)
    );
    if (h < 0 || h >= a.width)
      return null;
    const c = Fe(o), u = Math.floor(
      a.height * ((o[3] - n[1]) / c)
    );
    return u < 0 || u >= a.height ? null : this.getImageData(a, h, u);
  }
  /**
   * Render the layer.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target that may be used to render content to.
   * @return {HTMLElement} The rendered element.
   */
  renderFrame(e, t) {
    const i = this.image_, n = i.getExtent(), r = i.getResolution(), o = i.getPixelRatio(), a = e.layerStatesArray[e.layerIndex], l = e.pixelRatio, h = e.viewState, c = h.center, u = h.resolution, d = l * r / (u * o), f = e.extent, g = h.resolution, _ = h.rotation, m = Math.round(te(f) / g * l), p = Math.round(Fe(f) / g * l);
    Je(
      this.pixelTransform,
      e.size[0] / 2,
      e.size[1] / 2,
      1 / l,
      1 / l,
      _,
      -m / 2,
      -p / 2
    ), ns(this.inversePixelTransform, this.pixelTransform);
    const x = ca(this.pixelTransform);
    this.useContainer(t, x, this.getBackground(e));
    const y = this.context, E = y.canvas;
    E.width != m || E.height != p ? (E.width = m, E.height = p) : this.containerReused || y.clearRect(0, 0, m, p);
    let C = !1, T = !0;
    if (a.extent) {
      const Y = gt(
        a.extent,
        h.projection
      );
      T = Ce(Y, e.extent), C = T && !Ft(Y, e.extent), C && this.clipUnrotated(y, e, Y);
    }
    const w = this.getImage(), L = Je(
      this.tempTransform,
      m / 2,
      p / 2,
      d,
      d,
      0,
      o * (n[0] - c[0]) / r,
      o * (c[1] - n[3]) / r
    );
    this.renderedResolution = r * l / o;
    const I = w.width * L[0], S = w.height * L[3];
    if (this.getLayer().getSource().getInterpolate() || (y.imageSmoothingEnabled = !1), this.preRender(y, e), T && I >= 0.5 && S >= 0.5) {
      const Y = L[4], V = L[5], P = a.opacity;
      let q;
      P !== 1 && (q = y.globalAlpha, y.globalAlpha = P), y.drawImage(w, 0, 0, +w.width, +w.height, Y, V, I, S), P !== 1 && (y.globalAlpha = q);
    }
    return this.postRender(y, e), C && y.restore(), y.imageSmoothingEnabled = !0, x !== E.style.transform && (E.style.transform = x), this.container;
  }
}
const Ic = Kg, us = {
  BEGIN_GEOMETRY: 0,
  BEGIN_PATH: 1,
  CIRCLE: 2,
  CLOSE_PATH: 3,
  CUSTOM: 4,
  DRAW_CHARS: 5,
  DRAW_IMAGE: 6,
  END_GEOMETRY: 7,
  FILL: 8,
  MOVE_TO_LINE_TO: 9,
  SET_FILL_STYLE: 10,
  SET_STROKE_STYLE: 11,
  STROKE: 12
}, Os = [us.FILL], $t = [us.STROKE], di = [us.BEGIN_PATH], zl = [us.CLOSE_PATH], W = us;
class qg {
  /**
   * Render a geometry with a custom renderer.
   *
   * @param {import("../geom/SimpleGeometry.js").default} geometry Geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {Function} renderer Renderer.
   * @param {Function} hitDetectionRenderer Renderer.
   */
  drawCustom(e, t, i, n) {
  }
  /**
   * Render a geometry.
   *
   * @param {import("../geom/Geometry.js").default} geometry The geometry to render.
   */
  drawGeometry(e) {
  }
  /**
   * Set the rendering style.
   *
   * @param {import("../style/Style.js").default} style The rendering style.
   */
  setStyle(e) {
  }
  /**
   * @param {import("../geom/Circle.js").default} circleGeometry Circle geometry.
   * @param {import("../Feature.js").default} feature Feature.
   */
  drawCircle(e, t) {
  }
  /**
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("../style/Style.js").default} style Style.
   */
  drawFeature(e, t) {
  }
  /**
   * @param {import("../geom/GeometryCollection.js").default} geometryCollectionGeometry Geometry collection.
   * @param {import("../Feature.js").default} feature Feature.
   */
  drawGeometryCollection(e, t) {
  }
  /**
   * @param {import("../geom/LineString.js").default|import("./Feature.js").default} lineStringGeometry Line string geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */
  drawLineString(e, t) {
  }
  /**
   * @param {import("../geom/MultiLineString.js").default|import("./Feature.js").default} multiLineStringGeometry MultiLineString geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */
  drawMultiLineString(e, t) {
  }
  /**
   * @param {import("../geom/MultiPoint.js").default|import("./Feature.js").default} multiPointGeometry MultiPoint geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */
  drawMultiPoint(e, t) {
  }
  /**
   * @param {import("../geom/MultiPolygon.js").default} multiPolygonGeometry MultiPolygon geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */
  drawMultiPolygon(e, t) {
  }
  /**
   * @param {import("../geom/Point.js").default|import("./Feature.js").default} pointGeometry Point geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */
  drawPoint(e, t) {
  }
  /**
   * @param {import("../geom/Polygon.js").default|import("./Feature.js").default} polygonGeometry Polygon geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */
  drawPolygon(e, t) {
  }
  /**
   * @param {import("../geom/SimpleGeometry.js").default|import("./Feature.js").default} geometry Geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */
  drawText(e, t) {
  }
  /**
   * @param {import("../style/Fill.js").default} fillStyle Fill style.
   * @param {import("../style/Stroke.js").default} strokeStyle Stroke style.
   */
  setFillStrokeStyle(e, t) {
  }
  /**
   * @param {import("../style/Image.js").default} imageStyle Image style.
   * @param {import("../render/canvas.js").DeclutterImageWithText} [declutterImageWithText] Shared data for combined decluttering with a text style.
   */
  setImageStyle(e, t) {
  }
  /**
   * @param {import("../style/Text.js").default} textStyle Text style.
   * @param {import("../render/canvas.js").DeclutterImageWithText} [declutterImageWithText] Shared data for combined decluttering with an image style.
   */
  setTextStyle(e, t) {
  }
}
const Lc = qg;
class Jg extends Lc {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(e, t, i, n) {
    super(), this.tolerance = e, this.maxExtent = t, this.pixelRatio = n, this.maxLineWidth = 0, this.resolution = i, this.beginGeometryInstruction1_ = null, this.beginGeometryInstruction2_ = null, this.bufferedMaxExtent_ = null, this.instructions = [], this.coordinates = [], this.tmpCoordinate_ = [], this.hitDetectionInstructions = [], this.state = /** @type {import("../canvas.js").FillStrokeState} */
    {};
  }
  /**
   * @protected
   * @param {Array<number>} dashArray Dash array.
   * @return {Array<number>} Dash array with pixel ratio applied
   */
  applyPixelRatio(e) {
    const t = this.pixelRatio;
    return t == 1 ? e : e.map(function(i) {
      return i * t;
    });
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} stride Stride.
   * @protected
   * @return {number} My end
   */
  appendFlatPointCoordinates(e, t) {
    const i = this.getBufferedMaxExtent(), n = this.tmpCoordinate_, r = this.coordinates;
    let o = r.length;
    for (let a = 0, l = e.length; a < l; a += t)
      n[0] = e[a], n[1] = e[a + 1], ss(i, n) && (r[o++] = n[0], r[o++] = n[1]);
    return o;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {boolean} closed Last input coordinate equals first.
   * @param {boolean} skipFirst Skip first coordinate.
   * @protected
   * @return {number} My end.
   */
  appendFlatLineCoordinates(e, t, i, n, r, o) {
    const a = this.coordinates;
    let l = a.length;
    const h = this.getBufferedMaxExtent();
    o && (t += n);
    let c = e[t], u = e[t + 1];
    const d = this.tmpCoordinate_;
    let f = !0, g, _, m;
    for (g = t + n; g < i; g += n)
      d[0] = e[g], d[1] = e[g + 1], m = Ao(h, d), m !== _ ? (f && (a[l++] = c, a[l++] = u, f = !1), a[l++] = d[0], a[l++] = d[1]) : m === Te.INTERSECTING ? (a[l++] = d[0], a[l++] = d[1], f = !1) : f = !0, c = d[0], u = d[1], _ = m;
    return (r && f || g === t + n) && (a[l++] = c, a[l++] = u), l;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @param {Array<number>} builderEnds Builder ends.
   * @return {number} Offset.
   */
  drawCustomCoordinates_(e, t, i, n, r) {
    for (let o = 0, a = i.length; o < a; ++o) {
      const l = i[o], h = this.appendFlatLineCoordinates(
        e,
        t,
        l,
        n,
        !1,
        !1
      );
      r.push(h), t = l;
    }
    return t;
  }
  /**
   * @param {import("../../geom/SimpleGeometry.js").default} geometry Geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {Function} renderer Renderer.
   * @param {Function} hitDetectionRenderer Renderer.
   */
  drawCustom(e, t, i, n) {
    this.beginGeometry(e, t);
    const r = e.getType(), o = e.getStride(), a = this.coordinates.length;
    let l, h, c, u, d;
    switch (r) {
      case "MultiPolygon":
        l = /** @type {import("../../geom/MultiPolygon.js").default} */
        e.getOrientedFlatCoordinates(), u = [];
        const f = (
          /** @type {import("../../geom/MultiPolygon.js").default} */
          e.getEndss()
        );
        d = 0;
        for (let g = 0, _ = f.length; g < _; ++g) {
          const m = [];
          d = this.drawCustomCoordinates_(
            l,
            d,
            f[g],
            o,
            m
          ), u.push(m);
        }
        this.instructions.push([
          W.CUSTOM,
          a,
          u,
          e,
          i,
          ko
        ]), this.hitDetectionInstructions.push([
          W.CUSTOM,
          a,
          u,
          e,
          n || i,
          ko
        ]);
        break;
      case "Polygon":
      case "MultiLineString":
        c = [], l = r == "Polygon" ? (
          /** @type {import("../../geom/Polygon.js").default} */
          e.getOrientedFlatCoordinates()
        ) : e.getFlatCoordinates(), d = this.drawCustomCoordinates_(
          l,
          0,
          /** @type {import("../../geom/Polygon.js").default|import("../../geom/MultiLineString.js").default} */
          e.getEnds(),
          o,
          c
        ), this.instructions.push([
          W.CUSTOM,
          a,
          c,
          e,
          i,
          zn
        ]), this.hitDetectionInstructions.push([
          W.CUSTOM,
          a,
          c,
          e,
          n || i,
          zn
        ]);
        break;
      case "LineString":
      case "Circle":
        l = e.getFlatCoordinates(), h = this.appendFlatLineCoordinates(
          l,
          0,
          l.length,
          o,
          !1,
          !1
        ), this.instructions.push([
          W.CUSTOM,
          a,
          h,
          e,
          i,
          qt
        ]), this.hitDetectionInstructions.push([
          W.CUSTOM,
          a,
          h,
          e,
          n || i,
          qt
        ]);
        break;
      case "MultiPoint":
        l = e.getFlatCoordinates(), h = this.appendFlatPointCoordinates(l, o), h > a && (this.instructions.push([
          W.CUSTOM,
          a,
          h,
          e,
          i,
          qt
        ]), this.hitDetectionInstructions.push([
          W.CUSTOM,
          a,
          h,
          e,
          n || i,
          qt
        ]));
        break;
      case "Point":
        l = e.getFlatCoordinates(), this.coordinates.push(l[0], l[1]), h = this.coordinates.length, this.instructions.push([
          W.CUSTOM,
          a,
          h,
          e,
          i
        ]), this.hitDetectionInstructions.push([
          W.CUSTOM,
          a,
          h,
          e,
          n || i
        ]);
        break;
    }
    this.endGeometry(t);
  }
  /**
   * @protected
   * @param {import("../../geom/Geometry").default|import("../Feature.js").default} geometry The geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */
  beginGeometry(e, t) {
    this.beginGeometryInstruction1_ = [
      W.BEGIN_GEOMETRY,
      t,
      0,
      e
    ], this.instructions.push(this.beginGeometryInstruction1_), this.beginGeometryInstruction2_ = [
      W.BEGIN_GEOMETRY,
      t,
      0,
      e
    ], this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);
  }
  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */
  finish() {
    return {
      instructions: this.instructions,
      hitDetectionInstructions: this.hitDetectionInstructions,
      coordinates: this.coordinates
    };
  }
  /**
   * Reverse the hit detection instructions.
   */
  reverseHitDetectionInstructions() {
    const e = this.hitDetectionInstructions;
    e.reverse();
    let t;
    const i = e.length;
    let n, r, o = -1;
    for (t = 0; t < i; ++t)
      n = e[t], r = /** @type {import("./Instruction.js").default} */
      n[0], r == W.END_GEOMETRY ? o = t : r == W.BEGIN_GEOMETRY && (n[2] = t, Uu(this.hitDetectionInstructions, o, t), o = -1);
  }
  /**
   * @param {import("../../style/Fill.js").default} fillStyle Fill style.
   * @param {import("../../style/Stroke.js").default} strokeStyle Stroke style.
   */
  setFillStrokeStyle(e, t) {
    const i = this.state;
    if (e) {
      const n = e.getColor();
      i.fillStyle = _t(
        n || Pt
      );
    } else
      i.fillStyle = void 0;
    if (t) {
      const n = t.getColor();
      i.strokeStyle = _t(
        n || Yn
      );
      const r = t.getLineCap();
      i.lineCap = r !== void 0 ? r : hr;
      const o = t.getLineDash();
      i.lineDash = o ? o.slice() : Bn;
      const a = t.getLineDashOffset();
      i.lineDashOffset = a || Xn;
      const l = t.getLineJoin();
      i.lineJoin = l !== void 0 ? l : ln;
      const h = t.getWidth();
      i.lineWidth = h !== void 0 ? h : Zn;
      const c = t.getMiterLimit();
      i.miterLimit = c !== void 0 ? c : Wn, i.lineWidth > this.maxLineWidth && (this.maxLineWidth = i.lineWidth, this.bufferedMaxExtent_ = null);
    } else
      i.strokeStyle = void 0, i.lineCap = void 0, i.lineDash = null, i.lineDashOffset = void 0, i.lineJoin = void 0, i.lineWidth = void 0, i.miterLimit = void 0;
  }
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @return {Array<*>} Fill instruction.
   */
  createFill(e) {
    const t = e.fillStyle, i = [W.SET_FILL_STYLE, t];
    return typeof t != "string" && i.push(!0), i;
  }
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   */
  applyStroke(e) {
    this.instructions.push(this.createStroke(e));
  }
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @return {Array<*>} Stroke instruction.
   */
  createStroke(e) {
    return [
      W.SET_STROKE_STYLE,
      e.strokeStyle,
      e.lineWidth * this.pixelRatio,
      e.lineCap,
      e.lineJoin,
      e.miterLimit,
      this.applyPixelRatio(e.lineDash),
      e.lineDashOffset * this.pixelRatio
    ];
  }
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @param {function(this:CanvasBuilder, import("../canvas.js").FillStrokeState):Array<*>} createFill Create fill.
   */
  updateFillStyle(e, t) {
    const i = e.fillStyle;
    (typeof i != "string" || e.currentFillStyle != i) && (i !== void 0 && this.instructions.push(t.call(this, e)), e.currentFillStyle = i);
  }
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @param {function(this:CanvasBuilder, import("../canvas.js").FillStrokeState): void} applyStroke Apply stroke.
   */
  updateStrokeStyle(e, t) {
    const i = e.strokeStyle, n = e.lineCap, r = e.lineDash, o = e.lineDashOffset, a = e.lineJoin, l = e.lineWidth, h = e.miterLimit;
    (e.currentStrokeStyle != i || e.currentLineCap != n || r != e.currentLineDash && !xt(e.currentLineDash, r) || e.currentLineDashOffset != o || e.currentLineJoin != a || e.currentLineWidth != l || e.currentMiterLimit != h) && (i !== void 0 && t.call(this, e), e.currentStrokeStyle = i, e.currentLineCap = n, e.currentLineDash = r, e.currentLineDashOffset = o, e.currentLineJoin = a, e.currentLineWidth = l, e.currentMiterLimit = h);
  }
  /**
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */
  endGeometry(e) {
    this.beginGeometryInstruction1_[2] = this.instructions.length, this.beginGeometryInstruction1_ = null, this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length, this.beginGeometryInstruction2_ = null;
    const t = [W.END_GEOMETRY, e];
    this.instructions.push(t), this.hitDetectionInstructions.push(t);
  }
  /**
   * Get the buffered rendering extent.  Rendering will be clipped to the extent
   * provided to the constructor.  To account for symbolizers that may intersect
   * this extent, we calculate a buffered extent (e.g. based on stroke width).
   * @return {import("../../extent.js").Extent} The buffered rendering extent.
   * @protected
   */
  getBufferedMaxExtent() {
    if (!this.bufferedMaxExtent_ && (this.bufferedMaxExtent_ = bh(this.maxExtent), this.maxLineWidth > 0)) {
      const e = this.resolution * (this.maxLineWidth + 1) / 2;
      Si(this.bufferedMaxExtent_, e, this.bufferedMaxExtent_);
    }
    return this.bufferedMaxExtent_;
  }
}
const ds = Jg;
class $g extends ds {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(e, t, i, n) {
    super(e, t, i, n), this.hitDetectionImage_ = null, this.image_ = null, this.imagePixelRatio_ = void 0, this.anchorX_ = void 0, this.anchorY_ = void 0, this.height_ = void 0, this.opacity_ = void 0, this.originX_ = void 0, this.originY_ = void 0, this.rotateWithView_ = void 0, this.rotation_ = void 0, this.scale_ = void 0, this.width_ = void 0, this.declutterMode_ = void 0, this.declutterImageWithText_ = void 0;
  }
  /**
   * @param {import("../../geom/Point.js").default|import("../Feature.js").default} pointGeometry Point geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */
  drawPoint(e, t) {
    if (!this.image_)
      return;
    this.beginGeometry(e, t);
    const i = e.getFlatCoordinates(), n = e.getStride(), r = this.coordinates.length, o = this.appendFlatPointCoordinates(i, n);
    this.instructions.push([
      W.DRAW_IMAGE,
      r,
      o,
      this.image_,
      // Remaining arguments to DRAW_IMAGE are in alphabetical order
      this.anchorX_ * this.imagePixelRatio_,
      this.anchorY_ * this.imagePixelRatio_,
      Math.ceil(this.height_ * this.imagePixelRatio_),
      this.opacity_,
      this.originX_ * this.imagePixelRatio_,
      this.originY_ * this.imagePixelRatio_,
      this.rotateWithView_,
      this.rotation_,
      [
        this.scale_[0] * this.pixelRatio / this.imagePixelRatio_,
        this.scale_[1] * this.pixelRatio / this.imagePixelRatio_
      ],
      Math.ceil(this.width_ * this.imagePixelRatio_),
      this.declutterMode_,
      this.declutterImageWithText_
    ]), this.hitDetectionInstructions.push([
      W.DRAW_IMAGE,
      r,
      o,
      this.hitDetectionImage_,
      // Remaining arguments to DRAW_IMAGE are in alphabetical order
      this.anchorX_,
      this.anchorY_,
      this.height_,
      this.opacity_,
      this.originX_,
      this.originY_,
      this.rotateWithView_,
      this.rotation_,
      this.scale_,
      this.width_,
      this.declutterMode_,
      this.declutterImageWithText_
    ]), this.endGeometry(t);
  }
  /**
   * @param {import("../../geom/MultiPoint.js").default|import("../Feature.js").default} multiPointGeometry MultiPoint geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */
  drawMultiPoint(e, t) {
    if (!this.image_)
      return;
    this.beginGeometry(e, t);
    const i = e.getFlatCoordinates(), n = e.getStride(), r = this.coordinates.length, o = this.appendFlatPointCoordinates(i, n);
    this.instructions.push([
      W.DRAW_IMAGE,
      r,
      o,
      this.image_,
      // Remaining arguments to DRAW_IMAGE are in alphabetical order
      this.anchorX_ * this.imagePixelRatio_,
      this.anchorY_ * this.imagePixelRatio_,
      Math.ceil(this.height_ * this.imagePixelRatio_),
      this.opacity_,
      this.originX_ * this.imagePixelRatio_,
      this.originY_ * this.imagePixelRatio_,
      this.rotateWithView_,
      this.rotation_,
      [
        this.scale_[0] * this.pixelRatio / this.imagePixelRatio_,
        this.scale_[1] * this.pixelRatio / this.imagePixelRatio_
      ],
      Math.ceil(this.width_ * this.imagePixelRatio_),
      this.declutterMode_,
      this.declutterImageWithText_
    ]), this.hitDetectionInstructions.push([
      W.DRAW_IMAGE,
      r,
      o,
      this.hitDetectionImage_,
      // Remaining arguments to DRAW_IMAGE are in alphabetical order
      this.anchorX_,
      this.anchorY_,
      this.height_,
      this.opacity_,
      this.originX_,
      this.originY_,
      this.rotateWithView_,
      this.rotation_,
      this.scale_,
      this.width_,
      this.declutterMode_,
      this.declutterImageWithText_
    ]), this.endGeometry(t);
  }
  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */
  finish() {
    return this.reverseHitDetectionInstructions(), this.anchorX_ = void 0, this.anchorY_ = void 0, this.hitDetectionImage_ = null, this.image_ = null, this.imagePixelRatio_ = void 0, this.height_ = void 0, this.scale_ = void 0, this.opacity_ = void 0, this.originX_ = void 0, this.originY_ = void 0, this.rotateWithView_ = void 0, this.rotation_ = void 0, this.width_ = void 0, super.finish();
  }
  /**
   * @param {import("../../style/Image.js").default} imageStyle Image style.
   * @param {Object} [sharedData] Shared data.
   */
  setImageStyle(e, t) {
    const i = e.getAnchor(), n = e.getSize(), r = e.getOrigin();
    this.imagePixelRatio_ = e.getPixelRatio(this.pixelRatio), this.anchorX_ = i[0], this.anchorY_ = i[1], this.hitDetectionImage_ = e.getHitDetectionImage(), this.image_ = e.getImage(this.pixelRatio), this.height_ = n[1], this.opacity_ = e.getOpacity(), this.originX_ = r[0], this.originY_ = r[1], this.rotateWithView_ = e.getRotateWithView(), this.rotation_ = e.getRotation(), this.scale_ = e.getScaleArray(), this.width_ = n[0], this.declutterMode_ = e.getDeclutterMode(), this.declutterImageWithText_ = t;
  }
}
const Qg = $g;
class e_ extends ds {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(e, t, i, n) {
    super(e, t, i, n);
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @private
   * @return {number} end.
   */
  drawFlatCoordinates_(e, t, i, n) {
    const r = this.coordinates.length, o = this.appendFlatLineCoordinates(
      e,
      t,
      i,
      n,
      !1,
      !1
    ), a = [
      W.MOVE_TO_LINE_TO,
      r,
      o
    ];
    return this.instructions.push(a), this.hitDetectionInstructions.push(a), i;
  }
  /**
   * @param {import("../../geom/LineString.js").default|import("../Feature.js").default} lineStringGeometry Line string geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */
  drawLineString(e, t) {
    const i = this.state, n = i.strokeStyle, r = i.lineWidth;
    if (n === void 0 || r === void 0)
      return;
    this.updateStrokeStyle(i, this.applyStroke), this.beginGeometry(e, t), this.hitDetectionInstructions.push(
      [
        W.SET_STROKE_STYLE,
        i.strokeStyle,
        i.lineWidth,
        i.lineCap,
        i.lineJoin,
        i.miterLimit,
        Bn,
        Xn
      ],
      di
    );
    const o = e.getFlatCoordinates(), a = e.getStride();
    this.drawFlatCoordinates_(
      o,
      0,
      o.length,
      a
    ), this.hitDetectionInstructions.push($t), this.endGeometry(t);
  }
  /**
   * @param {import("../../geom/MultiLineString.js").default|import("../Feature.js").default} multiLineStringGeometry MultiLineString geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */
  drawMultiLineString(e, t) {
    const i = this.state, n = i.strokeStyle, r = i.lineWidth;
    if (n === void 0 || r === void 0)
      return;
    this.updateStrokeStyle(i, this.applyStroke), this.beginGeometry(e, t), this.hitDetectionInstructions.push(
      [
        W.SET_STROKE_STYLE,
        i.strokeStyle,
        i.lineWidth,
        i.lineCap,
        i.lineJoin,
        i.miterLimit,
        i.lineDash,
        i.lineDashOffset
      ],
      di
    );
    const o = e.getEnds(), a = e.getFlatCoordinates(), l = e.getStride();
    let h = 0;
    for (let c = 0, u = o.length; c < u; ++c)
      h = this.drawFlatCoordinates_(
        a,
        h,
        /** @type {number} */
        o[c],
        l
      );
    this.hitDetectionInstructions.push($t), this.endGeometry(t);
  }
  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */
  finish() {
    const e = this.state;
    return e.lastStroke != null && e.lastStroke != this.coordinates.length && this.instructions.push($t), this.reverseHitDetectionInstructions(), this.state = null, super.finish();
  }
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   */
  applyStroke(e) {
    e.lastStroke != null && e.lastStroke != this.coordinates.length && (this.instructions.push($t), e.lastStroke = this.coordinates.length), e.lastStroke = 0, super.applyStroke(e), this.instructions.push(di);
  }
}
const t_ = e_;
class i_ extends ds {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(e, t, i, n) {
    super(e, t, i, n);
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @private
   * @return {number} End.
   */
  drawFlatCoordinatess_(e, t, i, n) {
    const r = this.state, o = r.fillStyle !== void 0, a = r.strokeStyle !== void 0, l = i.length;
    this.instructions.push(di), this.hitDetectionInstructions.push(di);
    for (let h = 0; h < l; ++h) {
      const c = i[h], u = this.coordinates.length, d = this.appendFlatLineCoordinates(
        e,
        t,
        c,
        n,
        !0,
        !a
      ), f = [
        W.MOVE_TO_LINE_TO,
        u,
        d
      ];
      this.instructions.push(f), this.hitDetectionInstructions.push(f), a && (this.instructions.push(zl), this.hitDetectionInstructions.push(zl)), t = c;
    }
    return o && (this.instructions.push(Os), this.hitDetectionInstructions.push(Os)), a && (this.instructions.push($t), this.hitDetectionInstructions.push($t)), t;
  }
  /**
   * @param {import("../../geom/Circle.js").default} circleGeometry Circle geometry.
   * @param {import("../../Feature.js").default} feature Feature.
   */
  drawCircle(e, t) {
    const i = this.state, n = i.fillStyle, r = i.strokeStyle;
    if (n === void 0 && r === void 0)
      return;
    this.setFillStrokeStyles_(), this.beginGeometry(e, t), i.fillStyle !== void 0 && this.hitDetectionInstructions.push([
      W.SET_FILL_STYLE,
      Pt
    ]), i.strokeStyle !== void 0 && this.hitDetectionInstructions.push([
      W.SET_STROKE_STYLE,
      i.strokeStyle,
      i.lineWidth,
      i.lineCap,
      i.lineJoin,
      i.miterLimit,
      i.lineDash,
      i.lineDashOffset
    ]);
    const o = e.getFlatCoordinates(), a = e.getStride(), l = this.coordinates.length;
    this.appendFlatLineCoordinates(
      o,
      0,
      o.length,
      a,
      !1,
      !1
    );
    const h = [W.CIRCLE, l];
    this.instructions.push(di, h), this.hitDetectionInstructions.push(di, h), i.fillStyle !== void 0 && (this.instructions.push(Os), this.hitDetectionInstructions.push(Os)), i.strokeStyle !== void 0 && (this.instructions.push($t), this.hitDetectionInstructions.push($t)), this.endGeometry(t);
  }
  /**
   * @param {import("../../geom/Polygon.js").default|import("../Feature.js").default} polygonGeometry Polygon geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */
  drawPolygon(e, t) {
    const i = this.state, n = i.fillStyle, r = i.strokeStyle;
    if (n === void 0 && r === void 0)
      return;
    this.setFillStrokeStyles_(), this.beginGeometry(e, t), i.fillStyle !== void 0 && this.hitDetectionInstructions.push([
      W.SET_FILL_STYLE,
      Pt
    ]), i.strokeStyle !== void 0 && this.hitDetectionInstructions.push([
      W.SET_STROKE_STYLE,
      i.strokeStyle,
      i.lineWidth,
      i.lineCap,
      i.lineJoin,
      i.miterLimit,
      i.lineDash,
      i.lineDashOffset
    ]);
    const o = e.getEnds(), a = e.getOrientedFlatCoordinates(), l = e.getStride();
    this.drawFlatCoordinatess_(
      a,
      0,
      /** @type {Array<number>} */
      o,
      l
    ), this.endGeometry(t);
  }
  /**
   * @param {import("../../geom/MultiPolygon.js").default} multiPolygonGeometry MultiPolygon geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */
  drawMultiPolygon(e, t) {
    const i = this.state, n = i.fillStyle, r = i.strokeStyle;
    if (n === void 0 && r === void 0)
      return;
    this.setFillStrokeStyles_(), this.beginGeometry(e, t), i.fillStyle !== void 0 && this.hitDetectionInstructions.push([
      W.SET_FILL_STYLE,
      Pt
    ]), i.strokeStyle !== void 0 && this.hitDetectionInstructions.push([
      W.SET_STROKE_STYLE,
      i.strokeStyle,
      i.lineWidth,
      i.lineCap,
      i.lineJoin,
      i.miterLimit,
      i.lineDash,
      i.lineDashOffset
    ]);
    const o = e.getEndss(), a = e.getOrientedFlatCoordinates(), l = e.getStride();
    let h = 0;
    for (let c = 0, u = o.length; c < u; ++c)
      h = this.drawFlatCoordinatess_(
        a,
        h,
        o[c],
        l
      );
    this.endGeometry(t);
  }
  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */
  finish() {
    this.reverseHitDetectionInstructions(), this.state = null;
    const e = this.tolerance;
    if (e !== 0) {
      const t = this.coordinates;
      for (let i = 0, n = t.length; i < n; ++i)
        t[i] = li(t[i], e);
    }
    return super.finish();
  }
  /**
   * @private
   */
  setFillStrokeStyles_() {
    const e = this.state;
    e.fillStyle !== void 0 && this.updateFillStyle(e, this.createFill), e.strokeStyle !== void 0 && this.updateStrokeStyle(e, this.applyStroke);
  }
}
const Bl = i_;
function n_(s, e, t, i, n) {
  const r = [];
  let o = t, a = 0, l = e.slice(t, 2);
  for (; a < s && o + n < i; ) {
    const [h, c] = l.slice(-2), u = e[o + n], d = e[o + n + 1], f = Math.sqrt(
      (u - h) * (u - h) + (d - c) * (d - c)
    );
    if (a += f, a >= s) {
      const g = (s - a + f) / f, _ = He(h, u, g), m = He(c, d, g);
      l.push(_, m), r.push(l), l = [_, m], a == s && (o += n), a = 0;
    } else if (a < s)
      l.push(
        e[o + n],
        e[o + n + 1]
      ), o += n;
    else {
      const g = f - a, _ = He(h, u, g / f), m = He(c, d, g / f);
      l.push(_, m), r.push(l), l = [_, m], a = 0, o += n;
    }
  }
  return a > 0 && r.push(l), r;
}
function s_(s, e, t, i, n) {
  let r = t, o = t, a = 0, l = 0, h = t, c, u, d, f, g, _, m, p, x, y;
  for (u = t; u < i; u += n) {
    const E = e[u], C = e[u + 1];
    g !== void 0 && (x = E - g, y = C - _, f = Math.sqrt(x * x + y * y), m !== void 0 && (l += d, c = Math.acos((m * x + p * y) / (d * f)), c > s && (l > a && (a = l, r = h, o = u), l = 0, h = u - n)), d = f, m = x, p = y), g = E, _ = C;
  }
  return l += f, l > a ? [h, u] : [r, o];
}
const bn = {
  left: 0,
  end: 0,
  center: 0.5,
  right: 1,
  start: 1,
  top: 0,
  middle: 0.5,
  hanging: 0.2,
  alphabetic: 0.8,
  ideographic: 0.8,
  bottom: 1
};
class r_ extends ds {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(e, t, i, n) {
    super(e, t, i, n), this.labels_ = null, this.text_ = "", this.textOffsetX_ = 0, this.textOffsetY_ = 0, this.textRotateWithView_ = void 0, this.textRotation_ = 0, this.textFillState_ = null, this.fillStates = {}, this.textStrokeState_ = null, this.strokeStates = {}, this.textState_ = /** @type {import("../canvas.js").TextState} */
    {}, this.textStates = {}, this.textKey_ = "", this.fillKey_ = "", this.strokeKey_ = "", this.declutterImageWithText_ = void 0;
  }
  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */
  finish() {
    const e = super.finish();
    return e.textStates = this.textStates, e.fillStates = this.fillStates, e.strokeStates = this.strokeStates, e;
  }
  /**
   * @param {import("../../geom/SimpleGeometry.js").default|import("../Feature.js").default} geometry Geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */
  drawText(e, t) {
    const i = this.textFillState_, n = this.textStrokeState_, r = this.textState_;
    if (this.text_ === "" || !r || !i && !n)
      return;
    const o = this.coordinates;
    let a = o.length;
    const l = e.getType();
    let h = null, c = e.getStride();
    if (r.placement === "line" && (l == "LineString" || l == "MultiLineString" || l == "Polygon" || l == "MultiPolygon")) {
      if (!Ce(this.getBufferedMaxExtent(), e.getExtent()))
        return;
      let u;
      if (h = e.getFlatCoordinates(), l == "LineString")
        u = [h.length];
      else if (l == "MultiLineString")
        u = /** @type {import("../../geom/MultiLineString.js").default} */
        e.getEnds();
      else if (l == "Polygon")
        u = /** @type {import("../../geom/Polygon.js").default} */
        e.getEnds().slice(0, 1);
      else if (l == "MultiPolygon") {
        const _ = (
          /** @type {import("../../geom/MultiPolygon.js").default} */
          e.getEndss()
        );
        u = [];
        for (let m = 0, p = _.length; m < p; ++m)
          u.push(_[m][0]);
      }
      this.beginGeometry(e, t);
      const d = r.repeat, f = d ? void 0 : r.textAlign;
      let g = 0;
      for (let _ = 0, m = u.length; _ < m; ++_) {
        let p;
        d ? p = n_(
          d * this.resolution,
          h,
          g,
          u[_],
          c
        ) : p = [h.slice(g, u[_])];
        for (let x = 0, y = p.length; x < y; ++x) {
          const E = p[x];
          let C = 0, T = E.length;
          if (f == null) {
            const L = s_(
              r.maxAngle,
              E,
              0,
              E.length,
              2
            );
            C = L[0], T = L[1];
          }
          for (let L = C; L < T; L += c)
            o.push(E[L], E[L + 1]);
          const w = o.length;
          g = u[_], this.drawChars_(a, w), a = w;
        }
      }
      this.endGeometry(t);
    } else {
      let u = r.overflow ? null : [];
      switch (l) {
        case "Point":
        case "MultiPoint":
          h = /** @type {import("../../geom/MultiPoint.js").default} */
          e.getFlatCoordinates();
          break;
        case "LineString":
          h = /** @type {import("../../geom/LineString.js").default} */
          e.getFlatMidpoint();
          break;
        case "Circle":
          h = /** @type {import("../../geom/Circle.js").default} */
          e.getCenter();
          break;
        case "MultiLineString":
          h = /** @type {import("../../geom/MultiLineString.js").default} */
          e.getFlatMidpoints(), c = 2;
          break;
        case "Polygon":
          h = /** @type {import("../../geom/Polygon.js").default} */
          e.getFlatInteriorPoint(), r.overflow || u.push(h[2] / this.resolution), c = 3;
          break;
        case "MultiPolygon":
          const m = (
            /** @type {import("../../geom/MultiPolygon.js").default} */
            e.getFlatInteriorPoints()
          );
          h = [];
          for (let p = 0, x = m.length; p < x; p += 3)
            r.overflow || u.push(m[p + 2] / this.resolution), h.push(m[p], m[p + 1]);
          if (h.length === 0)
            return;
          c = 2;
          break;
      }
      const d = this.appendFlatPointCoordinates(h, c);
      if (d === a)
        return;
      if (u && (d - a) / 2 !== h.length / c) {
        let m = a / 2;
        u = u.filter((p, x) => {
          const y = o[(m + x) * 2] === h[x * c] && o[(m + x) * 2 + 1] === h[x * c + 1];
          return y || --m, y;
        });
      }
      this.saveTextStates_(), (r.backgroundFill || r.backgroundStroke) && (this.setFillStrokeStyle(
        r.backgroundFill,
        r.backgroundStroke
      ), r.backgroundFill && (this.updateFillStyle(this.state, this.createFill), this.hitDetectionInstructions.push(this.createFill(this.state))), r.backgroundStroke && (this.updateStrokeStyle(this.state, this.applyStroke), this.hitDetectionInstructions.push(this.createStroke(this.state)))), this.beginGeometry(e, t);
      let f = r.padding;
      if (f != ui && (r.scale[0] < 0 || r.scale[1] < 0)) {
        let m = r.padding[0], p = r.padding[1], x = r.padding[2], y = r.padding[3];
        r.scale[0] < 0 && (p = -p, y = -y), r.scale[1] < 0 && (m = -m, x = -x), f = [m, p, x, y];
      }
      const g = this.pixelRatio;
      this.instructions.push([
        W.DRAW_IMAGE,
        a,
        d,
        null,
        NaN,
        NaN,
        NaN,
        1,
        0,
        0,
        this.textRotateWithView_,
        this.textRotation_,
        [1, 1],
        NaN,
        void 0,
        this.declutterImageWithText_,
        f == ui ? ui : f.map(function(m) {
          return m * g;
        }),
        !!r.backgroundFill,
        !!r.backgroundStroke,
        this.text_,
        this.textKey_,
        this.strokeKey_,
        this.fillKey_,
        this.textOffsetX_,
        this.textOffsetY_,
        u
      ]);
      const _ = 1 / g;
      this.hitDetectionInstructions.push([
        W.DRAW_IMAGE,
        a,
        d,
        null,
        NaN,
        NaN,
        NaN,
        1,
        0,
        0,
        this.textRotateWithView_,
        this.textRotation_,
        [_, _],
        NaN,
        void 0,
        this.declutterImageWithText_,
        f,
        !!r.backgroundFill,
        !!r.backgroundStroke,
        this.text_,
        this.textKey_,
        this.strokeKey_,
        this.fillKey_,
        this.textOffsetX_,
        this.textOffsetY_,
        u
      ]), this.endGeometry(t);
    }
  }
  /**
   * @private
   */
  saveTextStates_() {
    const e = this.textStrokeState_, t = this.textState_, i = this.textFillState_, n = this.strokeKey_;
    e && (n in this.strokeStates || (this.strokeStates[n] = {
      strokeStyle: e.strokeStyle,
      lineCap: e.lineCap,
      lineDashOffset: e.lineDashOffset,
      lineWidth: e.lineWidth,
      lineJoin: e.lineJoin,
      miterLimit: e.miterLimit,
      lineDash: e.lineDash
    }));
    const r = this.textKey_;
    r in this.textStates || (this.textStates[r] = {
      font: t.font,
      textAlign: t.textAlign || Vn,
      justify: t.justify,
      textBaseline: t.textBaseline || cr,
      scale: t.scale
    });
    const o = this.fillKey_;
    i && (o in this.fillStates || (this.fillStates[o] = {
      fillStyle: i.fillStyle
    }));
  }
  /**
   * @private
   * @param {number} begin Begin.
   * @param {number} end End.
   */
  drawChars_(e, t) {
    const i = this.textStrokeState_, n = this.textState_, r = this.strokeKey_, o = this.textKey_, a = this.fillKey_;
    this.saveTextStates_();
    const l = this.pixelRatio, h = bn[n.textBaseline], c = this.textOffsetY_ * l, u = this.text_, d = i ? i.lineWidth * Math.abs(n.scale[0]) / 2 : 0;
    this.instructions.push([
      W.DRAW_CHARS,
      e,
      t,
      h,
      n.overflow,
      a,
      n.maxAngle,
      l,
      c,
      r,
      d * l,
      u,
      o,
      1
    ]), this.hitDetectionInstructions.push([
      W.DRAW_CHARS,
      e,
      t,
      h,
      n.overflow,
      a,
      n.maxAngle,
      1,
      c,
      r,
      d,
      u,
      o,
      1 / l
    ]);
  }
  /**
   * @param {import("../../style/Text.js").default} textStyle Text style.
   * @param {Object} [sharedData] Shared data.
   */
  setTextStyle(e, t) {
    let i, n, r;
    if (!e)
      this.text_ = "";
    else {
      const o = e.getFill();
      o ? (n = this.textFillState_, n || (n = /** @type {import("../canvas.js").FillState} */
      {}, this.textFillState_ = n), n.fillStyle = _t(
        o.getColor() || Pt
      )) : (n = null, this.textFillState_ = n);
      const a = e.getStroke();
      if (!a)
        r = null, this.textStrokeState_ = r;
      else {
        r = this.textStrokeState_, r || (r = /** @type {import("../canvas.js").StrokeState} */
        {}, this.textStrokeState_ = r);
        const g = a.getLineDash(), _ = a.getLineDashOffset(), m = a.getWidth(), p = a.getMiterLimit();
        r.lineCap = a.getLineCap() || hr, r.lineDash = g ? g.slice() : Bn, r.lineDashOffset = _ === void 0 ? Xn : _, r.lineJoin = a.getLineJoin() || ln, r.lineWidth = m === void 0 ? Zn : m, r.miterLimit = p === void 0 ? Wn : p, r.strokeStyle = _t(
          a.getColor() || Yn
        );
      }
      i = this.textState_;
      const l = e.getFont() || hc;
      Af(l);
      const h = e.getScaleArray();
      i.overflow = e.getOverflow(), i.font = l, i.maxAngle = e.getMaxAngle(), i.placement = e.getPlacement(), i.textAlign = e.getTextAlign(), i.repeat = e.getRepeat(), i.justify = e.getJustify(), i.textBaseline = e.getTextBaseline() || cr, i.backgroundFill = e.getBackgroundFill(), i.backgroundStroke = e.getBackgroundStroke(), i.padding = e.getPadding() || ui, i.scale = h === void 0 ? [1, 1] : h;
      const c = e.getOffsetX(), u = e.getOffsetY(), d = e.getRotateWithView(), f = e.getRotation();
      this.text_ = e.getText() || "", this.textOffsetX_ = c === void 0 ? 0 : c, this.textOffsetY_ = u === void 0 ? 0 : u, this.textRotateWithView_ = d === void 0 ? !1 : d, this.textRotation_ = f === void 0 ? 0 : f, this.strokeKey_ = r ? (typeof r.strokeStyle == "string" ? r.strokeStyle : B(r.strokeStyle)) + r.lineCap + r.lineDashOffset + "|" + r.lineWidth + r.lineJoin + r.miterLimit + "[" + r.lineDash.join() + "]" : "", this.textKey_ = i.font + i.scale + (i.textAlign || "?") + (i.repeat || "?") + (i.justify || "?") + (i.textBaseline || "?"), this.fillKey_ = n ? typeof n.fillStyle == "string" ? n.fillStyle : "|" + B(n.fillStyle) : "";
    }
    this.declutterImageWithText_ = t;
  }
}
const o_ = {
  Circle: Bl,
  Default: ds,
  Image: Qg,
  LineString: t_,
  Polygon: Bl,
  Text: r_
};
class a_ {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Max extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(e, t, i, n) {
    this.tolerance_ = e, this.maxExtent_ = t, this.pixelRatio_ = n, this.resolution_ = i, this.buildersByZIndex_ = {};
  }
  /**
   * @return {!Object<string, !Object<import("../canvas.js").BuilderType, import("./Builder.js").SerializableInstructions>>} The serializable instructions
   */
  finish() {
    const e = {};
    for (const t in this.buildersByZIndex_) {
      e[t] = e[t] || {};
      const i = this.buildersByZIndex_[t];
      for (const n in i) {
        const r = i[n].finish();
        e[t][n] = r;
      }
    }
    return e;
  }
  /**
   * @param {number|undefined} zIndex Z index.
   * @param {import("../canvas.js").BuilderType} builderType Replay type.
   * @return {import("../VectorContext.js").default} Replay.
   */
  getBuilder(e, t) {
    const i = e !== void 0 ? e.toString() : "0";
    let n = this.buildersByZIndex_[i];
    n === void 0 && (n = {}, this.buildersByZIndex_[i] = n);
    let r = n[t];
    if (r === void 0) {
      const o = o_[t];
      r = new o(
        this.tolerance_,
        this.maxExtent_,
        this.resolution_,
        this.pixelRatio_
      ), n[t] = r;
    }
    return r;
  }
}
const Xl = a_;
function l_(s, e, t, i, n, r, o, a, l, h, c, u) {
  let d = s[e], f = s[e + 1], g = 0, _ = 0, m = 0, p = 0;
  function x() {
    g = d, _ = f, e += i, d = s[e], f = s[e + 1], p += m, m = Math.sqrt((d - g) * (d - g) + (f - _) * (f - _));
  }
  do
    x();
  while (e < t - i && p + m < r);
  let y = m === 0 ? 0 : (r - p) / m;
  const E = He(g, d, y), C = He(_, f, y), T = e - i, w = p, L = r + a * l(h, n, c);
  for (; e < t - i && p + m < L; )
    x();
  y = m === 0 ? 0 : (L - p) / m;
  const I = He(g, d, y), S = He(_, f, y);
  let Y;
  if (u) {
    const b = [E, C, I, S];
    Ta(b, 0, 4, 2, u, b, b), Y = b[0] > b[2];
  } else
    Y = E > I;
  const V = Math.PI, P = [], q = T + i === e;
  e = T, m = 0, p = w, d = s[e], f = s[e + 1];
  let F;
  if (q) {
    x(), F = Math.atan2(f - _, d - g), Y && (F += F > 0 ? -V : V);
    const b = (I + E) / 2, A = (S + C) / 2;
    return P[0] = [b, A, (L - r) / 2, F, n], P;
  }
  n = n.replace(/\n/g, " ");
  for (let b = 0, A = n.length; b < A; ) {
    x();
    let j = Math.atan2(f - _, d - g);
    if (Y && (j += j > 0 ? -V : V), F !== void 0) {
      let ie = j - F;
      if (ie += ie > V ? -2 * V : ie < -V ? 2 * V : 0, Math.abs(ie) > o)
        return null;
    }
    F = j;
    const Q = b;
    let ee = 0;
    for (; b < A; ++b) {
      const ie = Y ? A - b - 1 : b, oe = a * l(h, n[ie], c);
      if (e + i < t && p + m < r + ee + oe / 2)
        break;
      ee += oe;
    }
    if (b === Q)
      continue;
    const me = Y ? n.substring(A - Q, A - b) : n.substring(Q, b);
    y = m === 0 ? 0 : (r + ee / 2 - p) / m;
    const R = He(g, d, y), ue = He(_, f, y);
    P.push([R, ue, ee / 2, j, me]), r += ee;
  }
  return P;
}
function Ac(s, e, t, i) {
  let n = s[e], r = s[e + 1], o = 0;
  for (let a = e + i; a < t; a += i) {
    const l = s[a], h = s[a + 1];
    o += Math.sqrt((l - n) * (l - n) + (h - r) * (h - r)), n = l, r = h;
  }
  return o;
}
const Ni = Me(), Wt = [], Tt = [], St = [], Yt = [];
function Wl(s) {
  return s[3].declutterBox;
}
const h_ = new RegExp(
  /* eslint-disable prettier/prettier */
  "[" + String.fromCharCode(1425) + "-" + String.fromCharCode(2303) + String.fromCharCode(64285) + "-" + String.fromCharCode(65023) + String.fromCharCode(65136) + "-" + String.fromCharCode(65276) + String.fromCharCode(67584) + "-" + String.fromCharCode(69631) + String.fromCharCode(124928) + "-" + String.fromCharCode(126975) + "]"
  /* eslint-enable prettier/prettier */
);
function Yl(s, e) {
  return (e === "start" || e === "end") && !h_.test(s) && (e = e === "start" ? "left" : "right"), bn[e];
}
function c_(s, e, t) {
  return t > 0 && s.push(`
`, ""), s.push(e, ""), s;
}
class u_ {
  /**
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {boolean} overlaps The replay can have overlapping geometries.
   * @param {import("../canvas.js").SerializableInstructions} instructions The serializable instructions
   */
  constructor(e, t, i, n) {
    this.overlaps = i, this.pixelRatio = t, this.resolution = e, this.alignFill_, this.instructions = n.instructions, this.coordinates = n.coordinates, this.coordinateCache_ = {}, this.renderedTransform_ = Se(), this.hitDetectionInstructions = n.hitDetectionInstructions, this.pixelCoordinates_ = null, this.viewRotation_ = 0, this.fillStates = n.fillStates || {}, this.strokeStates = n.strokeStates || {}, this.textStates = n.textStates || {}, this.widths_ = {}, this.labels_ = {};
  }
  /**
   * @param {string|Array<string>} text Text.
   * @param {string} textKey Text style key.
   * @param {string} fillKey Fill style key.
   * @param {string} strokeKey Stroke style key.
   * @return {import("../canvas.js").Label} Label.
   */
  createLabel(e, t, i, n) {
    const r = e + t + i + n;
    if (this.labels_[r])
      return this.labels_[r];
    const o = n ? this.strokeStates[n] : null, a = i ? this.fillStates[i] : null, l = this.textStates[t], h = this.pixelRatio, c = [
      l.scale[0] * h,
      l.scale[1] * h
    ], u = Array.isArray(e), d = l.justify ? bn[l.justify] : Yl(
      Array.isArray(e) ? e[0] : e,
      l.textAlign || Vn
    ), f = n && o.lineWidth ? o.lineWidth : 0, g = u ? e : e.split(`
`).reduce(c_, []), { width: _, height: m, widths: p, heights: x, lineWidths: y } = bf(
      l,
      g
    ), E = _ + f, C = [], T = (E + 2) * c[0], w = (m + f) * c[1], L = {
      width: T < 0 ? Math.floor(T) : Math.ceil(T),
      height: w < 0 ? Math.floor(w) : Math.ceil(w),
      contextInstructions: C
    };
    (c[0] != 1 || c[1] != 1) && C.push("scale", c), n && (C.push("strokeStyle", o.strokeStyle), C.push("lineWidth", f), C.push("lineCap", o.lineCap), C.push("lineJoin", o.lineJoin), C.push("miterLimit", o.miterLimit), C.push("setLineDash", [o.lineDash]), C.push("lineDashOffset", o.lineDashOffset)), i && C.push("fillStyle", a.fillStyle), C.push("textBaseline", "middle"), C.push("textAlign", "center");
    const I = 0.5 - d;
    let S = d * E + I * f;
    const Y = [], V = [];
    let P = 0, q = 0, F = 0, b = 0, A;
    for (let j = 0, Q = g.length; j < Q; j += 2) {
      const ee = g[j];
      if (ee === `
`) {
        q += P, P = 0, S = d * E + I * f, ++b;
        continue;
      }
      const me = g[j + 1] || l.font;
      me !== A && (n && Y.push("font", me), i && V.push("font", me), A = me), P = Math.max(P, x[F]);
      const R = [
        ee,
        S + I * p[F] + d * (p[F] - y[b]),
        0.5 * (f + P) + q
      ];
      S += p[F], n && Y.push("strokeText", R), i && V.push("fillText", R), ++F;
    }
    return Array.prototype.push.apply(C, Y), Array.prototype.push.apply(C, V), this.labels_[r] = L, L;
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../coordinate.js").Coordinate} p1 1st point of the background box.
   * @param {import("../../coordinate.js").Coordinate} p2 2nd point of the background box.
   * @param {import("../../coordinate.js").Coordinate} p3 3rd point of the background box.
   * @param {import("../../coordinate.js").Coordinate} p4 4th point of the background box.
   * @param {Array<*>} fillInstruction Fill instruction.
   * @param {Array<*>} strokeInstruction Stroke instruction.
   */
  replayTextBackground_(e, t, i, n, r, o, a) {
    e.beginPath(), e.moveTo.apply(e, t), e.lineTo.apply(e, i), e.lineTo.apply(e, n), e.lineTo.apply(e, r), e.lineTo.apply(e, t), o && (this.alignFill_ = /** @type {boolean} */
    o[2], this.fill_(e)), a && (this.setStrokeStyle_(
      e,
      /** @type {Array<*>} */
      a
    ), e.stroke());
  }
  /**
   * @private
   * @param {number} sheetWidth Width of the sprite sheet.
   * @param {number} sheetHeight Height of the sprite sheet.
   * @param {number} centerX X.
   * @param {number} centerY Y.
   * @param {number} width Width.
   * @param {number} height Height.
   * @param {number} anchorX Anchor X.
   * @param {number} anchorY Anchor Y.
   * @param {number} originX Origin X.
   * @param {number} originY Origin Y.
   * @param {number} rotation Rotation.
   * @param {import("../../size.js").Size} scale Scale.
   * @param {boolean} snapToPixel Snap to pixel.
   * @param {Array<number>} padding Padding.
   * @param {boolean} fillStroke Background fill or stroke.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @return {ImageOrLabelDimensions} Dimensions for positioning and decluttering the image or label.
   */
  calculateImageOrLabelDimensions_(e, t, i, n, r, o, a, l, h, c, u, d, f, g, _, m) {
    a *= d[0], l *= d[1];
    let p = i - a, x = n - l;
    const y = r + h > e ? e - h : r, E = o + c > t ? t - c : o, C = g[3] + y * d[0] + g[1], T = g[0] + E * d[1] + g[2], w = p - g[3], L = x - g[0];
    (_ || u !== 0) && (Wt[0] = w, Yt[0] = w, Wt[1] = L, Tt[1] = L, Tt[0] = w + C, St[0] = Tt[0], St[1] = L + T, Yt[1] = St[1]);
    let I;
    return u !== 0 ? (I = Je(
      Se(),
      i,
      n,
      1,
      1,
      u,
      -i,
      -n
    ), de(I, Wt), de(I, Tt), de(I, St), de(I, Yt), pt(
      Math.min(Wt[0], Tt[0], St[0], Yt[0]),
      Math.min(Wt[1], Tt[1], St[1], Yt[1]),
      Math.max(Wt[0], Tt[0], St[0], Yt[0]),
      Math.max(Wt[1], Tt[1], St[1], Yt[1]),
      Ni
    )) : pt(
      Math.min(w, w + C),
      Math.min(L, L + T),
      Math.max(w, w + C),
      Math.max(L, L + T),
      Ni
    ), f && (p = Math.round(p), x = Math.round(x)), {
      drawImageX: p,
      drawImageY: x,
      drawImageW: y,
      drawImageH: E,
      originX: h,
      originY: c,
      declutterBox: {
        minX: Ni[0],
        minY: Ni[1],
        maxX: Ni[2],
        maxY: Ni[3],
        value: m
      },
      canvasTransform: I,
      scale: d
    };
  }
  /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   * @param {number} contextScale Scale of the context.
   * @param {import("../canvas.js").Label|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} imageOrLabel Image.
   * @param {ImageOrLabelDimensions} dimensions Dimensions.
   * @param {number} opacity Opacity.
   * @param {Array<*>} fillInstruction Fill instruction.
   * @param {Array<*>} strokeInstruction Stroke instruction.
   * @return {boolean} The image or label was rendered.
   */
  replayImageOrLabel_(e, t, i, n, r, o, a) {
    const l = !!(o || a), h = n.declutterBox, c = e.canvas, u = a ? a[2] * n.scale[0] / 2 : 0;
    return h.minX - u <= c.width / t && h.maxX + u >= 0 && h.minY - u <= c.height / t && h.maxY + u >= 0 && (l && this.replayTextBackground_(
      e,
      Wt,
      Tt,
      St,
      Yt,
      /** @type {Array<*>} */
      o,
      /** @type {Array<*>} */
      a
    ), Pf(
      e,
      n.canvasTransform,
      r,
      i,
      n.originX,
      n.originY,
      n.drawImageW,
      n.drawImageH,
      n.drawImageX,
      n.drawImageY,
      n.scale
    )), !0;
  }
  /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   */
  fill_(e) {
    if (this.alignFill_) {
      const t = de(this.renderedTransform_, [0, 0]), i = 512 * this.pixelRatio;
      e.save(), e.translate(t[0] % i, t[1] % i), e.rotate(this.viewRotation_);
    }
    e.fill(), this.alignFill_ && e.restore();
  }
  /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   * @param {Array<*>} instruction Instruction.
   */
  setStrokeStyle_(e, t) {
    e.strokeStyle = /** @type {import("../../colorlike.js").ColorLike} */
    t[1], e.lineWidth = /** @type {number} */
    t[2], e.lineCap = /** @type {CanvasLineCap} */
    t[3], e.lineJoin = /** @type {CanvasLineJoin} */
    t[4], e.miterLimit = /** @type {number} */
    t[5], e.lineDashOffset = /** @type {number} */
    t[7], e.setLineDash(
      /** @type {Array<number>} */
      t[6]
    );
  }
  /**
   * @private
   * @param {string|Array<string>} text The text to draw.
   * @param {string} textKey The key of the text state.
   * @param {string} strokeKey The key for the stroke state.
   * @param {string} fillKey The key for the fill state.
   * @return {{label: import("../canvas.js").Label, anchorX: number, anchorY: number}} The text image and its anchor.
   */
  drawLabelWithPointPlacement_(e, t, i, n) {
    const r = this.textStates[t], o = this.createLabel(e, t, n, i), a = this.strokeStates[i], l = this.pixelRatio, h = Yl(
      Array.isArray(e) ? e[0] : e,
      r.textAlign || Vn
    ), c = bn[r.textBaseline || cr], u = a && a.lineWidth ? a.lineWidth : 0, d = o.width / l - 2 * r.scale[0], f = h * d + 2 * (0.5 - h) * u, g = c * o.height / l + 2 * (0.5 - c) * u;
    return {
      label: o,
      anchorX: f,
      anchorY: g
    };
  }
  /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   * @param {number} contextScale Scale of the context.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {Array<*>} instructions Instructions array.
   * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.
   * @param {FeatureCallback<T>} [featureCallback] Feature callback.
   * @param {import("../../extent.js").Extent} [hitExtent] Only check
   *     features that intersect this extent.
   * @param {import("rbush").default} [declutterTree] Declutter tree.
   * @return {T|undefined} Callback result.
   * @template T
   */
  execute_(e, t, i, n, r, o, a, l) {
    let h;
    this.pixelCoordinates_ && xt(i, this.renderedTransform_) ? h = this.pixelCoordinates_ : (this.pixelCoordinates_ || (this.pixelCoordinates_ = []), h = xi(
      this.coordinates,
      0,
      this.coordinates.length,
      2,
      i,
      this.pixelCoordinates_
    ), ed(this.renderedTransform_, i));
    let c = 0;
    const u = n.length;
    let d = 0, f, g, _, m, p, x, y, E, C, T, w, L, I = 0, S = 0, Y = null, V = null;
    const P = this.coordinateCache_, q = this.viewRotation_, F = Math.round(Math.atan2(-i[1], i[0]) * 1e12) / 1e12, b = (
      /** @type {import("../../render.js").State} */
      {
        context: e,
        pixelRatio: this.pixelRatio,
        resolution: this.resolution,
        rotation: q
      }
    ), A = this.instructions != n || this.overlaps ? 0 : 200;
    let j, Q, ee, me;
    for (; c < u; ) {
      const R = n[c];
      switch (
        /** @type {import("./Instruction.js").default} */
        R[0]
      ) {
        case W.BEGIN_GEOMETRY:
          j = /** @type {import("../../Feature.js").FeatureLike} */
          R[1], me = R[3], j.getGeometry() ? a !== void 0 && !Ce(a, me.getExtent()) ? c = /** @type {number} */
          R[2] + 1 : ++c : c = /** @type {number} */
          R[2];
          break;
        case W.BEGIN_PATH:
          I > A && (this.fill_(e), I = 0), S > A && (e.stroke(), S = 0), !I && !S && (e.beginPath(), m = NaN, p = NaN), ++c;
          break;
        case W.CIRCLE:
          d = /** @type {number} */
          R[1];
          const ie = h[d], oe = h[d + 1], Ut = h[d + 2], ct = h[d + 3], Ie = Ut - ie, Et = ct - oe, Ai = Math.sqrt(Ie * Ie + Et * Et);
          e.moveTo(ie + Ai, oe), e.arc(ie, oe, Ai, 0, 2 * Math.PI, !0), ++c;
          break;
        case W.CLOSE_PATH:
          e.closePath(), ++c;
          break;
        case W.CUSTOM:
          d = /** @type {number} */
          R[1], f = R[2];
          const ms = (
            /** @type {import("../../geom/SimpleGeometry.js").default} */
            R[3]
          ), Fi = R[4], ps = R.length == 6 ? R[5] : void 0;
          b.geometry = ms, b.feature = j, c in P || (P[c] = []);
          const zt = P[c];
          ps ? ps(h, d, f, 2, zt) : (zt[0] = h[d], zt[1] = h[d + 1], zt.length = 2), Fi(zt, b), ++c;
          break;
        case W.DRAW_IMAGE:
          d = /** @type {number} */
          R[1], f = /** @type {number} */
          R[2], E = /** @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} */
          R[3], g = /** @type {number} */
          R[4], _ = /** @type {number} */
          R[5];
          let mn = (
            /** @type {number} */
            R[6]
          );
          const Bt = (
            /** @type {number} */
            R[7]
          ), ys = (
            /** @type {number} */
            R[8]
          ), xs = (
            /** @type {number} */
            R[9]
          ), Es = (
            /** @type {boolean} */
            R[10]
          );
          let bi = (
            /** @type {number} */
            R[11]
          );
          const Xr = (
            /** @type {import("../../size.js").Size} */
            R[12]
          );
          let Ge = (
            /** @type {number} */
            R[13]
          );
          const $e = (
            /** @type {"declutter"|"obstacle"|"none"|undefined} */
            R[14]
          ), nt = (
            /** @type {import("../canvas.js").DeclutterImageWithText} */
            R[15]
          );
          if (!E && R.length >= 20) {
            C = /** @type {string} */
            R[19], T = /** @type {string} */
            R[20], w = /** @type {string} */
            R[21], L = /** @type {string} */
            R[22];
            const Ve = this.drawLabelWithPointPlacement_(
              C,
              T,
              w,
              L
            );
            E = Ve.label, R[3] = E;
            const Oi = (
              /** @type {number} */
              R[23]
            );
            g = (Ve.anchorX - Oi) * this.pixelRatio, R[4] = g;
            const Qe = (
              /** @type {number} */
              R[24]
            );
            _ = (Ve.anchorY - Qe) * this.pixelRatio, R[5] = _, mn = E.height, R[6] = mn, Ge = E.width, R[13] = Ge;
          }
          let vt;
          R.length > 25 && (vt = /** @type {number} */
          R[25]);
          let Pi, si, Xt;
          R.length > 17 ? (Pi = /** @type {Array<number>} */
          R[16], si = /** @type {boolean} */
          R[17], Xt = /** @type {boolean} */
          R[18]) : (Pi = ui, si = !1, Xt = !1), Es && F ? bi += q : !Es && !F && (bi -= q);
          let Mi = 0;
          for (; d < f; d += 2) {
            if (vt && vt[Mi++] < Ge / this.pixelRatio)
              continue;
            const Ve = this.calculateImageOrLabelDimensions_(
              E.width,
              E.height,
              h[d],
              h[d + 1],
              Ge,
              mn,
              g,
              _,
              ys,
              xs,
              bi,
              Xr,
              r,
              Pi,
              si || Xt,
              j
            ), Oi = [
              e,
              t,
              E,
              Ve,
              Bt,
              si ? (
                /** @type {Array<*>} */
                Y
              ) : null,
              Xt ? (
                /** @type {Array<*>} */
                V
              ) : null
            ];
            if (l) {
              if ($e === "none")
                continue;
              if ($e === "obstacle") {
                l.insert(Ve.declutterBox);
                continue;
              } else {
                let Qe, Ct;
                if (nt) {
                  const Ze = f - d;
                  if (!nt[Ze]) {
                    nt[Ze] = Oi;
                    continue;
                  }
                  if (Qe = nt[Ze], delete nt[Ze], Ct = Wl(Qe), l.collides(Ct))
                    continue;
                }
                if (l.collides(Ve.declutterBox))
                  continue;
                Qe && (l.insert(Ct), this.replayImageOrLabel_.apply(this, Qe)), l.insert(Ve.declutterBox);
              }
            }
            this.replayImageOrLabel_.apply(this, Oi);
          }
          ++c;
          break;
        case W.DRAW_CHARS:
          const vs = (
            /** @type {number} */
            R[1]
          ), Oe = (
            /** @type {number} */
            R[2]
          ), Wr = (
            /** @type {number} */
            R[3]
          ), bu = (
            /** @type {number} */
            R[4]
          );
          L = /** @type {string} */
          R[5];
          const Pu = (
            /** @type {number} */
            R[6]
          ), hl = (
            /** @type {number} */
            R[7]
          ), cl = (
            /** @type {number} */
            R[8]
          );
          w = /** @type {string} */
          R[9];
          const Yr = (
            /** @type {number} */
            R[10]
          );
          C = /** @type {string} */
          R[11], T = /** @type {string} */
          R[12];
          const ul = [
            /** @type {number} */
            R[13],
            /** @type {number} */
            R[13]
          ], Vr = this.textStates[T], pn = Vr.font, yn = [
            Vr.scale[0] * hl,
            Vr.scale[1] * hl
          ];
          let xn;
          pn in this.widths_ ? xn = this.widths_[pn] : (xn = {}, this.widths_[pn] = xn);
          const dl = Ac(h, vs, Oe, 2), fl = Math.abs(yn[0]) * Ml(pn, C, xn);
          if (bu || fl <= dl) {
            const Ve = this.textStates[T].textAlign, Oi = (dl - fl) * bn[Ve], Qe = l_(
              h,
              vs,
              Oe,
              2,
              C,
              Oi,
              Pu,
              Math.abs(yn[0]),
              Ml,
              pn,
              xn,
              F ? 0 : this.viewRotation_
            );
            e:
              if (Qe) {
                const Ct = [];
                let Ze, Cs, ws, Ue, et;
                if (w)
                  for (Ze = 0, Cs = Qe.length; Ze < Cs; ++Ze) {
                    et = Qe[Ze], ws = /** @type {string} */
                    et[4], Ue = this.createLabel(ws, T, "", w), g = /** @type {number} */
                    et[2] + (yn[0] < 0 ? -Yr : Yr), _ = Wr * Ue.height + (0.5 - Wr) * 2 * Yr * yn[1] / yn[0] - cl;
                    const wt = this.calculateImageOrLabelDimensions_(
                      Ue.width,
                      Ue.height,
                      et[0],
                      et[1],
                      Ue.width,
                      Ue.height,
                      g,
                      _,
                      0,
                      0,
                      et[3],
                      ul,
                      !1,
                      ui,
                      !1,
                      j
                    );
                    if (l && l.collides(wt.declutterBox))
                      break e;
                    Ct.push([
                      e,
                      t,
                      Ue,
                      wt,
                      1,
                      null,
                      null
                    ]);
                  }
                if (L)
                  for (Ze = 0, Cs = Qe.length; Ze < Cs; ++Ze) {
                    et = Qe[Ze], ws = /** @type {string} */
                    et[4], Ue = this.createLabel(ws, T, L, ""), g = /** @type {number} */
                    et[2], _ = Wr * Ue.height - cl;
                    const wt = this.calculateImageOrLabelDimensions_(
                      Ue.width,
                      Ue.height,
                      et[0],
                      et[1],
                      Ue.width,
                      Ue.height,
                      g,
                      _,
                      0,
                      0,
                      et[3],
                      ul,
                      !1,
                      ui,
                      !1,
                      j
                    );
                    if (l && l.collides(wt.declutterBox))
                      break e;
                    Ct.push([
                      e,
                      t,
                      Ue,
                      wt,
                      1,
                      null,
                      null
                    ]);
                  }
                l && l.load(Ct.map(Wl));
                for (let wt = 0, Mu = Ct.length; wt < Mu; ++wt)
                  this.replayImageOrLabel_.apply(this, Ct[wt]);
              }
          }
          ++c;
          break;
        case W.END_GEOMETRY:
          if (o !== void 0) {
            j = /** @type {import("../../Feature.js").FeatureLike} */
            R[1];
            const Ve = o(j, me);
            if (Ve)
              return Ve;
          }
          ++c;
          break;
        case W.FILL:
          A ? I++ : this.fill_(e), ++c;
          break;
        case W.MOVE_TO_LINE_TO:
          for (d = /** @type {number} */
          R[1], f = /** @type {number} */
          R[2], Q = h[d], ee = h[d + 1], x = Q + 0.5 | 0, y = ee + 0.5 | 0, (x !== m || y !== p) && (e.moveTo(Q, ee), m = x, p = y), d += 2; d < f; d += 2)
            Q = h[d], ee = h[d + 1], x = Q + 0.5 | 0, y = ee + 0.5 | 0, (d == f - 2 || x !== m || y !== p) && (e.lineTo(Q, ee), m = x, p = y);
          ++c;
          break;
        case W.SET_FILL_STYLE:
          Y = R, this.alignFill_ = R[2], I && (this.fill_(e), I = 0, S && (e.stroke(), S = 0)), e.fillStyle = /** @type {import("../../colorlike.js").ColorLike} */
          R[1], ++c;
          break;
        case W.SET_STROKE_STYLE:
          V = R, S && (e.stroke(), S = 0), this.setStrokeStyle_(
            e,
            /** @type {Array<*>} */
            R
          ), ++c;
          break;
        case W.STROKE:
          A ? S++ : e.stroke(), ++c;
          break;
        default:
          ++c;
          break;
      }
    }
    I && this.fill_(e), S && e.stroke();
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {number} contextScale Scale of the context.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.
   * @param {import("rbush").default} [declutterTree] Declutter tree.
   */
  execute(e, t, i, n, r, o) {
    this.viewRotation_ = n, this.execute_(
      e,
      t,
      i,
      this.instructions,
      r,
      void 0,
      void 0,
      o
    );
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {FeatureCallback<T>} [featureCallback] Feature callback.
   * @param {import("../../extent.js").Extent} [hitExtent] Only check
   *     features that intersect this extent.
   * @return {T|undefined} Callback result.
   * @template T
   */
  executeHitDetection(e, t, i, n, r) {
    return this.viewRotation_ = i, this.execute_(
      e,
      1,
      t,
      this.hitDetectionInstructions,
      !0,
      n,
      r
    );
  }
}
const d_ = u_, io = ["Polygon", "Circle", "LineString", "Image", "Text", "Default"];
class f_ {
  /**
   * @param {import("../../extent.js").Extent} maxExtent Max extent for clipping. When a
   * `maxExtent` was set on the Builder for this executor group, the same `maxExtent`
   * should be set here, unless the target context does not exceed that extent (which
   * can be the case when rendering to tiles).
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {boolean} overlaps The executor group can have overlapping geometries.
   * @param {!Object<string, !Object<import("../canvas.js").BuilderType, import("../canvas.js").SerializableInstructions>>} allInstructions
   * The serializable instructions.
   * @param {number} [renderBuffer] Optional rendering buffer.
   */
  constructor(e, t, i, n, r, o) {
    this.maxExtent_ = e, this.overlaps_ = n, this.pixelRatio_ = i, this.resolution_ = t, this.renderBuffer_ = o, this.executorsByZIndex_ = {}, this.hitDetectionContext_ = null, this.hitDetectionTransform_ = Se(), this.createExecutors_(r);
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../transform.js").Transform} transform Transform.
   */
  clip(e, t) {
    const i = this.getClipCoords(t);
    e.beginPath(), e.moveTo(i[0], i[1]), e.lineTo(i[2], i[3]), e.lineTo(i[4], i[5]), e.lineTo(i[6], i[7]), e.clip();
  }
  /**
   * Create executors and populate them using the provided instructions.
   * @private
   * @param {!Object<string, !Object<import("../canvas.js").BuilderType, import("../canvas.js").SerializableInstructions>>} allInstructions The serializable instructions
   */
  createExecutors_(e) {
    for (const t in e) {
      let i = this.executorsByZIndex_[t];
      i === void 0 && (i = {}, this.executorsByZIndex_[t] = i);
      const n = e[t];
      for (const r in n) {
        const o = n[r];
        i[r] = new d_(
          this.resolution_,
          this.pixelRatio_,
          this.overlaps_,
          o
        );
      }
    }
  }
  /**
   * @param {Array<import("../canvas.js").BuilderType>} executors Executors.
   * @return {boolean} Has executors of the provided types.
   */
  hasExecutors(e) {
    for (const t in this.executorsByZIndex_) {
      const i = this.executorsByZIndex_[t];
      for (let n = 0, r = e.length; n < r; ++n)
        if (e[n] in i)
          return !0;
    }
    return !1;
  }
  /**
   * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {function(import("../../Feature.js").FeatureLike, import("../../geom/SimpleGeometry.js").default, number): T} callback Feature callback.
   * @param {Array<import("../../Feature.js").FeatureLike>} declutteredFeatures Decluttered features.
   * @return {T|undefined} Callback result.
   * @template T
   */
  forEachFeatureAtCoordinate(e, t, i, n, r, o) {
    n = Math.round(n);
    const a = n * 2 + 1, l = Je(
      this.hitDetectionTransform_,
      n + 0.5,
      n + 0.5,
      1 / t,
      -1 / t,
      -i,
      -e[0],
      -e[1]
    ), h = !this.hitDetectionContext_;
    h && (this.hitDetectionContext_ = Re(
      a,
      a,
      void 0,
      { willReadFrequently: !0 }
    ));
    const c = this.hitDetectionContext_;
    c.canvas.width !== a || c.canvas.height !== a ? (c.canvas.width = a, c.canvas.height = a) : h || c.clearRect(0, 0, a, a);
    let u;
    this.renderBuffer_ !== void 0 && (u = Me(), Ln(u, e), Si(
      u,
      t * (this.renderBuffer_ + n),
      u
    ));
    const d = g_(n);
    let f;
    function g(C, T) {
      const w = c.getImageData(
        0,
        0,
        a,
        a
      ).data;
      for (let L = 0, I = d.length; L < I; L++)
        if (w[d[L]] > 0) {
          if (!o || f !== "Image" && f !== "Text" || o.includes(C)) {
            const S = (d[L] - 3) / 4, Y = n - S % a, V = n - (S / a | 0), P = r(C, T, Y * Y + V * V);
            if (P)
              return P;
          }
          c.clearRect(0, 0, a, a);
          break;
        }
    }
    const _ = Object.keys(this.executorsByZIndex_).map(Number);
    _.sort(vi);
    let m, p, x, y, E;
    for (m = _.length - 1; m >= 0; --m) {
      const C = _[m].toString();
      for (x = this.executorsByZIndex_[C], p = io.length - 1; p >= 0; --p)
        if (f = io[p], y = x[f], y !== void 0 && (E = y.executeHitDetection(
          c,
          l,
          i,
          g,
          u
        ), E))
          return E;
    }
  }
  /**
   * @param {import("../../transform.js").Transform} transform Transform.
   * @return {Array<number>|null} Clip coordinates.
   */
  getClipCoords(e) {
    const t = this.maxExtent_;
    if (!t)
      return null;
    const i = t[0], n = t[1], r = t[2], o = t[3], a = [i, n, i, o, r, o, r, n];
    return xi(a, 0, 8, 2, e, a), a;
  }
  /**
   * @return {boolean} Is empty.
   */
  isEmpty() {
    return sn(this.executorsByZIndex_);
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {number} contextScale Scale of the context.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {boolean} snapToPixel Snap point symbols and test to integer pixel.
   * @param {Array<import("../canvas.js").BuilderType>} [builderTypes] Ordered replay types to replay.
   *     Default is {@link module:ol/render/replay~ORDER}
   * @param {import("rbush").default} [declutterTree] Declutter tree.
   */
  execute(e, t, i, n, r, o, a) {
    const l = Object.keys(this.executorsByZIndex_).map(Number);
    l.sort(vi), this.maxExtent_ && (e.save(), this.clip(e, i)), o = o || io;
    let h, c, u, d, f, g;
    for (a && l.reverse(), h = 0, c = l.length; h < c; ++h) {
      const _ = l[h].toString();
      for (f = this.executorsByZIndex_[_], u = 0, d = o.length; u < d; ++u) {
        const m = o[u];
        g = f[m], g !== void 0 && g.execute(
          e,
          t,
          i,
          n,
          r,
          a
        );
      }
    }
    this.maxExtent_ && e.restore();
  }
}
const no = {};
function g_(s) {
  if (no[s] !== void 0)
    return no[s];
  const e = s * 2 + 1, t = s * s, i = new Array(t + 1);
  for (let r = 0; r <= s; ++r)
    for (let o = 0; o <= s; ++o) {
      const a = r * r + o * o;
      if (a > t)
        break;
      let l = i[a];
      l || (l = [], i[a] = l), l.push(((s + r) * e + (s + o)) * 4 + 3), r > 0 && l.push(((s - r) * e + (s + o)) * 4 + 3), o > 0 && (l.push(((s + r) * e + (s - o)) * 4 + 3), r > 0 && l.push(((s - r) * e + (s - o)) * 4 + 3));
    }
  const n = [];
  for (let r = 0, o = i.length; r < o; ++r)
    i[r] && n.push(...i[r]);
  return no[s] = n, n;
}
const Vl = f_;
class __ extends Lc {
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../../extent.js").Extent} extent Extent.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {number} [squaredTolerance] Optional squared tolerance for simplification.
   * @param {import("../../proj.js").TransformFunction} [userTransform] Transform from user to view projection.
   */
  constructor(e, t, i, n, r, o, a) {
    super(), this.context_ = e, this.pixelRatio_ = t, this.extent_ = i, this.transform_ = n, this.transformRotation_ = n ? Sr(Math.atan2(n[1], n[0]), 10) : 0, this.viewRotation_ = r, this.squaredTolerance_ = o, this.userTransform_ = a, this.contextFillState_ = null, this.contextStrokeState_ = null, this.contextTextState_ = null, this.fillState_ = null, this.strokeState_ = null, this.image_ = null, this.imageAnchorX_ = 0, this.imageAnchorY_ = 0, this.imageHeight_ = 0, this.imageOpacity_ = 0, this.imageOriginX_ = 0, this.imageOriginY_ = 0, this.imageRotateWithView_ = !1, this.imageRotation_ = 0, this.imageScale_ = [0, 0], this.imageWidth_ = 0, this.text_ = "", this.textOffsetX_ = 0, this.textOffsetY_ = 0, this.textRotateWithView_ = !1, this.textRotation_ = 0, this.textScale_ = [0, 0], this.textFillState_ = null, this.textStrokeState_ = null, this.textState_ = null, this.pixelCoordinates_ = [], this.tmpLocalTransform_ = Se();
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @private
   */
  drawImages_(e, t, i, n) {
    if (!this.image_)
      return;
    const r = xi(
      e,
      t,
      i,
      n,
      this.transform_,
      this.pixelCoordinates_
    ), o = this.context_, a = this.tmpLocalTransform_, l = o.globalAlpha;
    this.imageOpacity_ != 1 && (o.globalAlpha = l * this.imageOpacity_);
    let h = this.imageRotation_;
    this.transformRotation_ === 0 && (h -= this.viewRotation_), this.imageRotateWithView_ && (h += this.viewRotation_);
    for (let c = 0, u = r.length; c < u; c += 2) {
      const d = r[c] - this.imageAnchorX_, f = r[c + 1] - this.imageAnchorY_;
      if (h !== 0 || this.imageScale_[0] != 1 || this.imageScale_[1] != 1) {
        const g = d + this.imageAnchorX_, _ = f + this.imageAnchorY_;
        Je(
          a,
          g,
          _,
          1,
          1,
          h,
          -g,
          -_
        ), o.setTransform.apply(o, a), o.translate(g, _), o.scale(this.imageScale_[0], this.imageScale_[1]), o.drawImage(
          this.image_,
          this.imageOriginX_,
          this.imageOriginY_,
          this.imageWidth_,
          this.imageHeight_,
          -this.imageAnchorX_,
          -this.imageAnchorY_,
          this.imageWidth_,
          this.imageHeight_
        ), o.setTransform(1, 0, 0, 1, 0, 0);
      } else
        o.drawImage(
          this.image_,
          this.imageOriginX_,
          this.imageOriginY_,
          this.imageWidth_,
          this.imageHeight_,
          d,
          f,
          this.imageWidth_,
          this.imageHeight_
        );
    }
    this.imageOpacity_ != 1 && (o.globalAlpha = l);
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @private
   */
  drawText_(e, t, i, n) {
    if (!this.textState_ || this.text_ === "")
      return;
    this.textFillState_ && this.setContextFillState_(this.textFillState_), this.textStrokeState_ && this.setContextStrokeState_(this.textStrokeState_), this.setContextTextState_(this.textState_);
    const r = xi(
      e,
      t,
      i,
      n,
      this.transform_,
      this.pixelCoordinates_
    ), o = this.context_;
    let a = this.textRotation_;
    for (this.transformRotation_ === 0 && (a -= this.viewRotation_), this.textRotateWithView_ && (a += this.viewRotation_); t < i; t += n) {
      const l = r[t] + this.textOffsetX_, h = r[t + 1] + this.textOffsetY_;
      a !== 0 || this.textScale_[0] != 1 || this.textScale_[1] != 1 ? (o.translate(l - this.textOffsetX_, h - this.textOffsetY_), o.rotate(a), o.translate(this.textOffsetX_, this.textOffsetY_), o.scale(this.textScale_[0], this.textScale_[1]), this.textStrokeState_ && o.strokeText(this.text_, 0, 0), this.textFillState_ && o.fillText(this.text_, 0, 0), o.setTransform(1, 0, 0, 1, 0, 0)) : (this.textStrokeState_ && o.strokeText(this.text_, l, h), this.textFillState_ && o.fillText(this.text_, l, h));
    }
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {boolean} close Close.
   * @private
   * @return {number} end End.
   */
  moveToLineTo_(e, t, i, n, r) {
    const o = this.context_, a = xi(
      e,
      t,
      i,
      n,
      this.transform_,
      this.pixelCoordinates_
    );
    o.moveTo(a[0], a[1]);
    let l = a.length;
    r && (l -= 2);
    for (let h = 2; h < l; h += 2)
      o.lineTo(a[h], a[h + 1]);
    return r && o.closePath(), i;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @private
   * @return {number} End.
   */
  drawRings_(e, t, i, n) {
    for (let r = 0, o = i.length; r < o; ++r)
      t = this.moveToLineTo_(
        e,
        t,
        i[r],
        n,
        !0
      );
    return t;
  }
  /**
   * Render a circle geometry into the canvas.  Rendering is immediate and uses
   * the current fill and stroke styles.
   *
   * @param {import("../../geom/Circle.js").default} geometry Circle geometry.
   * @api
   */
  drawCircle(e) {
    if (Ce(this.extent_, e.getExtent())) {
      if (this.fillState_ || this.strokeState_) {
        this.fillState_ && this.setContextFillState_(this.fillState_), this.strokeState_ && this.setContextStrokeState_(this.strokeState_);
        const t = qd(
          e,
          this.transform_,
          this.pixelCoordinates_
        ), i = t[2] - t[0], n = t[3] - t[1], r = Math.sqrt(i * i + n * n), o = this.context_;
        o.beginPath(), o.arc(
          t[0],
          t[1],
          r,
          0,
          2 * Math.PI
        ), this.fillState_ && o.fill(), this.strokeState_ && o.stroke();
      }
      this.text_ !== "" && this.drawText_(e.getCenter(), 0, 2, 2);
    }
  }
  /**
   * Set the rendering style.  Note that since this is an immediate rendering API,
   * any `zIndex` on the provided style will be ignored.
   *
   * @param {import("../../style/Style.js").default} style The rendering style.
   * @api
   */
  setStyle(e) {
    this.setFillStrokeStyle(e.getFill(), e.getStroke()), this.setImageStyle(e.getImage()), this.setTextStyle(e.getText());
  }
  /**
   * @param {import("../../transform.js").Transform} transform Transform.
   */
  setTransform(e) {
    this.transform_ = e;
  }
  /**
   * Render a geometry into the canvas.  Call
   * {@link module:ol/render/canvas/Immediate~CanvasImmediateRenderer#setStyle renderer.setStyle()} first to set the rendering style.
   *
   * @param {import("../../geom/Geometry.js").default|import("../Feature.js").default} geometry The geometry to render.
   * @api
   */
  drawGeometry(e) {
    switch (e.getType()) {
      case "Point":
        this.drawPoint(
          /** @type {import("../../geom/Point.js").default} */
          e
        );
        break;
      case "LineString":
        this.drawLineString(
          /** @type {import("../../geom/LineString.js").default} */
          e
        );
        break;
      case "Polygon":
        this.drawPolygon(
          /** @type {import("../../geom/Polygon.js").default} */
          e
        );
        break;
      case "MultiPoint":
        this.drawMultiPoint(
          /** @type {import("../../geom/MultiPoint.js").default} */
          e
        );
        break;
      case "MultiLineString":
        this.drawMultiLineString(
          /** @type {import("../../geom/MultiLineString.js").default} */
          e
        );
        break;
      case "MultiPolygon":
        this.drawMultiPolygon(
          /** @type {import("../../geom/MultiPolygon.js").default} */
          e
        );
        break;
      case "GeometryCollection":
        this.drawGeometryCollection(
          /** @type {import("../../geom/GeometryCollection.js").default} */
          e
        );
        break;
      case "Circle":
        this.drawCircle(
          /** @type {import("../../geom/Circle.js").default} */
          e
        );
        break;
    }
  }
  /**
   * Render a feature into the canvas.  Note that any `zIndex` on the provided
   * style will be ignored - features are rendered immediately in the order that
   * this method is called.  If you need `zIndex` support, you should be using an
   * {@link module:ol/layer/Vector~VectorLayer} instead.
   *
   * @param {import("../../Feature.js").default} feature Feature.
   * @param {import("../../style/Style.js").default} style Style.
   * @api
   */
  drawFeature(e, t) {
    const i = t.getGeometryFunction()(e);
    !i || !Ce(this.extent_, i.getExtent()) || (this.setStyle(t), this.drawGeometry(i));
  }
  /**
   * Render a GeometryCollection to the canvas.  Rendering is immediate and
   * uses the current styles appropriate for each geometry in the collection.
   *
   * @param {import("../../geom/GeometryCollection.js").default} geometry Geometry collection.
   */
  drawGeometryCollection(e) {
    const t = e.getGeometriesArray();
    for (let i = 0, n = t.length; i < n; ++i)
      this.drawGeometry(t[i]);
  }
  /**
   * Render a Point geometry into the canvas.  Rendering is immediate and uses
   * the current style.
   *
   * @param {import("../../geom/Point.js").default|import("../Feature.js").default} geometry Point geometry.
   */
  drawPoint(e) {
    this.squaredTolerance_ && (e = /** @type {import("../../geom/Point.js").default} */
    e.simplifyTransformed(
      this.squaredTolerance_,
      this.userTransform_
    ));
    const t = e.getFlatCoordinates(), i = e.getStride();
    this.image_ && this.drawImages_(t, 0, t.length, i), this.text_ !== "" && this.drawText_(t, 0, t.length, i);
  }
  /**
   * Render a MultiPoint geometry  into the canvas.  Rendering is immediate and
   * uses the current style.
   *
   * @param {import("../../geom/MultiPoint.js").default|import("../Feature.js").default} geometry MultiPoint geometry.
   */
  drawMultiPoint(e) {
    this.squaredTolerance_ && (e = /** @type {import("../../geom/MultiPoint.js").default} */
    e.simplifyTransformed(
      this.squaredTolerance_,
      this.userTransform_
    ));
    const t = e.getFlatCoordinates(), i = e.getStride();
    this.image_ && this.drawImages_(t, 0, t.length, i), this.text_ !== "" && this.drawText_(t, 0, t.length, i);
  }
  /**
   * Render a LineString into the canvas.  Rendering is immediate and uses
   * the current style.
   *
   * @param {import("../../geom/LineString.js").default|import("../Feature.js").default} geometry LineString geometry.
   */
  drawLineString(e) {
    if (this.squaredTolerance_ && (e = /** @type {import("../../geom/LineString.js").default} */
    e.simplifyTransformed(
      this.squaredTolerance_,
      this.userTransform_
    )), !!Ce(this.extent_, e.getExtent())) {
      if (this.strokeState_) {
        this.setContextStrokeState_(this.strokeState_);
        const t = this.context_, i = e.getFlatCoordinates();
        t.beginPath(), this.moveToLineTo_(
          i,
          0,
          i.length,
          e.getStride(),
          !1
        ), t.stroke();
      }
      if (this.text_ !== "") {
        const t = e.getFlatMidpoint();
        this.drawText_(t, 0, 2, 2);
      }
    }
  }
  /**
   * Render a MultiLineString geometry into the canvas.  Rendering is immediate
   * and uses the current style.
   *
   * @param {import("../../geom/MultiLineString.js").default|import("../Feature.js").default} geometry MultiLineString geometry.
   */
  drawMultiLineString(e) {
    this.squaredTolerance_ && (e = /** @type {import("../../geom/MultiLineString.js").default} */
    e.simplifyTransformed(
      this.squaredTolerance_,
      this.userTransform_
    ));
    const t = e.getExtent();
    if (Ce(this.extent_, t)) {
      if (this.strokeState_) {
        this.setContextStrokeState_(this.strokeState_);
        const i = this.context_, n = e.getFlatCoordinates();
        let r = 0;
        const o = (
          /** @type {Array<number>} */
          e.getEnds()
        ), a = e.getStride();
        i.beginPath();
        for (let l = 0, h = o.length; l < h; ++l)
          r = this.moveToLineTo_(
            n,
            r,
            o[l],
            a,
            !1
          );
        i.stroke();
      }
      if (this.text_ !== "") {
        const i = e.getFlatMidpoints();
        this.drawText_(i, 0, i.length, 2);
      }
    }
  }
  /**
   * Render a Polygon geometry into the canvas.  Rendering is immediate and uses
   * the current style.
   *
   * @param {import("../../geom/Polygon.js").default|import("../Feature.js").default} geometry Polygon geometry.
   */
  drawPolygon(e) {
    if (this.squaredTolerance_ && (e = /** @type {import("../../geom/Polygon.js").default} */
    e.simplifyTransformed(
      this.squaredTolerance_,
      this.userTransform_
    )), !!Ce(this.extent_, e.getExtent())) {
      if (this.strokeState_ || this.fillState_) {
        this.fillState_ && this.setContextFillState_(this.fillState_), this.strokeState_ && this.setContextStrokeState_(this.strokeState_);
        const t = this.context_;
        t.beginPath(), this.drawRings_(
          e.getOrientedFlatCoordinates(),
          0,
          /** @type {Array<number>} */
          e.getEnds(),
          e.getStride()
        ), this.fillState_ && t.fill(), this.strokeState_ && t.stroke();
      }
      if (this.text_ !== "") {
        const t = e.getFlatInteriorPoint();
        this.drawText_(t, 0, 2, 2);
      }
    }
  }
  /**
   * Render MultiPolygon geometry into the canvas.  Rendering is immediate and
   * uses the current style.
   * @param {import("../../geom/MultiPolygon.js").default} geometry MultiPolygon geometry.
   */
  drawMultiPolygon(e) {
    if (this.squaredTolerance_ && (e = /** @type {import("../../geom/MultiPolygon.js").default} */
    e.simplifyTransformed(
      this.squaredTolerance_,
      this.userTransform_
    )), !!Ce(this.extent_, e.getExtent())) {
      if (this.strokeState_ || this.fillState_) {
        this.fillState_ && this.setContextFillState_(this.fillState_), this.strokeState_ && this.setContextStrokeState_(this.strokeState_);
        const t = this.context_, i = e.getOrientedFlatCoordinates();
        let n = 0;
        const r = e.getEndss(), o = e.getStride();
        t.beginPath();
        for (let a = 0, l = r.length; a < l; ++a) {
          const h = r[a];
          n = this.drawRings_(i, n, h, o);
        }
        this.fillState_ && t.fill(), this.strokeState_ && t.stroke();
      }
      if (this.text_ !== "") {
        const t = e.getFlatInteriorPoints();
        this.drawText_(t, 0, t.length, 2);
      }
    }
  }
  /**
   * @param {import("../canvas.js").FillState} fillState Fill state.
   * @private
   */
  setContextFillState_(e) {
    const t = this.context_, i = this.contextFillState_;
    i ? i.fillStyle != e.fillStyle && (i.fillStyle = e.fillStyle, t.fillStyle = e.fillStyle) : (t.fillStyle = e.fillStyle, this.contextFillState_ = {
      fillStyle: e.fillStyle
    });
  }
  /**
   * @param {import("../canvas.js").StrokeState} strokeState Stroke state.
   * @private
   */
  setContextStrokeState_(e) {
    const t = this.context_, i = this.contextStrokeState_;
    i ? (i.lineCap != e.lineCap && (i.lineCap = e.lineCap, t.lineCap = e.lineCap), xt(i.lineDash, e.lineDash) || t.setLineDash(
      i.lineDash = e.lineDash
    ), i.lineDashOffset != e.lineDashOffset && (i.lineDashOffset = e.lineDashOffset, t.lineDashOffset = e.lineDashOffset), i.lineJoin != e.lineJoin && (i.lineJoin = e.lineJoin, t.lineJoin = e.lineJoin), i.lineWidth != e.lineWidth && (i.lineWidth = e.lineWidth, t.lineWidth = e.lineWidth), i.miterLimit != e.miterLimit && (i.miterLimit = e.miterLimit, t.miterLimit = e.miterLimit), i.strokeStyle != e.strokeStyle && (i.strokeStyle = e.strokeStyle, t.strokeStyle = e.strokeStyle)) : (t.lineCap = e.lineCap, t.setLineDash(e.lineDash), t.lineDashOffset = e.lineDashOffset, t.lineJoin = e.lineJoin, t.lineWidth = e.lineWidth, t.miterLimit = e.miterLimit, t.strokeStyle = e.strokeStyle, this.contextStrokeState_ = {
      lineCap: e.lineCap,
      lineDash: e.lineDash,
      lineDashOffset: e.lineDashOffset,
      lineJoin: e.lineJoin,
      lineWidth: e.lineWidth,
      miterLimit: e.miterLimit,
      strokeStyle: e.strokeStyle
    });
  }
  /**
   * @param {import("../canvas.js").TextState} textState Text state.
   * @private
   */
  setContextTextState_(e) {
    const t = this.context_, i = this.contextTextState_, n = e.textAlign ? e.textAlign : Vn;
    i ? (i.font != e.font && (i.font = e.font, t.font = e.font), i.textAlign != n && (i.textAlign = n, t.textAlign = n), i.textBaseline != e.textBaseline && (i.textBaseline = e.textBaseline, t.textBaseline = e.textBaseline)) : (t.font = e.font, t.textAlign = n, t.textBaseline = e.textBaseline, this.contextTextState_ = {
      font: e.font,
      textAlign: n,
      textBaseline: e.textBaseline
    });
  }
  /**
   * Set the fill and stroke style for subsequent draw operations.  To clear
   * either fill or stroke styles, pass null for the appropriate parameter.
   *
   * @param {import("../../style/Fill.js").default} fillStyle Fill style.
   * @param {import("../../style/Stroke.js").default} strokeStyle Stroke style.
   */
  setFillStrokeStyle(e, t) {
    if (!e)
      this.fillState_ = null;
    else {
      const i = e.getColor();
      this.fillState_ = {
        fillStyle: _t(
          i || Pt
        )
      };
    }
    if (!t)
      this.strokeState_ = null;
    else {
      const i = t.getColor(), n = t.getLineCap(), r = t.getLineDash(), o = t.getLineDashOffset(), a = t.getLineJoin(), l = t.getWidth(), h = t.getMiterLimit(), c = r || Bn;
      this.strokeState_ = {
        lineCap: n !== void 0 ? n : hr,
        lineDash: this.pixelRatio_ === 1 ? c : c.map((u) => u * this.pixelRatio_),
        lineDashOffset: (o || Xn) * this.pixelRatio_,
        lineJoin: a !== void 0 ? a : ln,
        lineWidth: (l !== void 0 ? l : Zn) * this.pixelRatio_,
        miterLimit: h !== void 0 ? h : Wn,
        strokeStyle: _t(
          i || Yn
        )
      };
    }
  }
  /**
   * Set the image style for subsequent draw operations.  Pass null to remove
   * the image style.
   *
   * @param {import("../../style/Image.js").default} imageStyle Image style.
   */
  setImageStyle(e) {
    let t;
    if (!e || !(t = e.getSize())) {
      this.image_ = null;
      return;
    }
    const i = e.getPixelRatio(this.pixelRatio_), n = e.getAnchor(), r = e.getOrigin();
    this.image_ = e.getImage(this.pixelRatio_), this.imageAnchorX_ = n[0] * i, this.imageAnchorY_ = n[1] * i, this.imageHeight_ = t[1] * i, this.imageOpacity_ = e.getOpacity(), this.imageOriginX_ = r[0], this.imageOriginY_ = r[1], this.imageRotateWithView_ = e.getRotateWithView(), this.imageRotation_ = e.getRotation();
    const o = e.getScaleArray();
    this.imageScale_ = [
      o[0] * this.pixelRatio_ / i,
      o[1] * this.pixelRatio_ / i
    ], this.imageWidth_ = t[0] * i;
  }
  /**
   * Set the text style for subsequent draw operations.  Pass null to
   * remove the text style.
   *
   * @param {import("../../style/Text.js").default} textStyle Text style.
   */
  setTextStyle(e) {
    if (!e)
      this.text_ = "";
    else {
      const t = e.getFill();
      if (!t)
        this.textFillState_ = null;
      else {
        const f = t.getColor();
        this.textFillState_ = {
          fillStyle: _t(
            f || Pt
          )
        };
      }
      const i = e.getStroke();
      if (!i)
        this.textStrokeState_ = null;
      else {
        const f = i.getColor(), g = i.getLineCap(), _ = i.getLineDash(), m = i.getLineDashOffset(), p = i.getLineJoin(), x = i.getWidth(), y = i.getMiterLimit();
        this.textStrokeState_ = {
          lineCap: g !== void 0 ? g : hr,
          lineDash: _ || Bn,
          lineDashOffset: m || Xn,
          lineJoin: p !== void 0 ? p : ln,
          lineWidth: x !== void 0 ? x : Zn,
          miterLimit: y !== void 0 ? y : Wn,
          strokeStyle: _t(
            f || Yn
          )
        };
      }
      const n = e.getFont(), r = e.getOffsetX(), o = e.getOffsetY(), a = e.getRotateWithView(), l = e.getRotation(), h = e.getScaleArray(), c = e.getText(), u = e.getTextAlign(), d = e.getTextBaseline();
      this.textState_ = {
        font: n !== void 0 ? n : hc,
        textAlign: u !== void 0 ? u : Vn,
        textBaseline: d !== void 0 ? d : cr
      }, this.text_ = c !== void 0 ? Array.isArray(c) ? c.reduce((f, g, _) => f += _ % 2 ? " " : g, "") : c : "", this.textOffsetX_ = r !== void 0 ? this.pixelRatio_ * r : 0, this.textOffsetY_ = o !== void 0 ? this.pixelRatio_ * o : 0, this.textRotateWithView_ = a !== void 0 ? a : !1, this.textRotation_ = l !== void 0 ? l : 0, this.textScale_ = [
        this.pixelRatio_ * h[0],
        this.pixelRatio_ * h[1]
      ];
    }
  }
}
const m_ = __, ft = 0.5;
function p_(s, e, t, i, n, r, o) {
  const a = s[0] * ft, l = s[1] * ft, h = Re(a, l);
  h.imageSmoothingEnabled = !1;
  const c = h.canvas, u = new m_(
    h,
    ft,
    n,
    null,
    o
  ), d = t.length, f = Math.floor((256 * 256 * 256 - 1) / d), g = {};
  for (let m = 1; m <= d; ++m) {
    const p = t[m - 1], x = p.getStyleFunction() || i;
    if (!i)
      continue;
    let y = x(p, r);
    if (!y)
      continue;
    Array.isArray(y) || (y = [y]);
    const C = (m * f).toString(16).padStart(7, "#00000");
    for (let T = 0, w = y.length; T < w; ++T) {
      const L = y[T], I = L.getGeometryFunction()(p);
      if (!I || !Ce(n, I.getExtent()))
        continue;
      const S = L.clone(), Y = S.getFill();
      Y && Y.setColor(C);
      const V = S.getStroke();
      V && (V.setColor(C), V.setLineDash(null)), S.setText(void 0);
      const P = L.getImage();
      if (P && P.getOpacity() !== 0) {
        const A = P.getImageSize();
        if (!A)
          continue;
        const j = Re(
          A[0],
          A[1],
          void 0,
          { alpha: !1 }
        ), Q = j.canvas;
        j.fillStyle = C, j.fillRect(0, 0, Q.width, Q.height), S.setImage(
          new tt({
            img: Q,
            imgSize: A,
            anchor: P.getAnchor(),
            anchorXUnits: "pixels",
            anchorYUnits: "pixels",
            offset: P.getOrigin(),
            opacity: 1,
            size: P.getSize(),
            scale: P.getScale(),
            rotation: P.getRotation(),
            rotateWithView: P.getRotateWithView()
          })
        );
      }
      const q = S.getZIndex() || 0;
      let F = g[q];
      F || (F = {}, g[q] = F, F.Polygon = [], F.Circle = [], F.LineString = [], F.Point = []);
      const b = I.getType();
      if (b === "GeometryCollection") {
        const A = (
          /** @type {import("../../geom/GeometryCollection.js").default} */
          I.getGeometriesArrayRecursive()
        );
        for (let j = 0, Q = A.length; j < Q; ++j) {
          const ee = A[j];
          F[ee.getType().replace("Multi", "")].push(
            ee,
            S
          );
        }
      } else
        F[b.replace("Multi", "")].push(I, S);
    }
  }
  const _ = Object.keys(g).map(Number).sort(vi);
  for (let m = 0, p = _.length; m < p; ++m) {
    const x = g[_[m]];
    for (const y in x) {
      const E = x[y];
      for (let C = 0, T = E.length; C < T; C += 2) {
        u.setStyle(E[C + 1]);
        for (let w = 0, L = e.length; w < L; ++w)
          u.setTransform(e[w]), u.drawGeometry(E[C]);
      }
    }
  }
  return h.getImageData(0, 0, c.width, c.height);
}
function y_(s, e, t) {
  const i = [];
  if (t) {
    const n = Math.floor(Math.round(s[0]) * ft), r = Math.floor(Math.round(s[1]) * ft), o = (_e(n, 0, t.width - 1) + _e(r, 0, t.height - 1) * t.width) * 4, a = t.data[o], l = t.data[o + 1], c = t.data[o + 2] + 256 * (l + 256 * a), u = Math.floor((256 * 256 * 256 - 1) / e.length);
    c && c % u === 0 && i.push(e[c / u - 1]);
  }
  return i;
}
const x_ = 0.5, Fc = {
  Point: L_,
  LineString: S_,
  Polygon: F_,
  MultiPoint: A_,
  MultiLineString: R_,
  MultiPolygon: I_,
  GeometryCollection: T_,
  Circle: C_
};
function E_(s, e) {
  return parseInt(B(s), 10) - parseInt(B(e), 10);
}
function v_(s, e) {
  const t = Wo(s, e);
  return t * t;
}
function Wo(s, e) {
  return x_ * s / e;
}
function C_(s, e, t, i, n) {
  const r = t.getFill(), o = t.getStroke();
  if (r || o) {
    const l = s.getBuilder(t.getZIndex(), "Circle");
    l.setFillStrokeStyle(r, o), l.drawCircle(e, i);
  }
  const a = t.getText();
  if (a && a.getText()) {
    const l = (n || s).getBuilder(
      t.getZIndex(),
      "Text"
    );
    l.setTextStyle(a), l.drawText(e, i);
  }
}
function Zl(s, e, t, i, n, r, o) {
  let a = !1;
  const l = t.getImage();
  if (l) {
    const h = l.getImageState();
    h == k.LOADED || h == k.ERROR ? l.unlistenImageChange(n) : (h == k.IDLE && l.load(), l.listenImageChange(n), a = !0);
  }
  return w_(
    s,
    e,
    t,
    i,
    r,
    o
  ), a;
}
function w_(s, e, t, i, n, r) {
  const o = t.getGeometryFunction()(e);
  if (!o)
    return;
  const a = o.simplifyTransformed(
    i,
    n
  );
  if (t.getRenderer())
    bc(s, a, t, e);
  else {
    const h = Fc[a.getType()];
    h(
      s,
      a,
      t,
      e,
      r
    );
  }
}
function bc(s, e, t, i) {
  if (e.getType() == "GeometryCollection") {
    const r = (
      /** @type {import("../geom/GeometryCollection.js").default} */
      e.getGeometries()
    );
    for (let o = 0, a = r.length; o < a; ++o)
      bc(s, r[o], t, i);
    return;
  }
  s.getBuilder(t.getZIndex(), "Default").drawCustom(
    /** @type {import("../geom/SimpleGeometry.js").default} */
    e,
    i,
    t.getRenderer(),
    t.getHitDetectionRenderer()
  );
}
function T_(s, e, t, i, n) {
  const r = e.getGeometriesArray();
  let o, a;
  for (o = 0, a = r.length; o < a; ++o) {
    const l = Fc[r[o].getType()];
    l(
      s,
      r[o],
      t,
      i,
      n
    );
  }
}
function S_(s, e, t, i, n) {
  const r = t.getStroke();
  if (r) {
    const a = s.getBuilder(
      t.getZIndex(),
      "LineString"
    );
    a.setFillStrokeStyle(null, r), a.drawLineString(e, i);
  }
  const o = t.getText();
  if (o && o.getText()) {
    const a = (n || s).getBuilder(
      t.getZIndex(),
      "Text"
    );
    a.setTextStyle(o), a.drawText(e, i);
  }
}
function R_(s, e, t, i, n) {
  const r = t.getStroke();
  if (r) {
    const a = s.getBuilder(
      t.getZIndex(),
      "LineString"
    );
    a.setFillStrokeStyle(null, r), a.drawMultiLineString(e, i);
  }
  const o = t.getText();
  if (o && o.getText()) {
    const a = (n || s).getBuilder(
      t.getZIndex(),
      "Text"
    );
    a.setTextStyle(o), a.drawText(e, i);
  }
}
function I_(s, e, t, i, n) {
  const r = t.getFill(), o = t.getStroke();
  if (o || r) {
    const l = s.getBuilder(t.getZIndex(), "Polygon");
    l.setFillStrokeStyle(r, o), l.drawMultiPolygon(e, i);
  }
  const a = t.getText();
  if (a && a.getText()) {
    const l = (n || s).getBuilder(
      t.getZIndex(),
      "Text"
    );
    l.setTextStyle(a), l.drawText(e, i);
  }
}
function L_(s, e, t, i, n) {
  const r = t.getImage(), o = t.getText();
  let a;
  if (r) {
    if (r.getImageState() != k.LOADED)
      return;
    let l = s;
    if (n) {
      const c = r.getDeclutterMode();
      if (c !== "none")
        if (l = n, c === "obstacle") {
          const u = s.getBuilder(
            t.getZIndex(),
            "Image"
          );
          u.setImageStyle(r, a), u.drawPoint(e, i);
        } else
          o && o.getText() && (a = {});
    }
    const h = l.getBuilder(
      t.getZIndex(),
      "Image"
    );
    h.setImageStyle(r, a), h.drawPoint(e, i);
  }
  if (o && o.getText()) {
    let l = s;
    n && (l = n);
    const h = l.getBuilder(t.getZIndex(), "Text");
    h.setTextStyle(o, a), h.drawText(e, i);
  }
}
function A_(s, e, t, i, n) {
  const r = t.getImage(), o = t.getText();
  let a;
  if (r) {
    if (r.getImageState() != k.LOADED)
      return;
    let l = s;
    if (n) {
      const c = r.getDeclutterMode();
      if (c !== "none")
        if (l = n, c === "obstacle") {
          const u = s.getBuilder(
            t.getZIndex(),
            "Image"
          );
          u.setImageStyle(r, a), u.drawMultiPoint(e, i);
        } else
          o && o.getText() && (a = {});
    }
    const h = l.getBuilder(
      t.getZIndex(),
      "Image"
    );
    h.setImageStyle(r, a), h.drawMultiPoint(e, i);
  }
  if (o && o.getText()) {
    let l = s;
    n && (l = n);
    const h = l.getBuilder(t.getZIndex(), "Text");
    h.setTextStyle(o, a), h.drawText(e, i);
  }
}
function F_(s, e, t, i, n) {
  const r = t.getFill(), o = t.getStroke();
  if (r || o) {
    const l = s.getBuilder(t.getZIndex(), "Polygon");
    l.setFillStrokeStyle(r, o), l.drawPolygon(e, i);
  }
  const a = t.getText();
  if (a && a.getText()) {
    const l = (n || s).getBuilder(
      t.getZIndex(),
      "Text"
    );
    l.setTextStyle(a), l.drawText(e, i);
  }
}
class b_ extends qa {
  /**
   * @param {import("../../layer/BaseVector.js").default} vectorLayer Vector layer.
   */
  constructor(e) {
    super(e), this.boundHandleStyleImageChange_ = this.handleStyleImageChange_.bind(this), this.animatingOrInteracting_, this.hitDetectionImageData_ = null, this.renderedFeatures_ = null, this.renderedRevision_ = -1, this.renderedResolution_ = NaN, this.renderedExtent_ = Me(), this.wrappedRenderedExtent_ = Me(), this.renderedRotation_, this.renderedCenter_ = null, this.renderedProjection_ = null, this.renderedRenderOrder_ = null, this.replayGroup_ = null, this.replayGroupChanged = !0, this.declutterExecutorGroup = null, this.clipping = !0, this.compositionContext_ = null, this.opacity_ = 1;
  }
  /**
   * @param {ExecutorGroup} executorGroup Executor group.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {import("rbush").default} [declutterTree] Declutter tree.
   */
  renderWorlds(e, t, i) {
    const n = t.extent, r = t.viewState, o = r.center, a = r.resolution, l = r.projection, h = r.rotation, c = l.getExtent(), u = this.getLayer().getSource(), d = t.pixelRatio, f = t.viewHints, g = !(f[ge.ANIMATING] || f[ge.INTERACTING]), _ = this.compositionContext_, m = Math.round(t.size[0] * d), p = Math.round(t.size[1] * d), x = u.getWrapX() && l.canWrapX(), y = x ? te(c) : null, E = x ? Math.ceil((n[2] - c[2]) / y) + 1 : 1;
    let C = x ? Math.floor((n[0] - c[0]) / y) : 0;
    do {
      const T = this.getRenderTransform(
        o,
        a,
        h,
        d,
        m,
        p,
        C * y
      );
      e.execute(
        _,
        1,
        T,
        h,
        g,
        void 0,
        i
      );
    } while (++C < E);
  }
  setupCompositionContext_() {
    if (this.opacity_ !== 1) {
      const e = Re(
        this.context.canvas.width,
        this.context.canvas.height,
        Ul
      );
      this.compositionContext_ = e;
    } else
      this.compositionContext_ = this.context;
  }
  releaseCompositionContext_() {
    if (this.opacity_ !== 1) {
      const e = this.context.globalAlpha;
      this.context.globalAlpha = this.opacity_, this.context.drawImage(this.compositionContext_.canvas, 0, 0), this.context.globalAlpha = e, Ar(this.compositionContext_), Ul.push(this.compositionContext_.canvas), this.compositionContext_ = null;
    }
  }
  /**
   * Render declutter items for this layer
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   */
  renderDeclutter(e) {
    this.declutterExecutorGroup && (this.setupCompositionContext_(), this.renderWorlds(
      this.declutterExecutorGroup,
      e,
      e.declutterTree
    ), this.releaseCompositionContext_());
  }
  /**
   * Render the layer.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target that may be used to render content to.
   * @return {HTMLElement} The rendered element.
   */
  renderFrame(e, t) {
    const i = e.pixelRatio, n = e.layerStatesArray[e.layerIndex];
    nd(this.pixelTransform, 1 / i, 1 / i), ns(this.inversePixelTransform, this.pixelTransform);
    const r = ca(this.pixelTransform);
    this.useContainer(t, r, this.getBackground(e));
    const o = this.context, a = o.canvas, l = this.replayGroup_, h = this.declutterExecutorGroup;
    if ((!l || l.isEmpty()) && (!h || h.isEmpty()))
      return null;
    const c = Math.round(e.size[0] * i), u = Math.round(e.size[1] * i);
    a.width != c || a.height != u ? (a.width = c, a.height = u, a.style.transform !== r && (a.style.transform = r)) : this.containerReused || o.clearRect(0, 0, c, u), this.preRender(o, e);
    const d = e.viewState;
    d.projection, this.opacity_ = n.opacity, this.setupCompositionContext_();
    let f = !1, g = !0;
    if (n.extent && this.clipping) {
      const _ = gt(n.extent);
      g = Ce(_, e.extent), f = g && !Ft(_, e.extent), f && this.clipUnrotated(this.compositionContext_, e, _);
    }
    return g && this.renderWorlds(l, e), f && this.compositionContext_.restore(), this.releaseCompositionContext_(), this.postRender(o, e), this.renderedRotation_ !== d.rotation && (this.renderedRotation_ = d.rotation, this.hitDetectionImageData_ = null), this.container;
  }
  /**
   * Asynchronous layer level hit detection.
   * @param {import("../../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../../Feature").default>>} Promise
   * that resolves with an array of features.
   */
  getFeatures(e) {
    return new Promise((t) => {
      if (!this.hitDetectionImageData_ && !this.animatingOrInteracting_) {
        const i = [this.context.canvas.width, this.context.canvas.height];
        de(this.pixelTransform, i);
        const n = this.renderedCenter_, r = this.renderedResolution_, o = this.renderedRotation_, a = this.renderedProjection_, l = this.wrappedRenderedExtent_, h = this.getLayer(), c = [], u = i[0] * ft, d = i[1] * ft;
        c.push(
          this.getRenderTransform(
            n,
            r,
            o,
            ft,
            u,
            d,
            0
          ).slice()
        );
        const f = h.getSource(), g = a.getExtent();
        if (f.getWrapX() && a.canWrapX() && !Ft(g, l)) {
          let _ = l[0];
          const m = te(g);
          let p = 0, x;
          for (; _ < g[0]; )
            --p, x = m * p, c.push(
              this.getRenderTransform(
                n,
                r,
                o,
                ft,
                u,
                d,
                x
              ).slice()
            ), _ += m;
          for (p = 0, _ = l[2]; _ > g[2]; )
            ++p, x = m * p, c.push(
              this.getRenderTransform(
                n,
                r,
                o,
                ft,
                u,
                d,
                x
              ).slice()
            ), _ -= m;
        }
        this.hitDetectionImageData_ = p_(
          i,
          c,
          this.renderedFeatures_,
          h.getStyleFunction(),
          l,
          r,
          o
        );
      }
      t(
        y_(e, this.renderedFeatures_, this.hitDetectionImageData_)
      );
    });
  }
  /**
   * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {import("../vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {Array<import("../Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
   * @return {T|undefined} Callback result.
   * @template T
   */
  forEachFeatureAtCoordinate(e, t, i, n, r) {
    if (!this.replayGroup_)
      return;
    const o = t.viewState.resolution, a = t.viewState.rotation, l = this.getLayer(), h = {}, c = function(f, g, _) {
      const m = B(f), p = h[m];
      if (p) {
        if (p !== !0 && _ < p.distanceSq) {
          if (_ === 0)
            return h[m] = !0, r.splice(r.lastIndexOf(p), 1), n(f, l, g);
          p.geometry = g, p.distanceSq = _;
        }
      } else {
        if (_ === 0)
          return h[m] = !0, n(f, l, g);
        r.push(
          h[m] = {
            feature: f,
            layer: l,
            geometry: g,
            distanceSq: _,
            callback: n
          }
        );
      }
    };
    let u;
    const d = [this.replayGroup_];
    return this.declutterExecutorGroup && d.push(this.declutterExecutorGroup), d.some((f) => u = f.forEachFeatureAtCoordinate(
      e,
      o,
      a,
      i,
      c,
      f === this.declutterExecutorGroup && t.declutterTree ? t.declutterTree.all().map((g) => g.value) : null
    )), u;
  }
  /**
   * Perform action necessary to get the layer rendered after new fonts have loaded
   */
  handleFontsChanged() {
    const e = this.getLayer();
    e.getVisible() && this.replayGroup_ && e.changed();
  }
  /**
   * Handle changes in image style state.
   * @param {import("../../events/Event.js").default} event Image style change event.
   * @private
   */
  handleStyleImageChange_(e) {
    this.renderIfReadyAndVisible();
  }
  /**
   * Determine whether render should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */
  prepareFrame(e) {
    const t = this.getLayer(), i = t.getSource();
    if (!i)
      return !1;
    const n = e.viewHints[ge.ANIMATING], r = e.viewHints[ge.INTERACTING], o = t.getUpdateWhileAnimating(), a = t.getUpdateWhileInteracting();
    if (this.ready && !o && n || !a && r)
      return this.animatingOrInteracting_ = !0, !0;
    this.animatingOrInteracting_ = !1;
    const l = e.extent, h = e.viewState, c = h.projection, u = h.resolution, d = e.pixelRatio, f = t.getRevision(), g = t.getRenderBuffer();
    let _ = t.getRenderOrder();
    _ === void 0 && (_ = E_);
    const m = h.center.slice(), p = Si(
      l,
      g * u
    ), x = p.slice(), y = [p.slice()], E = c.getExtent();
    if (i.getWrapX() && c.canWrapX() && !Ft(E, e.extent)) {
      const F = te(E), b = Math.max(te(p) / 2, F);
      p[0] = E[0] - b, p[2] = E[2] + b, _a(m, c);
      const A = Dh(y[0], c);
      A[0] < E[0] && A[2] < E[2] ? y.push([
        A[0] + F,
        A[1],
        A[2] + F,
        A[3]
      ]) : A[0] > E[0] && A[2] > E[2] && y.push([
        A[0] - F,
        A[1],
        A[2] - F,
        A[3]
      ]);
    }
    if (this.ready && this.renderedResolution_ == u && this.renderedRevision_ == f && this.renderedRenderOrder_ == _ && Ft(this.wrappedRenderedExtent_, p))
      return xt(this.renderedExtent_, x) || (this.hitDetectionImageData_ = null, this.renderedExtent_ = x), this.renderedCenter_ = m, this.replayGroupChanged = !1, !0;
    this.replayGroup_ = null;
    const C = new Xl(
      Wo(u, d),
      p,
      u,
      d
    );
    let T;
    this.getLayer().getDeclutter() && (T = new Xl(
      Wo(u, d),
      p,
      u,
      d
    ));
    let w;
    for (let F = 0, b = y.length; F < b; ++F)
      i.loadFeatures(y[F], u, c);
    const L = v_(u, d);
    let I = !0;
    const S = (
      /**
       * @param {import("../../Feature.js").default} feature Feature.
       */
      (F) => {
        let b;
        const A = F.getStyleFunction() || t.getStyleFunction();
        if (A && (b = A(F, u)), b) {
          const j = this.renderFeature(
            F,
            L,
            b,
            C,
            w,
            T
          );
          I = I && !j;
        }
      }
    ), Y = Ea(p), V = i.getFeaturesInExtent(Y);
    _ && V.sort(_);
    for (let F = 0, b = V.length; F < b; ++F)
      S(V[F]);
    this.renderedFeatures_ = V, this.ready = I;
    const P = C.finish(), q = new Vl(
      p,
      u,
      d,
      i.getOverlaps(),
      P,
      t.getRenderBuffer()
    );
    return T && (this.declutterExecutorGroup = new Vl(
      p,
      u,
      d,
      i.getOverlaps(),
      T.finish(),
      t.getRenderBuffer()
    )), this.renderedResolution_ = u, this.renderedRevision_ = f, this.renderedRenderOrder_ = _, this.renderedExtent_ = x, this.wrappedRenderedExtent_ = p, this.renderedCenter_ = m, this.renderedProjection_ = c, this.replayGroup_ = q, this.hitDetectionImageData_ = null, this.replayGroupChanged = !0, !0;
  }
  /**
   * @param {import("../../Feature.js").default} feature Feature.
   * @param {number} squaredTolerance Squared render tolerance.
   * @param {import("../../style/Style.js").default|Array<import("../../style/Style.js").default>} styles The style or array of styles.
   * @param {import("../../render/canvas/BuilderGroup.js").default} builderGroup Builder group.
   * @param {import("../../proj.js").TransformFunction} [transform] Transform from user to view projection.
   * @param {import("../../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder for decluttering.
   * @return {boolean} `true` if an image is loading.
   */
  renderFeature(e, t, i, n, r, o) {
    if (!i)
      return !1;
    let a = !1;
    if (Array.isArray(i))
      for (let l = 0, h = i.length; l < h; ++l)
        a = Zl(
          n,
          e,
          i[l],
          t,
          this.boundHandleStyleImageChange_,
          r,
          o
        ) || a;
    else
      a = Zl(
        n,
        e,
        i,
        t,
        this.boundHandleStyleImageChange_,
        r,
        o
      );
    return a;
  }
}
const Pc = b_;
class P_ extends Za {
  /**
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {HTMLCanvasElement} canvas Canvas.
   * @param {Loader} [loader] Optional loader function to
   *     support asynchronous canvas drawing.
   */
  constructor(e, t, i, n, r) {
    const o = r !== void 0 ? k.IDLE : k.LOADED;
    super(e, t, i, o), this.loader_ = r !== void 0 ? r : null, this.canvas_ = n, this.error_ = null;
  }
  /**
   * Get any error associated with asynchronous rendering.
   * @return {?Error} Any error that occurred during rendering.
   */
  getError() {
    return this.error_;
  }
  /**
   * Handle async drawing complete.
   * @param {Error} [err] Any error during drawing.
   * @private
   */
  handleLoad_(e) {
    e ? (this.error_ = e, this.state = k.ERROR) : this.state = k.LOADED, this.changed();
  }
  /**
   * Load not yet loaded URI.
   */
  load() {
    this.state == k.IDLE && (this.state = k.LOADING, this.changed(), this.loader_(this.handleLoad_.bind(this)));
  }
  /**
   * @return {HTMLCanvasElement} Canvas element.
   */
  getImage() {
    return this.canvas_;
  }
}
const M_ = P_;
class O_ extends Ic {
  /**
   * @param {import("../../layer/VectorImage.js").default} layer Vector image layer.
   */
  constructor(e) {
    super(e), this.vectorRenderer_ = new Pc(e), this.layerImageRatio_ = e.getImageRatio(), this.coordinateToVectorPixelTransform_ = Se(), this.renderedPixelToCoordinateTransform_ = null;
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    this.vectorRenderer_.dispose(), super.disposeInternal();
  }
  /**
   * Asynchronous layer level hit detection.
   * @param {import("../../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../../Feature").default>>} Promise that resolves with an array of features.
   */
  getFeatures(e) {
    if (!this.vectorRenderer_)
      return Promise.resolve([]);
    const t = de(
      this.coordinateToVectorPixelTransform_,
      de(this.renderedPixelToCoordinateTransform_, e.slice())
    );
    return this.vectorRenderer_.getFeatures(t);
  }
  /**
   * Perform action necessary to get the layer rendered after new fonts have loaded
   */
  handleFontsChanged() {
    this.vectorRenderer_.handleFontsChanged();
  }
  /**
   * Determine whether render should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */
  prepareFrame(e) {
    const t = e.pixelRatio, i = e.viewState, n = i.resolution, r = e.viewHints, o = this.vectorRenderer_;
    let a = e.extent;
    this.layerImageRatio_ !== 1 && (a = a.slice(0), Oh(a, this.layerImageRatio_));
    const l = te(a) / n, h = Fe(a) / n;
    if (!r[ge.ANIMATING] && !r[ge.INTERACTING] && !as(a)) {
      o.useContainer(null, null);
      const c = o.context, u = e.layerStatesArray[e.layerIndex];
      c.globalAlpha = u.opacity;
      const d = Object.assign({}, u, { opacity: 1 }), f = (
        /** @type {import("../../Map.js").FrameState} */
        Object.assign({}, e, {
          declutterTree: new Ua(9),
          extent: a,
          size: [l, h],
          viewState: (
            /** @type {import("../../View.js").State} */
            Object.assign({}, e.viewState, {
              rotation: 0
            })
          ),
          layerStatesArray: [d],
          layerIndex: 0
        })
      );
      let g = !0;
      const _ = new M_(
        a,
        n,
        t,
        c.canvas,
        function(m) {
          o.prepareFrame(f) && o.replayGroupChanged && (o.clipping = !1, o.renderFrame(f, null) && (o.renderDeclutter(f), g = !1), m());
        }
      );
      _.addEventListener(z.CHANGE, () => {
        if (_.getState() !== k.LOADED)
          return;
        this.image_ = g ? null : _;
        const m = _.getResolution(), p = _.getPixelRatio(), x = m * t / p;
        this.renderedResolution = x, this.coordinateToVectorPixelTransform_ = Je(
          this.coordinateToVectorPixelTransform_,
          l / 2,
          h / 2,
          1 / x,
          -1 / x,
          0,
          -i.center[0],
          -i.center[1]
        );
      }), _.load();
    }
    return this.image_ && (this.renderedPixelToCoordinateTransform_ = e.pixelToCoordinateTransform.slice()), !!this.image_;
  }
  /**
   */
  preRender() {
  }
  /**
   */
  postRender() {
  }
  /**
   */
  renderDeclutter() {
  }
  /**
   * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {import("../vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {Array<import("../Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
   * @return {T|undefined} Callback result.
   * @template T
   */
  forEachFeatureAtCoordinate(e, t, i, n, r) {
    return this.vectorRenderer_ ? this.vectorRenderer_.forEachFeatureAtCoordinate(
      e,
      t,
      i,
      n,
      r
    ) : super.forEachFeatureAtCoordinate(
      e,
      t,
      i,
      n,
      r
    );
  }
}
const D_ = O_;
class k_ extends br {
  /**
   * @param {Options<VectorSourceType>} [options] Options.
   */
  constructor(e) {
    e = e || {};
    const t = Object.assign({}, e);
    delete t.imageRatio, super(t), this.imageRatio_ = e.imageRatio !== void 0 ? e.imageRatio : 1;
  }
  /**
   * @return {number} Ratio between rendered extent size and viewport extent size.
   */
  getImageRatio() {
    return this.imageRatio_;
  }
  createRenderer() {
    return new D_(this);
  }
}
const ai = k_;
class N_ {
  /**
   * @param {number} [maxEntries] Max entries.
   */
  constructor(e) {
    this.rbush_ = new Ua(e), this.items_ = {};
  }
  /**
   * Insert a value into the RBush.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {T} value Value.
   */
  insert(e, t) {
    const i = {
      minX: e[0],
      minY: e[1],
      maxX: e[2],
      maxY: e[3],
      value: t
    };
    this.rbush_.insert(i), this.items_[B(t)] = i;
  }
  /**
   * Bulk-insert values into the RBush.
   * @param {Array<import("../extent.js").Extent>} extents Extents.
   * @param {Array<T>} values Values.
   */
  load(e, t) {
    const i = new Array(t.length);
    for (let n = 0, r = t.length; n < r; n++) {
      const o = e[n], a = t[n], l = {
        minX: o[0],
        minY: o[1],
        maxX: o[2],
        maxY: o[3],
        value: a
      };
      i[n] = l, this.items_[B(a)] = l;
    }
    this.rbush_.load(i);
  }
  /**
   * Remove a value from the RBush.
   * @param {T} value Value.
   * @return {boolean} Removed.
   */
  remove(e) {
    const t = B(e), i = this.items_[t];
    return delete this.items_[t], this.rbush_.remove(i) !== null;
  }
  /**
   * Update the extent of a value in the RBush.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {T} value Value.
   */
  update(e, t) {
    const i = this.items_[B(t)], n = [i.minX, i.minY, i.maxX, i.maxY];
    ti(n, e) || (this.remove(t), this.insert(e, t));
  }
  /**
   * Return all values in the RBush.
   * @return {Array<T>} All.
   */
  getAll() {
    return this.rbush_.all().map(function(t) {
      return t.value;
    });
  }
  /**
   * Return all values in the given extent.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {Array<T>} All in extent.
   */
  getInExtent(e) {
    const t = {
      minX: e[0],
      minY: e[1],
      maxX: e[2],
      maxY: e[3]
    };
    return this.rbush_.search(t).map(function(n) {
      return n.value;
    });
  }
  /**
   * Calls a callback function with each value in the tree.
   * If the callback returns a truthy value, this value is returned without
   * checking the rest of the tree.
   * @param {function(T): *} callback Callback.
   * @return {*} Callback return value.
   */
  forEach(e) {
    return this.forEach_(this.getAll(), e);
  }
  /**
   * Calls a callback function with each value in the provided extent.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {function(T): *} callback Callback.
   * @return {*} Callback return value.
   */
  forEachInExtent(e, t) {
    return this.forEach_(this.getInExtent(e), t);
  }
  /**
   * @param {Array<T>} values Values.
   * @param {function(T): *} callback Callback.
   * @private
   * @return {*} Callback return value.
   */
  forEach_(e, t) {
    let i;
    for (let n = 0, r = e.length; n < r; n++)
      if (i = t(e[n]), i)
        return i;
    return i;
  }
  /**
   * @return {boolean} Is empty.
   */
  isEmpty() {
    return sn(this.items_);
  }
  /**
   * Remove all values from the RBush.
   */
  clear() {
    this.rbush_.clear(), this.items_ = {};
  }
  /**
   * @param {import("../extent.js").Extent} [extent] Extent.
   * @return {import("../extent.js").Extent} Extent.
   */
  getExtent(e) {
    const t = this.rbush_.toJSON();
    return pt(t.minX, t.minY, t.maxX, t.maxY, e);
  }
  /**
   * @param {RBush} rbush R-Tree.
   */
  concat(e) {
    this.rbush_.load(e.rbush_.all());
    for (const t in e.items_)
      this.items_[t] = e.items_[t];
  }
}
const Yo = N_;
class G_ extends ht {
  /**
   * @param {Options} options Source options.
   */
  constructor(e) {
    super(), this.projection = ye(e.projection), this.attributions_ = jl(e.attributions), this.attributionsCollapsible_ = e.attributionsCollapsible !== void 0 ? e.attributionsCollapsible : !0, this.loading = !1, this.state_ = e.state !== void 0 ? e.state : "ready", this.wrapX_ = e.wrapX !== void 0 ? e.wrapX : !1, this.interpolate_ = !!e.interpolate, this.viewResolver = null, this.viewRejector = null;
    const t = this;
    this.viewPromise_ = new Promise(function(i, n) {
      t.viewResolver = i, t.viewRejector = n;
    });
  }
  /**
   * Get the attribution function for the source.
   * @return {?Attribution} Attribution function.
   * @api
   */
  getAttributions() {
    return this.attributions_;
  }
  /**
   * @return {boolean} Attributions are collapsible.
   * @api
   */
  getAttributionsCollapsible() {
    return this.attributionsCollapsible_;
  }
  /**
   * Get the projection of the source.
   * @return {import("../proj/Projection.js").default|null} Projection.
   * @api
   */
  getProjection() {
    return this.projection;
  }
  /**
   * @param {import("../proj/Projection").default} [projection] Projection.
   * @return {Array<number>|null} Resolutions.
   */
  getResolutions(e) {
    return null;
  }
  /**
   * @return {Promise<import("../View.js").ViewOptions>} A promise for view-related properties.
   */
  getView() {
    return this.viewPromise_;
  }
  /**
   * Get the state of the source, see {@link import("./Source.js").State} for possible states.
   * @return {import("./Source.js").State} State.
   * @api
   */
  getState() {
    return this.state_;
  }
  /**
   * @return {boolean|undefined} Wrap X.
   */
  getWrapX() {
    return this.wrapX_;
  }
  /**
   * @return {boolean} Use linear interpolation when resampling.
   */
  getInterpolate() {
    return this.interpolate_;
  }
  /**
   * Refreshes the source. The source will be cleared, and data from the server will be reloaded.
   * @api
   */
  refresh() {
    this.changed();
  }
  /**
   * Set the attributions of the source.
   * @param {AttributionLike|undefined} attributions Attributions.
   *     Can be passed as `string`, `Array<string>`, {@link module:ol/source/Source~Attribution},
   *     or `undefined`.
   * @api
   */
  setAttributions(e) {
    this.attributions_ = jl(e), this.changed();
  }
  /**
   * Set the state of the source.
   * @param {import("./Source.js").State} state State.
   */
  setState(e) {
    this.state_ = e, this.changed();
  }
}
function jl(s) {
  return s ? Array.isArray(s) ? function(e) {
    return s;
  } : typeof s == "function" ? s : function(e) {
    return [s];
  } : null;
}
const Ja = G_, Le = {
  /**
   * Triggered when a feature is added to the source.
   * @event module:ol/source/Vector.VectorSourceEvent#addfeature
   * @api
   */
  ADDFEATURE: "addfeature",
  /**
   * Triggered when a feature is updated.
   * @event module:ol/source/Vector.VectorSourceEvent#changefeature
   * @api
   */
  CHANGEFEATURE: "changefeature",
  /**
   * Triggered when the clear method is called on the source.
   * @event module:ol/source/Vector.VectorSourceEvent#clear
   * @api
   */
  CLEAR: "clear",
  /**
   * Triggered when a feature is removed from the source.
   * See {@link module:ol/source/Vector~VectorSource#clear source.clear()} for exceptions.
   * @event module:ol/source/Vector.VectorSourceEvent#removefeature
   * @api
   */
  REMOVEFEATURE: "removefeature",
  /**
   * Triggered when features starts loading.
   * @event module:ol/source/Vector.VectorSourceEvent#featuresloadstart
   * @api
   */
  FEATURESLOADSTART: "featuresloadstart",
  /**
   * Triggered when features finishes loading.
   * @event module:ol/source/Vector.VectorSourceEvent#featuresloadend
   * @api
   */
  FEATURESLOADEND: "featuresloadend",
  /**
   * Triggered if feature loading results in an error.
   * @event module:ol/source/Vector.VectorSourceEvent#featuresloaderror
   * @api
   */
  FEATURESLOADERROR: "featuresloaderror"
};
function U_(s, e) {
  return [[-1 / 0, -1 / 0, 1 / 0, 1 / 0]];
}
let z_ = !1;
function B_(s, e, t, i, n, r, o) {
  const a = new XMLHttpRequest();
  a.open(
    "GET",
    typeof s == "function" ? s(t, i, n) : s,
    !0
  ), e.getType() == "arraybuffer" && (a.responseType = "arraybuffer"), a.withCredentials = z_, a.onload = function(l) {
    if (!a.status || a.status >= 200 && a.status < 300) {
      const h = e.getType();
      let c;
      h == "json" || h == "text" ? c = a.responseText : h == "xml" ? (c = a.responseXML, c || (c = new DOMParser().parseFromString(
        a.responseText,
        "application/xml"
      ))) : h == "arraybuffer" && (c = /** @type {ArrayBuffer} */
      a.response), c ? r(
        /** @type {Array<import("./Feature.js").default>} */
        e.readFeatures(c, {
          extent: t,
          featureProjection: n
        }),
        e.readProjection(c)
      ) : o();
    } else
      o();
  }, a.onerror = o, a.send();
}
function Hl(s, e) {
  return function(t, i, n, r, o) {
    const a = (
      /** @type {import("./source/Vector").default} */
      this
    );
    B_(
      s,
      e,
      t,
      i,
      n,
      /**
       * @param {Array<import("./Feature.js").default>} features The loaded features.
       * @param {import("./proj/Projection.js").default} dataProjection Data
       * projection.
       */
      function(l, h) {
        a.addFeatures(l), r !== void 0 && r(l);
      },
      /* FIXME handle error */
      o || nn
    );
  };
}
class Vt extends Ye {
  /**
   * @param {string} type Type.
   * @param {import("../Feature.js").default<Geometry>} [feature] Feature.
   * @param {Array<import("../Feature.js").default<Geometry>>} [features] Features.
   */
  constructor(e, t, i) {
    super(e), this.feature = t, this.features = i;
  }
}
class X_ extends Ja {
  /**
   * @param {Options<Geometry>} [options] Vector source options.
   */
  constructor(e) {
    e = e || {}, super({
      attributions: e.attributions,
      interpolate: !0,
      projection: void 0,
      state: "ready",
      wrapX: e.wrapX !== void 0 ? e.wrapX : !0
    }), this.on, this.once, this.un, this.loader_ = nn, this.format_ = e.format, this.overlaps_ = e.overlaps === void 0 ? !0 : e.overlaps, this.url_ = e.url, e.loader !== void 0 ? this.loader_ = e.loader : this.url_ !== void 0 && (Z(this.format_, 7), this.loader_ = Hl(
      this.url_,
      /** @type {import("../format/Feature.js").default} */
      this.format_
    )), this.strategy_ = e.strategy !== void 0 ? e.strategy : U_;
    const t = e.useSpatialIndex !== void 0 ? e.useSpatialIndex : !0;
    this.featuresRtree_ = t ? new Yo() : null, this.loadedExtentsRtree_ = new Yo(), this.loadingExtentsCount_ = 0, this.nullGeometryFeatures_ = {}, this.idIndex_ = {}, this.uidIndex_ = {}, this.featureChangeKeys_ = {}, this.featuresCollection_ = null;
    let i, n;
    Array.isArray(e.features) ? n = e.features : e.features && (i = e.features, n = i.getArray()), !t && i === void 0 && (i = new ce(n)), n !== void 0 && this.addFeaturesInternal(n), i !== void 0 && this.bindFeaturesCollection_(i);
  }
  /**
   * Add a single feature to the source.  If you want to add a batch of features
   * at once, call {@link module:ol/source/Vector~VectorSource#addFeatures #addFeatures()}
   * instead. A feature will not be added to the source if feature with
   * the same id is already there. The reason for this behavior is to avoid
   * feature duplication when using bbox or tile loading strategies.
   * Note: this also applies if an {@link module:ol/Collection~Collection} is used for features,
   * meaning that if a feature with a duplicate id is added in the collection, it will
   * be removed from it right away.
   * @param {import("../Feature.js").default<Geometry>} feature Feature to add.
   * @api
   */
  addFeature(e) {
    this.addFeatureInternal(e), this.changed();
  }
  /**
   * Add a feature without firing a `change` event.
   * @param {import("../Feature.js").default<Geometry>} feature Feature.
   * @protected
   */
  addFeatureInternal(e) {
    const t = B(e);
    if (!this.addToIndex_(t, e)) {
      this.featuresCollection_ && this.featuresCollection_.remove(e);
      return;
    }
    this.setupChangeEvents_(t, e);
    const i = e.getGeometry();
    if (i) {
      const n = i.getExtent();
      this.featuresRtree_ && this.featuresRtree_.insert(n, e);
    } else
      this.nullGeometryFeatures_[t] = e;
    this.dispatchEvent(
      new Vt(Le.ADDFEATURE, e)
    );
  }
  /**
   * @param {string} featureKey Unique identifier for the feature.
   * @param {import("../Feature.js").default<Geometry>} feature The feature.
   * @private
   */
  setupChangeEvents_(e, t) {
    this.featureChangeKeys_[e] = [
      H(t, z.CHANGE, this.handleFeatureChange_, this),
      H(
        t,
        Ei.PROPERTYCHANGE,
        this.handleFeatureChange_,
        this
      )
    ];
  }
  /**
   * @param {string} featureKey Unique identifier for the feature.
   * @param {import("../Feature.js").default<Geometry>} feature The feature.
   * @return {boolean} The feature is "valid", in the sense that it is also a
   *     candidate for insertion into the Rtree.
   * @private
   */
  addToIndex_(e, t) {
    let i = !0;
    const n = t.getId();
    return n !== void 0 && (n.toString() in this.idIndex_ ? i = !1 : this.idIndex_[n.toString()] = t), i && (Z(!(e in this.uidIndex_), 30), this.uidIndex_[e] = t), i;
  }
  /**
   * Add a batch of features to the source.
   * @param {Array<import("../Feature.js").default<Geometry>>} features Features to add.
   * @api
   */
  addFeatures(e) {
    this.addFeaturesInternal(e), this.changed();
  }
  /**
   * Add features without firing a `change` event.
   * @param {Array<import("../Feature.js").default<Geometry>>} features Features.
   * @protected
   */
  addFeaturesInternal(e) {
    const t = [], i = [], n = [];
    for (let r = 0, o = e.length; r < o; r++) {
      const a = e[r], l = B(a);
      this.addToIndex_(l, a) && i.push(a);
    }
    for (let r = 0, o = i.length; r < o; r++) {
      const a = i[r], l = B(a);
      this.setupChangeEvents_(l, a);
      const h = a.getGeometry();
      if (h) {
        const c = h.getExtent();
        t.push(c), n.push(a);
      } else
        this.nullGeometryFeatures_[l] = a;
    }
    if (this.featuresRtree_ && this.featuresRtree_.load(t, n), this.hasListener(Le.ADDFEATURE))
      for (let r = 0, o = i.length; r < o; r++)
        this.dispatchEvent(
          new Vt(Le.ADDFEATURE, i[r])
        );
  }
  /**
   * @param {!Collection<import("../Feature.js").default<Geometry>>} collection Collection.
   * @private
   */
  bindFeaturesCollection_(e) {
    let t = !1;
    this.addEventListener(
      Le.ADDFEATURE,
      /**
       * @param {VectorSourceEvent<Geometry>} evt The vector source event
       */
      function(i) {
        t || (t = !0, e.push(i.feature), t = !1);
      }
    ), this.addEventListener(
      Le.REMOVEFEATURE,
      /**
       * @param {VectorSourceEvent<Geometry>} evt The vector source event
       */
      function(i) {
        t || (t = !0, e.remove(i.feature), t = !1);
      }
    ), e.addEventListener(
      ve.ADD,
      /**
       * @param {import("../Collection.js").CollectionEvent<import("../Feature.js").default<Geometry>>} evt The collection event
       */
      (i) => {
        t || (t = !0, this.addFeature(i.element), t = !1);
      }
    ), e.addEventListener(
      ve.REMOVE,
      /**
       * @param {import("../Collection.js").CollectionEvent<import("../Feature.js").default<Geometry>>} evt The collection event
       */
      (i) => {
        t || (t = !0, this.removeFeature(i.element), t = !1);
      }
    ), this.featuresCollection_ = e;
  }
  /**
   * Remove all features from the source.
   * @param {boolean} [fast] Skip dispatching of {@link module:ol/source/Vector.VectorSourceEvent#event:removefeature} events.
   * @api
   */
  clear(e) {
    if (e) {
      for (const i in this.featureChangeKeys_)
        this.featureChangeKeys_[i].forEach(re);
      this.featuresCollection_ || (this.featureChangeKeys_ = {}, this.idIndex_ = {}, this.uidIndex_ = {});
    } else if (this.featuresRtree_) {
      const i = (n) => {
        this.removeFeatureInternal(n);
      };
      this.featuresRtree_.forEach(i);
      for (const n in this.nullGeometryFeatures_)
        this.removeFeatureInternal(this.nullGeometryFeatures_[n]);
    }
    this.featuresCollection_ && this.featuresCollection_.clear(), this.featuresRtree_ && this.featuresRtree_.clear(), this.nullGeometryFeatures_ = {};
    const t = new Vt(Le.CLEAR);
    this.dispatchEvent(t), this.changed();
  }
  /**
   * Iterate through all features on the source, calling the provided callback
   * with each one.  If the callback returns any "truthy" value, iteration will
   * stop and the function will return the same value.
   * Note: this function only iterate through the feature that have a defined geometry.
   *
   * @param {function(import("../Feature.js").default<Geometry>): T} callback Called with each feature
   *     on the source.  Return a truthy value to stop iteration.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   * @api
   */
  forEachFeature(e) {
    if (this.featuresRtree_)
      return this.featuresRtree_.forEach(e);
    this.featuresCollection_ && this.featuresCollection_.forEach(e);
  }
  /**
   * Iterate through all features whose geometries contain the provided
   * coordinate, calling the callback with each feature.  If the callback returns
   * a "truthy" value, iteration will stop and the function will return the same
   * value.
   *
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {function(import("../Feature.js").default<Geometry>): T} callback Called with each feature
   *     whose goemetry contains the provided coordinate.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   */
  forEachFeatureAtCoordinateDirect(e, t) {
    const i = [e[0], e[1], e[0], e[1]];
    return this.forEachFeatureInExtent(i, function(n) {
      if (n.getGeometry().intersectsCoordinate(e))
        return t(n);
    });
  }
  /**
   * Iterate through all features whose bounding box intersects the provided
   * extent (note that the feature's geometry may not intersect the extent),
   * calling the callback with each feature.  If the callback returns a "truthy"
   * value, iteration will stop and the function will return the same value.
   *
   * If you are interested in features whose geometry intersects an extent, call
   * the {@link module:ol/source/Vector~VectorSource#forEachFeatureIntersectingExtent #forEachFeatureIntersectingExtent()} method instead.
   *
   * When `useSpatialIndex` is set to false, this method will loop through all
   * features, equivalent to {@link module:ol/source/Vector~VectorSource#forEachFeature #forEachFeature()}.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {function(import("../Feature.js").default<Geometry>): T} callback Called with each feature
   *     whose bounding box intersects the provided extent.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   * @api
   */
  forEachFeatureInExtent(e, t) {
    if (this.featuresRtree_)
      return this.featuresRtree_.forEachInExtent(e, t);
    this.featuresCollection_ && this.featuresCollection_.forEach(t);
  }
  /**
   * Iterate through all features whose geometry intersects the provided extent,
   * calling the callback with each feature.  If the callback returns a "truthy"
   * value, iteration will stop and the function will return the same value.
   *
   * If you only want to test for bounding box intersection, call the
   * {@link module:ol/source/Vector~VectorSource#forEachFeatureInExtent #forEachFeatureInExtent()} method instead.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {function(import("../Feature.js").default<Geometry>): T} callback Called with each feature
   *     whose geometry intersects the provided extent.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   * @api
   */
  forEachFeatureIntersectingExtent(e, t) {
    return this.forEachFeatureInExtent(
      e,
      /**
       * @param {import("../Feature.js").default<Geometry>} feature Feature.
       * @return {T|undefined} The return value from the last call to the callback.
       */
      function(i) {
        if (i.getGeometry().intersectsExtent(e)) {
          const r = t(i);
          if (r)
            return r;
        }
      }
    );
  }
  /**
   * Get the features collection associated with this source. Will be `null`
   * unless the source was configured with `useSpatialIndex` set to `false`, or
   * with an {@link module:ol/Collection~Collection} as `features`.
   * @return {Collection<import("../Feature.js").default<Geometry>>|null} The collection of features.
   * @api
   */
  getFeaturesCollection() {
    return this.featuresCollection_;
  }
  /**
   * Get a snapshot of the features currently on the source in random order. The returned array
   * is a copy, the features are references to the features in the source.
   * @return {Array<import("../Feature.js").default<Geometry>>} Features.
   * @api
   */
  getFeatures() {
    let e;
    return this.featuresCollection_ ? e = this.featuresCollection_.getArray().slice(0) : this.featuresRtree_ && (e = this.featuresRtree_.getAll(), sn(this.nullGeometryFeatures_) || ae(e, Object.values(this.nullGeometryFeatures_))), /** @type {Array<import("../Feature.js").default<Geometry>>} */
    e;
  }
  /**
   * Get all features whose geometry intersects the provided coordinate.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @return {Array<import("../Feature.js").default<Geometry>>} Features.
   * @api
   */
  getFeaturesAtCoordinate(e) {
    const t = [];
    return this.forEachFeatureAtCoordinateDirect(e, function(i) {
      t.push(i);
    }), t;
  }
  /**
   * Get all features whose bounding box intersects the provided extent.  Note that this returns an array of
   * all features intersecting the given extent in random order (so it may include
   * features whose geometries do not intersect the extent).
   *
   * When `useSpatialIndex` is set to false, this method will return all
   * features.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {import("../proj/Projection.js").default} [projection] Include features
   * where `extent` exceeds the x-axis bounds of `projection` and wraps around the world.
   * @return {Array<import("../Feature.js").default<Geometry>>} Features.
   * @api
   */
  getFeaturesInExtent(e, t) {
    if (this.featuresRtree_) {
      if (!(t && t.canWrapX() && this.getWrapX()))
        return this.featuresRtree_.getInExtent(e);
      const n = hd(e, t);
      return [].concat(
        ...n.map((r) => this.featuresRtree_.getInExtent(r))
      );
    } else if (this.featuresCollection_)
      return this.featuresCollection_.getArray().slice(0);
    return [];
  }
  /**
   * Get the closest feature to the provided coordinate.
   *
   * This method is not available when the source is configured with
   * `useSpatialIndex` set to `false`.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {function(import("../Feature.js").default<Geometry>):boolean} [filter] Feature filter function.
   *     The filter function will receive one argument, the {@link module:ol/Feature~Feature feature}
   *     and it should return a boolean value. By default, no filtering is made.
   * @return {import("../Feature.js").default<Geometry>} Closest feature.
   * @api
   */
  getClosestFeatureToCoordinate(e, t) {
    const i = e[0], n = e[1];
    let r = null;
    const o = [NaN, NaN];
    let a = 1 / 0;
    const l = [-1 / 0, -1 / 0, 1 / 0, 1 / 0];
    return t = t || mt, this.featuresRtree_.forEachInExtent(
      l,
      /**
       * @param {import("../Feature.js").default<Geometry>} feature Feature.
       */
      function(h) {
        if (t(h)) {
          const c = h.getGeometry(), u = a;
          if (a = c.closestPointXY(
            i,
            n,
            o,
            a
          ), a < u) {
            r = h;
            const d = Math.sqrt(a);
            l[0] = i - d, l[1] = n - d, l[2] = i + d, l[3] = n + d;
          }
        }
      }
    ), r;
  }
  /**
   * Get the extent of the features currently in the source.
   *
   * This method is not available when the source is configured with
   * `useSpatialIndex` set to `false`.
   * @param {import("../extent.js").Extent} [extent] Destination extent. If provided, no new extent
   *     will be created. Instead, that extent's coordinates will be overwritten.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getExtent(e) {
    return this.featuresRtree_.getExtent(e);
  }
  /**
   * Get a feature by its identifier (the value returned by feature.getId()).
   * Note that the index treats string and numeric identifiers as the same.  So
   * `source.getFeatureById(2)` will return a feature with id `'2'` or `2`.
   *
   * @param {string|number} id Feature identifier.
   * @return {import("../Feature.js").default<Geometry>|null} The feature (or `null` if not found).
   * @api
   */
  getFeatureById(e) {
    const t = this.idIndex_[e.toString()];
    return t !== void 0 ? t : null;
  }
  /**
   * Get a feature by its internal unique identifier (using `getUid`).
   *
   * @param {string} uid Feature identifier.
   * @return {import("../Feature.js").default<Geometry>|null} The feature (or `null` if not found).
   */
  getFeatureByUid(e) {
    const t = this.uidIndex_[e];
    return t !== void 0 ? t : null;
  }
  /**
   * Get the format associated with this source.
   *
   * @return {import("../format/Feature.js").default|undefined} The feature format.
   * @api
   */
  getFormat() {
    return this.format_;
  }
  /**
   * @return {boolean} The source can have overlapping geometries.
   */
  getOverlaps() {
    return this.overlaps_;
  }
  /**
   * Get the url associated with this source.
   *
   * @return {string|import("../featureloader.js").FeatureUrlFunction|undefined} The url.
   * @api
   */
  getUrl() {
    return this.url_;
  }
  /**
   * @param {Event} event Event.
   * @private
   */
  handleFeatureChange_(e) {
    const t = (
      /** @type {import("../Feature.js").default<Geometry>} */
      e.target
    ), i = B(t), n = t.getGeometry();
    if (!n)
      i in this.nullGeometryFeatures_ || (this.featuresRtree_ && this.featuresRtree_.remove(t), this.nullGeometryFeatures_[i] = t);
    else {
      const o = n.getExtent();
      i in this.nullGeometryFeatures_ ? (delete this.nullGeometryFeatures_[i], this.featuresRtree_ && this.featuresRtree_.insert(o, t)) : this.featuresRtree_ && this.featuresRtree_.update(o, t);
    }
    const r = t.getId();
    if (r !== void 0) {
      const o = r.toString();
      this.idIndex_[o] !== t && (this.removeFromIdIndex_(t), this.idIndex_[o] = t);
    } else
      this.removeFromIdIndex_(t), this.uidIndex_[i] = t;
    this.changed(), this.dispatchEvent(
      new Vt(Le.CHANGEFEATURE, t)
    );
  }
  /**
   * Returns true if the feature is contained within the source.
   * @param {import("../Feature.js").default<Geometry>} feature Feature.
   * @return {boolean} Has feature.
   * @api
   */
  hasFeature(e) {
    const t = e.getId();
    return t !== void 0 ? t in this.idIndex_ : B(e) in this.uidIndex_;
  }
  /**
   * @return {boolean} Is empty.
   */
  isEmpty() {
    return this.featuresRtree_ ? this.featuresRtree_.isEmpty() && sn(this.nullGeometryFeatures_) : this.featuresCollection_ ? this.featuresCollection_.getLength() === 0 : !0;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {import("../proj/Projection.js").default} projection Projection.
   */
  loadFeatures(e, t, i) {
    const n = this.loadedExtentsRtree_, r = this.strategy_(e, t, i);
    for (let o = 0, a = r.length; o < a; ++o) {
      const l = r[o];
      n.forEachInExtent(
        l,
        /**
         * @param {{extent: import("../extent.js").Extent}} object Object.
         * @return {boolean} Contains.
         */
        function(c) {
          return Ft(c.extent, l);
        }
      ) || (++this.loadingExtentsCount_, this.dispatchEvent(
        new Vt(Le.FEATURESLOADSTART)
      ), this.loader_.call(
        this,
        l,
        t,
        i,
        (c) => {
          --this.loadingExtentsCount_, this.dispatchEvent(
            new Vt(
              Le.FEATURESLOADEND,
              void 0,
              c
            )
          );
        },
        () => {
          --this.loadingExtentsCount_, this.dispatchEvent(
            new Vt(Le.FEATURESLOADERROR)
          );
        }
      ), n.insert(l, { extent: l.slice() }));
    }
    this.loading = this.loader_.length < 4 ? !1 : this.loadingExtentsCount_ > 0;
  }
  refresh() {
    this.clear(!0), this.loadedExtentsRtree_.clear(), super.refresh();
  }
  /**
   * Remove an extent from the list of loaded extents.
   * @param {import("../extent.js").Extent} extent Extent.
   * @api
   */
  removeLoadedExtent(e) {
    const t = this.loadedExtentsRtree_;
    let i;
    t.forEachInExtent(e, function(n) {
      if (ti(n.extent, e))
        return i = n, !0;
    }), i && t.remove(i);
  }
  /**
   * Remove a single feature from the source.  If you want to remove all features
   * at once, use the {@link module:ol/source/Vector~VectorSource#clear #clear()} method
   * instead.
   * @param {import("../Feature.js").default<Geometry>} feature Feature to remove.
   * @api
   */
  removeFeature(e) {
    if (!e)
      return;
    const t = B(e);
    t in this.nullGeometryFeatures_ ? delete this.nullGeometryFeatures_[t] : this.featuresRtree_ && this.featuresRtree_.remove(e), this.removeFeatureInternal(e) && this.changed();
  }
  /**
   * Remove feature without firing a `change` event.
   * @param {import("../Feature.js").default<Geometry>} feature Feature.
   * @return {import("../Feature.js").default<Geometry>|undefined} The removed feature
   *     (or undefined if the feature was not found).
   * @protected
   */
  removeFeatureInternal(e) {
    const t = B(e), i = this.featureChangeKeys_[t];
    if (!i)
      return;
    i.forEach(re), delete this.featureChangeKeys_[t];
    const n = e.getId();
    return n !== void 0 && delete this.idIndex_[n.toString()], delete this.uidIndex_[t], this.dispatchEvent(
      new Vt(Le.REMOVEFEATURE, e)
    ), e;
  }
  /**
   * Remove a feature from the id index.  Called internally when the feature id
   * may have changed.
   * @param {import("../Feature.js").default<Geometry>} feature The feature.
   * @return {boolean} Removed the feature from the index.
   * @private
   */
  removeFromIdIndex_(e) {
    let t = !1;
    for (const i in this.idIndex_)
      if (this.idIndex_[i] === e) {
        delete this.idIndex_[i], t = !0;
        break;
      }
    return t;
  }
  /**
   * Set the new loader of the source. The next render cycle will use the
   * new loader.
   * @param {import("../featureloader.js").FeatureLoader} loader The loader to set.
   * @api
   */
  setLoader(e) {
    this.loader_ = e;
  }
  /**
   * Points the source to a new url. The next render cycle will use the new url.
   * @param {string|import("../featureloader.js").FeatureUrlFunction} url Url.
   * @api
   */
  setUrl(e) {
    Z(this.format_, 7), this.url_ = e, this.setLoader(Hl(e, this.format_));
  }
}
const we = X_;
class $a extends ht {
  /**
   * @param {Geometry|ObjectWithGeometry<Geometry>} [geometryOrProperties]
   *     You may pass a Geometry object directly, or an object literal containing
   *     properties. If you pass an object literal, you may include a Geometry
   *     associated with a `geometry` key.
   */
  constructor(e) {
    if (super(), this.on, this.once, this.un, this.id_ = void 0, this.geometryName_ = "geometry", this.style_ = null, this.styleFunction_ = void 0, this.geometryChangeKey_ = null, this.addChangeListener(this.geometryName_, this.handleGeometryChanged_), e)
      if (typeof /** @type {?} */
      e.getSimplifiedGeometry == "function") {
        const t = (
          /** @type {Geometry} */
          e
        );
        this.setGeometry(t);
      } else {
        const t = e;
        this.setProperties(t);
      }
  }
  /**
   * Clone this feature. If the original feature has a geometry it
   * is also cloned. The feature id is not set in the clone.
   * @return {Feature<Geometry>} The clone.
   * @api
   */
  clone() {
    const e = (
      /** @type {Feature<Geometry>} */
      new $a(this.hasProperties() ? this.getProperties() : null)
    );
    e.setGeometryName(this.getGeometryName());
    const t = this.getGeometry();
    t && e.setGeometry(
      /** @type {Geometry} */
      t.clone()
    );
    const i = this.getStyle();
    return i && e.setStyle(i), e;
  }
  /**
   * Get the feature's default geometry.  A feature may have any number of named
   * geometries.  The "default" geometry (the one that is rendered by default) is
   * set when calling {@link module:ol/Feature~Feature#setGeometry}.
   * @return {Geometry|undefined} The default geometry for the feature.
   * @api
   * @observable
   */
  getGeometry() {
    return (
      /** @type {Geometry|undefined} */
      this.get(this.geometryName_)
    );
  }
  /**
   * Get the feature identifier.  This is a stable identifier for the feature and
   * is either set when reading data from a remote source or set explicitly by
   * calling {@link module:ol/Feature~Feature#setId}.
   * @return {number|string|undefined} Id.
   * @api
   */
  getId() {
    return this.id_;
  }
  /**
   * Get the name of the feature's default geometry.  By default, the default
   * geometry is named `geometry`.
   * @return {string} Get the property name associated with the default geometry
   *     for this feature.
   * @api
   */
  getGeometryName() {
    return this.geometryName_;
  }
  /**
   * Get the feature's style. Will return what was provided to the
   * {@link module:ol/Feature~Feature#setStyle} method.
   * @return {import("./style/Style.js").StyleLike|undefined} The feature style.
   * @api
   */
  getStyle() {
    return this.style_;
  }
  /**
   * Get the feature's style function.
   * @return {import("./style/Style.js").StyleFunction|undefined} Return a function
   * representing the current style of this feature.
   * @api
   */
  getStyleFunction() {
    return this.styleFunction_;
  }
  /**
   * @private
   */
  handleGeometryChange_() {
    this.changed();
  }
  /**
   * @private
   */
  handleGeometryChanged_() {
    this.geometryChangeKey_ && (re(this.geometryChangeKey_), this.geometryChangeKey_ = null);
    const e = this.getGeometry();
    e && (this.geometryChangeKey_ = H(
      e,
      z.CHANGE,
      this.handleGeometryChange_,
      this
    )), this.changed();
  }
  /**
   * Set the default geometry for the feature.  This will update the property
   * with the name returned by {@link module:ol/Feature~Feature#getGeometryName}.
   * @param {Geometry|undefined} geometry The new geometry.
   * @api
   * @observable
   */
  setGeometry(e) {
    this.set(this.geometryName_, e);
  }
  /**
   * Set the style for the feature to override the layer style.  This can be a
   * single style object, an array of styles, or a function that takes a
   * resolution and returns an array of styles. To unset the feature style, call
   * `setStyle()` without arguments or a falsey value.
   * @param {import("./style/Style.js").StyleLike} [style] Style for this feature.
   * @api
   * @fires module:ol/events/Event~BaseEvent#event:change
   */
  setStyle(e) {
    this.style_ = e, this.styleFunction_ = e ? W_(e) : void 0, this.changed();
  }
  /**
   * Set the feature id.  The feature id is considered stable and may be used when
   * requesting features or comparing identifiers returned from a remote source.
   * The feature id can be used with the
   * {@link module:ol/source/Vector~VectorSource#getFeatureById} method.
   * @param {number|string|undefined} id The feature id.
   * @api
   * @fires module:ol/events/Event~BaseEvent#event:change
   */
  setId(e) {
    this.id_ = e, this.changed();
  }
  /**
   * Set the property name to be used when getting the feature's default geometry.
   * When calling {@link module:ol/Feature~Feature#getGeometry}, the value of the property with
   * this name will be returned.
   * @param {string} name The property name of the default geometry.
   * @api
   */
  setGeometryName(e) {
    this.removeChangeListener(this.geometryName_, this.handleGeometryChanged_), this.geometryName_ = e, this.addChangeListener(this.geometryName_, this.handleGeometryChanged_), this.handleGeometryChanged_();
  }
}
function W_(s) {
  if (typeof s == "function")
    return s;
  let e;
  return Array.isArray(s) ? e = s : (Z(typeof /** @type {?} */
  s.getZIndex == "function", 41), e = [
    /** @type {import("./style/Style.js").default} */
    s
  ]), function() {
    return e;
  };
}
const $ = $a;
class gr extends Hh {
  /**
   * @param {Array<Geometry>} [geometries] Geometries.
   */
  constructor(e) {
    super(), this.geometries_ = e || null, this.changeEventsKeys_ = [], this.listenGeometriesChange_();
  }
  /**
   * @private
   */
  unlistenGeometriesChange_() {
    this.changeEventsKeys_.forEach(re), this.changeEventsKeys_.length = 0;
  }
  /**
   * @private
   */
  listenGeometriesChange_() {
    if (this.geometries_)
      for (let e = 0, t = this.geometries_.length; e < t; ++e)
        this.changeEventsKeys_.push(
          H(this.geometries_[e], z.CHANGE, this.changed, this)
        );
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!GeometryCollection} Clone.
   * @api
   */
  clone() {
    const e = new gr(null);
    return e.setGeometries(this.geometries_), e.applyProperties(this), e;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(e, t, i, n) {
    if (n < Ri(this.getExtent(), e, t))
      return n;
    const r = this.geometries_;
    for (let o = 0, a = r.length; o < a; ++o)
      n = r[o].closestPointXY(
        e,
        t,
        i,
        n
      );
    return n;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */
  containsXY(e, t) {
    const i = this.geometries_;
    for (let n = 0, r = i.length; n < r; ++n)
      if (i[n].containsXY(e, t))
        return !0;
    return !1;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */
  computeExtent(e) {
    rs(e);
    const t = this.geometries_;
    for (let i = 0, n = t.length; i < n; ++i)
      In(e, t[i].getExtent());
    return e;
  }
  /**
   * Return the geometries that make up this geometry collection.
   * @return {Array<Geometry>} Geometries.
   * @api
   */
  getGeometries() {
    return Kl(this.geometries_);
  }
  /**
   * @return {Array<Geometry>} Geometries.
   */
  getGeometriesArray() {
    return this.geometries_;
  }
  /**
   * @return {Array<Geometry>} Geometries.
   */
  getGeometriesArrayRecursive() {
    let e = [];
    const t = this.geometries_;
    for (let i = 0, n = t.length; i < n; ++i)
      t[i].getType() === this.getType() ? e = e.concat(
        /** @type {GeometryCollection} */
        t[i].getGeometriesArrayRecursive()
      ) : e.push(t[i]);
    return e;
  }
  /**
   * Create a simplified version of this geometry using the Douglas Peucker algorithm.
   * @param {number} squaredTolerance Squared tolerance.
   * @return {GeometryCollection} Simplified GeometryCollection.
   */
  getSimplifiedGeometry(e) {
    if (this.simplifiedGeometryRevision !== this.getRevision() && (this.simplifiedGeometryMaxMinSquaredTolerance = 0, this.simplifiedGeometryRevision = this.getRevision()), e < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && e < this.simplifiedGeometryMaxMinSquaredTolerance)
      return this;
    const t = [], i = this.geometries_;
    let n = !1;
    for (let r = 0, o = i.length; r < o; ++r) {
      const a = i[r], l = a.getSimplifiedGeometry(e);
      t.push(l), l !== a && (n = !0);
    }
    if (n) {
      const r = new gr(null);
      return r.setGeometriesArray(t), r;
    }
    return this.simplifiedGeometryMaxMinSquaredTolerance = e, this;
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return "GeometryCollection";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(e) {
    const t = this.geometries_;
    for (let i = 0, n = t.length; i < n; ++i)
      if (t[i].intersectsExtent(e))
        return !0;
    return !1;
  }
  /**
   * @return {boolean} Is empty.
   */
  isEmpty() {
    return this.geometries_.length === 0;
  }
  /**
   * Rotate the geometry around a given coordinate. This modifies the geometry
   * coordinates in place.
   * @param {number} angle Rotation angle in radians.
   * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
   * @api
   */
  rotate(e, t) {
    const i = this.geometries_;
    for (let n = 0, r = i.length; n < r; ++n)
      i[n].rotate(e, t);
    this.changed();
  }
  /**
   * Scale the geometry (with an optional origin).  This modifies the geometry
   * coordinates in place.
   * @abstract
   * @param {number} sx The scaling factor in the x-direction.
   * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
   * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
   *     of the geometry extent).
   * @api
   */
  scale(e, t, i) {
    i || (i = Ne(this.getExtent()));
    const n = this.geometries_;
    for (let r = 0, o = n.length; r < o; ++r)
      n[r].scale(e, t, i);
    this.changed();
  }
  /**
   * Set the geometries that make up this geometry collection.
   * @param {Array<Geometry>} geometries Geometries.
   * @api
   */
  setGeometries(e) {
    this.setGeometriesArray(Kl(e));
  }
  /**
   * @param {Array<Geometry>} geometries Geometries.
   */
  setGeometriesArray(e) {
    this.unlistenGeometriesChange_(), this.geometries_ = e, this.listenGeometriesChange_(), this.changed();
  }
  /**
   * Apply a transform function to the coordinates of the geometry.
   * The geometry is modified in place.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   * @param {import("../proj.js").TransformFunction} transformFn Transform function.
   * Called with a flat array of geometry coordinates.
   * @api
   */
  applyTransform(e) {
    const t = this.geometries_;
    for (let i = 0, n = t.length; i < n; ++i)
      t[i].applyTransform(e);
    this.changed();
  }
  /**
   * Translate the geometry.  This modifies the geometry coordinates in place.  If
   * instead you want a new geometry, first `clone()` this geometry.
   * @param {number} deltaX Delta X.
   * @param {number} deltaY Delta Y.
   * @api
   */
  translate(e, t) {
    const i = this.geometries_;
    for (let n = 0, r = i.length; n < r; ++n)
      i[n].translate(e, t);
    this.changed();
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    this.unlistenGeometriesChange_(), super.disposeInternal();
  }
}
function Kl(s) {
  const e = [];
  for (let t = 0, i = s.length; t < i; ++t)
    e.push(s[t].clone());
  return e;
}
const Mt = gr;
function Mc(s, e, t, i, n, r, o) {
  let a, l;
  const h = (t - e) / i;
  if (h === 1)
    a = e;
  else if (h === 2)
    a = e, l = n;
  else if (h !== 0) {
    let c = s[e], u = s[e + 1], d = 0;
    const f = [0];
    for (let m = e + i; m < t; m += i) {
      const p = s[m], x = s[m + 1];
      d += Math.sqrt((p - c) * (p - c) + (x - u) * (x - u)), f.push(d), c = p, u = x;
    }
    const g = n * d, _ = Gu(f, g);
    _ < 0 ? (l = (g - f[-_ - 2]) / (f[-_ - 1] - f[-_ - 2]), a = e + (-_ - 2) * i) : a = e + _ * i;
  }
  o = o > 1 ? o : 2, r = r || new Array(o);
  for (let c = 0; c < o; ++c)
    r[c] = a === void 0 ? NaN : l === void 0 ? s[a + c] : He(s[a + c], s[a + i + c], l);
  return r;
}
function Vo(s, e, t, i, n, r) {
  if (t == e)
    return null;
  let o;
  if (n < s[e + i - 1])
    return r ? (o = s.slice(e, e + i), o[i - 1] = n, o) : null;
  if (s[t - 1] < n)
    return r ? (o = s.slice(t - i, t), o[i - 1] = n, o) : null;
  if (n == s[e + i - 1])
    return s.slice(e, e + i);
  let a = e / i, l = t / i;
  for (; a < l; ) {
    const d = a + l >> 1;
    n < s[(d + 1) * i - 1] ? l = d : a = d + 1;
  }
  const h = s[a * i - 1];
  if (n == h)
    return s.slice((a - 1) * i, (a - 1) * i + i);
  const c = s[(a + 1) * i - 1], u = (n - h) / (c - h);
  o = [];
  for (let d = 0; d < i - 1; ++d)
    o.push(
      He(
        s[(a - 1) * i + d],
        s[a * i + d],
        u
      )
    );
  return o.push(n), o;
}
function Y_(s, e, t, i, n, r, o) {
  if (o)
    return Vo(
      s,
      e,
      t[t.length - 1],
      i,
      n,
      r
    );
  let a;
  if (n < s[i - 1])
    return r ? (a = s.slice(0, i), a[i - 1] = n, a) : null;
  if (s[s.length - 1] < n)
    return r ? (a = s.slice(s.length - i), a[i - 1] = n, a) : null;
  for (let l = 0, h = t.length; l < h; ++l) {
    const c = t[l];
    if (e != c) {
      if (n < s[e + i - 1])
        return null;
      if (n <= s[c - 1])
        return Vo(
          s,
          e,
          c,
          i,
          n,
          !1
        );
      e = c;
    }
  }
  return null;
}
class _r extends ni {
  /**
   * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `layout` are also accepted.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  constructor(e, t) {
    super(), this.flatMidpoint_ = null, this.flatMidpointRevision_ = -1, this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, t !== void 0 && !Array.isArray(e[0]) ? this.setFlatCoordinates(
      t,
      /** @type {Array<number>} */
      e
    ) : this.setCoordinates(
      /** @type {Array<import("../coordinate.js").Coordinate>} */
      e,
      t
    );
  }
  /**
   * Append the passed coordinate to the coordinates of the linestring.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @api
   */
  appendCoordinate(e) {
    this.flatCoordinates ? ae(this.flatCoordinates, e) : this.flatCoordinates = e.slice(), this.changed();
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!LineString} Clone.
   * @api
   */
  clone() {
    const e = new _r(
      this.flatCoordinates.slice(),
      this.layout
    );
    return e.applyProperties(this), e;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(e, t, i, n) {
    return n < Ri(this.getExtent(), e, t) ? n : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(
      Sa(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride,
        0
      )
    ), this.maxDeltaRevision_ = this.getRevision()), Ia(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      this.maxDelta_,
      !1,
      e,
      t,
      i,
      n
    ));
  }
  /**
   * Iterate over each segment, calling the provided callback.
   * If the callback returns a truthy value the function returns that
   * value immediately. Otherwise the function returns `false`.
   *
   * @param {function(this: S, import("../coordinate.js").Coordinate, import("../coordinate.js").Coordinate): T} callback Function
   *     called for each segment. The function will receive two arguments, the start and end coordinates of the segment.
   * @return {T|boolean} Value.
   * @template T,S
   * @api
   */
  forEachSegment(e) {
    return tc(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      e
    );
  }
  /**
   * Returns the coordinate at `m` using linear interpolation, or `null` if no
   * such coordinate exists.
   *
   * `extrapolate` controls extrapolation beyond the range of Ms in the
   * MultiLineString. If `extrapolate` is `true` then Ms less than the first
   * M will return the first coordinate and Ms greater than the last M will
   * return the last coordinate.
   *
   * @param {number} m M.
   * @param {boolean} [extrapolate] Extrapolate. Default is `false`.
   * @return {import("../coordinate.js").Coordinate|null} Coordinate.
   * @api
   */
  getCoordinateAtM(e, t) {
    return this.layout != "XYM" && this.layout != "XYZM" ? null : (t = t !== void 0 ? t : !1, Vo(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      e,
      t
    ));
  }
  /**
   * Return the coordinates of the linestring.
   * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
   * @api
   */
  getCoordinates() {
    return qt(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride
    );
  }
  /**
   * Return the coordinate at the provided fraction along the linestring.
   * The `fraction` is a number between 0 and 1, where 0 is the start of the
   * linestring and 1 is the end.
   * @param {number} fraction Fraction.
   * @param {import("../coordinate.js").Coordinate} [dest] Optional coordinate whose values will
   *     be modified. If not provided, a new coordinate will be returned.
   * @return {import("../coordinate.js").Coordinate} Coordinate of the interpolated point.
   * @api
   */
  getCoordinateAt(e, t) {
    return Mc(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      e,
      t,
      this.stride
    );
  }
  /**
   * Return the length of the linestring on projected plane.
   * @return {number} Length (on projected plane).
   * @api
   */
  getLength() {
    return Ac(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride
    );
  }
  /**
   * @return {Array<number>} Flat midpoint.
   */
  getFlatMidpoint() {
    return this.flatMidpointRevision_ != this.getRevision() && (this.flatMidpoint_ = this.getCoordinateAt(0.5, this.flatMidpoint_), this.flatMidpointRevision_ = this.getRevision()), this.flatMidpoint_;
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {LineString} Simplified LineString.
   * @protected
   */
  getSimplifiedGeometryInternal(e) {
    const t = [];
    return t.length = Fa(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      e,
      t,
      0
    ), new _r(t, "XY");
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return "LineString";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(e) {
    return Lr(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      e
    );
  }
  /**
   * Set the coordinates of the linestring.
   * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCoordinates(e, t) {
    this.setLayout(t, e, 1), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = Ir(
      this.flatCoordinates,
      0,
      e,
      this.stride
    ), this.changed();
  }
}
const qe = _r;
class mr extends ni {
  /**
   * @param {Array<Array<import("../coordinate.js").Coordinate>|LineString>|Array<number>} coordinates
   *     Coordinates or LineString geometries. (For internal use, flat coordinates in
   *     combination with `layout` and `ends` are also accepted.)
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @param {Array<number>} [ends] Flat coordinate ends for internal use.
   */
  constructor(e, t, i) {
    if (super(), this.ends_ = [], this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, Array.isArray(e[0]))
      this.setCoordinates(
        /** @type {Array<Array<import("../coordinate.js").Coordinate>>} */
        e,
        t
      );
    else if (t !== void 0 && i)
      this.setFlatCoordinates(
        t,
        /** @type {Array<number>} */
        e
      ), this.ends_ = i;
    else {
      let n = this.getLayout();
      const r = (
        /** @type {Array<LineString>} */
        e
      ), o = [], a = [];
      for (let l = 0, h = r.length; l < h; ++l) {
        const c = r[l];
        l === 0 && (n = c.getLayout()), ae(o, c.getFlatCoordinates()), a.push(o.length);
      }
      this.setFlatCoordinates(n, o), this.ends_ = a;
    }
  }
  /**
   * Append the passed linestring to the multilinestring.
   * @param {LineString} lineString LineString.
   * @api
   */
  appendLineString(e) {
    this.flatCoordinates ? ae(this.flatCoordinates, e.getFlatCoordinates().slice()) : this.flatCoordinates = e.getFlatCoordinates().slice(), this.ends_.push(this.flatCoordinates.length), this.changed();
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!MultiLineString} Clone.
   * @api
   */
  clone() {
    const e = new mr(
      this.flatCoordinates.slice(),
      this.layout,
      this.ends_.slice()
    );
    return e.applyProperties(this), e;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(e, t, i, n) {
    return n < Ri(this.getExtent(), e, t) ? n : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(
      Ra(
        this.flatCoordinates,
        0,
        this.ends_,
        this.stride,
        0
      )
    ), this.maxDeltaRevision_ = this.getRevision()), La(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      this.maxDelta_,
      !1,
      e,
      t,
      i,
      n
    ));
  }
  /**
   * Returns the coordinate at `m` using linear interpolation, or `null` if no
   * such coordinate exists.
   *
   * `extrapolate` controls extrapolation beyond the range of Ms in the
   * MultiLineString. If `extrapolate` is `true` then Ms less than the first
   * M will return the first coordinate and Ms greater than the last M will
   * return the last coordinate.
   *
   * `interpolate` controls interpolation between consecutive LineStrings
   * within the MultiLineString. If `interpolate` is `true` the coordinates
   * will be linearly interpolated between the last coordinate of one LineString
   * and the first coordinate of the next LineString.  If `interpolate` is
   * `false` then the function will return `null` for Ms falling between
   * LineStrings.
   *
   * @param {number} m M.
   * @param {boolean} [extrapolate] Extrapolate. Default is `false`.
   * @param {boolean} [interpolate] Interpolate. Default is `false`.
   * @return {import("../coordinate.js").Coordinate|null} Coordinate.
   * @api
   */
  getCoordinateAtM(e, t, i) {
    return this.layout != "XYM" && this.layout != "XYZM" || this.flatCoordinates.length === 0 ? null : (t = t !== void 0 ? t : !1, i = i !== void 0 ? i : !1, Y_(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      e,
      t,
      i
    ));
  }
  /**
   * Return the coordinates of the multilinestring.
   * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.
   * @api
   */
  getCoordinates() {
    return zn(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride
    );
  }
  /**
   * @return {Array<number>} Ends.
   */
  getEnds() {
    return this.ends_;
  }
  /**
   * Return the linestring at the specified index.
   * @param {number} index Index.
   * @return {LineString} LineString.
   * @api
   */
  getLineString(e) {
    return e < 0 || this.ends_.length <= e ? null : new qe(
      this.flatCoordinates.slice(
        e === 0 ? 0 : this.ends_[e - 1],
        this.ends_[e]
      ),
      this.layout
    );
  }
  /**
   * Return the linestrings of this multilinestring.
   * @return {Array<LineString>} LineStrings.
   * @api
   */
  getLineStrings() {
    const e = this.flatCoordinates, t = this.ends_, i = this.layout, n = [];
    let r = 0;
    for (let o = 0, a = t.length; o < a; ++o) {
      const l = t[o], h = new qe(
        e.slice(r, l),
        i
      );
      n.push(h), r = l;
    }
    return n;
  }
  /**
   * @return {Array<number>} Flat midpoints.
   */
  getFlatMidpoints() {
    const e = [], t = this.flatCoordinates;
    let i = 0;
    const n = this.ends_, r = this.stride;
    for (let o = 0, a = n.length; o < a; ++o) {
      const l = n[o], h = Mc(
        t,
        i,
        l,
        r,
        0.5
      );
      ae(e, h), i = l;
    }
    return e;
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {MultiLineString} Simplified MultiLineString.
   * @protected
   */
  getSimplifiedGeometryInternal(e) {
    const t = [], i = [];
    return t.length = ef(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      e,
      t,
      0,
      i
    ), new mr(t, "XY", i);
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return "MultiLineString";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(e) {
    return hf(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      e
    );
  }
  /**
   * Set the coordinates of the multilinestring.
   * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCoordinates(e, t) {
    this.setLayout(t, e, 2), this.flatCoordinates || (this.flatCoordinates = []);
    const i = Aa(
      this.flatCoordinates,
      0,
      e,
      this.stride,
      this.ends_
    );
    this.flatCoordinates.length = i.length === 0 ? 0 : i[i.length - 1], this.changed();
  }
}
const fs = mr;
class Qa extends ni {
  /**
   * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `layout` are also accepted.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  constructor(e, t) {
    super(), t && !Array.isArray(e[0]) ? this.setFlatCoordinates(
      t,
      /** @type {Array<number>} */
      e
    ) : this.setCoordinates(
      /** @type {Array<import("../coordinate.js").Coordinate>} */
      e,
      t
    );
  }
  /**
   * Append the passed point to this multipoint.
   * @param {Point} point Point.
   * @api
   */
  appendPoint(e) {
    this.flatCoordinates ? ae(this.flatCoordinates, e.getFlatCoordinates()) : this.flatCoordinates = e.getFlatCoordinates().slice(), this.changed();
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!MultiPoint} Clone.
   * @api
   */
  clone() {
    const e = new Qa(
      this.flatCoordinates.slice(),
      this.layout
    );
    return e.applyProperties(this), e;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(e, t, i, n) {
    if (n < Ri(this.getExtent(), e, t))
      return n;
    const r = this.flatCoordinates, o = this.stride;
    for (let a = 0, l = r.length; a < l; a += o) {
      const h = bt(
        e,
        t,
        r[a],
        r[a + 1]
      );
      if (h < n) {
        n = h;
        for (let c = 0; c < o; ++c)
          i[c] = r[a + c];
        i.length = o;
      }
    }
    return n;
  }
  /**
   * Return the coordinates of the multipoint.
   * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
   * @api
   */
  getCoordinates() {
    return qt(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride
    );
  }
  /**
   * Return the point at the specified index.
   * @param {number} index Index.
   * @return {Point} Point.
   * @api
   */
  getPoint(e) {
    const t = this.flatCoordinates ? this.flatCoordinates.length / this.stride : 0;
    return e < 0 || t <= e ? null : new Ee(
      this.flatCoordinates.slice(
        e * this.stride,
        (e + 1) * this.stride
      ),
      this.layout
    );
  }
  /**
   * Return the points of this multipoint.
   * @return {Array<Point>} Points.
   * @api
   */
  getPoints() {
    const e = this.flatCoordinates, t = this.layout, i = this.stride, n = [];
    for (let r = 0, o = e.length; r < o; r += i) {
      const a = new Ee(e.slice(r, r + i), t);
      n.push(a);
    }
    return n;
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return "MultiPoint";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(e) {
    const t = this.flatCoordinates, i = this.stride;
    for (let n = 0, r = t.length; n < r; n += i) {
      const o = t[n], a = t[n + 1];
      if (ua(e, o, a))
        return !0;
    }
    return !1;
  }
  /**
   * Set the coordinates of the multipoint.
   * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCoordinates(e, t) {
    this.setLayout(t, e, 1), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = Ir(
      this.flatCoordinates,
      0,
      e,
      this.stride
    ), this.changed();
  }
}
const gs = Qa;
function V_(s, e, t, i) {
  const n = [];
  let r = Me();
  for (let o = 0, a = t.length; o < a; ++o) {
    const l = t[o];
    r = Ph(
      s,
      e,
      l[0],
      i
    ), n.push((r[0] + r[2]) / 2, (r[1] + r[3]) / 2), e = l[l.length - 1];
  }
  return n;
}
class pr extends ni {
  /**
   * @param {Array<Array<Array<import("../coordinate.js").Coordinate>>|Polygon>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `layout` and `endss` are also accepted.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @param {Array<Array<number>>} [endss] Array of ends for internal use with flat coordinates.
   */
  constructor(e, t, i) {
    if (super(), this.endss_ = [], this.flatInteriorPointsRevision_ = -1, this.flatInteriorPoints_ = null, this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, this.orientedRevision_ = -1, this.orientedFlatCoordinates_ = null, !i && !Array.isArray(e[0])) {
      let n = this.getLayout();
      const r = (
        /** @type {Array<Polygon>} */
        e
      ), o = [], a = [];
      for (let l = 0, h = r.length; l < h; ++l) {
        const c = r[l];
        l === 0 && (n = c.getLayout());
        const u = o.length, d = c.getEnds();
        for (let f = 0, g = d.length; f < g; ++f)
          d[f] += u;
        ae(o, c.getFlatCoordinates()), a.push(d);
      }
      t = n, e = o, i = a;
    }
    t !== void 0 && i ? (this.setFlatCoordinates(
      t,
      /** @type {Array<number>} */
      e
    ), this.endss_ = i) : this.setCoordinates(
      /** @type {Array<Array<Array<import("../coordinate.js").Coordinate>>>} */
      e,
      t
    );
  }
  /**
   * Append the passed polygon to this multipolygon.
   * @param {Polygon} polygon Polygon.
   * @api
   */
  appendPolygon(e) {
    let t;
    if (!this.flatCoordinates)
      this.flatCoordinates = e.getFlatCoordinates().slice(), t = e.getEnds().slice(), this.endss_.push();
    else {
      const i = this.flatCoordinates.length;
      ae(this.flatCoordinates, e.getFlatCoordinates()), t = e.getEnds().slice();
      for (let n = 0, r = t.length; n < r; ++n)
        t[n] += i;
    }
    this.endss_.push(t), this.changed();
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!MultiPolygon} Clone.
   * @api
   */
  clone() {
    const e = this.endss_.length, t = new Array(e);
    for (let n = 0; n < e; ++n)
      t[n] = this.endss_[n].slice();
    const i = new pr(
      this.flatCoordinates.slice(),
      this.layout,
      t
    );
    return i.applyProperties(this), i;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(e, t, i, n) {
    return n < Ri(this.getExtent(), e, t) ? n : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(
      Jd(
        this.flatCoordinates,
        0,
        this.endss_,
        this.stride,
        0
      )
    ), this.maxDeltaRevision_ = this.getRevision()), $d(
      this.getOrientedFlatCoordinates(),
      0,
      this.endss_,
      this.stride,
      this.maxDelta_,
      !0,
      e,
      t,
      i,
      n
    ));
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */
  containsXY(e, t) {
    return af(
      this.getOrientedFlatCoordinates(),
      0,
      this.endss_,
      this.stride,
      e,
      t
    );
  }
  /**
   * Return the area of the multipolygon on projected plane.
   * @return {number} Area (on projected plane).
   * @api
   */
  getArea() {
    return sf(
      this.getOrientedFlatCoordinates(),
      0,
      this.endss_,
      this.stride
    );
  }
  /**
   * Get the coordinate array for this geometry.  This array has the structure
   * of a GeoJSON coordinate array for multi-polygons.
   *
   * @param {boolean} [right] Orient coordinates according to the right-hand
   *     rule (counter-clockwise for exterior and clockwise for interior rings).
   *     If `false`, coordinates will be oriented according to the left-hand rule
   *     (clockwise for exterior and counter-clockwise for interior rings).
   *     By default, coordinate orientation will depend on how the geometry was
   *     constructed.
   * @return {Array<Array<Array<import("../coordinate.js").Coordinate>>>} Coordinates.
   * @api
   */
  getCoordinates(e) {
    let t;
    return e !== void 0 ? (t = this.getOrientedFlatCoordinates().slice(), Fl(
      t,
      0,
      this.endss_,
      this.stride,
      e
    )) : t = this.flatCoordinates, ko(
      t,
      0,
      this.endss_,
      this.stride
    );
  }
  /**
   * @return {Array<Array<number>>} Endss.
   */
  getEndss() {
    return this.endss_;
  }
  /**
   * @return {Array<number>} Flat interior points.
   */
  getFlatInteriorPoints() {
    if (this.flatInteriorPointsRevision_ != this.getRevision()) {
      const e = V_(
        this.flatCoordinates,
        0,
        this.endss_,
        this.stride
      );
      this.flatInteriorPoints_ = lf(
        this.getOrientedFlatCoordinates(),
        0,
        this.endss_,
        this.stride,
        e
      ), this.flatInteriorPointsRevision_ = this.getRevision();
    }
    return this.flatInteriorPoints_;
  }
  /**
   * Return the interior points as {@link module:ol/geom/MultiPoint~MultiPoint multipoint}.
   * @return {MultiPoint} Interior points as XYM coordinates, where M is
   * the length of the horizontal intersection that the point belongs to.
   * @api
   */
  getInteriorPoints() {
    return new gs(this.getFlatInteriorPoints().slice(), "XYM");
  }
  /**
   * @return {Array<number>} Oriented flat coordinates.
   */
  getOrientedFlatCoordinates() {
    if (this.orientedRevision_ != this.getRevision()) {
      const e = this.flatCoordinates;
      df(e, 0, this.endss_, this.stride) ? this.orientedFlatCoordinates_ = e : (this.orientedFlatCoordinates_ = e.slice(), this.orientedFlatCoordinates_.length = Fl(
        this.orientedFlatCoordinates_,
        0,
        this.endss_,
        this.stride
      )), this.orientedRevision_ = this.getRevision();
    }
    return this.orientedFlatCoordinates_;
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {MultiPolygon} Simplified MultiPolygon.
   * @protected
   */
  getSimplifiedGeometryInternal(e) {
    const t = [], i = [];
    return t.length = nf(
      this.flatCoordinates,
      0,
      this.endss_,
      this.stride,
      Math.sqrt(e),
      t,
      0,
      i
    ), new pr(t, "XY", i);
  }
  /**
   * Return the polygon at the specified index.
   * @param {number} index Index.
   * @return {Polygon} Polygon.
   * @api
   */
  getPolygon(e) {
    if (e < 0 || this.endss_.length <= e)
      return null;
    let t;
    if (e === 0)
      t = 0;
    else {
      const r = this.endss_[e - 1];
      t = r[r.length - 1];
    }
    const i = this.endss_[e].slice(), n = i[i.length - 1];
    if (t !== 0)
      for (let r = 0, o = i.length; r < o; ++r)
        i[r] -= t;
    return new We(
      this.flatCoordinates.slice(t, n),
      this.layout,
      i
    );
  }
  /**
   * Return the polygons of this multipolygon.
   * @return {Array<Polygon>} Polygons.
   * @api
   */
  getPolygons() {
    const e = this.layout, t = this.flatCoordinates, i = this.endss_, n = [];
    let r = 0;
    for (let o = 0, a = i.length; o < a; ++o) {
      const l = i[o].slice(), h = l[l.length - 1];
      if (r !== 0)
        for (let u = 0, d = l.length; u < d; ++u)
          l[u] -= r;
      const c = new We(
        t.slice(r, h),
        e,
        l
      );
      n.push(c), r = h;
    }
    return n;
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return "MultiPolygon";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(e) {
    return cf(
      this.getOrientedFlatCoordinates(),
      0,
      this.endss_,
      this.stride,
      e
    );
  }
  /**
   * Set the coordinates of the multipolygon.
   * @param {!Array<Array<Array<import("../coordinate.js").Coordinate>>>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCoordinates(e, t) {
    this.setLayout(t, e, 3), this.flatCoordinates || (this.flatCoordinates = []);
    const i = Qd(
      this.flatCoordinates,
      0,
      e,
      this.stride,
      this.endss_
    );
    if (i.length === 0)
      this.flatCoordinates.length = 0;
    else {
      const n = i[i.length - 1];
      this.flatCoordinates.length = n.length === 0 ? 0 : n[n.length - 1];
    }
    this.changed();
  }
}
const Pr = pr;
class Oc {
  constructor() {
    this.dataProjection = void 0, this.defaultFeatureProjection = void 0, this.supportedMediaTypes = null;
  }
  /**
   * Adds the data projection to the read options.
   * @param {Document|Element|Object|string} source Source.
   * @param {ReadOptions} [options] Options.
   * @return {ReadOptions|undefined} Options.
   * @protected
   */
  getReadOptions(e, t) {
    if (t) {
      let i = t.dataProjection ? ye(t.dataProjection) : this.readProjection(e);
      t.extent && i && i.getUnits() === "tile-pixels" && (i = ye(i), i.setWorldExtent(t.extent)), t = {
        dataProjection: i,
        featureProjection: t.featureProjection
      };
    }
    return this.adaptOptions(t);
  }
  /**
   * Sets the `dataProjection` on the options, if no `dataProjection`
   * is set.
   * @param {WriteOptions|ReadOptions|undefined} options
   *     Options.
   * @protected
   * @return {WriteOptions|ReadOptions|undefined}
   *     Updated options.
   */
  adaptOptions(e) {
    return Object.assign(
      {
        dataProjection: this.dataProjection,
        featureProjection: this.defaultFeatureProjection
      },
      e
    );
  }
  /**
   * @abstract
   * @return {Type} The format type.
   */
  getType() {
    return X();
  }
  /**
   * Read a single feature from a source.
   *
   * @abstract
   * @param {Document|Element|Object|string} source Source.
   * @param {ReadOptions} [options] Read options.
   * @return {import("../Feature.js").FeatureLike} Feature.
   */
  readFeature(e, t) {
    return X();
  }
  /**
   * Read all features from a source.
   *
   * @abstract
   * @param {Document|Element|ArrayBuffer|Object|string} source Source.
   * @param {ReadOptions} [options] Read options.
   * @return {Array<import("../Feature.js").FeatureLike>} Features.
   */
  readFeatures(e, t) {
    return X();
  }
  /**
   * Read a single geometry from a source.
   *
   * @abstract
   * @param {Document|Element|Object|string} source Source.
   * @param {ReadOptions} [options] Read options.
   * @return {import("../geom/Geometry.js").default} Geometry.
   */
  readGeometry(e, t) {
    return X();
  }
  /**
   * Read the projection from a source.
   *
   * @abstract
   * @param {Document|Element|Object|string} source Source.
   * @return {import("../proj/Projection.js").default|undefined} Projection.
   */
  readProjection(e) {
    return X();
  }
  /**
   * Encode a feature in this format.
   *
   * @abstract
   * @param {import("../Feature.js").default} feature Feature.
   * @param {WriteOptions} [options] Write options.
   * @return {string|ArrayBuffer} Result.
   */
  writeFeature(e, t) {
    return X();
  }
  /**
   * Encode an array of features in this format.
   *
   * @abstract
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {WriteOptions} [options] Write options.
   * @return {string|ArrayBuffer} Result.
   */
  writeFeatures(e, t) {
    return X();
  }
  /**
   * Write a single geometry in this format.
   *
   * @abstract
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {WriteOptions} [options] Write options.
   * @return {string|ArrayBuffer} Result.
   */
  writeGeometry(e, t) {
    return X();
  }
}
function Mr(s, e, t) {
  const i = t ? ye(t.featureProjection) : null, n = t ? ye(t.dataProjection) : null;
  let r;
  if (i && n && !At(i, n) ? r = (e ? s.clone() : s).transform(
    e ? i : n,
    e ? n : i
  ) : r = s, e && t && /** @type {WriteOptions} */
  t.decimals !== void 0) {
    const o = Math.pow(
      10,
      /** @type {WriteOptions} */
      t.decimals
    ), a = function(l) {
      for (let h = 0, c = l.length; h < c; ++h)
        l[h] = Math.round(l[h] * o) / o;
      return l;
    };
    r === s && (r = s.clone()), r.applyTransform(a);
  }
  return r;
}
const ql = "http://www.w3.org/2001/XMLSchema-instance";
function _s(s, e) {
  return Or().createElementNS(s, e);
}
function kt(s, e) {
  return Dc(s, e, []).join("");
}
function Dc(s, e, t) {
  if (s.nodeType == Node.CDATA_SECTION_NODE || s.nodeType == Node.TEXT_NODE)
    e ? t.push(String(s.nodeValue).replace(/(\r\n|\r|\n)/g, "")) : t.push(s.nodeValue);
  else {
    let i;
    for (i = s.firstChild; i; i = i.nextSibling)
      Dc(i, e, t);
  }
  return t;
}
function fi(s) {
  return "documentElement" in s;
}
function gi(s) {
  return new DOMParser().parseFromString(s, "application/xml");
}
function Jl(s, e) {
  return (
    /**
     * @param {Node} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function(t, i) {
      const n = s.call(
        e !== void 0 ? e : this,
        t,
        i
      );
      if (n !== void 0) {
        const r = (
          /** @type {Array<*>} */
          i[i.length - 1]
        );
        ae(r, n);
      }
    }
  );
}
function Kt(s, e) {
  return (
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function(t, i) {
      const n = s.call(
        e !== void 0 ? e : this,
        t,
        i
      );
      n !== void 0 && /** @type {Array<*>} */
      i[i.length - 1].push(n);
    }
  );
}
function el(s, e) {
  return (
    /**
     * @param {Node} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function(t, i) {
      const n = s.call(
        e !== void 0 ? e : this,
        t,
        i
      );
      n !== void 0 && (i[i.length - 1] = n);
    }
  );
}
function M(s, e, t) {
  return (
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function(i, n) {
      const r = s.call(
        t !== void 0 ? t : this,
        i,
        n
      );
      if (r !== void 0) {
        const o = (
          /** @type {!Object} */
          n[n.length - 1]
        ), a = e !== void 0 ? e : i.localName;
        o[a] = r;
      }
    }
  );
}
function U(s, e) {
  return function(t, i, n) {
    s.call(
      e !== void 0 ? e : this,
      t,
      i,
      n
    ), /** @type {NodeStackItem} */
    n[n.length - 1].node.appendChild(t);
  };
}
function Nt(s, e) {
  return (
    /**
     * @param {*} value Value.
     * @param {Array<*>} objectStack Object stack.
     * @param {string} [newNodeName] Node name.
     * @return {Node} Node.
     */
    function(t, i, n) {
      const o = /** @type {NodeStackItem} */ i[i.length - 1].node;
      let a = s;
      a === void 0 && (a = n);
      const l = e !== void 0 ? e : o.namespaceURI;
      return _s(
        l,
        /** @type {string} */
        a
      );
    }
  );
}
const it = Nt();
function lt(s, e) {
  const t = e.length, i = new Array(t);
  for (let n = 0; n < t; ++n)
    i[n] = s[e[n]];
  return i;
}
function D(s, e, t) {
  t = t !== void 0 ? t : {};
  let i, n;
  for (i = 0, n = s.length; i < n; ++i)
    t[s[i]] = e;
  return t;
}
function gn(s, e, t, i) {
  let n;
  for (n = e.firstElementChild; n; n = n.nextElementSibling) {
    const r = s[n.namespaceURI];
    if (r !== void 0) {
      const o = r[n.localName];
      o !== void 0 && o.call(i, n, t);
    }
  }
}
function le(s, e, t, i, n) {
  return i.push(s), gn(e, t, i, n), /** @type {T} */
  i.pop();
}
function Z_(s, e, t, i, n, r) {
  const o = (n !== void 0 ? n : t).length;
  let a, l;
  for (let h = 0; h < o; ++h)
    a = t[h], a !== void 0 && (l = e.call(
      r !== void 0 ? r : this,
      a,
      i,
      n !== void 0 ? n[h] : void 0
    ), l !== void 0 && s[l.namespaceURI][l.localName].call(
      r,
      l,
      a,
      i
    ));
}
function xe(s, e, t, i, n, r, o) {
  return n.push(s), Z_(e, t, i, n, r, o), /** @type {O|undefined} */
  n.pop();
}
let so;
function j_() {
  return so === void 0 && typeof XMLSerializer < "u" && (so = new XMLSerializer()), so;
}
let ro;
function Or() {
  return ro === void 0 && typeof document < "u" && (ro = document.implementation.createDocument("", "", null)), ro;
}
class H_ extends Oc {
  constructor() {
    super(), this.xmlSerializer_ = j_();
  }
  /**
   * @return {import("./Feature.js").Type} Format.
   */
  getType() {
    return "xml";
  }
  /**
   * Read a single feature.
   *
   * @param {Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {import("../Feature.js").default} Feature.
   * @api
   */
  readFeature(e, t) {
    if (e) {
      if (typeof e == "string") {
        const i = gi(e);
        return this.readFeatureFromDocument(i, t);
      } else if (fi(e))
        return this.readFeatureFromDocument(
          /** @type {Document} */
          e,
          t
        );
    } else
      return null;
    return this.readFeatureFromNode(
      /** @type {Element} */
      e,
      t
    );
  }
  /**
   * @param {Document} doc Document.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @return {import("../Feature.js").default} Feature.
   */
  readFeatureFromDocument(e, t) {
    const i = this.readFeaturesFromDocument(e, t);
    return i.length > 0 ? i[0] : null;
  }
  /**
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @return {import("../Feature.js").default} Feature.
   */
  readFeatureFromNode(e, t) {
    return null;
  }
  /**
   * Read all features from a feature collection.
   *
   * @param {Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @return {Array<import("../Feature.js").default>} Features.
   * @api
   */
  readFeatures(e, t) {
    if (e) {
      if (typeof e == "string") {
        const i = gi(e);
        return this.readFeaturesFromDocument(i, t);
      } else if (fi(e))
        return this.readFeaturesFromDocument(
          /** @type {Document} */
          e,
          t
        );
    } else
      return [];
    return this.readFeaturesFromNode(
      /** @type {Element} */
      e,
      t
    );
  }
  /**
   * @param {Document} doc Document.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @protected
   * @return {Array<import("../Feature.js").default>} Features.
   */
  readFeaturesFromDocument(e, t) {
    const i = [];
    for (let n = e.firstChild; n; n = n.nextSibling)
      n.nodeType == Node.ELEMENT_NODE && ae(
        i,
        this.readFeaturesFromNode(
          /** @type {Element} */
          n,
          t
        )
      );
    return i;
  }
  /**
   * @abstract
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @protected
   * @return {Array<import("../Feature.js").default>} Features.
   */
  readFeaturesFromNode(e, t) {
    return X();
  }
  /**
   * Read a single geometry from a source.
   *
   * @param {Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {import("../geom/Geometry.js").default} Geometry.
   */
  readGeometry(e, t) {
    if (e) {
      if (typeof e == "string") {
        const i = gi(e);
        return this.readGeometryFromDocument(i, t);
      } else if (fi(e))
        return this.readGeometryFromDocument(
          /** @type {Document} */
          e,
          t
        );
    } else
      return null;
    return this.readGeometryFromNode(
      /** @type {Element} */
      e,
      t
    );
  }
  /**
   * @param {Document} doc Document.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @protected
   * @return {import("../geom/Geometry.js").default} Geometry.
   */
  readGeometryFromDocument(e, t) {
    return null;
  }
  /**
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @protected
   * @return {import("../geom/Geometry.js").default} Geometry.
   */
  readGeometryFromNode(e, t) {
    return null;
  }
  /**
   * Read the projection from the source.
   *
   * @param {Document|Element|Object|string} source Source.
   * @return {import("../proj/Projection.js").default} Projection.
   * @api
   */
  readProjection(e) {
    if (e) {
      if (typeof e == "string") {
        const t = gi(e);
        return this.readProjectionFromDocument(t);
      } else if (fi(e))
        return this.readProjectionFromDocument(
          /** @type {Document} */
          e
        );
    } else
      return null;
    return this.readProjectionFromNode(
      /** @type {Element} */
      e
    );
  }
  /**
   * @param {Document} doc Document.
   * @protected
   * @return {import("../proj/Projection.js").default} Projection.
   */
  readProjectionFromDocument(e) {
    return this.dataProjection;
  }
  /**
   * @param {Element} node Node.
   * @protected
   * @return {import("../proj/Projection.js").default} Projection.
   */
  readProjectionFromNode(e) {
    return this.dataProjection;
  }
  /**
   * Encode a feature as string.
   *
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Encoded feature.
   */
  writeFeature(e, t) {
    const i = this.writeFeatureNode(e, t);
    return this.xmlSerializer_.serializeToString(i);
  }
  /**
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [options] Options.
   * @protected
   * @return {Node} Node.
   */
  writeFeatureNode(e, t) {
    return null;
  }
  /**
   * Encode an array of features as string.
   *
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Result.
   * @api
   */
  writeFeatures(e, t) {
    const i = this.writeFeaturesNode(e, t);
    return this.xmlSerializer_.serializeToString(i);
  }
  /**
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Options.
   * @return {Node} Node.
   */
  writeFeaturesNode(e, t) {
    return null;
  }
  /**
   * Encode a geometry as string.
   *
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Encoded geometry.
   */
  writeGeometry(e, t) {
    const i = this.writeGeometryNode(e, t);
    return this.xmlSerializer_.serializeToString(i);
  }
  /**
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Options.
   * @return {Node} Node.
   */
  writeGeometryNode(e, t) {
    return null;
  }
}
const K_ = H_;
function ii(s) {
  const e = kt(s, !1);
  return q_(e);
}
function q_(s) {
  const e = /^\s*(true|1)|(false|0)\s*$/.exec(s);
  if (e)
    return e[1] !== void 0 || !1;
}
function Ae(s) {
  const e = kt(s, !1);
  return J_(e);
}
function J_(s) {
  const e = /^\s*([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)\s*$/i.exec(s);
  if (e)
    return parseFloat(e[1]);
}
function ke(s) {
  return kt(s, !1).trim();
}
function hn(s, e) {
  at(s, e ? "1" : "0");
}
function $_(s, e) {
  s.appendChild(Or().createCDATASection(e));
}
function _i(s, e) {
  const t = e.toPrecision();
  s.appendChild(Or().createTextNode(t));
}
function at(s, e) {
  s.appendChild(Or().createTextNode(e));
}
const Gt = ["http://www.google.com/kml/ext/2.2"], O = [
  null,
  "http://earth.google.com/kml/2.0",
  "http://earth.google.com/kml/2.1",
  "http://earth.google.com/kml/2.2",
  "http://www.opengis.net/kml/2.2"
], Q_ = "http://www.opengis.net/kml/2.2 https://developers.google.com/kml/schema/kml22gx.xsd", $l = {
  fraction: "fraction",
  pixels: "pixels",
  insetPixels: "pixels"
}, em = D(
  O,
  {
    ExtendedData: qc,
    Region: Jc,
    MultiGeometry: M(jc, "geometry"),
    LineString: M(Vc, "geometry"),
    LinearRing: M(Zc, "geometry"),
    Point: M(Hc, "geometry"),
    Polygon: M(Kc, "geometry"),
    Style: M(nl),
    StyleMap: km,
    address: M(ke),
    description: M(ke),
    name: M(ke),
    open: M(ii),
    phoneNumber: M(ke),
    styleUrl: M(zc),
    visibility: M(ii)
  },
  D(Gt, {
    MultiTrack: M(wm, "geometry"),
    Track: M(Yc, "geometry")
  })
), tm = D(O, {
  ExtendedData: qc,
  Region: Jc,
  Link: Hm,
  address: M(ke),
  description: M(ke),
  name: M(ke),
  open: M(ii),
  phoneNumber: M(ke),
  visibility: M(ii)
}), im = D(O, {
  href: M(Uc)
}), kc = D(O, {
  LatLonAltBox: Bm,
  Lod: Wm
}), nm = D(O, ["Document", "Placemark"]), sm = D(O, {
  Document: U(ip),
  Placemark: U(eu)
});
let Ji, Ks = null, Zo, Pn, Mn, On, yr, jo = null, tl, Ho = null, Ko, mi = null, Ql = null, qo = null;
function xr(s) {
  return 32 / Math.min(s[0], s[1]);
}
function rm() {
  Ji = [255, 255, 255, 1], Ks = new N({
    color: Ji
  }), Zo = [20, 2], Pn = "pixels", Mn = "pixels", On = [64, 64], yr = "https://maps.google.com/mapfiles/kml/pushpin/ylw-pushpin.png", jo = new tt({
    anchor: Zo,
    anchorOrigin: "bottom-left",
    anchorXUnits: Pn,
    anchorYUnits: Mn,
    crossOrigin: "anonymous",
    rotation: 0,
    scale: xr(On),
    size: On,
    src: yr
  }), tl = "NO_IMAGE", Ho = new K({
    color: Ji,
    width: 1
  }), Ko = new K({
    color: [51, 51, 51, 1],
    width: 2
  }), mi = new De({
    font: "bold 16px Helvetica",
    fill: Ks,
    stroke: Ko,
    scale: 0.8
  }), Ql = new se({
    fill: Ks,
    image: jo,
    text: mi,
    stroke: Ho,
    zIndex: 0
  }), qo = [Ql];
}
let Ds;
function om(s) {
  return s;
}
class am extends K_ {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    super(), e = e || {}, qo || rm(), this.dataProjection = ye("EPSG:4326"), this.defaultStyle_ = e.defaultStyle ? e.defaultStyle : qo, this.extractStyles_ = e.extractStyles !== void 0 ? e.extractStyles : !0, this.writeStyles_ = e.writeStyles !== void 0 ? e.writeStyles : !0, this.sharedStyles_ = {}, this.showPointNames_ = e.showPointNames !== void 0 ? e.showPointNames : !0, this.crossOrigin_ = e.crossOrigin !== void 0 ? e.crossOrigin : "anonymous", this.iconUrlFunction_ = e.iconUrlFunction ? e.iconUrlFunction : om, this.supportedMediaTypes = ["application/vnd.google-earth.kml+xml"];
  }
  /**
   * @param {Node} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @private
   * @return {Array<Feature>|undefined} Features.
   */
  readDocumentOrFolder_(e, t) {
    const i = D(O, {
      Document: Jl(this.readDocumentOrFolder_, this),
      Folder: Jl(this.readDocumentOrFolder_, this),
      Placemark: Kt(this.readPlacemark_, this),
      Style: this.readSharedStyle_.bind(this),
      StyleMap: this.readSharedStyleMap_.bind(this)
    }), n = le([], i, e, t, this);
    if (n)
      return n;
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @private
   * @return {Feature|undefined} Feature.
   */
  readPlacemark_(e, t) {
    const i = le(
      { geometry: null },
      em,
      e,
      t,
      this
    );
    if (!i)
      return;
    const n = new $(), r = e.getAttribute("id");
    r !== null && n.setId(r);
    const o = (
      /** @type {import("./Feature.js").ReadOptions} */
      t[0]
    ), a = i.geometry;
    if (a && Mr(a, !1, o), n.setGeometry(a), delete i.geometry, this.extractStyles_) {
      const l = i.Style, h = i.styleUrl, c = hm(
        l,
        h,
        this.defaultStyle_,
        this.sharedStyles_,
        this.showPointNames_
      );
      n.setStyle(c);
    }
    return delete i.Style, n.setProperties(i, !0), n;
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @private
   */
  readSharedStyle_(e, t) {
    const i = e.getAttribute("id");
    if (i !== null) {
      const n = nl.call(this, e, t);
      if (n) {
        let r, o = e.baseURI;
        (!o || o == "about:blank") && (o = window.location.href), o ? r = new URL("#" + i, o).href : r = "#" + i, this.sharedStyles_[r] = n;
      }
    }
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @private
   */
  readSharedStyleMap_(e, t) {
    const i = e.getAttribute("id");
    if (i === null)
      return;
    const n = Xc.call(this, e, t);
    if (!n)
      return;
    let r, o = e.baseURI;
    (!o || o == "about:blank") && (o = window.location.href), o ? r = new URL("#" + i, o).href : r = "#" + i, this.sharedStyles_[r] = n;
  }
  /**
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @return {import("../Feature.js").default} Feature.
   */
  readFeatureFromNode(e, t) {
    if (!O.includes(e.namespaceURI))
      return null;
    const i = this.readPlacemark_(e, [
      this.getReadOptions(e, t)
    ]);
    return i || null;
  }
  /**
   * @protected
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @return {Array<import("../Feature.js").default>} Features.
   */
  readFeaturesFromNode(e, t) {
    if (!O.includes(e.namespaceURI))
      return [];
    let i;
    const n = e.localName;
    if (n == "Document" || n == "Folder")
      return i = this.readDocumentOrFolder_(e, [
        this.getReadOptions(e, t)
      ]), i || [];
    if (n == "Placemark") {
      const r = this.readPlacemark_(e, [
        this.getReadOptions(e, t)
      ]);
      return r ? [r] : [];
    } else if (n == "kml") {
      i = [];
      for (let r = e.firstElementChild; r; r = r.nextElementSibling) {
        const o = this.readFeaturesFromNode(r, t);
        o && ae(i, o);
      }
      return i;
    }
    return [];
  }
  /**
   * Read the name of the KML.
   *
   * @param {Document|Element|string} source Source.
   * @return {string|undefined} Name.
   * @api
   */
  readName(e) {
    if (e) {
      if (typeof e == "string") {
        const t = gi(e);
        return this.readNameFromDocument(t);
      } else if (fi(e))
        return this.readNameFromDocument(
          /** @type {Document} */
          e
        );
    } else
      return;
    return this.readNameFromNode(
      /** @type {Element} */
      e
    );
  }
  /**
   * @param {Document} doc Document.
   * @return {string|undefined} Name.
   */
  readNameFromDocument(e) {
    for (let t = (
      /** @type {Node} */
      e.firstChild
    ); t; t = t.nextSibling)
      if (t.nodeType == Node.ELEMENT_NODE) {
        const i = this.readNameFromNode(
          /** @type {Element} */
          t
        );
        if (i)
          return i;
      }
  }
  /**
   * @param {Element} node Node.
   * @return {string|undefined} Name.
   */
  readNameFromNode(e) {
    for (let t = e.firstElementChild; t; t = t.nextElementSibling)
      if (O.includes(t.namespaceURI) && t.localName == "name")
        return ke(t);
    for (let t = e.firstElementChild; t; t = t.nextElementSibling) {
      const i = t.localName;
      if (O.includes(t.namespaceURI) && (i == "Document" || i == "Folder" || i == "Placemark" || i == "kml")) {
        const n = this.readNameFromNode(t);
        if (n)
          return n;
      }
    }
  }
  /**
   * Read the network links of the KML.
   *
   * @param {Document|Element|string} source Source.
   * @return {Array<Object>} Network links.
   * @api
   */
  readNetworkLinks(e) {
    const t = [];
    if (typeof e == "string") {
      const i = gi(e);
      ae(t, this.readNetworkLinksFromDocument(i));
    } else
      fi(e) ? ae(
        t,
        this.readNetworkLinksFromDocument(
          /** @type {Document} */
          e
        )
      ) : ae(
        t,
        this.readNetworkLinksFromNode(
          /** @type {Element} */
          e
        )
      );
    return t;
  }
  /**
   * @param {Document} doc Document.
   * @return {Array<Object>} Network links.
   */
  readNetworkLinksFromDocument(e) {
    const t = [];
    for (let i = (
      /** @type {Node} */
      e.firstChild
    ); i; i = i.nextSibling)
      i.nodeType == Node.ELEMENT_NODE && ae(
        t,
        this.readNetworkLinksFromNode(
          /** @type {Element} */
          i
        )
      );
    return t;
  }
  /**
   * @param {Element} node Node.
   * @return {Array<Object>} Network links.
   */
  readNetworkLinksFromNode(e) {
    const t = [];
    for (let i = e.firstElementChild; i; i = i.nextElementSibling)
      if (O.includes(i.namespaceURI) && i.localName == "NetworkLink") {
        const n = le({}, tm, i, []);
        t.push(n);
      }
    for (let i = e.firstElementChild; i; i = i.nextElementSibling) {
      const n = i.localName;
      O.includes(i.namespaceURI) && (n == "Document" || n == "Folder" || n == "kml") && ae(t, this.readNetworkLinksFromNode(i));
    }
    return t;
  }
  /**
   * Read the regions of the KML.
   *
   * @param {Document|Element|string} source Source.
   * @return {Array<Object>} Regions.
   * @api
   */
  readRegion(e) {
    const t = [];
    if (typeof e == "string") {
      const i = gi(e);
      ae(t, this.readRegionFromDocument(i));
    } else
      fi(e) ? ae(
        t,
        this.readRegionFromDocument(
          /** @type {Document} */
          e
        )
      ) : ae(t, this.readRegionFromNode(
        /** @type {Element} */
        e
      ));
    return t;
  }
  /**
   * @param {Document} doc Document.
   * @return {Array<Object>} Region.
   */
  readRegionFromDocument(e) {
    const t = [];
    for (let i = (
      /** @type {Node} */
      e.firstChild
    ); i; i = i.nextSibling)
      i.nodeType == Node.ELEMENT_NODE && ae(t, this.readRegionFromNode(
        /** @type {Element} */
        i
      ));
    return t;
  }
  /**
   * @param {Element} node Node.
   * @return {Array<Object>} Region.
   * @api
   */
  readRegionFromNode(e) {
    const t = [];
    for (let i = e.firstElementChild; i; i = i.nextElementSibling)
      if (O.includes(i.namespaceURI) && i.localName == "Region") {
        const n = le({}, kc, i, []);
        t.push(n);
      }
    for (let i = e.firstElementChild; i; i = i.nextElementSibling) {
      const n = i.localName;
      O.includes(i.namespaceURI) && (n == "Document" || n == "Folder" || n == "kml") && ae(t, this.readRegionFromNode(i));
    }
    return t;
  }
  /**
   * Encode an array of features in the KML format as an XML node. GeometryCollections,
   * MultiPoints, MultiLineStrings, and MultiPolygons are output as MultiGeometries.
   *
   * @param {Array<Feature>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Options.
   * @return {Node} Node.
   * @api
   */
  writeFeaturesNode(e, t) {
    t = this.adaptOptions(t);
    const i = _s(O[4], "kml"), n = "http://www.w3.org/2000/xmlns/";
    i.setAttributeNS(n, "xmlns:gx", Gt[0]), i.setAttributeNS(n, "xmlns:xsi", ql), i.setAttributeNS(
      ql,
      "xsi:schemaLocation",
      Q_
    );
    const r = {
      node: i
    }, o = {};
    e.length > 1 ? o.Document = e : e.length == 1 && (o.Placemark = e[0]);
    const a = nm[i.namespaceURI], l = lt(o, a);
    return xe(
      r,
      sm,
      it,
      l,
      [t],
      a,
      this
    ), i;
  }
}
function lm(s, e) {
  const t = [0, 0];
  let i = "start";
  const n = s.getImage();
  if (n) {
    const a = n.getSize();
    if (a && a.length == 2) {
      const l = n.getScaleArray(), h = n.getAnchor();
      t[0] = l[0] * (a[0] - h[0]), t[1] = l[1] * (a[1] / 2 - h[1]), i = "left";
    }
  }
  let r = s.getText();
  return r ? (r = r.clone(), r.setFont(r.getFont() || mi.getFont()), r.setScale(r.getScale() || mi.getScale()), r.setFill(r.getFill() || mi.getFill()), r.setStroke(r.getStroke() || Ko)) : r = mi.clone(), r.setText(e), r.setOffsetX(t[0]), r.setOffsetY(t[1]), r.setTextAlign(i), new se({
    image: n,
    text: r
  });
}
function hm(s, e, t, i, n) {
  return (
    /**
     * @param {Feature} feature feature.
     * @param {number} resolution Resolution.
     * @return {Array<Style>|Style} Style.
     */
    function(r, o) {
      let a = n, l = "", h = [];
      if (a) {
        const u = r.getGeometry();
        if (u)
          if (u instanceof Mt)
            h = u.getGeometriesArrayRecursive().filter(function(d) {
              const f = d.getType();
              return f === "Point" || f === "MultiPoint";
            }), a = h.length > 0;
          else {
            const d = u.getType();
            a = d === "Point" || d === "MultiPoint";
          }
      }
      a && (l = /** @type {string} */
      r.get("name"), a = a && !!l, a && /&[^&]+;/.test(l) && (Ds || (Ds = document.createElement("textarea")), Ds.innerHTML = l, l = Ds.value));
      let c = t;
      if (s ? c = s : e && (c = Nc(e, t, i)), a) {
        const u = lm(c[0], l);
        if (h.length > 0) {
          u.setGeometry(new Mt(h));
          const d = new se({
            geometry: c[0].getGeometry(),
            image: null,
            fill: c[0].getFill(),
            stroke: c[0].getStroke(),
            text: null
          });
          return [u, d].concat(c.slice(1));
        }
        return u;
      }
      return c;
    }
  );
}
function Nc(s, e, t) {
  return Array.isArray(s) ? s : typeof s == "string" ? Nc(t[s], e, t) : e;
}
function Dr(s) {
  const e = kt(s, !1), t = /^\s*#?\s*([0-9A-Fa-f]{8})\s*$/.exec(e);
  if (t) {
    const i = t[1];
    return [
      parseInt(i.substr(6, 2), 16),
      parseInt(i.substr(4, 2), 16),
      parseInt(i.substr(2, 2), 16),
      parseInt(i.substr(0, 2), 16) / 255
    ];
  }
}
function Gc(s) {
  let e = kt(s, !1);
  const t = [];
  e = e.replace(/\s*,\s*/g, ",");
  const i = /^\s*([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?),([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)(?:\s+|,|$)(?:([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)(?:\s+|$))?\s*/i;
  let n;
  for (; n = i.exec(e); ) {
    const r = parseFloat(n[1]), o = parseFloat(n[2]), a = n[3] ? parseFloat(n[3]) : 0;
    t.push(r, o, a), e = e.substr(n[0].length);
  }
  if (e === "")
    return t;
}
function Uc(s) {
  const e = kt(s, !1).trim();
  let t = s.baseURI;
  return (!t || t == "about:blank") && (t = window.location.href), t ? new URL(e, t).href : e;
}
function zc(s) {
  const e = kt(s, !1).trim().replace(/^(?!.*#)/, "#");
  let t = s.baseURI;
  return (!t || t == "about:blank") && (t = window.location.href), t ? new URL(e, t).href : e;
}
function cm(s) {
  const e = s.getAttribute("xunits"), t = s.getAttribute("yunits");
  let i;
  return e !== "insetPixels" ? t !== "insetPixels" ? i = "bottom-left" : i = "top-left" : t !== "insetPixels" ? i = "bottom-right" : i = "top-right", {
    x: parseFloat(s.getAttribute("x")),
    xunits: $l[e],
    y: parseFloat(s.getAttribute("y")),
    yunits: $l[t],
    origin: i
  };
}
function Bc(s) {
  return Ae(s);
}
const um = D(O, {
  Pair: Dm
});
function Xc(s, e) {
  return le(void 0, um, s, e, this);
}
const dm = D(O, {
  Icon: M(Rm),
  color: M(Dr),
  heading: M(Ae),
  hotSpot: M(cm),
  scale: M(Bc)
});
function fm(s, e) {
  const t = le({}, dm, s, e);
  if (!t)
    return;
  const i = (
    /** @type {Object} */
    e[e.length - 1]
  ), n = "Icon" in t ? t.Icon : {}, r = !("Icon" in t) || Object.keys(n).length > 0;
  let o;
  const a = (
    /** @type {string|undefined} */
    n.href
  );
  a ? o = a : r && (o = yr);
  let l, h, c, u = "bottom-left";
  const d = (
    /** @type {Vec2|undefined} */
    t.hotSpot
  );
  d ? (l = [d.x, d.y], h = d.xunits, c = d.yunits, u = d.origin) : /^https?:\/\/maps\.(?:google|gstatic)\.com\//.test(o) && (o.includes("pushpin") ? (l = Zo, h = Pn, c = Mn) : o.includes("arrow-reverse") ? (l = [54, 42], h = Pn, c = Mn) : o.includes("paddle") && (l = [32, 1], h = Pn, c = Mn));
  let f;
  const g = (
    /** @type {number|undefined} */
    n.x
  ), _ = (
    /** @type {number|undefined} */
    n.y
  );
  g !== void 0 && _ !== void 0 && (f = [g, _]);
  let m;
  const p = (
    /** @type {number|undefined} */
    n.w
  ), x = (
    /** @type {number|undefined} */
    n.h
  );
  p !== void 0 && x !== void 0 && (m = [p, x]);
  let y;
  const E = (
    /** @type {number} */
    t.heading
  );
  E !== void 0 && (y = Qt(E));
  const C = (
    /** @type {number|undefined} */
    t.scale
  ), T = (
    /** @type {Array<number>|undefined} */
    t.color
  );
  if (r) {
    o == yr && (m = On);
    const w = new tt({
      anchor: l,
      anchorOrigin: u,
      anchorXUnits: h,
      anchorYUnits: c,
      crossOrigin: this.crossOrigin_,
      offset: f,
      offsetOrigin: "bottom-left",
      rotation: y,
      scale: C,
      size: m,
      src: this.iconUrlFunction_(o),
      color: T
    }), L = w.getScaleArray()[0], I = w.getSize();
    if (I === null) {
      const S = w.getImageState();
      if (S === k.IDLE || S === k.LOADING) {
        const Y = function() {
          const V = w.getImageState();
          if (!(V === k.IDLE || V === k.LOADING)) {
            const P = w.getSize();
            if (P && P.length == 2) {
              const q = xr(P);
              w.setScale(L * q);
            }
            w.unlistenImageChange(Y);
          }
        };
        w.listenImageChange(Y), S === k.IDLE && w.load();
      }
    } else if (I.length == 2) {
      const S = xr(I);
      w.setScale(L * S);
    }
    i.imageStyle = w;
  } else
    i.imageStyle = tl;
}
const gm = D(O, {
  color: M(Dr),
  scale: M(Bc)
});
function _m(s, e) {
  const t = le({}, gm, s, e);
  if (!t)
    return;
  const i = e[e.length - 1], n = new De({
    fill: new N({
      color: (
        /** @type {import("../color.js").Color} */
        "color" in t ? t.color : Ji
      )
    }),
    scale: (
      /** @type {number|undefined} */
      t.scale
    )
  });
  i.textStyle = n;
}
const mm = D(O, {
  color: M(Dr),
  width: M(Ae)
});
function pm(s, e) {
  const t = le({}, mm, s, e);
  if (!t)
    return;
  const i = e[e.length - 1], n = new K({
    color: (
      /** @type {import("../color.js").Color} */
      "color" in t ? t.color : Ji
    ),
    width: (
      /** @type {number} */
      "width" in t ? t.width : 1
    )
  });
  i.strokeStyle = n;
}
const ym = D(O, {
  color: M(Dr),
  fill: M(ii),
  outline: M(ii)
});
function xm(s, e) {
  const t = le({}, ym, s, e);
  if (!t)
    return;
  const i = e[e.length - 1], n = new N({
    color: (
      /** @type {import("../color.js").Color} */
      "color" in t ? t.color : Ji
    )
  });
  i.fillStyle = n;
  const r = (
    /** @type {boolean|undefined} */
    t.fill
  );
  r !== void 0 && (i.fill = r);
  const o = (
    /** @type {boolean|undefined} */
    t.outline
  );
  o !== void 0 && (i.outline = o);
}
const Em = D(O, {
  coordinates: el(Gc)
});
function Wc(s, e) {
  return le(null, Em, s, e);
}
function vm(s, e) {
  const i = /** @type {GxTrackObject} */ e[e.length - 1].coordinates, n = kt(s, !1), o = /^\s*([+\-]?\d+(?:\.\d*)?(?:e[+\-]?\d*)?)\s+([+\-]?\d+(?:\.\d*)?(?:e[+\-]?\d*)?)\s+([+\-]?\d+(?:\.\d*)?(?:e[+\-]?\d*)?)\s*$/i.exec(n);
  if (o) {
    const a = parseFloat(o[1]), l = parseFloat(o[2]), h = parseFloat(o[3]);
    i.push([a, l, h]);
  } else
    i.push([]);
}
const Cm = D(Gt, {
  Track: Kt(Yc)
});
function wm(s, e) {
  const t = le(
    [],
    Cm,
    s,
    e
  );
  if (t)
    return new fs(t);
}
const Tm = D(
  O,
  {
    when: Km
  },
  D(Gt, {
    coord: vm
  })
);
function Yc(s, e) {
  const t = le(
    /** @type {GxTrackObject} */
    {
      coordinates: [],
      whens: []
    },
    Tm,
    s,
    e
  );
  if (!t)
    return;
  const i = [], n = t.coordinates, r = t.whens;
  for (let o = 0, a = Math.min(n.length, r.length); o < a; ++o)
    n[o].length == 3 && i.push(
      n[o][0],
      n[o][1],
      n[o][2],
      r[o]
    );
  return new qe(i, "XYZM");
}
const Sm = D(
  O,
  {
    href: M(Uc)
  },
  D(Gt, {
    x: M(Ae),
    y: M(Ae),
    w: M(Ae),
    h: M(Ae)
  })
);
function Rm(s, e) {
  const t = le({}, Sm, s, e);
  return t || null;
}
const Im = D(O, {
  coordinates: el(Gc)
});
function il(s, e) {
  return le(
    null,
    Im,
    s,
    e
  );
}
const kr = D(O, {
  extrude: M(ii),
  tessellate: M(ii),
  altitudeMode: M(ke)
});
function Vc(s, e) {
  const t = le(
    {},
    kr,
    s,
    e
  ), i = il(s, e);
  if (i) {
    const n = new qe(i, "XYZ");
    return n.setProperties(t, !0), n;
  }
}
function Zc(s, e) {
  const t = le(
    {},
    kr,
    s,
    e
  ), i = il(s, e);
  if (i) {
    const n = new We(i, "XYZ", [
      i.length
    ]);
    return n.setProperties(t, !0), n;
  }
}
const Lm = D(O, {
  LineString: Kt(Vc),
  LinearRing: Kt(Zc),
  MultiGeometry: Kt(jc),
  Point: Kt(Hc),
  Polygon: Kt(Kc)
});
function jc(s, e) {
  const t = le(
    [],
    Lm,
    s,
    e
  );
  if (!t)
    return null;
  if (t.length === 0)
    return new Mt(t);
  let i, n = !0;
  const r = t[0].getType();
  let o;
  for (let a = 1, l = t.length; a < l; ++a)
    if (o = t[a], o.getType() != r) {
      n = !1;
      break;
    }
  if (n) {
    let a, l;
    if (r == "Point") {
      const h = t[0];
      a = h.getLayout(), l = h.getFlatCoordinates();
      for (let c = 1, u = t.length; c < u; ++c)
        o = t[c], ae(l, o.getFlatCoordinates());
      i = new gs(l, a), oo(i, t);
    } else
      r == "LineString" ? (i = new fs(t), oo(i, t)) : r == "Polygon" ? (i = new Pr(t), oo(i, t)) : r == "GeometryCollection" ? i = new Mt(t) : Z(!1, 37);
  } else
    i = new Mt(t);
  return (
    /** @type {import("../geom/Geometry.js").default} */
    i
  );
}
function Hc(s, e) {
  const t = le(
    {},
    kr,
    s,
    e
  ), i = il(s, e);
  if (i) {
    const n = new Ee(i, "XYZ");
    return n.setProperties(t, !0), n;
  }
}
const Am = D(O, {
  innerBoundaryIs: Vm,
  outerBoundaryIs: jm
});
function Kc(s, e) {
  const t = le(
    /** @type {Object<string,*>} */
    {},
    kr,
    s,
    e
  ), i = le(
    [null],
    Am,
    s,
    e
  );
  if (i && i[0]) {
    const n = i[0], r = [n.length];
    for (let a = 1, l = i.length; a < l; ++a)
      ae(n, i[a]), r.push(n.length);
    const o = new We(n, "XYZ", r);
    return o.setProperties(t, !0), o;
  }
}
const Fm = D(O, {
  IconStyle: fm,
  LabelStyle: _m,
  LineStyle: pm,
  PolyStyle: xm
});
function nl(s, e) {
  const t = le(
    {},
    Fm,
    s,
    e,
    this
  );
  if (!t)
    return null;
  let i = (
    /** @type {Fill} */
    "fillStyle" in t ? t.fillStyle : Ks
  );
  const n = (
    /** @type {boolean|undefined} */
    t.fill
  );
  n !== void 0 && !n && (i = null);
  let r;
  "imageStyle" in t ? t.imageStyle != tl && (r = /** @type {import("../style/Image.js").default} */
  t.imageStyle) : r = jo;
  const o = (
    /** @type {Text} */
    "textStyle" in t ? t.textStyle : mi
  ), a = (
    /** @type {Stroke} */
    "strokeStyle" in t ? t.strokeStyle : Ho
  ), l = (
    /** @type {boolean|undefined} */
    t.outline
  );
  return l !== void 0 && !l ? [
    new se({
      geometry: function(h) {
        const c = h.getGeometry(), u = c.getType();
        if (u === "GeometryCollection") {
          const d = (
            /** @type {import("../geom/GeometryCollection").default} */
            c
          );
          return new Mt(
            d.getGeometriesArrayRecursive().filter(function(f) {
              const g = f.getType();
              return g !== "Polygon" && g !== "MultiPolygon";
            })
          );
        } else if (u !== "Polygon" && u !== "MultiPolygon")
          return c;
      },
      fill: i,
      image: r,
      stroke: a,
      text: o,
      zIndex: void 0
      // FIXME
    }),
    new se({
      geometry: function(h) {
        const c = h.getGeometry(), u = c.getType();
        if (u === "GeometryCollection") {
          const d = (
            /** @type {import("../geom/GeometryCollection").default} */
            c
          );
          return new Mt(
            d.getGeometriesArrayRecursive().filter(function(f) {
              const g = f.getType();
              return g === "Polygon" || g === "MultiPolygon";
            })
          );
        } else if (u === "Polygon" || u === "MultiPolygon")
          return c;
      },
      fill: i,
      stroke: null,
      zIndex: void 0
      // FIXME
    })
  ] : [
    new se({
      fill: i,
      image: r,
      stroke: a,
      text: o,
      zIndex: void 0
      // FIXME
    })
  ];
}
function oo(s, e) {
  const t = e.length, i = new Array(e.length), n = new Array(e.length), r = new Array(e.length);
  let o, a, l;
  o = !1, a = !1, l = !1;
  for (let h = 0; h < t; ++h) {
    const c = e[h];
    i[h] = c.get("extrude"), n[h] = c.get("tessellate"), r[h] = c.get("altitudeMode"), o = o || i[h] !== void 0, a = a || n[h] !== void 0, l = l || r[h];
  }
  o && s.set("extrude", i), a && s.set("tessellate", n), l && s.set("altitudeMode", r);
}
const bm = D(O, {
  displayName: M(ke),
  value: M(ke)
});
function Pm(s, e) {
  const t = s.getAttribute("name");
  gn(bm, s, e);
  const i = (
    /** @type {Object} */
    e[e.length - 1]
  );
  t && i.displayName ? i[t] = {
    value: i.value,
    displayName: i.displayName,
    toString: function() {
      return i.value;
    }
  } : t !== null ? i[t] = i.value : i.displayName !== null && (i[i.displayName] = i.value), delete i.value;
}
const Mm = D(O, {
  Data: Pm,
  SchemaData: Gm
});
function qc(s, e) {
  gn(Mm, s, e);
}
function Jc(s, e) {
  gn(kc, s, e);
}
const Om = D(O, {
  Style: M(nl),
  key: M(ke),
  styleUrl: M(zc)
});
function Dm(s, e) {
  const t = le({}, Om, s, e, this);
  if (!t)
    return;
  const i = (
    /** @type {string|undefined} */
    t.key
  );
  if (i && i == "normal") {
    const n = (
      /** @type {string|undefined} */
      t.styleUrl
    );
    n && (e[e.length - 1] = n);
    const r = (
      /** @type {Style} */
      t.Style
    );
    r && (e[e.length - 1] = r);
  }
}
function km(s, e) {
  const t = Xc.call(this, s, e);
  if (!t)
    return;
  const i = e[e.length - 1];
  Array.isArray(t) ? i.Style = t : typeof t == "string" ? i.styleUrl = t : Z(!1, 38);
}
const Nm = D(O, {
  SimpleData: Um
});
function Gm(s, e) {
  gn(Nm, s, e);
}
function Um(s, e) {
  const t = s.getAttribute("name");
  if (t !== null) {
    const i = ke(s), n = (
      /** @type {Object} */
      e[e.length - 1]
    );
    n[t] = i;
  }
}
const zm = D(O, {
  altitudeMode: M(ke),
  minAltitude: M(Ae),
  maxAltitude: M(Ae),
  north: M(Ae),
  south: M(Ae),
  east: M(Ae),
  west: M(Ae)
});
function Bm(s, e) {
  const t = le(
    {},
    zm,
    s,
    e
  );
  if (!t)
    return;
  const i = (
    /** @type {Object} */
    e[e.length - 1]
  ), n = [
    parseFloat(t.west),
    parseFloat(t.south),
    parseFloat(t.east),
    parseFloat(t.north)
  ];
  i.extent = n, i.altitudeMode = t.altitudeMode, i.minAltitude = parseFloat(t.minAltitude), i.maxAltitude = parseFloat(t.maxAltitude);
}
const Xm = D(O, {
  minLodPixels: M(Ae),
  maxLodPixels: M(Ae),
  minFadeExtent: M(Ae),
  maxFadeExtent: M(Ae)
});
function Wm(s, e) {
  const t = le({}, Xm, s, e);
  if (!t)
    return;
  const i = (
    /** @type {Object} */
    e[e.length - 1]
  );
  i.minLodPixels = parseFloat(t.minLodPixels), i.maxLodPixels = parseFloat(t.maxLodPixels), i.minFadeExtent = parseFloat(t.minFadeExtent), i.maxFadeExtent = parseFloat(t.maxFadeExtent);
}
const Ym = D(O, {
  // KML spec only allows one LinearRing  per innerBoundaryIs, but Google Earth
  // allows multiple, so we parse multiple here too.
  LinearRing: Kt(Wc)
});
function Vm(s, e) {
  const t = le(
    /** @type {Array<Array<number>>} */
    [],
    Ym,
    s,
    e
  );
  t.length > 0 && /** @type {Array<Array<number>>} */
  e[e.length - 1].push(...t);
}
const Zm = D(O, {
  LinearRing: el(Wc)
});
function jm(s, e) {
  const t = le(
    void 0,
    Zm,
    s,
    e
  );
  if (t) {
    const i = (
      /** @type {Array<Array<number>>} */
      e[e.length - 1]
    );
    i[0] = t;
  }
}
function Hm(s, e) {
  gn(im, s, e);
}
function Km(s, e) {
  const i = /** @type {GxTrackObject} */ e[e.length - 1].whens, n = kt(s, !1), r = Date.parse(n);
  i.push(isNaN(r) ? 0 : r);
}
function Nr(s, e) {
  const t = Gn(e), n = [(t.length == 4 ? t[3] : 1) * 255, t[2], t[1], t[0]];
  for (let r = 0; r < 4; ++r) {
    const o = Math.floor(
      /** @type {number} */
      n[r]
    ).toString(16);
    n[r] = o.length == 1 ? "0" + o : o;
  }
  at(s, n.join(""));
}
function qm(s, e, t) {
  const i = t[t.length - 1], n = i.layout, r = i.stride;
  let o;
  n == "XY" || n == "XYM" ? o = 2 : n == "XYZ" || n == "XYZM" ? o = 3 : Z(!1, 34);
  const a = e.length;
  let l = "";
  if (a > 0) {
    l += e[0];
    for (let h = 1; h < o; ++h)
      l += "," + e[h];
    for (let h = r; h < a; h += r) {
      l += " " + e[h];
      for (let c = 1; c < o; ++c)
        l += "," + e[h + c];
    }
  }
  at(s, l);
}
const qs = D(O, {
  Data: U(Jm),
  value: U(Qm),
  displayName: U($m)
});
function Jm(s, e, t) {
  s.setAttribute("name", e.name);
  const i = { node: s }, n = e.value;
  typeof n == "object" ? (n !== null && n.displayName && xe(
    i,
    qs,
    it,
    [n.displayName],
    t,
    ["displayName"]
  ), n !== null && n.value && xe(
    i,
    qs,
    it,
    [n.value],
    t,
    ["value"]
  )) : xe(
    i,
    qs,
    it,
    [n],
    t,
    ["value"]
  );
}
function $m(s, e) {
  $_(s, e);
}
function Qm(s, e) {
  at(s, e);
}
const ep = D(O, {
  Placemark: U(eu)
}), tp = function(s, e, t) {
  const i = e[e.length - 1].node;
  return _s(i.namespaceURI, "Placemark");
};
function ip(s, e, t) {
  xe(
    { node: s },
    ep,
    tp,
    e,
    t,
    void 0,
    this
  );
}
const np = Nt("Data");
function sp(s, e, t) {
  const i = { node: s }, n = e.names, r = e.values, o = n.length;
  for (let a = 0; a < o; a++)
    xe(
      i,
      qs,
      np,
      [{ name: n[a], value: r[a] }],
      t
    );
}
const eh = D(
  O,
  ["href"],
  D(Gt, ["x", "y", "w", "h"])
), th = D(
  O,
  {
    href: U(at)
  },
  D(Gt, {
    x: U(_i),
    y: U(_i),
    w: U(_i),
    h: U(_i)
  })
), rp = function(s, e, t) {
  return _s(Gt[0], "gx:" + t);
};
function op(s, e, t) {
  const i = { node: s }, n = t[t.length - 1].node;
  let r = eh[n.namespaceURI], o = lt(e, r);
  xe(
    i,
    th,
    it,
    o,
    t,
    r
  ), r = eh[Gt[0]], o = lt(e, r), xe(
    i,
    th,
    rp,
    o,
    t,
    r
  );
}
const ap = D(O, [
  "scale",
  "heading",
  "Icon",
  "color",
  "hotSpot"
]), lp = D(O, {
  Icon: U(op),
  color: U(Nr),
  heading: U(_i),
  hotSpot: U(Dp),
  scale: U(iu)
});
function hp(s, e, t) {
  const i = { node: s }, n = {}, r = e.getSrc(), o = e.getSize(), a = e.getImageSize(), l = {
    href: r
  };
  if (o) {
    l.w = o[0], l.h = o[1];
    const m = e.getAnchor(), p = e.getOrigin();
    if (p && a && p[0] !== 0 && p[1] !== o[1] && (l.x = p[0], l.y = a[1] - (p[1] + o[1])), m && (m[0] !== o[0] / 2 || m[1] !== o[1] / 2)) {
      const x = {
        x: m[0],
        xunits: "pixels",
        y: o[1] - m[1],
        yunits: "pixels"
      };
      n.hotSpot = x;
    }
  }
  n.Icon = l;
  let h = e.getScaleArray()[0], c = o;
  if (c === null && (c = On), c.length == 2) {
    const m = xr(c);
    h = h / m;
  }
  h !== 1 && (n.scale = h);
  const u = e.getRotation();
  u !== 0 && (n.heading = u);
  const d = e.getColor();
  d && (n.color = d);
  const f = t[t.length - 1].node, g = ap[f.namespaceURI], _ = lt(n, g);
  xe(
    i,
    lp,
    it,
    _,
    t,
    g
  );
}
const cp = D(O, [
  "color",
  "scale"
]), up = D(O, {
  color: U(Nr),
  scale: U(iu)
});
function dp(s, e, t) {
  const i = { node: s }, n = {}, r = e.getFill();
  r && (n.color = r.getColor());
  const o = e.getScale();
  o && o !== 1 && (n.scale = o);
  const a = t[t.length - 1].node, l = cp[a.namespaceURI], h = lt(n, l);
  xe(
    i,
    up,
    it,
    h,
    t,
    l
  );
}
const fp = D(O, ["color", "width"]), gp = D(O, {
  color: U(Nr),
  width: U(_i)
});
function _p(s, e, t) {
  const i = { node: s }, n = {
    color: e.getColor(),
    width: Number(e.getWidth()) || 1
  }, r = t[t.length - 1].node, o = fp[r.namespaceURI], a = lt(n, o);
  xe(
    i,
    gp,
    it,
    a,
    t,
    o
  );
}
const mp = {
  Point: "Point",
  LineString: "LineString",
  LinearRing: "LinearRing",
  Polygon: "Polygon",
  MultiPoint: "MultiGeometry",
  MultiLineString: "MultiGeometry",
  MultiPolygon: "MultiGeometry",
  GeometryCollection: "MultiGeometry"
}, $c = function(s, e, t) {
  if (s) {
    const i = e[e.length - 1].node;
    return _s(
      i.namespaceURI,
      mp[
        /** @type {import("../geom/Geometry.js").default} */
        s.getType()
      ]
    );
  }
}, pp = Nt("Point"), yp = Nt("LineString"), xp = Nt("LinearRing"), Ep = Nt("Polygon"), vp = D(O, {
  LineString: U($i),
  Point: U($i),
  Polygon: U(tu),
  GeometryCollection: U(Qc)
});
function Qc(s, e, t) {
  const i = { node: s }, n = e.getType();
  let r = [], o;
  n === "GeometryCollection" ? (e.getGeometriesArrayRecursive().forEach(function(a) {
    const l = a.getType();
    l === "MultiPoint" ? r = r.concat(
      /** @type {MultiPoint} */
      a.getPoints()
    ) : l === "MultiLineString" ? r = r.concat(
      /** @type {MultiLineString} */
      a.getLineStrings()
    ) : l === "MultiPolygon" ? r = r.concat(
      /** @type {MultiPolygon} */
      a.getPolygons()
    ) : l === "Point" || l === "LineString" || l === "Polygon" ? r.push(a) : Z(!1, 39);
  }), o = $c) : n === "MultiPoint" ? (r = /** @type {MultiPoint} */
  e.getPoints(), o = pp) : n === "MultiLineString" ? (r = /** @type {MultiLineString} */
  e.getLineStrings(), o = yp) : n === "MultiPolygon" ? (r = /** @type {MultiPolygon} */
  e.getPolygons(), o = Ep) : Z(!1, 39), xe(
    i,
    vp,
    o,
    r,
    t
  );
}
const Cp = D(O, {
  LinearRing: U($i)
});
function ih(s, e, t) {
  xe(
    { node: s },
    Cp,
    xp,
    [e],
    t
  );
}
const ao = D(O, {
  ExtendedData: U(sp),
  MultiGeometry: U(Qc),
  LineString: U($i),
  LinearRing: U($i),
  Point: U($i),
  Polygon: U(tu),
  Style: U(Op),
  address: U(at),
  description: U(at),
  name: U(at),
  open: U(hn),
  phoneNumber: U(at),
  styleUrl: U(at),
  visibility: U(hn)
}), wp = D(O, [
  "name",
  "open",
  "visibility",
  "address",
  "phoneNumber",
  "description",
  "styleUrl",
  "Style"
]), Tp = Nt("ExtendedData");
function eu(s, e, t) {
  const i = { node: s };
  e.getId() && s.setAttribute(
    "id",
    /** @type {string} */
    e.getId()
  );
  const n = e.getProperties(), r = {
    address: 1,
    description: 1,
    name: 1,
    open: 1,
    phoneNumber: 1,
    styleUrl: 1,
    visibility: 1
  };
  r[e.getGeometryName()] = 1;
  const o = Object.keys(n || {}).sort().filter(function(f) {
    return !r[f];
  }), a = e.getStyleFunction();
  if (a) {
    const f = a(e, 0);
    if (f) {
      const g = Array.isArray(f) ? f : [f];
      let _ = g;
      if (e.getGeometry() && (_ = g.filter(function(m) {
        const p = m.getGeometryFunction()(e);
        if (p) {
          const x = p.getType();
          return x === "GeometryCollection" ? (
            /** @type {GeometryCollection} */
            p.getGeometriesArrayRecursive().filter(function(y) {
              const E = y.getType();
              return E === "Point" || E === "MultiPoint";
            }).length
          ) : x === "Point" || x === "MultiPoint";
        }
      })), this.writeStyles_) {
        let m = g, p = g;
        e.getGeometry() && (m = g.filter(function(x) {
          const y = x.getGeometryFunction()(e);
          if (y) {
            const E = y.getType();
            return E === "GeometryCollection" ? (
              /** @type {GeometryCollection} */
              y.getGeometriesArrayRecursive().filter(function(C) {
                const T = C.getType();
                return T === "LineString" || T === "MultiLineString";
              }).length
            ) : E === "LineString" || E === "MultiLineString";
          }
        }), p = g.filter(function(x) {
          const y = x.getGeometryFunction()(e);
          if (y) {
            const E = y.getType();
            return E === "GeometryCollection" ? (
              /** @type {GeometryCollection} */
              y.getGeometriesArrayRecursive().filter(function(C) {
                const T = C.getType();
                return T === "Polygon" || T === "MultiPolygon";
              }).length
            ) : E === "Polygon" || E === "MultiPolygon";
          }
        })), n.Style = {
          pointStyles: _,
          lineStyles: m,
          polyStyles: p
        };
      }
      if (_.length && n.name === void 0) {
        const m = _[0].getText();
        m && (n.name = m.getText());
      }
    }
  }
  const l = t[t.length - 1].node, h = wp[l.namespaceURI], c = lt(n, h);
  if (xe(
    i,
    ao,
    it,
    c,
    t,
    h
  ), o.length > 0) {
    const f = lt(n, o);
    xe(
      i,
      ao,
      Tp,
      [{ names: o, values: f }],
      t
    );
  }
  const u = (
    /** @type {import("./Feature.js").WriteOptions} */
    t[0]
  );
  let d = e.getGeometry();
  d && (d = Mr(d, !0, u)), xe(
    i,
    ao,
    $c,
    [d],
    t
  );
}
const Sp = D(O, [
  "extrude",
  "tessellate",
  "altitudeMode",
  "coordinates"
]), Rp = D(O, {
  extrude: U(hn),
  tessellate: U(hn),
  altitudeMode: U(at),
  coordinates: U(qm)
});
function $i(s, e, t) {
  const i = e.getFlatCoordinates(), n = { node: s };
  n.layout = e.getLayout(), n.stride = e.getStride();
  const r = e.getProperties();
  r.coordinates = i;
  const o = t[t.length - 1].node, a = Sp[o.namespaceURI], l = lt(r, a);
  xe(
    n,
    Rp,
    it,
    l,
    t,
    a
  );
}
const Ip = D(O, [
  "color",
  "fill",
  "outline"
]), nh = D(O, {
  outerBoundaryIs: U(ih),
  innerBoundaryIs: U(ih)
}), Lp = Nt("innerBoundaryIs"), Ap = Nt("outerBoundaryIs");
function tu(s, e, t) {
  const i = e.getLinearRings(), n = i.shift(), r = { node: s };
  xe(
    r,
    nh,
    Lp,
    i,
    t
  ), xe(
    r,
    nh,
    Ap,
    [n],
    t
  );
}
const Fp = D(O, {
  color: U(Nr),
  fill: U(hn),
  outline: U(hn)
});
function bp(s, e, t) {
  const i = { node: s }, n = e.getFill(), r = e.getStroke(), o = {
    color: n ? n.getColor() : void 0,
    fill: n ? void 0 : !1,
    outline: r ? void 0 : !1
  }, a = t[t.length - 1].node, l = Ip[a.namespaceURI], h = lt(o, l);
  xe(
    i,
    Fp,
    it,
    h,
    t,
    l
  );
}
function iu(s, e) {
  _i(s, Math.round(e * 1e6) / 1e6);
}
const Pp = D(O, [
  "IconStyle",
  "LabelStyle",
  "LineStyle",
  "PolyStyle"
]), Mp = D(O, {
  IconStyle: U(hp),
  LabelStyle: U(dp),
  LineStyle: U(_p),
  PolyStyle: U(bp)
});
function Op(s, e, t) {
  const i = { node: s }, n = {};
  if (e.pointStyles.length) {
    const l = e.pointStyles[0].getText();
    l && (n.LabelStyle = l);
    const h = e.pointStyles[0].getImage();
    h && typeof /** @type {?} */
    h.getSrc == "function" && (n.IconStyle = h);
  }
  if (e.lineStyles.length) {
    const l = e.lineStyles[0].getStroke();
    l && (n.LineStyle = l);
  }
  if (e.polyStyles.length) {
    const l = e.polyStyles[0].getStroke();
    l && !n.LineStyle && (n.LineStyle = l), n.PolyStyle = e.polyStyles[0];
  }
  const r = t[t.length - 1].node, o = Pp[r.namespaceURI], a = lt(n, o);
  xe(
    i,
    Mp,
    it,
    a,
    t,
    o
  );
}
function Dp(s, e) {
  s.setAttribute("x", String(e.x)), s.setAttribute("y", String(e.y)), s.setAttribute("xunits", e.xunits), s.setAttribute("yunits", e.yunits);
}
const sh = am;
class kp extends Oc {
  constructor() {
    super();
  }
  /**
   * @return {import("./Feature.js").Type} Format.
   */
  getType() {
    return "json";
  }
  /**
   * Read a feature.  Only works for a single feature. Use `readFeatures` to
   * read a feature collection.
   *
   * @param {ArrayBuffer|Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {import("../Feature.js").default} Feature.
   * @api
   */
  readFeature(e, t) {
    return this.readFeatureFromObject(
      ks(e),
      this.getReadOptions(e, t)
    );
  }
  /**
   * Read all features.  Works with both a single feature and a feature
   * collection.
   *
   * @param {ArrayBuffer|Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {Array<import("../Feature.js").default>} Features.
   * @api
   */
  readFeatures(e, t) {
    return this.readFeaturesFromObject(
      ks(e),
      this.getReadOptions(e, t)
    );
  }
  /**
   * @abstract
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {import("../Feature.js").default} Feature.
   */
  readFeatureFromObject(e, t) {
    return X();
  }
  /**
   * @abstract
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {Array<import("../Feature.js").default>} Features.
   */
  readFeaturesFromObject(e, t) {
    return X();
  }
  /**
   * Read a geometry.
   *
   * @param {ArrayBuffer|Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {import("../geom/Geometry.js").default} Geometry.
   * @api
   */
  readGeometry(e, t) {
    return this.readGeometryFromObject(
      ks(e),
      this.getReadOptions(e, t)
    );
  }
  /**
   * @abstract
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {import("../geom/Geometry.js").default} Geometry.
   */
  readGeometryFromObject(e, t) {
    return X();
  }
  /**
   * Read the projection.
   *
   * @param {ArrayBuffer|Document|Element|Object|string} source Source.
   * @return {import("../proj/Projection.js").default} Projection.
   * @api
   */
  readProjection(e) {
    return this.readProjectionFromObject(ks(e));
  }
  /**
   * @abstract
   * @param {Object} object Object.
   * @protected
   * @return {import("../proj/Projection.js").default} Projection.
   */
  readProjectionFromObject(e) {
    return X();
  }
  /**
   * Encode a feature as string.
   *
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Encoded feature.
   * @api
   */
  writeFeature(e, t) {
    return JSON.stringify(this.writeFeatureObject(e, t));
  }
  /**
   * @abstract
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {Object} Object.
   */
  writeFeatureObject(e, t) {
    return X();
  }
  /**
   * Encode an array of features as string.
   *
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Encoded features.
   * @api
   */
  writeFeatures(e, t) {
    return JSON.stringify(this.writeFeaturesObject(e, t));
  }
  /**
   * @abstract
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {Object} Object.
   */
  writeFeaturesObject(e, t) {
    return X();
  }
  /**
   * Encode a geometry as string.
   *
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Encoded geometry.
   * @api
   */
  writeGeometry(e, t) {
    return JSON.stringify(this.writeGeometryObject(e, t));
  }
  /**
   * @abstract
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {Object} Object.
   */
  writeGeometryObject(e, t) {
    return X();
  }
}
function ks(s) {
  if (typeof s == "string") {
    const e = JSON.parse(s);
    return e || null;
  } else if (s !== null)
    return s;
  return null;
}
const Np = kp;
class Gp extends Np {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {}, super(), this.dataProjection = ye(
      e.dataProjection ? e.dataProjection : "EPSG:4326"
    ), e.featureProjection && (this.defaultFeatureProjection = ye(e.featureProjection)), this.geometryName_ = e.geometryName, this.extractGeometryName_ = e.extractGeometryName, this.supportedMediaTypes = [
      "application/geo+json",
      "application/vnd.geo+json"
    ];
  }
  /**
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {import("../Feature.js").default} Feature.
   */
  readFeatureFromObject(e, t) {
    let i = null;
    e.type === "Feature" ? i = /** @type {GeoJSONFeature} */
    e : i = {
      type: "Feature",
      geometry: (
        /** @type {GeoJSONGeometry} */
        e
      ),
      properties: null
    };
    const n = Jo(i.geometry, t), r = new $();
    return this.geometryName_ ? r.setGeometryName(this.geometryName_) : this.extractGeometryName_ && "geometry_name" in i !== void 0 && r.setGeometryName(i.geometry_name), r.setGeometry(n), "id" in i && r.setId(i.id), i.properties && r.setProperties(i.properties, !0), r;
  }
  /**
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {Array<Feature>} Features.
   */
  readFeaturesFromObject(e, t) {
    const i = (
      /** @type {GeoJSONObject} */
      e
    );
    let n = null;
    if (i.type === "FeatureCollection") {
      const r = (
        /** @type {GeoJSONFeatureCollection} */
        e
      );
      n = [];
      const o = r.features;
      for (let a = 0, l = o.length; a < l; ++a)
        n.push(this.readFeatureFromObject(o[a], t));
    } else
      n = [this.readFeatureFromObject(e, t)];
    return n;
  }
  /**
   * @param {GeoJSONGeometry} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {import("../geom/Geometry.js").default} Geometry.
   */
  readGeometryFromObject(e, t) {
    return Jo(e, t);
  }
  /**
   * @param {Object} object Object.
   * @protected
   * @return {import("../proj/Projection.js").default} Projection.
   */
  readProjectionFromObject(e) {
    const t = e.crs;
    let i;
    return t ? t.type == "name" ? i = ye(t.properties.name) : t.type === "EPSG" ? i = ye("EPSG:" + t.properties.code) : Z(!1, 36) : i = this.dataProjection, /** @type {import("../proj/Projection.js").default} */
    i;
  }
  /**
   * Encode a feature as a GeoJSON Feature object.
   *
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {GeoJSONFeature} Object.
   * @api
   */
  writeFeatureObject(e, t) {
    t = this.adaptOptions(t);
    const i = {
      type: "Feature",
      geometry: null,
      properties: null
    }, n = e.getId();
    if (n !== void 0 && (i.id = n), !e.hasProperties())
      return i;
    const r = e.getProperties(), o = e.getGeometry();
    return o && (i.geometry = $o(o, t), delete r[e.getGeometryName()]), sn(r) || (i.properties = r), i;
  }
  /**
   * Encode an array of features as a GeoJSON object.
   *
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {GeoJSONFeatureCollection} GeoJSON Object.
   * @api
   */
  writeFeaturesObject(e, t) {
    t = this.adaptOptions(t);
    const i = [];
    for (let n = 0, r = e.length; n < r; ++n)
      i.push(this.writeFeatureObject(e[n], t));
    return {
      type: "FeatureCollection",
      features: i
    };
  }
  /**
   * Encode a geometry as a GeoJSON object.
   *
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {GeoJSONGeometry|GeoJSONGeometryCollection} Object.
   * @api
   */
  writeGeometryObject(e, t) {
    return $o(e, this.adaptOptions(t));
  }
}
function Jo(s, e) {
  if (!s)
    return null;
  let t;
  switch (s.type) {
    case "Point": {
      t = zp(
        /** @type {GeoJSONPoint} */
        s
      );
      break;
    }
    case "LineString": {
      t = Bp(
        /** @type {GeoJSONLineString} */
        s
      );
      break;
    }
    case "Polygon": {
      t = Vp(
        /** @type {GeoJSONPolygon} */
        s
      );
      break;
    }
    case "MultiPoint": {
      t = Wp(
        /** @type {GeoJSONMultiPoint} */
        s
      );
      break;
    }
    case "MultiLineString": {
      t = Xp(
        /** @type {GeoJSONMultiLineString} */
        s
      );
      break;
    }
    case "MultiPolygon": {
      t = Yp(
        /** @type {GeoJSONMultiPolygon} */
        s
      );
      break;
    }
    case "GeometryCollection": {
      t = Up(
        /** @type {GeoJSONGeometryCollection} */
        s
      );
      break;
    }
    default:
      throw new Error("Unsupported GeoJSON type: " + s.type);
  }
  return Mr(t, !1, e);
}
function Up(s, e) {
  const t = s.geometries.map(
    /**
     * @param {GeoJSONGeometry} geometry Geometry.
     * @return {import("../geom/Geometry.js").default} geometry Geometry.
     */
    function(i) {
      return Jo(i, e);
    }
  );
  return new Mt(t);
}
function zp(s) {
  return new Ee(s.coordinates);
}
function Bp(s) {
  return new qe(s.coordinates);
}
function Xp(s) {
  return new fs(s.coordinates);
}
function Wp(s) {
  return new gs(s.coordinates);
}
function Yp(s) {
  return new Pr(s.coordinates);
}
function Vp(s) {
  return new We(s.coordinates);
}
function $o(s, e) {
  s = Mr(s, !0, e);
  const t = s.getType();
  let i;
  switch (t) {
    case "Point": {
      i = Jp(
        /** @type {Point} */
        s
      );
      break;
    }
    case "LineString": {
      i = jp(
        /** @type {LineString} */
        s
      );
      break;
    }
    case "Polygon": {
      i = $p(
        /** @type {Polygon} */
        s,
        e
      );
      break;
    }
    case "MultiPoint": {
      i = Kp(
        /** @type {MultiPoint} */
        s
      );
      break;
    }
    case "MultiLineString": {
      i = Hp(
        /** @type {MultiLineString} */
        s
      );
      break;
    }
    case "MultiPolygon": {
      i = qp(
        /** @type {MultiPolygon} */
        s,
        e
      );
      break;
    }
    case "GeometryCollection": {
      i = Zp(
        /** @type {GeometryCollection} */
        s,
        e
      );
      break;
    }
    case "Circle": {
      i = {
        type: "GeometryCollection",
        geometries: []
      };
      break;
    }
    default:
      throw new Error("Unsupported geometry type: " + t);
  }
  return i;
}
function Zp(s, e) {
  return e = Object.assign({}, e), delete e.featureProjection, {
    type: "GeometryCollection",
    geometries: s.getGeometriesArray().map(function(i) {
      return $o(i, e);
    })
  };
}
function jp(s, e) {
  return {
    type: "LineString",
    coordinates: s.getCoordinates()
  };
}
function Hp(s, e) {
  return {
    type: "MultiLineString",
    coordinates: s.getCoordinates()
  };
}
function Kp(s, e) {
  return {
    type: "MultiPoint",
    coordinates: s.getCoordinates()
  };
}
function qp(s, e) {
  let t;
  return e && (t = e.rightHanded), {
    type: "MultiPolygon",
    coordinates: s.getCoordinates(t)
  };
}
function Jp(s, e) {
  return {
    type: "Point",
    coordinates: s.getCoordinates()
  };
}
function $p(s, e) {
  let t;
  return e && (t = e.rightHanded), {
    type: "Polygon",
    coordinates: s.getCoordinates(t)
  };
}
const rh = Gp;
class Qp extends hs {
  /**
   * @param {Options<ImageSourceType>} [options] Layer options.
   */
  constructor(e) {
    e = e || {}, super(e);
  }
}
const ey = Qp;
class ty extends ey {
  /**
   * @param {import("./BaseImage.js").Options<ImageSourceType>} [options] Layer options.
   */
  constructor(e) {
    super(e);
  }
  createRenderer() {
    return new Ic(this);
  }
  /**
   * Get data for a pixel location.  A four element RGBA array will be returned.  For requests outside the
   * layer extent, `null` will be returned.  Data for an image can only be retrieved if the
   * source's `crossOrigin` property is set.
   *
   * ```js
   * // display layer data on every pointer move
   * map.on('pointermove', (event) => {
   *   console.log(layer.getData(event.pixel));
   * });
   * ```
   * @param {import("../pixel").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
   * @api
   */
  getData(e) {
    return super.getData(e);
  }
}
const Ns = ty, nu = 0.5, iy = 10, oh = 0.25;
class ny {
  /**
   * @param {import("../proj/Projection.js").default} sourceProj Source projection.
   * @param {import("../proj/Projection.js").default} targetProj Target projection.
   * @param {import("../extent.js").Extent} targetExtent Target extent to triangulate.
   * @param {import("../extent.js").Extent} maxSourceExtent Maximal source extent that can be used.
   * @param {number} errorThreshold Acceptable error (in source units).
   * @param {?number} destinationResolution The (optional) resolution of the destination.
   */
  constructor(e, t, i, n, r, o) {
    this.sourceProj_ = e, this.targetProj_ = t;
    let a = {};
    const l = sr(this.targetProj_, this.sourceProj_);
    this.transformInv_ = function(x) {
      const y = x[0] + "/" + x[1];
      return a[y] || (a[y] = l(x)), a[y];
    }, this.maxSourceExtent_ = n, this.errorThresholdSquared_ = r * r, this.triangles_ = [], this.wrapsXInSource_ = !1, this.canWrapXInSource_ = this.sourceProj_.canWrapX() && !!n && !!this.sourceProj_.getExtent() && te(n) == te(this.sourceProj_.getExtent()), this.sourceWorldWidth_ = this.sourceProj_.getExtent() ? te(this.sourceProj_.getExtent()) : null, this.targetWorldWidth_ = this.targetProj_.getExtent() ? te(this.targetProj_.getExtent()) : null;
    const h = Ot(i), c = os(i), u = un(i), d = rn(i), f = this.transformInv_(h), g = this.transformInv_(c), _ = this.transformInv_(u), m = this.transformInv_(d), p = iy + (o ? Math.max(
      0,
      Math.ceil(
        Math.log2(
          Fo(i) / (o * o * 256 * 256)
        )
      )
    ) : 0);
    if (this.addQuad_(
      h,
      c,
      u,
      d,
      f,
      g,
      _,
      m,
      p
    ), this.wrapsXInSource_) {
      let x = 1 / 0;
      this.triangles_.forEach(function(y, E, C) {
        x = Math.min(
          x,
          y.source[0][0],
          y.source[1][0],
          y.source[2][0]
        );
      }), this.triangles_.forEach((y) => {
        if (Math.max(
          y.source[0][0],
          y.source[1][0],
          y.source[2][0]
        ) - x > this.sourceWorldWidth_ / 2) {
          const E = [
            [y.source[0][0], y.source[0][1]],
            [y.source[1][0], y.source[1][1]],
            [y.source[2][0], y.source[2][1]]
          ];
          E[0][0] - x > this.sourceWorldWidth_ / 2 && (E[0][0] -= this.sourceWorldWidth_), E[1][0] - x > this.sourceWorldWidth_ / 2 && (E[1][0] -= this.sourceWorldWidth_), E[2][0] - x > this.sourceWorldWidth_ / 2 && (E[2][0] -= this.sourceWorldWidth_);
          const C = Math.min(
            E[0][0],
            E[1][0],
            E[2][0]
          );
          Math.max(
            E[0][0],
            E[1][0],
            E[2][0]
          ) - C < this.sourceWorldWidth_ / 2 && (y.source = E);
        }
      });
    }
    a = {};
  }
  /**
   * Adds triangle to the triangulation.
   * @param {import("../coordinate.js").Coordinate} a The target a coordinate.
   * @param {import("../coordinate.js").Coordinate} b The target b coordinate.
   * @param {import("../coordinate.js").Coordinate} c The target c coordinate.
   * @param {import("../coordinate.js").Coordinate} aSrc The source a coordinate.
   * @param {import("../coordinate.js").Coordinate} bSrc The source b coordinate.
   * @param {import("../coordinate.js").Coordinate} cSrc The source c coordinate.
   * @private
   */
  addTriangle_(e, t, i, n, r, o) {
    this.triangles_.push({
      source: [n, r, o],
      target: [e, t, i]
    });
  }
  /**
   * Adds quad (points in clock-wise order) to the triangulation
   * (and reprojects the vertices) if valid.
   * Performs quad subdivision if needed to increase precision.
   *
   * @param {import("../coordinate.js").Coordinate} a The target a coordinate.
   * @param {import("../coordinate.js").Coordinate} b The target b coordinate.
   * @param {import("../coordinate.js").Coordinate} c The target c coordinate.
   * @param {import("../coordinate.js").Coordinate} d The target d coordinate.
   * @param {import("../coordinate.js").Coordinate} aSrc The source a coordinate.
   * @param {import("../coordinate.js").Coordinate} bSrc The source b coordinate.
   * @param {import("../coordinate.js").Coordinate} cSrc The source c coordinate.
   * @param {import("../coordinate.js").Coordinate} dSrc The source d coordinate.
   * @param {number} maxSubdivision Maximal allowed subdivision of the quad.
   * @private
   */
  addQuad_(e, t, i, n, r, o, a, l, h) {
    const c = ze([r, o, a, l]), u = this.sourceWorldWidth_ ? te(c) / this.sourceWorldWidth_ : null, d = (
      /** @type {number} */
      this.sourceWorldWidth_
    ), f = this.sourceProj_.canWrapX() && u > 0.5 && u < 1;
    let g = !1;
    if (h > 0) {
      if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {
        const m = ze([e, t, i, n]);
        g = te(m) / this.targetWorldWidth_ > oh || g;
      }
      !f && this.sourceProj_.isGlobal() && u && (g = u > oh || g);
    }
    if (!g && this.maxSourceExtent_ && isFinite(c[0]) && isFinite(c[1]) && isFinite(c[2]) && isFinite(c[3]) && !Ce(c, this.maxSourceExtent_))
      return;
    let _ = 0;
    if (!g && (!isFinite(r[0]) || !isFinite(r[1]) || !isFinite(o[0]) || !isFinite(o[1]) || !isFinite(a[0]) || !isFinite(a[1]) || !isFinite(l[0]) || !isFinite(l[1]))) {
      if (h > 0)
        g = !0;
      else if (_ = (!isFinite(r[0]) || !isFinite(r[1]) ? 8 : 0) + (!isFinite(o[0]) || !isFinite(o[1]) ? 4 : 0) + (!isFinite(a[0]) || !isFinite(a[1]) ? 2 : 0) + (!isFinite(l[0]) || !isFinite(l[1]) ? 1 : 0), _ != 1 && _ != 2 && _ != 4 && _ != 8)
        return;
    }
    if (h > 0) {
      if (!g) {
        const m = [(e[0] + i[0]) / 2, (e[1] + i[1]) / 2], p = this.transformInv_(m);
        let x;
        f ? x = (yi(r[0], d) + yi(a[0], d)) / 2 - yi(p[0], d) : x = (r[0] + a[0]) / 2 - p[0];
        const y = (r[1] + a[1]) / 2 - p[1];
        g = x * x + y * y > this.errorThresholdSquared_;
      }
      if (g) {
        if (Math.abs(e[0] - i[0]) <= Math.abs(e[1] - i[1])) {
          const m = [(t[0] + i[0]) / 2, (t[1] + i[1]) / 2], p = this.transformInv_(m), x = [(n[0] + e[0]) / 2, (n[1] + e[1]) / 2], y = this.transformInv_(x);
          this.addQuad_(
            e,
            t,
            m,
            x,
            r,
            o,
            p,
            y,
            h - 1
          ), this.addQuad_(
            x,
            m,
            i,
            n,
            y,
            p,
            a,
            l,
            h - 1
          );
        } else {
          const m = [(e[0] + t[0]) / 2, (e[1] + t[1]) / 2], p = this.transformInv_(m), x = [(i[0] + n[0]) / 2, (i[1] + n[1]) / 2], y = this.transformInv_(x);
          this.addQuad_(
            e,
            m,
            x,
            n,
            r,
            p,
            y,
            l,
            h - 1
          ), this.addQuad_(
            m,
            t,
            i,
            x,
            p,
            o,
            a,
            y,
            h - 1
          );
        }
        return;
      }
    }
    if (f) {
      if (!this.canWrapXInSource_)
        return;
      this.wrapsXInSource_ = !0;
    }
    _ & 11 || this.addTriangle_(e, i, n, r, a, l), _ & 14 || this.addTriangle_(e, i, t, r, a, o), _ && (_ & 13 || this.addTriangle_(t, n, e, o, l, r), _ & 7 || this.addTriangle_(t, n, i, o, l, a));
  }
  /**
   * Calculates extent of the `source` coordinates from all the triangles.
   *
   * @return {import("../extent.js").Extent} Calculated extent.
   */
  calculateSourceExtent() {
    const e = Me();
    return this.triangles_.forEach(function(t, i, n) {
      const r = t.source;
      Ln(e, r[0]), Ln(e, r[1]), Ln(e, r[2]);
    }), e;
  }
  /**
   * @return {Array<Triangle>} Array of the calculated triangles.
   */
  getTriangles() {
    return this.triangles_;
  }
}
const su = ny;
let lo;
const Qi = [];
function ah(s, e, t, i, n) {
  s.beginPath(), s.moveTo(0, 0), s.lineTo(e, t), s.lineTo(i, n), s.closePath(), s.save(), s.clip(), s.fillRect(0, 0, Math.max(e, i) + 1, Math.max(t, n)), s.restore();
}
function ho(s, e) {
  return Math.abs(s[e * 4] - 210) > 2 || Math.abs(s[e * 4 + 3] - 0.75 * 255) > 2;
}
function sy() {
  if (lo === void 0) {
    const s = Re(6, 6, Qi);
    s.globalCompositeOperation = "lighter", s.fillStyle = "rgba(210, 0, 0, 0.75)", ah(s, 4, 5, 4, 0), ah(s, 4, 5, 0, 5);
    const e = s.getImageData(0, 0, 3, 3).data;
    lo = ho(e, 0) || ho(e, 4) || ho(e, 8), Ar(s), Qi.push(s.canvas);
  }
  return lo;
}
function Qo(s, e, t, i) {
  const n = Nd(t, e, s);
  let r = nr(
    e,
    i,
    t
  );
  const o = e.getMetersPerUnit();
  o !== void 0 && (r *= o);
  const a = s.getMetersPerUnit();
  a !== void 0 && (r /= a);
  const l = s.getExtent();
  if (!l || ss(l, n)) {
    const h = nr(s, r, n) / r;
    isFinite(h) && h > 0 && (r /= h);
  }
  return r;
}
function ry(s, e, t, i) {
  const n = Ne(t);
  let r = Qo(
    s,
    e,
    n,
    i
  );
  return (!isFinite(r) || r <= 0) && da(t, function(o) {
    return r = Qo(
      s,
      e,
      o,
      i
    ), isFinite(r) && r > 0;
  }), r;
}
function ru(s, e, t, i, n, r, o, a, l, h, c, u) {
  const d = Re(
    Math.round(t * s),
    Math.round(t * e),
    Qi
  );
  if (u || (d.imageSmoothingEnabled = !1), l.length === 0)
    return d.canvas;
  d.scale(t, t);
  function f(E) {
    return Math.round(E * t) / t;
  }
  d.globalCompositeOperation = "lighter";
  const g = Me();
  l.forEach(function(E, C, T) {
    In(g, E.extent);
  });
  const _ = te(g), m = Fe(g), p = Re(
    Math.round(t * _ / i),
    Math.round(t * m / i),
    Qi
  );
  u || (p.imageSmoothingEnabled = !1);
  const x = t / i;
  l.forEach(function(E, C, T) {
    const w = E.extent[0] - g[0], L = -(E.extent[3] - g[3]), I = te(E.extent), S = Fe(E.extent);
    E.image.width > 0 && E.image.height > 0 && p.drawImage(
      E.image,
      h,
      h,
      E.image.width - 2 * h,
      E.image.height - 2 * h,
      w * x,
      L * x,
      I * x,
      S * x
    );
  });
  const y = Ot(o);
  return a.getTriangles().forEach(function(E, C, T) {
    const w = E.source, L = E.target;
    let I = w[0][0], S = w[0][1], Y = w[1][0], V = w[1][1], P = w[2][0], q = w[2][1];
    const F = f((L[0][0] - y[0]) / r), b = f(
      -(L[0][1] - y[1]) / r
    ), A = f((L[1][0] - y[0]) / r), j = f(
      -(L[1][1] - y[1]) / r
    ), Q = f((L[2][0] - y[0]) / r), ee = f(
      -(L[2][1] - y[1]) / r
    ), me = I, R = S;
    I = 0, S = 0, Y -= me, V -= R, P -= me, q -= R;
    const ue = [
      [Y, V, 0, 0, A - F],
      [P, q, 0, 0, Q - F],
      [0, 0, Y, V, j - b],
      [0, 0, P, q, ee - b]
    ], ie = ud(ue);
    if (ie) {
      if (d.save(), d.beginPath(), sy() || !u) {
        d.moveTo(A, j);
        const oe = 4, Ut = F - A, ct = b - j;
        for (let Ie = 0; Ie < oe; Ie++)
          d.lineTo(
            A + f((Ie + 1) * Ut / oe),
            j + f(Ie * ct / (oe - 1))
          ), Ie != oe - 1 && d.lineTo(
            A + f((Ie + 1) * Ut / oe),
            j + f((Ie + 1) * ct / (oe - 1))
          );
        d.lineTo(Q, ee);
      } else
        d.moveTo(A, j), d.lineTo(F, b), d.lineTo(Q, ee);
      d.clip(), d.transform(
        ie[0],
        ie[2],
        ie[1],
        ie[3],
        F,
        b
      ), d.translate(
        g[0] - me,
        g[3] - R
      ), d.scale(
        i / t,
        -i / t
      ), d.drawImage(p.canvas, 0, 0), d.restore();
    }
  }), Ar(p), Qi.push(p.canvas), c && (d.save(), d.globalCompositeOperation = "source-over", d.strokeStyle = "black", d.lineWidth = 1, a.getTriangles().forEach(function(E, C, T) {
    const w = E.target, L = (w[0][0] - y[0]) / r, I = -(w[0][1] - y[1]) / r, S = (w[1][0] - y[0]) / r, Y = -(w[1][1] - y[1]) / r, V = (w[2][0] - y[0]) / r, P = -(w[2][1] - y[1]) / r;
    d.beginPath(), d.moveTo(S, Y), d.lineTo(L, I), d.lineTo(V, P), d.closePath(), d.stroke();
  }), d.restore()), d.canvas;
}
class oy extends Za {
  /**
   * @param {import("../proj/Projection.js").default} sourceProj Source projection (of the data).
   * @param {import("../proj/Projection.js").default} targetProj Target projection.
   * @param {import("../extent.js").Extent} targetExtent Target extent.
   * @param {number} targetResolution Target resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {FunctionType} getImageFunction
   *     Function returning source images (extent, resolution, pixelRatio).
   * @param {boolean} interpolate Use linear interpolation when resampling.
   */
  constructor(e, t, i, n, r, o, a) {
    const l = e.getExtent(), h = t.getExtent(), c = h ? pi(i, h) : i, u = Ne(c), d = Qo(
      e,
      t,
      u,
      n
    ), f = nu, g = new su(
      e,
      t,
      c,
      l,
      d * f,
      n
    ), _ = g.calculateSourceExtent(), m = o(
      _,
      d,
      r
    ), p = m ? k.IDLE : k.EMPTY, x = m ? m.getPixelRatio() : 1;
    super(i, n, x, p), this.targetProj_ = t, this.maxSourceExtent_ = l, this.triangulation_ = g, this.targetResolution_ = n, this.targetExtent_ = i, this.sourceImage_ = m, this.sourcePixelRatio_ = x, this.interpolate_ = a, this.canvas_ = null, this.sourceListenerKey_ = null;
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    this.state == k.LOADING && this.unlistenSource_(), super.disposeInternal();
  }
  /**
   * @return {HTMLCanvasElement} Image.
   */
  getImage() {
    return this.canvas_;
  }
  /**
   * @return {import("../proj/Projection.js").default} Projection.
   */
  getProjection() {
    return this.targetProj_;
  }
  /**
   * @private
   */
  reproject_() {
    const e = this.sourceImage_.getState();
    if (e == k.LOADED) {
      const t = te(this.targetExtent_) / this.targetResolution_, i = Fe(this.targetExtent_) / this.targetResolution_;
      this.canvas_ = ru(
        t,
        i,
        this.sourcePixelRatio_,
        this.sourceImage_.getResolution(),
        this.maxSourceExtent_,
        this.targetResolution_,
        this.targetExtent_,
        this.triangulation_,
        [
          {
            extent: this.sourceImage_.getExtent(),
            image: this.sourceImage_.getImage()
          }
        ],
        0,
        void 0,
        this.interpolate_
      );
    }
    this.state = e, this.changed();
  }
  /**
   * Load not yet loaded URI.
   */
  load() {
    if (this.state == k.IDLE) {
      this.state = k.LOADING, this.changed();
      const e = this.sourceImage_.getState();
      e == k.LOADED || e == k.ERROR ? this.reproject_() : (this.sourceListenerKey_ = H(
        this.sourceImage_,
        z.CHANGE,
        function(t) {
          const i = this.sourceImage_.getState();
          (i == k.LOADED || i == k.ERROR) && (this.unlistenSource_(), this.reproject_());
        },
        this
      ), this.sourceImage_.load());
    }
  }
  /**
   * @private
   */
  unlistenSource_() {
    re(
      /** @type {!import("../events.js").EventsKey} */
      this.sourceListenerKey_
    ), this.sourceListenerKey_ = null;
  }
}
const ay = oy, co = {
  /**
   * Triggered when an image starts loading.
   * @event module:ol/source/Image.ImageSourceEvent#imageloadstart
   * @api
   */
  IMAGELOADSTART: "imageloadstart",
  /**
   * Triggered when an image finishes loading.
   * @event module:ol/source/Image.ImageSourceEvent#imageloadend
   * @api
   */
  IMAGELOADEND: "imageloadend",
  /**
   * Triggered if image loading results in an error.
   * @event module:ol/source/Image.ImageSourceEvent#imageloaderror
   * @api
   */
  IMAGELOADERROR: "imageloaderror"
};
class ly extends Ye {
  /**
   * @param {string} type Type.
   * @param {import("../Image.js").default} image The image.
   */
  constructor(e, t) {
    super(e), this.image = t;
  }
}
class hy extends Ja {
  /**
   * @param {Options} options Single image source options.
   */
  constructor(e) {
    super({
      attributions: e.attributions,
      projection: e.projection,
      state: e.state,
      interpolate: e.interpolate !== void 0 ? e.interpolate : !0
    }), this.on, this.once, this.un, this.resolutions_ = e.resolutions !== void 0 ? e.resolutions : null, this.reprojectedImage_ = null, this.reprojectedRevision_ = 0;
  }
  /**
   * @return {Array<number>|null} Resolutions.
   */
  getResolutions() {
    return this.resolutions_;
  }
  /**
   * @param {Array<number>|null} resolutions Resolutions.
   */
  setResolutions(e) {
    this.resolutions_ = e;
  }
  /**
   * @protected
   * @param {number} resolution Resolution.
   * @return {number} Resolution.
   */
  findNearestResolution(e) {
    const t = this.getResolutions();
    if (t) {
      const i = Tr(t, e, 0);
      e = t[i];
    }
    return e;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../ImageBase.js").default} Single image.
   */
  getImage(e, t, i, n) {
    const r = this.getProjection();
    if (!r || !n || At(r, n))
      return r && (n = r), this.getImageInternal(e, t, i, n);
    if (this.reprojectedImage_) {
      if (this.reprojectedRevision_ == this.getRevision() && At(this.reprojectedImage_.getProjection(), n) && this.reprojectedImage_.getResolution() == t && ti(this.reprojectedImage_.getExtent(), e))
        return this.reprojectedImage_;
      this.reprojectedImage_.dispose(), this.reprojectedImage_ = null;
    }
    return this.reprojectedImage_ = new ay(
      r,
      n,
      e,
      t,
      i,
      (o, a, l) => this.getImageInternal(o, a, l, r),
      this.getInterpolate()
    ), this.reprojectedRevision_ = this.getRevision(), this.reprojectedImage_;
  }
  /**
   * @abstract
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../ImageBase.js").default} Single image.
   * @protected
   */
  getImageInternal(e, t, i, n) {
    return X();
  }
  /**
   * Handle image change events.
   * @param {import("../events/Event.js").default} event Event.
   * @protected
   */
  handleImageChange(e) {
    const t = (
      /** @type {import("../Image.js").default} */
      e.target
    );
    let i;
    switch (t.getState()) {
      case k.LOADING:
        this.loading = !0, i = co.IMAGELOADSTART;
        break;
      case k.LOADED:
        this.loading = !1, i = co.IMAGELOADEND;
        break;
      case k.ERROR:
        this.loading = !1, i = co.IMAGELOADERROR;
        break;
      default:
        return;
    }
    this.hasListener(i) && this.dispatchEvent(new ly(i, t));
  }
}
function cy(s, e) {
  s.getImage().src = e;
}
const uy = hy;
class dy extends uy {
  /**
   * @param {Options} options ImageStatic options.
   */
  constructor(e) {
    const t = e.crossOrigin !== void 0 ? e.crossOrigin : null, i = e.imageLoadFunction !== void 0 ? e.imageLoadFunction : cy;
    super({
      attributions: e.attributions,
      interpolate: e.interpolate,
      projection: ye(e.projection)
    }), this.url_ = e.url, this.imageExtent_ = e.imageExtent, this.image_ = new Ug(
      this.imageExtent_,
      void 0,
      1,
      this.url_,
      t,
      i,
      Re(1, 1)
    ), this.imageSize_ = e.imageSize ? e.imageSize : null, this.image_.addEventListener(
      z.CHANGE,
      this.handleImageChange.bind(this)
    );
  }
  /**
   * Returns the image extent
   * @return {import("../extent.js").Extent} image extent.
   * @api
   */
  getImageExtent() {
    return this.imageExtent_;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../Image.js").default} Single image.
   */
  getImageInternal(e, t, i, n) {
    return Ce(e, this.image_.getExtent()) ? this.image_ : null;
  }
  /**
   * Return the URL used for this image source.
   * @return {string} URL.
   * @api
   */
  getUrl() {
    return this.url_;
  }
  /**
   * @param {import("../events/Event.js").default} evt Event.
   */
  handleImageChange(e) {
    if (this.image_.getState() == k.LOADED) {
      const t = this.image_.getExtent(), i = this.image_.getImage();
      let n, r;
      this.imageSize_ ? (n = this.imageSize_[0], r = this.imageSize_[1]) : (n = i.width, r = i.height);
      const o = te(t), a = Fe(t), l = o / n, h = a / r;
      let c = n, u = r;
      if (l > h ? c = Math.round(o / h) : u = Math.round(a / l), c !== n || u !== r) {
        const d = Re(c, u);
        this.getInterpolate() || (d.imageSmoothingEnabled = !1);
        const f = d.canvas;
        d.drawImage(
          i,
          0,
          0,
          n,
          r,
          0,
          0,
          f.width,
          f.height
        ), this.image_.setImage(f);
      }
    }
    super.handleImageChange(e);
  }
}
const lh = dy;
class ou {
  /**
   * @param {number} minX Minimum X.
   * @param {number} maxX Maximum X.
   * @param {number} minY Minimum Y.
   * @param {number} maxY Maximum Y.
   */
  constructor(e, t, i, n) {
    this.minX = e, this.maxX = t, this.minY = i, this.maxY = n;
  }
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @return {boolean} Contains tile coordinate.
   */
  contains(e) {
    return this.containsXY(e[1], e[2]);
  }
  /**
   * @param {TileRange} tileRange Tile range.
   * @return {boolean} Contains.
   */
  containsTileRange(e) {
    return this.minX <= e.minX && e.maxX <= this.maxX && this.minY <= e.minY && e.maxY <= this.maxY;
  }
  /**
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @return {boolean} Contains coordinate.
   */
  containsXY(e, t) {
    return this.minX <= e && e <= this.maxX && this.minY <= t && t <= this.maxY;
  }
  /**
   * @param {TileRange} tileRange Tile range.
   * @return {boolean} Equals.
   */
  equals(e) {
    return this.minX == e.minX && this.minY == e.minY && this.maxX == e.maxX && this.maxY == e.maxY;
  }
  /**
   * @param {TileRange} tileRange Tile range.
   */
  extend(e) {
    e.minX < this.minX && (this.minX = e.minX), e.maxX > this.maxX && (this.maxX = e.maxX), e.minY < this.minY && (this.minY = e.minY), e.maxY > this.maxY && (this.maxY = e.maxY);
  }
  /**
   * @return {number} Height.
   */
  getHeight() {
    return this.maxY - this.minY + 1;
  }
  /**
   * @return {import("./size.js").Size} Size.
   */
  getSize() {
    return [this.getWidth(), this.getHeight()];
  }
  /**
   * @return {number} Width.
   */
  getWidth() {
    return this.maxX - this.minX + 1;
  }
  /**
   * @param {TileRange} tileRange Tile range.
   * @return {boolean} Intersects.
   */
  intersects(e) {
    return this.minX <= e.maxX && this.maxX >= e.minX && this.minY <= e.maxY && this.maxY >= e.minY;
  }
}
function Gi(s, e, t, i, n) {
  return n !== void 0 ? (n.minX = s, n.maxX = e, n.minY = t, n.maxY = i, n) : new ou(s, e, t, i);
}
const au = ou;
function hh(s, e, t, i) {
  return i !== void 0 ? (i[0] = s, i[1] = e, i[2] = t, i) : [s, e, t];
}
function Gr(s, e, t) {
  return s + "/" + e + "/" + t;
}
function lu(s) {
  return Gr(s[0], s[1], s[2]);
}
function fy(s) {
  return s.split("/").map(Number);
}
function gy(s) {
  return (s[1] << s[0]) + s[2];
}
function _y(s, e) {
  const t = s[0], i = s[1], n = s[2];
  if (e.getMinZoom() > t || t > e.getMaxZoom())
    return !1;
  const r = e.getFullTileRange(t);
  return r ? r.containsXY(i, n) : !0;
}
const Ui = [0, 0, 0], Zt = 5;
class my {
  /**
   * @param {Options} options Tile grid options.
   */
  constructor(e) {
    this.minZoom = e.minZoom !== void 0 ? e.minZoom : 0, this.resolutions_ = e.resolutions, Z(
      zu(
        this.resolutions_,
        function(n, r) {
          return r - n;
        },
        !0
      ),
      17
    );
    let t;
    if (!e.origins) {
      for (let n = 0, r = this.resolutions_.length - 1; n < r; ++n)
        if (!t)
          t = this.resolutions_[n] / this.resolutions_[n + 1];
        else if (this.resolutions_[n] / this.resolutions_[n + 1] !== t) {
          t = void 0;
          break;
        }
    }
    this.zoomFactor_ = t, this.maxZoom = this.resolutions_.length - 1, this.origin_ = e.origin !== void 0 ? e.origin : null, this.origins_ = null, e.origins !== void 0 && (this.origins_ = e.origins, Z(this.origins_.length == this.resolutions_.length, 20));
    const i = e.extent;
    i !== void 0 && !this.origin_ && !this.origins_ && (this.origin_ = Ot(i)), Z(
      !this.origin_ && this.origins_ || this.origin_ && !this.origins_,
      18
    ), this.tileSizes_ = null, e.tileSizes !== void 0 && (this.tileSizes_ = e.tileSizes, Z(this.tileSizes_.length == this.resolutions_.length, 19)), this.tileSize_ = e.tileSize !== void 0 ? e.tileSize : this.tileSizes_ ? null : fa, Z(
      !this.tileSize_ && this.tileSizes_ || this.tileSize_ && !this.tileSizes_,
      22
    ), this.extent_ = i !== void 0 ? i : null, this.fullTileRanges_ = null, this.tmpSize_ = [0, 0], this.tmpExtent_ = [0, 0, 0, 0], e.sizes !== void 0 ? this.fullTileRanges_ = e.sizes.map(function(n, r) {
      const o = new au(
        Math.min(0, n[0]),
        Math.max(n[0] - 1, -1),
        Math.min(0, n[1]),
        Math.max(n[1] - 1, -1)
      );
      if (i) {
        const a = this.getTileRangeForExtentAndZ(i, r);
        o.minX = Math.max(a.minX, o.minX), o.maxX = Math.min(a.maxX, o.maxX), o.minY = Math.max(a.minY, o.minY), o.maxY = Math.min(a.maxY, o.maxY);
      }
      return o;
    }, this) : i && this.calculateTileRanges_(i);
  }
  /**
   * Call a function with each tile coordinate for a given extent and zoom level.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} zoom Integer zoom level.
   * @param {function(import("../tilecoord.js").TileCoord): void} callback Function called with each tile coordinate.
   * @api
   */
  forEachTileCoord(e, t, i) {
    const n = this.getTileRangeForExtentAndZ(e, t);
    for (let r = n.minX, o = n.maxX; r <= o; ++r)
      for (let a = n.minY, l = n.maxY; a <= l; ++a)
        i([t, r, a]);
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {function(number, import("../TileRange.js").default): boolean} callback Callback.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
   * @param {import("../extent.js").Extent} [tempExtent] Temporary import("../extent.js").Extent object.
   * @return {boolean} Callback succeeded.
   */
  forEachTileCoordParentTileRange(e, t, i, n) {
    let r, o, a, l = null, h = e[0] - 1;
    for (this.zoomFactor_ === 2 ? (o = e[1], a = e[2]) : l = this.getTileCoordExtent(e, n); h >= this.minZoom; ) {
      if (this.zoomFactor_ === 2 ? (o = Math.floor(o / 2), a = Math.floor(a / 2), r = Gi(o, o, a, a, i)) : r = this.getTileRangeForExtentAndZ(
        l,
        h,
        i
      ), t(h, r))
        return !0;
      --h;
    }
    return !1;
  }
  /**
   * Get the extent for this tile grid, if it was configured.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getExtent() {
    return this.extent_;
  }
  /**
   * Get the maximum zoom level for the grid.
   * @return {number} Max zoom.
   * @api
   */
  getMaxZoom() {
    return this.maxZoom;
  }
  /**
   * Get the minimum zoom level for the grid.
   * @return {number} Min zoom.
   * @api
   */
  getMinZoom() {
    return this.minZoom;
  }
  /**
   * Get the origin for the grid at the given zoom level.
   * @param {number} z Integer zoom level.
   * @return {import("../coordinate.js").Coordinate} Origin.
   * @api
   */
  getOrigin(e) {
    return this.origin_ ? this.origin_ : this.origins_[e];
  }
  /**
   * Get the resolution for the given zoom level.
   * @param {number} z Integer zoom level.
   * @return {number} Resolution.
   * @api
   */
  getResolution(e) {
    return this.resolutions_[e];
  }
  /**
   * Get the list of resolutions for the tile grid.
   * @return {Array<number>} Resolutions.
   * @api
   */
  getResolutions() {
    return this.resolutions_;
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
   * @param {import("../extent.js").Extent} [tempExtent] Temporary import("../extent.js").Extent object.
   * @return {import("../TileRange.js").default|null} Tile range.
   */
  getTileCoordChildTileRange(e, t, i) {
    if (e[0] < this.maxZoom) {
      if (this.zoomFactor_ === 2) {
        const r = e[1] * 2, o = e[2] * 2;
        return Gi(
          r,
          r + 1,
          o,
          o + 1,
          t
        );
      }
      const n = this.getTileCoordExtent(
        e,
        i || this.tmpExtent_
      );
      return this.getTileRangeForExtentAndZ(
        n,
        e[0] + 1,
        t
      );
    }
    return null;
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {number} z Integer zoom level.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
   * @return {import("../TileRange.js").default|null} Tile range.
   */
  getTileRangeForTileCoordAndZ(e, t, i) {
    if (t > this.maxZoom || t < this.minZoom)
      return null;
    const n = e[0], r = e[1], o = e[2];
    if (t === n)
      return Gi(
        r,
        o,
        r,
        o,
        i
      );
    if (this.zoomFactor_) {
      const l = Math.pow(this.zoomFactor_, t - n), h = Math.floor(r * l), c = Math.floor(o * l);
      if (t < n)
        return Gi(h, h, c, c, i);
      const u = Math.floor(l * (r + 1)) - 1, d = Math.floor(l * (o + 1)) - 1;
      return Gi(h, u, c, d, i);
    }
    const a = this.getTileCoordExtent(e, this.tmpExtent_);
    return this.getTileRangeForExtentAndZ(a, t, i);
  }
  /**
   * Get the extent for a tile range.
   * @param {number} z Integer zoom level.
   * @param {import("../TileRange.js").default} tileRange Tile range.
   * @param {import("../extent.js").Extent} [tempExtent] Temporary import("../extent.js").Extent object.
   * @return {import("../extent.js").Extent} Extent.
   */
  getTileRangeExtent(e, t, i) {
    const n = this.getOrigin(e), r = this.getResolution(e), o = Ke(this.getTileSize(e), this.tmpSize_), a = n[0] + t.minX * o[0] * r, l = n[0] + (t.maxX + 1) * o[0] * r, h = n[1] + t.minY * o[1] * r, c = n[1] + (t.maxY + 1) * o[1] * r;
    return pt(a, h, l, c, i);
  }
  /**
   * Get a tile range for the given extent and integer zoom level.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} z Integer zoom level.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary tile range object.
   * @return {import("../TileRange.js").default} Tile range.
   */
  getTileRangeForExtentAndZ(e, t, i) {
    this.getTileCoordForXYAndZ_(e[0], e[3], t, !1, Ui);
    const n = Ui[1], r = Ui[2];
    this.getTileCoordForXYAndZ_(e[2], e[1], t, !0, Ui);
    const o = Ui[1], a = Ui[2];
    return Gi(n, o, r, a, i);
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @return {import("../coordinate.js").Coordinate} Tile center.
   */
  getTileCoordCenter(e) {
    const t = this.getOrigin(e[0]), i = this.getResolution(e[0]), n = Ke(this.getTileSize(e[0]), this.tmpSize_);
    return [
      t[0] + (e[1] + 0.5) * n[0] * i,
      t[1] - (e[2] + 0.5) * n[1] * i
    ];
  }
  /**
   * Get the extent of a tile coordinate.
   *
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../extent.js").Extent} [tempExtent] Temporary extent object.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getTileCoordExtent(e, t) {
    const i = this.getOrigin(e[0]), n = this.getResolution(e[0]), r = Ke(this.getTileSize(e[0]), this.tmpSize_), o = i[0] + e[1] * r[0] * n, a = i[1] - (e[2] + 1) * r[1] * n, l = o + r[0] * n, h = a + r[1] * n;
    return pt(o, a, l, h, t);
  }
  /**
   * Get the tile coordinate for the given map coordinate and resolution.  This
   * method considers that coordinates that intersect tile boundaries should be
   * assigned the higher tile coordinate.
   *
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} resolution Resolution.
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Destination import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @api
   */
  getTileCoordForCoordAndResolution(e, t, i) {
    return this.getTileCoordForXYAndResolution_(
      e[0],
      e[1],
      t,
      !1,
      i
    );
  }
  /**
   * Note that this method should not be called for resolutions that correspond
   * to an integer zoom level.  Instead call the `getTileCoordForXYAndZ_` method.
   * @param {number} x X.
   * @param {number} y Y.
   * @param {number} resolution Resolution (for a non-integer zoom level).
   * @param {boolean} reverseIntersectionPolicy Instead of letting edge
   *     intersections go to the higher tile coordinate, let edge intersections
   *     go to the lower tile coordinate.
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Temporary import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @private
   */
  getTileCoordForXYAndResolution_(e, t, i, n, r) {
    const o = this.getZForResolution(i), a = i / this.getResolution(o), l = this.getOrigin(o), h = Ke(this.getTileSize(o), this.tmpSize_);
    let c = a * (e - l[0]) / i / h[0], u = a * (l[1] - t) / i / h[1];
    return n ? (c = Rs(c, Zt) - 1, u = Rs(u, Zt) - 1) : (c = Ss(c, Zt), u = Ss(u, Zt)), hh(o, c, u, r);
  }
  /**
   * Although there is repetition between this method and `getTileCoordForXYAndResolution_`,
   * they should have separate implementations.  This method is for integer zoom
   * levels.  The other method should only be called for resolutions corresponding
   * to non-integer zoom levels.
   * @param {number} x Map x coordinate.
   * @param {number} y Map y coordinate.
   * @param {number} z Integer zoom level.
   * @param {boolean} reverseIntersectionPolicy Instead of letting edge
   *     intersections go to the higher tile coordinate, let edge intersections
   *     go to the lower tile coordinate.
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Temporary import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @private
   */
  getTileCoordForXYAndZ_(e, t, i, n, r) {
    const o = this.getOrigin(i), a = this.getResolution(i), l = Ke(this.getTileSize(i), this.tmpSize_);
    let h = (e - o[0]) / a / l[0], c = (o[1] - t) / a / l[1];
    return n ? (h = Rs(h, Zt) - 1, c = Rs(c, Zt) - 1) : (h = Ss(h, Zt), c = Ss(c, Zt)), hh(i, h, c, r);
  }
  /**
   * Get a tile coordinate given a map coordinate and zoom level.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} z Zoom level.
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Destination import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @api
   */
  getTileCoordForCoordAndZ(e, t, i) {
    return this.getTileCoordForXYAndZ_(
      e[0],
      e[1],
      t,
      !1,
      i
    );
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @return {number} Tile resolution.
   */
  getTileCoordResolution(e) {
    return this.resolutions_[e[0]];
  }
  /**
   * Get the tile size for a zoom level. The type of the return value matches the
   * `tileSize` or `tileSizes` that the tile grid was configured with. To always
   * get an {@link import("../size.js").Size}, run the result through {@link module:ol/size.toSize}.
   * @param {number} z Z.
   * @return {number|import("../size.js").Size} Tile size.
   * @api
   */
  getTileSize(e) {
    return this.tileSize_ ? this.tileSize_ : this.tileSizes_[e];
  }
  /**
   * @param {number} z Zoom level.
   * @return {import("../TileRange.js").default} Extent tile range for the specified zoom level.
   */
  getFullTileRange(e) {
    return this.fullTileRanges_ ? this.fullTileRanges_[e] : this.extent_ ? this.getTileRangeForExtentAndZ(this.extent_, e) : null;
  }
  /**
   * @param {number} resolution Resolution.
   * @param {number|import("../array.js").NearestDirectionFunction} [opt_direction]
   *     If 0, the nearest resolution will be used.
   *     If 1, the nearest higher resolution (lower Z) will be used. If -1, the
   *     nearest lower resolution (higher Z) will be used. Default is 0.
   *     Use a {@link module:ol/array~NearestDirectionFunction} for more precise control.
   *
   * For example to change tile Z at the midpoint of zoom levels
   * ```js
   * function(value, high, low) {
   *   return value - low * Math.sqrt(high / low);
   * }
   * ```
   * @return {number} Z.
   * @api
   */
  getZForResolution(e, t) {
    const i = Tr(
      this.resolutions_,
      e,
      t || 0
    );
    return _e(i, this.minZoom, this.maxZoom);
  }
  /**
   * The tile with the provided tile coordinate intersects the given viewport.
   * @param {import('../tilecoord.js').TileCoord} tileCoord Tile coordinate.
   * @param {Array<number>} viewport Viewport as returned from {@link module:ol/extent.getRotatedViewport}.
   * @return {boolean} The tile with the provided tile coordinate intersects the given viewport.
   */
  tileCoordIntersectsViewport(e, t) {
    return ic(
      t,
      0,
      t.length,
      2,
      this.getTileCoordExtent(e)
    );
  }
  /**
   * @param {!import("../extent.js").Extent} extent Extent for this tile grid.
   * @private
   */
  calculateTileRanges_(e) {
    const t = this.resolutions_.length, i = new Array(t);
    for (let n = this.minZoom; n < t; ++n)
      i[n] = this.getTileRangeForExtentAndZ(e, n);
    this.fullTileRanges_ = i;
  }
}
const hu = my;
class py extends es {
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("./TileState.js").default} state State.
   * @param {Options} [options] Tile options.
   */
  constructor(e, t, i) {
    super(), i = i || {}, this.tileCoord = e, this.state = t, this.interimTile = null, this.key = "", this.transition_ = i.transition === void 0 ? 250 : i.transition, this.transitionStarts_ = {}, this.interpolate = !!i.interpolate;
  }
  /**
   * @protected
   */
  changed() {
    this.dispatchEvent(z.CHANGE);
  }
  /**
   * Called by the tile cache when the tile is removed from the cache due to expiry
   */
  release() {
    this.state === G.ERROR && this.setState(G.EMPTY);
  }
  /**
   * @return {string} Key.
   */
  getKey() {
    return this.key + "/" + this.tileCoord;
  }
  /**
   * Get the interim tile most suitable for rendering using the chain of interim
   * tiles. This corresponds to the  most recent tile that has been loaded, if no
   * such tile exists, the original tile is returned.
   * @return {!Tile} Best tile for rendering.
   */
  getInterimTile() {
    if (!this.interimTile)
      return this;
    let e = this.interimTile;
    do {
      if (e.getState() == G.LOADED)
        return this.transition_ = 0, e;
      e = e.interimTile;
    } while (e);
    return this;
  }
  /**
   * Goes through the chain of interim tiles and discards sections of the chain
   * that are no longer relevant.
   */
  refreshInterimChain() {
    if (!this.interimTile)
      return;
    let e = this.interimTile, t = this;
    do {
      if (e.getState() == G.LOADED) {
        e.interimTile = null;
        break;
      } else
        e.getState() == G.LOADING ? t = e : e.getState() == G.IDLE ? t.interimTile = e.interimTile : t = e;
      e = t.interimTile;
    } while (e);
  }
  /**
   * Get the tile coordinate for this tile.
   * @return {import("./tilecoord.js").TileCoord} The tile coordinate.
   * @api
   */
  getTileCoord() {
    return this.tileCoord;
  }
  /**
   * @return {import("./TileState.js").default} State.
   */
  getState() {
    return this.state;
  }
  /**
   * Sets the state of this tile. If you write your own {@link module:ol/Tile~LoadFunction tileLoadFunction} ,
   * it is important to set the state correctly to {@link module:ol/TileState~ERROR}
   * when the tile cannot be loaded. Otherwise the tile cannot be removed from
   * the tile queue and will block other requests.
   * @param {import("./TileState.js").default} state State.
   * @api
   */
  setState(e) {
    if (this.state !== G.ERROR && this.state > e)
      throw new Error("Tile load sequence violation");
    this.state = e, this.changed();
  }
  /**
   * Load the image or retry if loading previously failed.
   * Loading is taken care of by the tile queue, and calling this method is
   * only needed for preloading or for reloading in case of an error.
   * @abstract
   * @api
   */
  load() {
    X();
  }
  /**
   * Get the alpha value for rendering.
   * @param {string} id An id for the renderer.
   * @param {number} time The render frame time.
   * @return {number} A number between 0 and 1.
   */
  getAlpha(e, t) {
    if (!this.transition_)
      return 1;
    let i = this.transitionStarts_[e];
    if (!i)
      i = t, this.transitionStarts_[e] = i;
    else if (i === -1)
      return 1;
    const n = t - i + 1e3 / 60;
    return n >= this.transition_ ? 1 : Zh(n / this.transition_);
  }
  /**
   * Determine if a tile is in an alpha transition.  A tile is considered in
   * transition if tile.getAlpha() has not yet been called or has been called
   * and returned 1.
   * @param {string} id An id for the renderer.
   * @return {boolean} The tile is in transition.
   */
  inTransition(e) {
    return this.transition_ ? this.transitionStarts_[e] !== -1 : !1;
  }
  /**
   * Mark a transition as complete.
   * @param {string} id An id for the renderer.
   */
  endTransition(e) {
    this.transition_ && (this.transitionStarts_[e] = -1);
  }
}
const cu = py;
class yy extends cu {
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("./TileState.js").default} state State.
   * @param {string} src Image source URI.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("./Tile.js").LoadFunction} tileLoadFunction Tile load function.
   * @param {import("./Tile.js").Options} [options] Tile options.
   */
  constructor(e, t, i, n, r, o) {
    super(e, t, o), this.crossOrigin_ = n, this.src_ = i, this.key = i, this.image_ = new Image(), n !== null && (this.image_.crossOrigin = n), this.unlisten_ = null, this.tileLoadFunction_ = r;
  }
  /**
   * Get the HTML image element for this tile (may be a Canvas, Image, or Video).
   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
   * @api
   */
  getImage() {
    return this.image_;
  }
  /**
   * Sets an HTML image element for this tile (may be a Canvas or preloaded Image).
   * @param {HTMLCanvasElement|HTMLImageElement} element Element.
   */
  setImage(e) {
    this.image_ = e, this.state = G.LOADED, this.unlistenImage_(), this.changed();
  }
  /**
   * Tracks loading or read errors.
   *
   * @private
   */
  handleImageError_() {
    this.state = G.ERROR, this.unlistenImage_(), this.image_ = xy(), this.changed();
  }
  /**
   * Tracks successful image load.
   *
   * @private
   */
  handleImageLoad_() {
    const e = (
      /** @type {HTMLImageElement} */
      this.image_
    );
    e.naturalWidth && e.naturalHeight ? this.state = G.LOADED : this.state = G.EMPTY, this.unlistenImage_(), this.changed();
  }
  /**
   * Load the image or retry if loading previously failed.
   * Loading is taken care of by the tile queue, and calling this method is
   * only needed for preloading or for reloading in case of an error.
   *
   * To retry loading tiles on failed requests, use a custom `tileLoadFunction`
   * that checks for error status codes and reloads only when the status code is
   * 408, 429, 500, 502, 503 and 504, and only when not too many retries have been
   * made already:
   *
   * ```js
   * const retryCodes = [408, 429, 500, 502, 503, 504];
   * const retries = {};
   * source.setTileLoadFunction((tile, src) => {
   *   const image = tile.getImage();
   *   fetch(src)
   *     .then((response) => {
   *       if (retryCodes.includes(response.status)) {
   *         retries[src] = (retries[src] || 0) + 1;
   *         if (retries[src] <= 3) {
   *           setTimeout(() => tile.load(), retries[src] * 1000);
   *         }
   *         return Promise.reject();
   *       }
   *       return response.blob();
   *     })
   *     .then((blob) => {
   *       const imageUrl = URL.createObjectURL(blob);
   *       image.src = imageUrl;
   *       setTimeout(() => URL.revokeObjectURL(imageUrl), 5000);
   *     })
   *     .catch(() => tile.setState(3)); // error
   * });
   * ```
   *
   * @api
   */
  load() {
    this.state == G.ERROR && (this.state = G.IDLE, this.image_ = new Image(), this.crossOrigin_ !== null && (this.image_.crossOrigin = this.crossOrigin_)), this.state == G.IDLE && (this.state = G.LOADING, this.changed(), this.tileLoadFunction_(this, this.src_), this.unlisten_ = ja(
      this.image_,
      this.handleImageLoad_.bind(this),
      this.handleImageError_.bind(this)
    ));
  }
  /**
   * Discards event handlers which listen for load completion or errors.
   *
   * @private
   */
  unlistenImage_() {
    this.unlisten_ && (this.unlisten_(), this.unlisten_ = null);
  }
}
function xy() {
  const s = Re(1, 1);
  return s.fillStyle = "rgba(0,0,0,0)", s.fillRect(0, 0, 1, 1), s.canvas;
}
const uu = yy;
class Ey extends cu {
  /**
   * @param {import("../proj/Projection.js").default} sourceProj Source projection.
   * @param {import("../tilegrid/TileGrid.js").default} sourceTileGrid Source tile grid.
   * @param {import("../proj/Projection.js").default} targetProj Target projection.
   * @param {import("../tilegrid/TileGrid.js").default} targetTileGrid Target tile grid.
   * @param {import("../tilecoord.js").TileCoord} tileCoord Coordinate of the tile.
   * @param {import("../tilecoord.js").TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.
   * @param {number} pixelRatio Pixel ratio.
   * @param {number} gutter Gutter of the source tiles.
   * @param {FunctionType} getTileFunction
   *     Function returning source tiles (z, x, y, pixelRatio).
   * @param {number} [errorThreshold] Acceptable reprojection error (in px).
   * @param {boolean} [renderEdges] Render reprojection edges.
   * @param {boolean} [interpolate] Use linear interpolation when resampling.
   */
  constructor(e, t, i, n, r, o, a, l, h, c, u, d) {
    super(r, G.IDLE, { interpolate: !!d }), this.renderEdges_ = u !== void 0 ? u : !1, this.pixelRatio_ = a, this.gutter_ = l, this.canvas_ = null, this.sourceTileGrid_ = t, this.targetTileGrid_ = n, this.wrappedTileCoord_ = o || r, this.sourceTiles_ = [], this.sourcesListenerKeys_ = null, this.sourceZ_ = 0;
    const f = n.getTileCoordExtent(
      this.wrappedTileCoord_
    ), g = this.targetTileGrid_.getExtent();
    let _ = this.sourceTileGrid_.getExtent();
    const m = g ? pi(f, g) : f;
    if (Fo(m) === 0) {
      this.state = G.EMPTY;
      return;
    }
    const p = e.getExtent();
    p && (_ ? _ = pi(_, p) : _ = p);
    const x = n.getResolution(
      this.wrappedTileCoord_[0]
    ), y = ry(
      e,
      i,
      m,
      x
    );
    if (!isFinite(y) || y <= 0) {
      this.state = G.EMPTY;
      return;
    }
    const E = c !== void 0 ? c : nu;
    if (this.triangulation_ = new su(
      e,
      i,
      m,
      _,
      y * E,
      x
    ), this.triangulation_.getTriangles().length === 0) {
      this.state = G.EMPTY;
      return;
    }
    this.sourceZ_ = t.getZForResolution(y);
    let C = this.triangulation_.calculateSourceExtent();
    if (_ && (e.canWrapX() ? (C[1] = _e(
      C[1],
      _[1],
      _[3]
    ), C[3] = _e(
      C[3],
      _[1],
      _[3]
    )) : C = pi(C, _)), !Fo(C))
      this.state = G.EMPTY;
    else {
      const T = t.getTileRangeForExtentAndZ(
        C,
        this.sourceZ_
      );
      for (let w = T.minX; w <= T.maxX; w++)
        for (let L = T.minY; L <= T.maxY; L++) {
          const I = h(this.sourceZ_, w, L, a);
          I && this.sourceTiles_.push(I);
        }
      this.sourceTiles_.length === 0 && (this.state = G.EMPTY);
    }
  }
  /**
   * Get the HTML Canvas element for this tile.
   * @return {HTMLCanvasElement} Canvas.
   */
  getImage() {
    return this.canvas_;
  }
  /**
   * @private
   */
  reproject_() {
    const e = [];
    if (this.sourceTiles_.forEach((t) => {
      t && t.getState() == G.LOADED && e.push({
        extent: this.sourceTileGrid_.getTileCoordExtent(t.tileCoord),
        image: t.getImage()
      });
    }), this.sourceTiles_.length = 0, e.length === 0)
      this.state = G.ERROR;
    else {
      const t = this.wrappedTileCoord_[0], i = this.targetTileGrid_.getTileSize(t), n = typeof i == "number" ? i : i[0], r = typeof i == "number" ? i : i[1], o = this.targetTileGrid_.getResolution(t), a = this.sourceTileGrid_.getResolution(
        this.sourceZ_
      ), l = this.targetTileGrid_.getTileCoordExtent(
        this.wrappedTileCoord_
      );
      this.canvas_ = ru(
        n,
        r,
        this.pixelRatio_,
        a,
        this.sourceTileGrid_.getExtent(),
        o,
        l,
        this.triangulation_,
        e,
        this.gutter_,
        this.renderEdges_,
        this.interpolate
      ), this.state = G.LOADED;
    }
    this.changed();
  }
  /**
   * Load not yet loaded URI.
   */
  load() {
    if (this.state == G.IDLE) {
      this.state = G.LOADING, this.changed();
      let e = 0;
      this.sourcesListenerKeys_ = [], this.sourceTiles_.forEach((t) => {
        const i = t.getState();
        if (i == G.IDLE || i == G.LOADING) {
          e++;
          const n = H(
            t,
            z.CHANGE,
            function(r) {
              const o = t.getState();
              (o == G.LOADED || o == G.ERROR || o == G.EMPTY) && (re(n), e--, e === 0 && (this.unlistenSources_(), this.reproject_()));
            },
            this
          );
          this.sourcesListenerKeys_.push(n);
        }
      }), e === 0 ? setTimeout(this.reproject_.bind(this), 0) : this.sourceTiles_.forEach(function(t, i, n) {
        t.getState() == G.IDLE && t.load();
      });
    }
  }
  /**
   * @private
   */
  unlistenSources_() {
    this.sourcesListenerKeys_.forEach(re), this.sourcesListenerKeys_ = null;
  }
  /**
   * Remove from the cache due to expiry
   */
  release() {
    this.canvas_ && (Ar(this.canvas_.getContext("2d")), Qi.push(this.canvas_), this.canvas_ = null), super.release();
  }
}
const ea = Ey;
class vy {
  /**
   * @param {number} [highWaterMark] High water mark.
   */
  constructor(e) {
    this.highWaterMark = e !== void 0 ? e : 2048, this.count_ = 0, this.entries_ = {}, this.oldest_ = null, this.newest_ = null;
  }
  /**
   * @return {boolean} Can expire cache.
   */
  canExpireCache() {
    return this.highWaterMark > 0 && this.getCount() > this.highWaterMark;
  }
  /**
   * Expire the cache.
   * @param {!Object<string, boolean>} [keep] Keys to keep. To be implemented by subclasses.
   */
  expireCache(e) {
    for (; this.canExpireCache(); )
      this.pop();
  }
  /**
   * FIXME empty description for jsdoc
   */
  clear() {
    this.count_ = 0, this.entries_ = {}, this.oldest_ = null, this.newest_ = null;
  }
  /**
   * @param {string} key Key.
   * @return {boolean} Contains key.
   */
  containsKey(e) {
    return this.entries_.hasOwnProperty(e);
  }
  /**
   * @param {function(T, string, LRUCache<T>): ?} f The function
   *     to call for every entry from the oldest to the newer. This function takes
   *     3 arguments (the entry value, the entry key and the LRUCache object).
   *     The return value is ignored.
   */
  forEach(e) {
    let t = this.oldest_;
    for (; t; )
      e(t.value_, t.key_, this), t = t.newer;
  }
  /**
   * @param {string} key Key.
   * @param {*} [options] Options (reserved for subclasses).
   * @return {T} Value.
   */
  get(e, t) {
    const i = this.entries_[e];
    return Z(i !== void 0, 15), i === this.newest_ || (i === this.oldest_ ? (this.oldest_ = /** @type {Entry} */
    this.oldest_.newer, this.oldest_.older = null) : (i.newer.older = i.older, i.older.newer = i.newer), i.newer = null, i.older = this.newest_, this.newest_.newer = i, this.newest_ = i), i.value_;
  }
  /**
   * Remove an entry from the cache.
   * @param {string} key The entry key.
   * @return {T} The removed entry.
   */
  remove(e) {
    const t = this.entries_[e];
    return Z(t !== void 0, 15), t === this.newest_ ? (this.newest_ = /** @type {Entry} */
    t.older, this.newest_ && (this.newest_.newer = null)) : t === this.oldest_ ? (this.oldest_ = /** @type {Entry} */
    t.newer, this.oldest_ && (this.oldest_.older = null)) : (t.newer.older = t.older, t.older.newer = t.newer), delete this.entries_[e], --this.count_, t.value_;
  }
  /**
   * @return {number} Count.
   */
  getCount() {
    return this.count_;
  }
  /**
   * @return {Array<string>} Keys.
   */
  getKeys() {
    const e = new Array(this.count_);
    let t = 0, i;
    for (i = this.newest_; i; i = i.older)
      e[t++] = i.key_;
    return e;
  }
  /**
   * @return {Array<T>} Values.
   */
  getValues() {
    const e = new Array(this.count_);
    let t = 0, i;
    for (i = this.newest_; i; i = i.older)
      e[t++] = i.value_;
    return e;
  }
  /**
   * @return {T} Last value.
   */
  peekLast() {
    return this.oldest_.value_;
  }
  /**
   * @return {string} Last key.
   */
  peekLastKey() {
    return this.oldest_.key_;
  }
  /**
   * Get the key of the newest item in the cache.  Throws if the cache is empty.
   * @return {string} The newest key.
   */
  peekFirstKey() {
    return this.newest_.key_;
  }
  /**
   * Return an entry without updating least recently used time.
   * @param {string} key Key.
   * @return {T} Value.
   */
  peek(e) {
    if (this.containsKey(e))
      return this.entries_[e].value_;
  }
  /**
   * @return {T} value Value.
   */
  pop() {
    const e = this.oldest_;
    return delete this.entries_[e.key_], e.newer && (e.newer.older = null), this.oldest_ = /** @type {Entry} */
    e.newer, this.oldest_ || (this.newest_ = null), --this.count_, e.value_;
  }
  /**
   * @param {string} key Key.
   * @param {T} value Value.
   */
  replace(e, t) {
    this.get(e), this.entries_[e].value_ = t;
  }
  /**
   * @param {string} key Key.
   * @param {T} value Value.
   */
  set(e, t) {
    Z(!(e in this.entries_), 16);
    const i = {
      key_: e,
      newer: null,
      older: this.newest_,
      value_: t
    };
    this.newest_ ? this.newest_.newer = i : this.oldest_ = i, this.newest_ = i, this.entries_[e] = i, ++this.count_;
  }
  /**
   * Set a maximum number of entries for the cache.
   * @param {number} size Cache size.
   * @api
   */
  setSize(e) {
    this.highWaterMark = e;
  }
}
const Cy = vy;
class wy extends Cy {
  clear() {
    for (; this.getCount() > 0; )
      this.pop().release();
    super.clear();
  }
  /**
   * @param {!Object<string, boolean>} usedTiles Used tiles.
   */
  expireCache(e) {
    for (; this.canExpireCache() && !(this.peekLast().getKey() in e); )
      this.pop().release();
  }
  /**
   * Prune all tiles from the cache that don't have the same z as the newest tile.
   */
  pruneExceptNewestZ() {
    if (this.getCount() === 0)
      return;
    const e = this.peekFirstKey(), i = fy(e)[0];
    this.forEach((n) => {
      n.tileCoord[0] !== i && (this.remove(lu(n.tileCoord)), n.release());
    });
  }
}
const du = wy, uo = {
  /**
   * Triggered when a tile starts loading.
   * @event module:ol/source/Tile.TileSourceEvent#tileloadstart
   * @api
   */
  TILELOADSTART: "tileloadstart",
  /**
   * Triggered when a tile finishes loading, either when its data is loaded,
   * or when loading was aborted because the tile is no longer needed.
   * @event module:ol/source/Tile.TileSourceEvent#tileloadend
   * @api
   */
  TILELOADEND: "tileloadend",
  /**
   * Triggered if tile loading results in an error. Note that this is not the
   * right place to re-fetch tiles. See {@link module:ol/ImageTile~ImageTile#load}
   * for details.
   * @event module:ol/source/Tile.TileSourceEvent#tileloaderror
   * @api
   */
  TILELOADERROR: "tileloaderror"
};
function fu(s) {
  let e = s.getDefaultTileGrid();
  return e || (e = Iy(s), s.setDefaultTileGrid(e)), e;
}
function Ty(s, e, t) {
  const i = e[0], n = s.getTileCoordCenter(e), r = gu(t);
  if (!ss(r, n)) {
    const o = te(r), a = Math.ceil(
      (r[0] - n[0]) / o
    );
    return n[0] += o * a, s.getTileCoordForCoordAndZ(n, i);
  }
  return e;
}
function Sy(s, e, t, i) {
  i = i !== void 0 ? i : "top-left";
  const n = Ry(s, e, t);
  return new hu({
    extent: s,
    origin: od(s, i),
    resolutions: n,
    tileSize: t
  });
}
function Ry(s, e, t, i) {
  e = e !== void 0 ? e : xd, t = Ke(t !== void 0 ? t : fa);
  const n = Fe(s), r = te(s);
  i = i > 0 ? i : Math.max(r / t[0], n / t[1]);
  const o = e + 1, a = new Array(o);
  for (let l = 0; l < o; ++l)
    a[l] = i / Math.pow(2, l);
  return a;
}
function Iy(s, e, t, i) {
  const n = gu(s);
  return Sy(n, e, t, i);
}
function gu(s) {
  s = ye(s);
  let e = s.getExtent();
  if (!e) {
    const t = 180 * on.degrees / s.getMetersPerUnit();
    e = pt(-t, -t, t, t);
  }
  return e;
}
class Ly extends Ja {
  /**
   * @param {Options} options SourceTile source options.
   */
  constructor(e) {
    super({
      attributions: e.attributions,
      attributionsCollapsible: e.attributionsCollapsible,
      projection: e.projection,
      state: e.state,
      wrapX: e.wrapX,
      interpolate: e.interpolate
    }), this.on, this.once, this.un, this.opaque_ = e.opaque !== void 0 ? e.opaque : !1, this.tilePixelRatio_ = e.tilePixelRatio !== void 0 ? e.tilePixelRatio : 1, this.tileGrid = e.tileGrid !== void 0 ? e.tileGrid : null;
    const t = [256, 256];
    this.tileGrid && Ke(this.tileGrid.getTileSize(this.tileGrid.getMinZoom()), t), this.tileCache = new du(e.cacheSize || 0), this.tmpSize = [0, 0], this.key_ = e.key || "", this.tileOptions = {
      transition: e.transition,
      interpolate: e.interpolate
    }, this.zDirection = e.zDirection ? e.zDirection : 0;
  }
  /**
   * @return {boolean} Can expire cache.
   */
  canExpireCache() {
    return this.tileCache.canExpireCache();
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {!Object<string, boolean>} usedTiles Used tiles.
   */
  expireCache(e, t) {
    const i = this.getTileCacheForProjection(e);
    i && i.expireCache(t);
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {number} z Zoom level.
   * @param {import("../TileRange.js").default} tileRange Tile range.
   * @param {function(import("../Tile.js").default):(boolean|void)} callback Called with each
   *     loaded tile.  If the callback returns `false`, the tile will not be
   *     considered loaded.
   * @return {boolean} The tile range is fully covered with loaded tiles.
   */
  forEachLoadedTile(e, t, i, n) {
    const r = this.getTileCacheForProjection(e);
    if (!r)
      return !1;
    let o = !0, a, l, h;
    for (let c = i.minX; c <= i.maxX; ++c)
      for (let u = i.minY; u <= i.maxY; ++u)
        l = Gr(t, c, u), h = !1, r.containsKey(l) && (a = /** @type {!import("../Tile.js").default} */
        r.get(l), h = a.getState() === G.LOADED, h && (h = n(a) !== !1)), h || (o = !1);
    return o;
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {number} Gutter.
   */
  getGutterForProjection(e) {
    return 0;
  }
  /**
   * Return the key to be used for all tiles in the source.
   * @return {string} The key for all tiles.
   */
  getKey() {
    return this.key_;
  }
  /**
   * Set the value to be used as the key for all tiles in the source.
   * @param {string} key The key for tiles.
   * @protected
   */
  setKey(e) {
    this.key_ !== e && (this.key_ = e, this.changed());
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {boolean} Opaque.
   */
  getOpaque(e) {
    return this.opaque_;
  }
  /**
   * @param {import("../proj/Projection").default} [projection] Projection.
   * @return {Array<number>|null} Resolutions.
   */
  getResolutions(e) {
    const t = e ? this.getTileGridForProjection(e) : this.tileGrid;
    return t ? t.getResolutions() : null;
  }
  /**
   * @abstract
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../Tile.js").default} Tile.
   */
  getTile(e, t, i, n, r) {
    return X();
  }
  /**
   * Return the tile grid of the tile source.
   * @return {import("../tilegrid/TileGrid.js").default|null} Tile grid.
   * @api
   */
  getTileGrid() {
    return this.tileGrid;
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
   */
  getTileGridForProjection(e) {
    return this.tileGrid ? this.tileGrid : fu(e);
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../TileCache.js").default} Tile cache.
   * @protected
   */
  getTileCacheForProjection(e) {
    const t = this.getProjection();
    return Z(
      t === null || At(t, e),
      68
      // A VectorTile source can only be rendered if it has a projection compatible with the view projection.
    ), this.tileCache;
  }
  /**
   * Get the tile pixel ratio for this source. Subclasses may override this
   * method, which is meant to return a supported pixel ratio that matches the
   * provided `pixelRatio` as close as possible.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Tile pixel ratio.
   */
  getTilePixelRatio(e) {
    return this.tilePixelRatio_;
  }
  /**
   * @param {number} z Z.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../size.js").Size} Tile size.
   */
  getTilePixelSize(e, t, i) {
    const n = this.getTileGridForProjection(i), r = this.getTilePixelRatio(t), o = Ke(n.getTileSize(e), this.tmpSize);
    return r == 1 ? o : Sg(o, r, this.tmpSize);
  }
  /**
   * Returns a tile coordinate wrapped around the x-axis. When the tile coordinate
   * is outside the resolution and extent range of the tile grid, `null` will be
   * returned.
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../proj/Projection.js").default} [projection] Projection.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate to be passed to the tileUrlFunction or
   *     null if no tile URL should be created for the passed `tileCoord`.
   */
  getTileCoordForTileUrlFunction(e, t) {
    t = t !== void 0 ? t : this.getProjection();
    const i = this.getTileGridForProjection(t);
    return this.getWrapX() && t.isGlobal() && (e = Ty(i, e, t)), _y(e, i) ? e : null;
  }
  /**
   * Remove all cached tiles from the source. The next render cycle will fetch new tiles.
   * @api
   */
  clear() {
    this.tileCache.clear();
  }
  refresh() {
    this.clear(), super.refresh();
  }
  /**
   * Increases the cache size if needed
   * @param {number} tileCount Minimum number of tiles needed.
   * @param {import("../proj/Projection.js").default} projection Projection.
   */
  updateCacheSize(e, t) {
    const i = this.getTileCacheForProjection(t);
    e > i.highWaterMark && (i.highWaterMark = e);
  }
  /**
   * Marks a tile coord as being used, without triggering a load.
   * @abstract
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {import("../proj/Projection.js").default} projection Projection.
   */
  useTile(e, t, i, n) {
  }
}
class Ay extends Ye {
  /**
   * @param {string} type Type.
   * @param {import("../Tile.js").default} tile The tile.
   */
  constructor(e, t) {
    super(e), this.tile = t;
  }
}
const Fy = Ly;
function by(s, e) {
  const t = /\{z\}/g, i = /\{x\}/g, n = /\{y\}/g, r = /\{-y\}/g;
  return (
    /**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile Coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("./proj/Projection.js").default} projection Projection.
     * @return {string|undefined} Tile URL.
     */
    function(o, a, l) {
      if (o)
        return s.replace(t, o[0].toString()).replace(i, o[1].toString()).replace(n, o[2].toString()).replace(r, function() {
          const h = o[0], c = e.getFullTileRange(h);
          return Z(c, 55), (c.getHeight() - o[2] - 1).toString();
        });
    }
  );
}
function Py(s, e) {
  const t = s.length, i = new Array(t);
  for (let n = 0; n < t; ++n)
    i[n] = by(s[n], e);
  return My(i);
}
function My(s) {
  return s.length === 1 ? s[0] : (
    /**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile Coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("./proj/Projection.js").default} projection Projection.
     * @return {string|undefined} Tile URL.
     */
    function(e, t, i) {
      if (!e)
        return;
      const n = gy(e), r = yi(n, s.length);
      return s[r](e, t, i);
    }
  );
}
function Oy(s) {
  const e = [];
  let t = /\{([a-z])-([a-z])\}/.exec(s);
  if (t) {
    const i = t[1].charCodeAt(0), n = t[2].charCodeAt(0);
    let r;
    for (r = i; r <= n; ++r)
      e.push(s.replace(t[0], String.fromCharCode(r)));
    return e;
  }
  if (t = /\{(\d+)-(\d+)\}/.exec(s), t) {
    const i = parseInt(t[2], 10);
    for (let n = parseInt(t[1], 10); n <= i; n++)
      e.push(s.replace(t[0], n.toString()));
    return e;
  }
  return e.push(s), e;
}
class sl extends Fy {
  /**
   * @param {Options} options Image tile options.
   */
  constructor(e) {
    super({
      attributions: e.attributions,
      cacheSize: e.cacheSize,
      opaque: e.opaque,
      projection: e.projection,
      state: e.state,
      tileGrid: e.tileGrid,
      tilePixelRatio: e.tilePixelRatio,
      wrapX: e.wrapX,
      transition: e.transition,
      interpolate: e.interpolate,
      key: e.key,
      attributionsCollapsible: e.attributionsCollapsible,
      zDirection: e.zDirection
    }), this.generateTileUrlFunction_ = this.tileUrlFunction === sl.prototype.tileUrlFunction, this.tileLoadFunction = e.tileLoadFunction, e.tileUrlFunction && (this.tileUrlFunction = e.tileUrlFunction), this.urls = null, e.urls ? this.setUrls(e.urls) : e.url && this.setUrl(e.url), this.tileLoadingKeys_ = {};
  }
  /**
   * Return the tile load function of the source.
   * @return {import("../Tile.js").LoadFunction} TileLoadFunction
   * @api
   */
  getTileLoadFunction() {
    return this.tileLoadFunction;
  }
  /**
   * Return the tile URL function of the source.
   * @return {import("../Tile.js").UrlFunction} TileUrlFunction
   * @api
   */
  getTileUrlFunction() {
    return Object.getPrototypeOf(this).tileUrlFunction === this.tileUrlFunction ? this.tileUrlFunction.bind(this) : this.tileUrlFunction;
  }
  /**
   * Return the URLs used for this source.
   * When a tileUrlFunction is used instead of url or urls,
   * null will be returned.
   * @return {!Array<string>|null} URLs.
   * @api
   */
  getUrls() {
    return this.urls;
  }
  /**
   * Handle tile change events.
   * @param {import("../events/Event.js").default} event Event.
   * @protected
   */
  handleTileChange(e) {
    const t = (
      /** @type {import("../Tile.js").default} */
      e.target
    ), i = B(t), n = t.getState();
    let r;
    n == G.LOADING ? (this.tileLoadingKeys_[i] = !0, r = uo.TILELOADSTART) : i in this.tileLoadingKeys_ && (delete this.tileLoadingKeys_[i], r = n == G.ERROR ? uo.TILELOADERROR : n == G.LOADED ? uo.TILELOADEND : void 0), r != null && this.dispatchEvent(new Ay(r, t));
  }
  /**
   * Set the tile load function of the source.
   * @param {import("../Tile.js").LoadFunction} tileLoadFunction Tile load function.
   * @api
   */
  setTileLoadFunction(e) {
    this.tileCache.clear(), this.tileLoadFunction = e, this.changed();
  }
  /**
   * Set the tile URL function of the source.
   * @param {import("../Tile.js").UrlFunction} tileUrlFunction Tile URL function.
   * @param {string} [key] Optional new tile key for the source.
   * @api
   */
  setTileUrlFunction(e, t) {
    this.tileUrlFunction = e, this.tileCache.pruneExceptNewestZ(), typeof t < "u" ? this.setKey(t) : this.changed();
  }
  /**
   * Set the URL to use for requests.
   * @param {string} url URL.
   * @api
   */
  setUrl(e) {
    const t = Oy(e);
    this.urls = t, this.setUrls(t);
  }
  /**
   * Set the URLs to use for requests.
   * @param {Array<string>} urls URLs.
   * @api
   */
  setUrls(e) {
    this.urls = e;
    const t = e.join(`
`);
    this.generateTileUrlFunction_ ? this.setTileUrlFunction(Py(e, this.tileGrid), t) : this.setKey(t);
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {string|undefined} Tile URL.
   */
  tileUrlFunction(e, t, i) {
  }
  /**
   * Marks a tile coord as being used, without triggering a load.
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   */
  useTile(e, t, i) {
    const n = Gr(e, t, i);
    this.tileCache.containsKey(n) && this.tileCache.get(n);
  }
}
const Dy = sl;
class ky extends Dy {
  /**
   * @param {!Options} options Image tile options.
   */
  constructor(e) {
    super({
      attributions: e.attributions,
      cacheSize: e.cacheSize,
      opaque: e.opaque,
      projection: e.projection,
      state: e.state,
      tileGrid: e.tileGrid,
      tileLoadFunction: e.tileLoadFunction ? e.tileLoadFunction : Ny,
      tilePixelRatio: e.tilePixelRatio,
      tileUrlFunction: e.tileUrlFunction,
      url: e.url,
      urls: e.urls,
      wrapX: e.wrapX,
      transition: e.transition,
      interpolate: e.interpolate !== void 0 ? e.interpolate : !0,
      key: e.key,
      attributionsCollapsible: e.attributionsCollapsible,
      zDirection: e.zDirection
    }), this.crossOrigin = e.crossOrigin !== void 0 ? e.crossOrigin : null, this.tileClass = e.tileClass !== void 0 ? e.tileClass : uu, this.tileCacheForProjection = {}, this.tileGridForProjection = {}, this.reprojectionErrorThreshold_ = e.reprojectionErrorThreshold, this.renderReprojectionEdges_ = !1;
  }
  /**
   * @return {boolean} Can expire cache.
   */
  canExpireCache() {
    if (this.tileCache.canExpireCache())
      return !0;
    for (const e in this.tileCacheForProjection)
      if (this.tileCacheForProjection[e].canExpireCache())
        return !0;
    return !1;
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {!Object<string, boolean>} usedTiles Used tiles.
   */
  expireCache(e, t) {
    const i = this.getTileCacheForProjection(e);
    this.tileCache.expireCache(
      this.tileCache == i ? t : {}
    );
    for (const n in this.tileCacheForProjection) {
      const r = this.tileCacheForProjection[n];
      r.expireCache(r == i ? t : {});
    }
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {number} Gutter.
   */
  getGutterForProjection(e) {
    return this.getProjection() && e && !At(this.getProjection(), e) ? 0 : this.getGutter();
  }
  /**
   * @return {number} Gutter.
   */
  getGutter() {
    return 0;
  }
  /**
   * Return the key to be used for all tiles in the source.
   * @return {string} The key for all tiles.
   */
  getKey() {
    let e = super.getKey();
    return this.getInterpolate() || (e += ":disable-interpolation"), e;
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {boolean} Opaque.
   */
  getOpaque(e) {
    return this.getProjection() && e && !At(this.getProjection(), e) ? !1 : super.getOpaque(e);
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
   */
  getTileGridForProjection(e) {
    const t = this.getProjection();
    if (this.tileGrid && (!t || At(t, e)))
      return this.tileGrid;
    const i = B(e);
    return i in this.tileGridForProjection || (this.tileGridForProjection[i] = fu(e)), this.tileGridForProjection[i];
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../TileCache.js").default} Tile cache.
   */
  getTileCacheForProjection(e) {
    const t = this.getProjection();
    if (!t || At(t, e))
      return this.tileCache;
    const i = B(e);
    return i in this.tileCacheForProjection || (this.tileCacheForProjection[i] = new du(
      this.tileCache.highWaterMark
    )), this.tileCacheForProjection[i];
  }
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {string} key The key set on the tile.
   * @return {!ImageTile} Tile.
   * @private
   */
  createTile_(e, t, i, n, r, o) {
    const a = [e, t, i], l = this.getTileCoordForTileUrlFunction(
      a,
      r
    ), h = l ? this.tileUrlFunction(l, n, r) : void 0, c = new this.tileClass(
      a,
      h !== void 0 ? G.IDLE : G.EMPTY,
      h !== void 0 ? h : "",
      this.crossOrigin,
      this.tileLoadFunction,
      this.tileOptions
    );
    return c.key = o, c.addEventListener(z.CHANGE, this.handleTileChange.bind(this)), c;
  }
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!(ImageTile|ReprojTile)} Tile.
   */
  getTile(e, t, i, n, r) {
    const o = this.getProjection();
    if (!o || !r || At(o, r))
      return this.getTileInternal(
        e,
        t,
        i,
        n,
        o || r
      );
    const a = this.getTileCacheForProjection(r), l = [e, t, i];
    let h;
    const c = lu(l);
    a.containsKey(c) && (h = a.get(c));
    const u = this.getKey();
    if (h && h.key == u)
      return h;
    const d = this.getTileGridForProjection(o), f = this.getTileGridForProjection(r), g = this.getTileCoordForTileUrlFunction(
      l,
      r
    ), _ = new ea(
      o,
      d,
      r,
      f,
      l,
      g,
      this.getTilePixelRatio(n),
      this.getGutter(),
      (m, p, x, y) => this.getTileInternal(m, p, x, y, o),
      this.reprojectionErrorThreshold_,
      this.renderReprojectionEdges_,
      this.getInterpolate()
    );
    return _.key = u, h ? (_.interimTile = h, _.refreshInterimChain(), a.replace(c, _)) : a.set(c, _), _;
  }
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {!import("../proj/Projection.js").default} projection Projection.
   * @return {!ImageTile} Tile.
   * @protected
   */
  getTileInternal(e, t, i, n, r) {
    let o = null;
    const a = Gr(e, t, i), l = this.getKey();
    if (!this.tileCache.containsKey(a))
      o = this.createTile_(e, t, i, n, r, l), this.tileCache.set(a, o);
    else if (o = this.tileCache.get(a), o.key != l) {
      const h = o;
      o = this.createTile_(e, t, i, n, r, l), h.getState() == G.IDLE ? o.interimTile = h.interimTile : o.interimTile = h, o.refreshInterimChain(), this.tileCache.replace(a, o);
    }
    return o;
  }
  /**
   * Sets whether to render reprojection edges or not (usually for debugging).
   * @param {boolean} render Render the edges.
   * @api
   */
  setRenderReprojectionEdges(e) {
    if (this.renderReprojectionEdges_ != e) {
      this.renderReprojectionEdges_ = e;
      for (const t in this.tileCacheForProjection)
        this.tileCacheForProjection[t].clear();
      this.changed();
    }
  }
  /**
   * Sets the tile grid to use when reprojecting the tiles to the given
   * projection instead of the default tile grid for the projection.
   *
   * This can be useful when the default tile grid cannot be created
   * (e.g. projection has no extent defined) or
   * for optimization reasons (custom tile size, resolutions, ...).
   *
   * @param {import("../proj.js").ProjectionLike} projection Projection.
   * @param {import("../tilegrid/TileGrid.js").default} tilegrid Tile grid to use for the projection.
   * @api
   */
  setTileGridForProjection(e, t) {
    const i = ye(e);
    if (i) {
      const n = B(i);
      n in this.tileGridForProjection || (this.tileGridForProjection[n] = t);
    }
  }
  clear() {
    super.clear();
    for (const e in this.tileCacheForProjection)
      this.tileCacheForProjection[e].clear();
  }
}
function Ny(s, e) {
  s.getImage().src = e;
}
const Gy = ky, Gs = {
  PRELOAD: "preload",
  USE_INTERIM_TILES_ON_ERROR: "useInterimTilesOnError"
};
class Uy extends hs {
  /**
   * @param {Options<TileSourceType>} [options] Tile layer options.
   */
  constructor(e) {
    e = e || {};
    const t = Object.assign({}, e);
    delete t.preload, delete t.useInterimTilesOnError, super(t), this.on, this.once, this.un, this.setPreload(e.preload !== void 0 ? e.preload : 0), this.setUseInterimTilesOnError(
      e.useInterimTilesOnError !== void 0 ? e.useInterimTilesOnError : !0
    );
  }
  /**
   * Return the level as number to which we will preload tiles up to.
   * @return {number} The level to preload tiles up to.
   * @observable
   * @api
   */
  getPreload() {
    return (
      /** @type {number} */
      this.get(Gs.PRELOAD)
    );
  }
  /**
   * Set the level as number to which we will preload tiles up to.
   * @param {number} preload The level to preload tiles up to.
   * @observable
   * @api
   */
  setPreload(e) {
    this.set(Gs.PRELOAD, e);
  }
  /**
   * Whether we use interim tiles on error.
   * @return {boolean} Use interim tiles on error.
   * @observable
   * @api
   */
  getUseInterimTilesOnError() {
    return (
      /** @type {boolean} */
      this.get(Gs.USE_INTERIM_TILES_ON_ERROR)
    );
  }
  /**
   * Set whether we use interim tiles on error.
   * @param {boolean} useInterimTilesOnError Use interim tiles on error.
   * @observable
   * @api
   */
  setUseInterimTilesOnError(e) {
    this.set(Gs.USE_INTERIM_TILES_ON_ERROR, e);
  }
  /**
   * Get data for a pixel location.  The return type depends on the source data.  For image tiles,
   * a four element RGBA array will be returned.  For data tiles, the array length will match the
   * number of bands in the dataset.  For requests outside the layer extent, `null` will be returned.
   * Data for a image tiles can only be retrieved if the source's `crossOrigin` property is set.
   *
   * ```js
   * // display layer data on every pointer move
   * map.on('pointermove', (event) => {
   *   console.log(layer.getData(event.pixel));
   * });
   * ```
   * @param {import("../pixel").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
   * @api
   */
  getData(e) {
    return super.getData(e);
  }
}
const zy = Uy;
class By extends qa {
  /**
   * @param {LayerType} tileLayer Tile layer.
   */
  constructor(e) {
    super(e), this.extentChanged = !0, this.renderedExtent_ = null, this.renderedPixelRatio, this.renderedProjection = null, this.renderedRevision, this.renderedTiles = [], this.newTiles_ = !1, this.tmpExtent = Me(), this.tmpTileRange_ = new au(0, 0, 0, 0);
  }
  /**
   * @protected
   * @param {import("../../Tile.js").default} tile Tile.
   * @return {boolean} Tile is drawable.
   */
  isDrawableTile(e) {
    const t = this.getLayer(), i = e.getState(), n = t.getUseInterimTilesOnError();
    return i == G.LOADED || i == G.EMPTY || i == G.ERROR && !n;
  }
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {!import("../../Tile.js").default} Tile.
   */
  getTile(e, t, i, n) {
    const r = n.pixelRatio, o = n.viewState.projection, a = this.getLayer();
    let h = a.getSource().getTile(e, t, i, r, o);
    return h.getState() == G.ERROR && a.getUseInterimTilesOnError() && a.getPreload() > 0 && (this.newTiles_ = !0), this.isDrawableTile(h) || (h = h.getInterimTile()), h;
  }
  /**
   * @param {import("../../pixel.js").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray} Data at the pixel location.
   */
  getData(e) {
    const t = this.frameState;
    if (!t)
      return null;
    const i = this.getLayer(), n = de(
      t.pixelToCoordinateTransform,
      e.slice()
    ), r = i.getExtent();
    if (r && !ss(r, n))
      return null;
    const o = t.pixelRatio, a = t.viewState.projection, l = t.viewState, h = i.getRenderSource(), c = h.getTileGridForProjection(l.projection), u = h.getTilePixelRatio(t.pixelRatio);
    for (let d = c.getZForResolution(l.resolution); d >= c.getMinZoom(); --d) {
      const f = c.getTileCoordForCoordAndZ(n, d), g = h.getTile(
        d,
        f[1],
        f[2],
        o,
        a
      );
      if (!(g instanceof uu || g instanceof ea) || g instanceof ea && g.getState() === G.EMPTY)
        return null;
      if (g.getState() !== G.LOADED)
        continue;
      const _ = c.getOrigin(d), m = Ke(c.getTileSize(d)), p = c.getResolution(d), x = Math.floor(
        u * ((n[0] - _[0]) / p - f[1] * m[0])
      ), y = Math.floor(
        u * ((_[1] - n[1]) / p - f[2] * m[1])
      ), E = Math.round(
        u * h.getGutterForProjection(l.projection)
      );
      return this.getImageData(g.getImage(), x + E, y + E);
    }
    return null;
  }
  /**
   * @param {Object<number, Object<string, import("../../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.
   * @param {number} zoom Zoom level.
   * @param {import("../../Tile.js").default} tile Tile.
   * @return {boolean|void} If `false`, the tile will not be considered loaded.
   */
  loadedTileCallback(e, t, i) {
    return this.isDrawableTile(i) ? super.loadedTileCallback(e, t, i) : !1;
  }
  /**
   * Determine whether render should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */
  prepareFrame(e) {
    return !!this.getLayer().getSource();
  }
  /**
   * Render the layer.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target that may be used to render content to.
   * @return {HTMLElement} The rendered element.
   */
  renderFrame(e, t) {
    const i = e.layerStatesArray[e.layerIndex], n = e.viewState, r = n.projection, o = n.resolution, a = n.center, l = n.rotation, h = e.pixelRatio, c = this.getLayer(), u = c.getSource(), d = u.getRevision(), f = u.getTileGridForProjection(r), g = f.getZForResolution(o, u.zDirection), _ = f.getResolution(g);
    let m = e.extent;
    const p = e.viewState.resolution, x = u.getTilePixelRatio(h), y = Math.round(te(m) / p * h), E = Math.round(Fe(m) / p * h), C = i.extent && gt(i.extent);
    C && (m = pi(
      m,
      gt(i.extent)
    ));
    const T = _ * y / 2 / x, w = _ * E / 2 / x, L = [
      a[0] - T,
      a[1] - w,
      a[0] + T,
      a[1] + w
    ], I = f.getTileRangeForExtentAndZ(m, g), S = {};
    S[g] = {};
    const Y = this.createLoadedTileFinder(
      u,
      r,
      S
    ), V = this.tmpExtent, P = this.tmpTileRange_;
    this.newTiles_ = !1;
    const q = l ? Po(
      n.center,
      p,
      l,
      e.size
    ) : void 0;
    for (let ue = I.minX; ue <= I.maxX; ++ue)
      for (let ie = I.minY; ie <= I.maxY; ++ie) {
        if (l && !f.tileCoordIntersectsViewport([g, ue, ie], q))
          continue;
        const oe = this.getTile(g, ue, ie, e);
        if (this.isDrawableTile(oe)) {
          const Ie = B(this);
          if (oe.getState() == G.LOADED) {
            S[g][oe.tileCoord.toString()] = oe;
            let Et = oe.inTransition(Ie);
            Et && i.opacity !== 1 && (oe.endTransition(Ie), Et = !1), !this.newTiles_ && (Et || !this.renderedTiles.includes(oe)) && (this.newTiles_ = !0);
          }
          if (oe.getAlpha(Ie, e.time) === 1)
            continue;
        }
        const Ut = f.getTileCoordChildTileRange(
          oe.tileCoord,
          P,
          V
        );
        let ct = !1;
        Ut && (ct = Y(g + 1, Ut)), ct || f.forEachTileCoordParentTileRange(
          oe.tileCoord,
          Y,
          P,
          V
        );
      }
    const F = _ / o * h / x;
    Je(
      this.pixelTransform,
      e.size[0] / 2,
      e.size[1] / 2,
      1 / h,
      1 / h,
      l,
      -y / 2,
      -E / 2
    );
    const b = ca(this.pixelTransform);
    this.useContainer(t, b, this.getBackground(e));
    const A = this.context, j = A.canvas;
    ns(this.inversePixelTransform, this.pixelTransform), Je(
      this.tempTransform,
      y / 2,
      E / 2,
      F,
      F,
      0,
      -y / 2,
      -E / 2
    ), j.width != y || j.height != E ? (j.width = y, j.height = E) : this.containerReused || A.clearRect(0, 0, y, E), C && this.clipUnrotated(A, e, C), u.getInterpolate() || (A.imageSmoothingEnabled = !1), this.preRender(A, e), this.renderedTiles.length = 0;
    let Q = Object.keys(S).map(Number);
    Q.sort(vi);
    let ee, me, R;
    i.opacity === 1 && (!this.containerReused || u.getOpaque(e.viewState.projection)) ? Q = Q.reverse() : (ee = [], me = []);
    for (let ue = Q.length - 1; ue >= 0; --ue) {
      const ie = Q[ue], oe = u.getTilePixelSize(
        ie,
        h,
        r
      ), ct = f.getResolution(ie) / _, Ie = oe[0] * ct * F, Et = oe[1] * ct * F, Ai = f.getTileCoordForCoordAndZ(
        Ot(L),
        ie
      ), ms = f.getTileCoordExtent(Ai), Fi = de(this.tempTransform, [
        x * (ms[0] - L[0]) / _,
        x * (L[3] - ms[3]) / _
      ]), ps = x * u.getGutterForProjection(r), zt = S[ie];
      for (const mn in zt) {
        const Bt = (
          /** @type {import("../../ImageTile.js").default} */
          zt[mn]
        ), ys = Bt.tileCoord, xs = Ai[1] - ys[1], Es = Math.round(Fi[0] - (xs - 1) * Ie), bi = Ai[2] - ys[2], Xr = Math.round(Fi[1] - (bi - 1) * Et), Ge = Math.round(Fi[0] - xs * Ie), $e = Math.round(Fi[1] - bi * Et), nt = Es - Ge, vt = Xr - $e, Pi = g === ie, si = Pi && Bt.getAlpha(B(this), e.time) !== 1;
        let Xt = !1;
        if (!si)
          if (ee) {
            R = [Ge, $e, Ge + nt, $e, Ge + nt, $e + vt, Ge, $e + vt];
            for (let Mi = 0, vs = ee.length; Mi < vs; ++Mi)
              if (g !== ie && ie < me[Mi]) {
                const Oe = ee[Mi];
                Ce(
                  [Ge, $e, Ge + nt, $e + vt],
                  [Oe[0], Oe[3], Oe[4], Oe[7]]
                ) && (Xt || (A.save(), Xt = !0), A.beginPath(), A.moveTo(R[0], R[1]), A.lineTo(R[2], R[3]), A.lineTo(R[4], R[5]), A.lineTo(R[6], R[7]), A.moveTo(Oe[6], Oe[7]), A.lineTo(Oe[4], Oe[5]), A.lineTo(Oe[2], Oe[3]), A.lineTo(Oe[0], Oe[1]), A.clip());
              }
            ee.push(R), me.push(ie);
          } else
            A.clearRect(Ge, $e, nt, vt);
        this.drawTileImage(
          Bt,
          e,
          Ge,
          $e,
          nt,
          vt,
          ps,
          Pi
        ), ee && !si ? (Xt && A.restore(), this.renderedTiles.unshift(Bt)) : this.renderedTiles.push(Bt), this.updateUsedTiles(e.usedTiles, u, Bt);
      }
    }
    return this.renderedRevision = d, this.renderedResolution = _, this.extentChanged = !this.renderedExtent_ || !ti(this.renderedExtent_, L), this.renderedExtent_ = L, this.renderedPixelRatio = h, this.renderedProjection = r, this.manageTilePyramid(
      e,
      u,
      f,
      h,
      r,
      m,
      g,
      c.getPreload()
    ), this.scheduleExpireCache(e, u), this.postRender(A, e), i.extent && A.restore(), A.imageSmoothingEnabled = !0, b !== j.style.transform && (j.style.transform = b), this.container;
  }
  /**
   * @param {import("../../ImageTile.js").default} tile Tile.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {number} x Left of the tile.
   * @param {number} y Top of the tile.
   * @param {number} w Width of the tile.
   * @param {number} h Height of the tile.
   * @param {number} gutter Tile gutter.
   * @param {boolean} transition Apply an alpha transition.
   */
  drawTileImage(e, t, i, n, r, o, a, l) {
    const h = this.getTileImage(e);
    if (!h)
      return;
    const c = B(this), u = t.layerStatesArray[t.layerIndex], d = u.opacity * (l ? e.getAlpha(c, t.time) : 1), f = d !== this.context.globalAlpha;
    f && (this.context.save(), this.context.globalAlpha = d), this.context.drawImage(
      h,
      a,
      a,
      h.width - 2 * a,
      h.height - 2 * a,
      i,
      n,
      r,
      o
    ), f && this.context.restore(), d !== u.opacity ? t.animate = !0 : l && e.endTransition(c);
  }
  /**
   * @return {HTMLCanvasElement} Image
   */
  getImage() {
    const e = this.context;
    return e ? e.canvas : null;
  }
  /**
   * Get the image from a tile.
   * @param {import("../../ImageTile.js").default} tile Tile.
   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
   * @protected
   */
  getTileImage(e) {
    return e.getImage();
  }
  /**
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {import("../../source/Tile.js").default} tileSource Tile source.
   * @protected
   */
  scheduleExpireCache(e, t) {
    if (t.canExpireCache()) {
      const i = function(n, r, o) {
        const a = B(n);
        a in o.usedTiles && n.expireCache(
          o.viewState.projection,
          o.usedTiles[a]
        );
      }.bind(null, t);
      e.postRenderFunctions.push(
        /** @type {import("../../Map.js").PostRenderFunction} */
        i
      );
    }
  }
  /**
   * @param {!Object<string, !Object<string, boolean>>} usedTiles Used tiles.
   * @param {import("../../source/Tile.js").default} tileSource Tile source.
   * @param {import('../../Tile.js').default} tile Tile.
   * @protected
   */
  updateUsedTiles(e, t, i) {
    const n = B(t);
    n in e || (e[n] = {}), e[n][i.getKey()] = !0;
  }
  /**
   * Manage tile pyramid.
   * This function performs a number of functions related to the tiles at the
   * current zoom and lower zoom levels:
   * - registers idle tiles in frameState.wantedTiles so that they are not
   *   discarded by the tile queue
   * - enqueues missing tiles
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {import("../../source/Tile.js").default} tileSource Tile source.
   * @param {import("../../tilegrid/TileGrid.js").default} tileGrid Tile grid.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../../proj/Projection.js").default} projection Projection.
   * @param {import("../../extent.js").Extent} extent Extent.
   * @param {number} currentZ Current Z.
   * @param {number} preload Load low resolution tiles up to `preload` levels.
   * @param {function(import("../../Tile.js").default):void} [tileCallback] Tile callback.
   * @protected
   */
  manageTilePyramid(e, t, i, n, r, o, a, l, h) {
    const c = B(t);
    c in e.wantedTiles || (e.wantedTiles[c] = {});
    const u = e.wantedTiles[c], d = e.tileQueue, f = i.getMinZoom(), g = e.viewState.rotation, _ = g ? Po(
      e.viewState.center,
      e.viewState.resolution,
      g,
      e.size
    ) : void 0;
    let m = 0, p, x, y, E, C, T;
    for (T = f; T <= a; ++T)
      for (x = i.getTileRangeForExtentAndZ(o, T, x), y = i.getResolution(T), E = x.minX; E <= x.maxX; ++E)
        for (C = x.minY; C <= x.maxY; ++C)
          g && !i.tileCoordIntersectsViewport([T, E, C], _) || (a - T <= l ? (++m, p = t.getTile(T, E, C, n, r), p.getState() == G.IDLE && (u[p.getKey()] = !0, d.isKeyQueued(p.getKey()) || d.enqueue([
            p,
            c,
            i.getTileCoordCenter(p.tileCoord),
            y
          ])), h !== void 0 && h(p)) : t.useTile(T, E, C, r));
    t.updateCacheSize(m, r);
  }
}
const Xy = By;
class Wy extends zy {
  /**
   * @param {import("./BaseTile.js").Options<TileSourceType>} [options] Tile layer options.
   */
  constructor(e) {
    super(e);
  }
  createRenderer() {
    return new Xy(this);
  }
}
const fo = Wy;
class Yy extends br {
  /**
   * @param {import("./BaseVector.js").Options<VectorSourceType>} [options] Options.
   */
  constructor(e) {
    super(e);
  }
  createRenderer() {
    return new Pc(this);
  }
}
const Be = Yy;
class Vy extends we {
  /**
   * @param {Options} options Cluster options.
   */
  constructor(e) {
    super({
      attributions: e.attributions,
      wrapX: e.wrapX
    }), this.resolution = void 0, this.distance = e.distance !== void 0 ? e.distance : 20, this.minDistance = e.minDistance || 0, this.interpolationRatio = 0, this.features = [], this.geometryFunction = e.geometryFunction || function(t) {
      const i = (
        /** @type {Point} */
        t.getGeometry()
      );
      return Z(i.getType() == "Point", 10), i;
    }, this.createCustomCluster_ = e.createCluster, this.source = null, this.boundRefresh_ = this.refresh.bind(this), this.updateDistance(this.distance, this.minDistance), this.setSource(e.source || null);
  }
  /**
   * Remove all features from the source.
   * @param {boolean} [fast] Skip dispatching of {@link module:ol/source/VectorEventType~VectorEventType#removefeature} events.
   * @api
   */
  clear(e) {
    this.features.length = 0, super.clear(e);
  }
  /**
   * Get the distance in pixels between clusters.
   * @return {number} Distance.
   * @api
   */
  getDistance() {
    return this.distance;
  }
  /**
   * Get a reference to the wrapped source.
   * @return {VectorSource|null} Source.
   * @api
   */
  getSource() {
    return this.source;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {import("../proj/Projection.js").default} projection Projection.
   */
  loadFeatures(e, t, i) {
    this.source.loadFeatures(e, t, i), t !== this.resolution && (this.resolution = t, this.refresh());
  }
  /**
   * Set the distance within which features will be clusterd together.
   * @param {number} distance The distance in pixels.
   * @api
   */
  setDistance(e) {
    this.updateDistance(e, this.minDistance);
  }
  /**
   * Set the minimum distance between clusters. Will be capped at the
   * configured distance.
   * @param {number} minDistance The minimum distance in pixels.
   * @api
   */
  setMinDistance(e) {
    this.updateDistance(this.distance, e);
  }
  /**
   * The configured minimum distance between clusters.
   * @return {number} The minimum distance in pixels.
   * @api
   */
  getMinDistance() {
    return this.minDistance;
  }
  /**
   * Replace the wrapped source.
   * @param {VectorSource|null} source The new source for this instance.
   * @api
   */
  setSource(e) {
    this.source && this.source.removeEventListener(z.CHANGE, this.boundRefresh_), this.source = e, e && e.addEventListener(z.CHANGE, this.boundRefresh_), this.refresh();
  }
  /**
   * Handle the source changing.
   */
  refresh() {
    this.clear(), this.cluster(), this.addFeatures(this.features);
  }
  /**
   * Update the distances and refresh the source if necessary.
   * @param {number} distance The new distance.
   * @param {number} minDistance The new minimum distance.
   */
  updateDistance(e, t) {
    const i = e === 0 ? 0 : Math.min(t, e) / e, n = e !== this.distance || this.interpolationRatio !== i;
    this.distance = e, this.minDistance = t, this.interpolationRatio = i, n && this.refresh();
  }
  /**
   * @protected
   */
  cluster() {
    if (this.resolution === void 0 || !this.source)
      return;
    const e = Me(), t = this.distance * this.resolution, i = this.source.getFeatures(), n = {};
    for (let r = 0, o = i.length; r < o; r++) {
      const a = i[r];
      if (!(B(a) in n)) {
        const l = this.geometryFunction(a);
        if (l) {
          const h = l.getCoordinates();
          Rn(h, e), Si(e, t, e);
          const c = this.source.getFeaturesInExtent(e).filter(function(u) {
            const d = B(u);
            return d in n ? !1 : (n[d] = !0, !0);
          });
          this.features.push(this.createCluster(c, e));
        }
      }
    }
  }
  /**
   * @param {Array<Feature>} features Features
   * @param {import("../extent.js").Extent} extent The searched extent for these features.
   * @return {Feature} The cluster feature.
   * @protected
   */
  createCluster(e, t) {
    const i = [0, 0];
    for (let a = e.length - 1; a >= 0; --a) {
      const l = this.geometryFunction(e[a]);
      l ? Uh(i, l.getCoordinates()) : e.splice(a, 1);
    }
    Bh(i, 1 / e.length);
    const n = Ne(t), r = this.interpolationRatio, o = new Ee([
      i[0] * (1 - r) + n[0] * r,
      i[1] * (1 - r) + n[1] * r
    ]);
    return this.createCustomCluster_ ? this.createCustomCluster_(o, e) : new $({
      geometry: o,
      features: e
    });
  }
}
const Zy = Vy;
let _u = class mu extends ni {
  /**
   * @param {!import("../coordinate.js").Coordinate} center Center.
   *     For internal use, flat coordinates in combination with `layout` and no
   *     `radius` are also accepted.
   * @param {number} [radius] Radius.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  constructor(e, t, i) {
    super(), i !== void 0 && t === void 0 ? this.setFlatCoordinates(i, e) : (t = t || 0, this.setCenterAndRadius(e, t, i));
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!Circle} Clone.
   * @api
   */
  clone() {
    const e = new mu(
      this.flatCoordinates.slice(),
      void 0,
      this.layout
    );
    return e.applyProperties(this), e;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(e, t, i, n) {
    const r = this.flatCoordinates, o = e - r[0], a = t - r[1], l = o * o + a * a;
    if (l < n) {
      if (l === 0)
        for (let h = 0; h < this.stride; ++h)
          i[h] = r[h];
      else {
        const h = this.getRadius() / Math.sqrt(l);
        i[0] = r[0] + h * o, i[1] = r[1] + h * a;
        for (let c = 2; c < this.stride; ++c)
          i[c] = r[c];
      }
      return i.length = this.stride, l;
    }
    return n;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */
  containsXY(e, t) {
    const i = this.flatCoordinates, n = e - i[0], r = t - i[1];
    return n * n + r * r <= this.getRadiusSquared_();
  }
  /**
   * Return the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.
   * @return {import("../coordinate.js").Coordinate} Center.
   * @api
   */
  getCenter() {
    return this.flatCoordinates.slice(0, this.stride);
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */
  computeExtent(e) {
    const t = this.flatCoordinates, i = t[this.stride] - t[0];
    return pt(
      t[0] - i,
      t[1] - i,
      t[0] + i,
      t[1] + i,
      e
    );
  }
  /**
   * Return the radius of the circle.
   * @return {number} Radius.
   * @api
   */
  getRadius() {
    return Math.sqrt(this.getRadiusSquared_());
  }
  /**
   * @private
   * @return {number} Radius squared.
   */
  getRadiusSquared_() {
    const e = this.flatCoordinates[this.stride] - this.flatCoordinates[0], t = this.flatCoordinates[this.stride + 1] - this.flatCoordinates[1];
    return e * e + t * t;
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return "Circle";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(e) {
    const t = this.getExtent();
    if (Ce(e, t)) {
      const i = this.getCenter();
      return e[0] <= i[0] && e[2] >= i[0] || e[1] <= i[1] && e[3] >= i[1] ? !0 : da(e, this.intersectsCoordinate.bind(this));
    }
    return !1;
  }
  /**
   * Set the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.
   * @param {import("../coordinate.js").Coordinate} center Center.
   * @api
   */
  setCenter(e) {
    const t = this.stride, i = this.flatCoordinates[t] - this.flatCoordinates[0], n = e.slice();
    n[t] = n[0] + i;
    for (let r = 1; r < t; ++r)
      n[t + r] = e[r];
    this.setFlatCoordinates(this.layout, n), this.changed();
  }
  /**
   * Set the center (as {@link module:ol/coordinate~Coordinate coordinate}) and the radius (as
   * number) of the circle.
   * @param {!import("../coordinate.js").Coordinate} center Center.
   * @param {number} radius Radius.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCenterAndRadius(e, t, i) {
    this.setLayout(i, e, 0), this.flatCoordinates || (this.flatCoordinates = []);
    const n = this.flatCoordinates;
    let r = Kh(n, 0, e, this.stride);
    n[r++] = n[0] + t;
    for (let o = 1, a = this.stride; o < a; ++o)
      n[r++] = n[o];
    n.length = r, this.changed();
  }
  getCoordinates() {
    return null;
  }
  setCoordinates(e, t) {
  }
  /**
   * Set the radius of the circle. The radius is in the units of the projection.
   * @param {number} radius Radius.
   * @api
   */
  setRadius(e) {
    this.flatCoordinates[this.stride] = this.flatCoordinates[0] + e, this.changed();
  }
  /**
   * Rotate the geometry around a given coordinate. This modifies the geometry
   * coordinates in place.
   * @param {number} angle Rotation angle in counter-clockwise radians.
   * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
   * @api
   */
  rotate(e, t) {
    const i = this.getCenter(), n = this.getStride();
    this.setCenter(
      Ta(i, 0, i.length, n, e, t, i)
    ), this.changed();
  }
  /**
   * Translate the geometry.  This modifies the geometry coordinates in place.  If
   * instead you want a new geometry, first `clone()` this geometry.
   * @param {number} deltaX Delta X.
   * @param {number} deltaY Delta Y.
   * @api
   */
  translate(e, t) {
    const i = this.getCenter(), n = this.getStride();
    this.setCenter(
      jh(i, 0, i.length, n, e, t, i)
    ), this.changed();
  }
};
_u.prototype.transform;
const rl = _u;
class Js extends $ {
  constructor(t, i) {
    super({ geometry: new Ee(t) });
    /**
     *
     *
     * @param {number[]} point
     * @memberof Point
     */
    v(this, "setCoordinates", (t) => {
      var i;
      return (i = this.getGeometry()) == null || i.setCoordinates(t), !0;
    });
    /**
     *
     *
     * @param {string} icon
     * @param {feature_style} options
     * @memberof Point
     */
    v(this, "setIcon", (t, i) => {
      let n = this.getStyle();
      const r = i || {};
      let o = n == null ? void 0 : n.getImage(), a = n == null ? void 0 : n.getText();
      return t && (o = new tt({
        anchor: r.anchor ? r.anchor : [0.5, 0.92],
        src: t,
        rotation: r.rotation ? r.rotation : o.getRotation(),
        rotateWithView: r.rotate_with_view
      })), r.icon_scale && o.setScale(r.icon_scale), r.offset_y && (a == null || a.setOffsetY(r.offset_y)), n == null || n.setImage(o), this.changed(), !0;
    });
    /**
        *
        *
        * @param {string} text
        * @param {feature_style} options
        * @memberof Point
        */
    v(this, "setText", (t, i) => {
      let n = this.getStyle(), r = (n == null ? void 0 : n.getText()) || new De({
        textAlign: "center",
        textBaseline: "top",
        font: "14px Source Han Sans CN",
        scale: i == null ? void 0 : i.text_scale,
        offsetY: i == null ? void 0 : i.offset_y,
        text: t,
        fill: new N({ color: "#15F9F8" }),
        backgroundFill: new N({ color: "rgba(15, 33, 51, 0.85)" }),
        padding: [4, 5, 2, 6],
        rotateWithView: i == null ? void 0 : i.text_rotate_with_view
      });
      return t !== void 0 && (r == null || r.setText(t)), i && i.text_scale && (r == null || r.setScale(i.text_scale)), n.setText(r), this.changed(), !0;
    });
    if (i !== void 0) {
      let n, r;
      i.icon && (n = new tt({
        anchor: i.anchor ? i.anchor : [0.5, 0.92],
        src: i.icon,
        scale: i.icon_scale,
        rotateWithView: i.rotate_with_view,
        rotation: i.rotation
      })), i.text && (r = new De({
        textAlign: "center",
        textBaseline: "top",
        font: "14px Source Han Sans CN",
        scale: i.text_scale,
        offsetY: i.offset_y,
        text: i.text,
        fill: new N({ color: "#15F9F8" }),
        backgroundFill: new N({ color: "rgba(15, 33, 51, 0.85)" }),
        padding: [4, 5, 2, 6],
        rotateWithView: i.text_rotate_with_view
      }), i.text_color && r.setFill(new N({ color: i.text_color })), i.text_background_color && r.setBackgroundFill(new N({ color: i.text_background_color })), i.text_background_border_color && r.setBackgroundStroke(new K({ color: i.text_background_border_color })), i.text_stroke_color && r.setStroke(new K({ color: i.text_stroke_color, width: i.text_stroke_width })));
      let o = new se({
        image: n,
        text: r
      });
      this.setStyle(o);
    }
  }
}
let jy = class extends $ {
  constructor(t) {
    super({ geometry: new qe(t) });
    /**
     *
     *
     * @param {number[][]} points
     * @memberof Line
     */
    v(this, "setCoordinates", (t) => {
      var i;
      return (i = this.getGeometry()) == null || i.setCoordinates(t), !0;
    });
    /**
     *
     *
     * 
     * @param {string} stroke_color
     * @param {number} width
     * @param {string} text
     * @memberof Polygon
     */
    v(this, "updateStyle", (t, i, n, r) => {
      let o = new se({
        stroke: new K({
          color: t,
          width: i,
          lineDash: r
        }),
        text: new De({
          textAlign: "center",
          font: "14px serif",
          text: n
        })
      });
      return this.setStyle(o), !0;
    });
  }
}, pu = class extends $ {
  constructor(t) {
    super({ geometry: new We([t]) });
    /**
     *
     *
     * @param {number[][]} points
     * @memberof Polygon
     */
    v(this, "setCoordinates", (t) => {
      var i;
      return (i = this.getGeometry()) == null || i.setCoordinates([t]), !0;
    });
    /**
     *
     *
     * @param {string} fill_color
     * @param {string} stroke_color
     * @param {number} width
     * @param {string} text
     * @memberof Polygon
     */
    v(this, "updateStyle", (t, i, n, r, o) => {
      let a = new se({
        fill: new N({
          color: t
        }),
        stroke: new K({
          color: i,
          width: n,
          lineDash: o
        }),
        text: new De({
          textAlign: "center",
          font: "500 16px Noto Sans CJK SC Regular",
          text: r
        })
      });
      return this.setStyle(a), !0;
    });
  }
}, Hy = class extends $ {
  constructor(t, i, n) {
    super({ geometry: new rl(t, i) });
    v(this, "z_index", 20);
    /**
     *
     *
     * @param {string} fill_color
     * @param {string} stroke_color
     * @param {number} width
     * @param {string} text
     * @memberof Circle
     */
    v(this, "updateStyle", (t, i, n, r, o, a) => {
      let l = new se({
        fill: new N({
          color: t
        }),
        stroke: new K({
          color: i,
          width: n,
          lineDash: o
        }),
        text: new De({
          textAlign: "center",
          font: "500 16px Noto Sans CJK SC Regular",
          offsetY: a == null ? void 0 : a.offset_y,
          text: r
        })
      });
      const h = l.getText();
      return a != null && a.text_color && h.setFill(new N({ color: a.text_color })), a != null && a.text_background_color && (h.setBackgroundFill(new N({ color: a.text_background_color })), h.setPadding([3, 6, 1, 6])), a != null && a.text_background_border_color && h.setBackgroundStroke(new K({ color: a.text_background_border_color })), l.setZIndex(a == null ? void 0 : a.z_index), this.setStyle(l), !0;
    });
    v(this, "_transformGatherColor", (t) => {
      const n = (t.match(/rgba\((.+)\)/) || ["rgba(255,0,0,1)", "255,0,0,1"])[1].split(","), r = parseFloat(n[3]) * 0.9, o = parseFloat(n[3]) * 0.3, a = parseFloat(n[3]) * 0.4, l = n.slice(0, 3).join();
      return {
        inner_color: `rgba(${l},${r})`,
        outer_color: `rgba(${l},${o})`,
        color: `rgba(${l},1)`,
        border_color: `rgba(${l},${a})`
      };
    });
    v(this, "updateGatherStyle", (t, i, n, r, o, a) => {
      const { inner_color: l, outer_color: h, color: c, border_color: u } = this._transformGatherColor(t), d = new se({
        renderer(E, C) {
          const [[T, w], [L, I]] = E, S = C.context, Y = L - T, V = I - w, P = Math.sqrt(Y * Y + V * V), q = 0, F = P * 1.1, b = S.createRadialGradient(
            T,
            w,
            q,
            T,
            w,
            F
          );
          b.addColorStop(0, l), b.addColorStop(1, h), S.beginPath(), S.arc(T, w, P, 0, 2 * Math.PI, !0), S.fillStyle = b, S.fill();
        },
        zIndex: this.z_index
      });
      console.log(this.z_index);
      const f = r || o ? "rgba(0, 255, 254, 1)" : u, g = r || o ? "rgba(255, 255, 255, 1)" : c, _ = r || o ? c : "#332E2C", m = o ? "rgba(0, 255, 254, 1)" : c, p = new se({
        text: new De({
          textAlign: "center",
          font: "500 16px Noto Sans CJK SC Regular",
          text: i,
          scale: n || 1,
          fill: new N({ color: g }),
          padding: [3, 6, 1, 6],
          offsetY: 15,
          backgroundFill: new N({ color: _ }),
          backgroundStroke: new K({ color: m, width: 2 })
        }),
        zIndex: this.z_index + 1
      }), x = new se({
        stroke: new K({ color: f, width: 2 }),
        zIndex: this.z_index + 1
      }), y = a ? p : [d, p, x];
      this.setStyle(y);
    });
    /**
     *
     *
     * @param {number[]} center
     * @memberof Circle
     */
    v(this, "setCenter", (t) => {
      var i;
      return (i = this.getGeometry()) == null || i.setCenter(t), !0;
    });
    /**
     *
     *
     * @param {number} radius
     */
    v(this, "setRadius", (t) => {
      var i;
      return (i = this.getGeometry()) == null || i.setRadius(t), !0;
    });
    this.z_index = n || 20;
  }
};
$.prototype.getCoordinates = function() {
  var s;
  return (s = this.getGeometry()) == null ? void 0 : s.getCoordinates();
};
$.prototype.startFlash = function(s, e) {
  return s = s || 300, this.getStyle() && this.getStyle().getImage() ? this.images_flash_timer ? (console.error("该元素已经在闪烁"), !1) : (this.images_flash_timer = setInterval(() => {
    this.getStyle().getImage().getOpacity() > 0 ? this.getStyle().getImage().setOpacity(0) : this.getStyle().getImage().setOpacity(1), this.changed();
  }, s), !0) : this.getStyle() && this.getStyle().getStroke() ? (this.old_stroke_color = this.getStyle().getStroke().getColor(), this.stroke_flash_timer ? (console.error("该元素已经在闪烁"), !1) : (this.stroke_flash_timer = setInterval(() => {
    this.getStyle().getStroke().getColor() == "rgba(255, 0, 0, 0.5)" ? (this.getStyle().getStroke().setColor(this.old_stroke_color), e || this.getStyle().getFill().setColor(this.old_stroke_color)) : (this.getStyle().getStroke().setColor("rgba(255, 0, 0, 0.5)"), e || this.getStyle().getFill().setColor("rgba(255, 0, 0, 0.5)")), this.changed();
  }, s), !0)) : (console.error("该元素不能闪烁"), !1);
};
$.prototype.stopFlash = function() {
  return this.images_flash_timer ? (clearInterval(this.images_flash_timer), this.getStyle().getImage().setOpacity(1), this.changed(), this.images_flash_timer = void 0, !0) : this.stroke_flash_timer ? (clearInterval(this.stroke_flash_timer), this.getStyle().getStroke().getColor() === "rgba(255, 0, 0, 0.5)" && (this.getStyle().getStroke().setColor(this.old_stroke_color), this.getStyle().getFill().setColor(this.old_stroke_color), this.changed()), this.stroke_flash_timer = void 0, !0) : (console.error("该元素并未处于闪烁状态"), !1);
};
const be = {
  ELEMENT: "element",
  MAP: "map",
  OFFSET: "offset",
  POSITION: "position",
  POSITIONING: "positioning"
};
class Ky extends ht {
  /**
   * @param {Options} options Overlay options.
   */
  constructor(e) {
    super(), this.on, this.once, this.un, this.options = e, this.id = e.id, this.insertFirst = e.insertFirst !== void 0 ? e.insertFirst : !0, this.stopEvent = e.stopEvent !== void 0 ? e.stopEvent : !0, this.element = document.createElement("div"), this.element.className = e.className !== void 0 ? e.className : "ol-overlay-container " + Tf, this.element.style.position = "absolute", this.element.style.pointerEvents = "auto", this.autoPan = e.autoPan === !0 ? {} : e.autoPan || void 0, this.rendered = {
      transform_: "",
      visible: !0
    }, this.mapPostrenderListenerKey = null, this.addChangeListener(be.ELEMENT, this.handleElementChanged), this.addChangeListener(be.MAP, this.handleMapChanged), this.addChangeListener(be.OFFSET, this.handleOffsetChanged), this.addChangeListener(be.POSITION, this.handlePositionChanged), this.addChangeListener(be.POSITIONING, this.handlePositioningChanged), e.element !== void 0 && this.setElement(e.element), this.setOffset(e.offset !== void 0 ? e.offset : [0, 0]), this.setPositioning(e.positioning || "top-left"), e.position !== void 0 && this.setPosition(e.position);
  }
  /**
   * Get the DOM element of this overlay.
   * @return {HTMLElement|undefined} The Element containing the overlay.
   * @observable
   * @api
   */
  getElement() {
    return (
      /** @type {HTMLElement|undefined} */
      this.get(be.ELEMENT)
    );
  }
  /**
   * Get the overlay identifier which is set on constructor.
   * @return {number|string|undefined} Id.
   * @api
   */
  getId() {
    return this.id;
  }
  /**
   * Get the map associated with this overlay.
   * @return {import("./Map.js").default|null} The map that the
   * overlay is part of.
   * @observable
   * @api
   */
  getMap() {
    return (
      /** @type {import("./Map.js").default|null} */
      this.get(be.MAP) || null
    );
  }
  /**
   * Get the offset of this overlay.
   * @return {Array<number>} The offset.
   * @observable
   * @api
   */
  getOffset() {
    return (
      /** @type {Array<number>} */
      this.get(be.OFFSET)
    );
  }
  /**
   * Get the current position of this overlay.
   * @return {import("./coordinate.js").Coordinate|undefined} The spatial point that the overlay is
   *     anchored at.
   * @observable
   * @api
   */
  getPosition() {
    return (
      /** @type {import("./coordinate.js").Coordinate|undefined} */
      this.get(be.POSITION)
    );
  }
  /**
   * Get the current positioning of this overlay.
   * @return {Positioning} How the overlay is positioned
   *     relative to its point on the map.
   * @observable
   * @api
   */
  getPositioning() {
    return (
      /** @type {Positioning} */
      this.get(be.POSITIONING)
    );
  }
  /**
   * @protected
   */
  handleElementChanged() {
    lc(this.element);
    const e = this.getElement();
    e && this.element.appendChild(e);
  }
  /**
   * @protected
   */
  handleMapChanged() {
    this.mapPostrenderListenerKey && (lr(this.element), re(this.mapPostrenderListenerKey), this.mapPostrenderListenerKey = null);
    const e = this.getMap();
    if (e) {
      this.mapPostrenderListenerKey = H(
        e,
        dt.POSTRENDER,
        this.render,
        this
      ), this.updatePixelPosition();
      const t = this.stopEvent ? e.getOverlayContainerStopEvent() : e.getOverlayContainer();
      this.insertFirst ? t.insertBefore(this.element, t.childNodes[0] || null) : t.appendChild(this.element), this.performAutoPan();
    }
  }
  /**
   * @protected
   */
  render() {
    this.updatePixelPosition();
  }
  /**
   * @protected
   */
  handleOffsetChanged() {
    this.updatePixelPosition();
  }
  /**
   * @protected
   */
  handlePositionChanged() {
    this.updatePixelPosition(), this.performAutoPan();
  }
  /**
   * @protected
   */
  handlePositioningChanged() {
    this.updatePixelPosition();
  }
  /**
   * Set the DOM element to be associated with this overlay.
   * @param {HTMLElement|undefined} element The Element containing the overlay.
   * @observable
   * @api
   */
  setElement(e) {
    this.set(be.ELEMENT, e);
  }
  /**
   * Set the map to be associated with this overlay.
   * @param {import("./Map.js").default|null} map The map that the
   * overlay is part of. Pass `null` to just remove the overlay from the current map.
   * @observable
   * @api
   */
  setMap(e) {
    this.set(be.MAP, e);
  }
  /**
   * Set the offset for this overlay.
   * @param {Array<number>} offset Offset.
   * @observable
   * @api
   */
  setOffset(e) {
    this.set(be.OFFSET, e);
  }
  /**
   * Set the position for this overlay. If the position is `undefined` the
   * overlay is hidden.
   * @param {import("./coordinate.js").Coordinate|undefined} position The spatial point that the overlay
   *     is anchored at.
   * @observable
   * @api
   */
  setPosition(e) {
    this.set(be.POSITION, e);
  }
  /**
   * Pan the map so that the overlay is entirely visible in the current viewport
   * (if necessary) using the configured autoPan parameters
   * @protected
   */
  performAutoPan() {
    this.autoPan && this.panIntoView(this.autoPan);
  }
  /**
   * Pan the map so that the overlay is entirely visible in the current viewport
   * (if necessary).
   * @param {PanIntoViewOptions} [panIntoViewOptions] Options for the pan action
   * @api
   */
  panIntoView(e) {
    const t = this.getMap();
    if (!t || !t.getTargetElement() || !this.get(be.POSITION))
      return;
    const i = this.getRect(t.getTargetElement(), t.getSize()), n = this.getElement(), r = this.getRect(n, [
      Rf(n),
      If(n)
    ]);
    e = e || {};
    const o = e.margin === void 0 ? 20 : e.margin;
    if (!Ft(i, r)) {
      const a = r[0] - i[0], l = i[2] - r[2], h = r[1] - i[1], c = i[3] - r[3], u = [0, 0];
      if (a < 0 ? u[0] = a - o : l < 0 && (u[0] = Math.abs(l) + o), h < 0 ? u[1] = h - o : c < 0 && (u[1] = Math.abs(c) + o), u[0] !== 0 || u[1] !== 0) {
        const d = (
          /** @type {import("./coordinate.js").Coordinate} */
          t.getView().getCenterInternal()
        ), f = t.getPixelFromCoordinateInternal(d);
        if (!f)
          return;
        const g = [f[0] + u[0], f[1] + u[1]], _ = e.animation || {};
        t.getView().animateInternal({
          center: t.getCoordinateFromPixelInternal(g),
          duration: _.duration,
          easing: _.easing
        });
      }
    }
  }
  /**
   * Get the extent of an element relative to the document
   * @param {HTMLElement} element The element.
   * @param {import("./size.js").Size} size The size of the element.
   * @return {import("./extent.js").Extent} The extent.
   * @protected
   */
  getRect(e, t) {
    const i = e.getBoundingClientRect(), n = i.left + window.pageXOffset, r = i.top + window.pageYOffset;
    return [n, r, n + t[0], r + t[1]];
  }
  /**
   * Set the positioning for this overlay.
   * @param {Positioning} positioning how the overlay is
   *     positioned relative to its point on the map.
   * @observable
   * @api
   */
  setPositioning(e) {
    this.set(be.POSITIONING, e);
  }
  /**
   * Modify the visibility of the element.
   * @param {boolean} visible Element visibility.
   * @protected
   */
  setVisible(e) {
    this.rendered.visible !== e && (this.element.style.display = e ? "" : "none", this.rendered.visible = e);
  }
  /**
   * Update pixel position.
   * @protected
   */
  updatePixelPosition() {
    const e = this.getMap(), t = this.getPosition();
    if (!e || !e.isRendered() || !t) {
      this.setVisible(!1);
      return;
    }
    const i = e.getPixelFromCoordinate(t), n = e.getSize();
    this.updateRenderedPosition(i, n);
  }
  /**
   * @param {import("./pixel.js").Pixel} pixel The pixel location.
   * @param {import("./size.js").Size|undefined} mapSize The map size.
   * @protected
   */
  updateRenderedPosition(e, t) {
    const i = this.element.style, n = this.getOffset(), r = this.getPositioning();
    this.setVisible(!0);
    const o = Math.round(e[0] + n[0]) + "px", a = Math.round(e[1] + n[1]) + "px";
    let l = "0%", h = "0%";
    r == "bottom-right" || r == "center-right" || r == "top-right" ? l = "-100%" : (r == "bottom-center" || r == "center-center" || r == "top-center") && (l = "-50%"), r == "bottom-left" || r == "bottom-center" || r == "bottom-right" ? h = "-100%" : (r == "center-left" || r == "center-center" || r == "center-right") && (h = "-50%");
    const c = `translate(${l}, ${h}) translate(${o}, ${a})`;
    this.rendered.transform_ != c && (this.rendered.transform_ = c, i.transform = c);
  }
  /**
   * returns the options this Overlay has been created with
   * @return {Options} overlay options
   */
  getOptions() {
    return this.options;
  }
}
const ta = Ky, Er = 34962, ol = 34963, qy = 35040, Jy = 35044, $s = 35048, $y = 5121, Qy = 5123, e0 = 5125, yu = 5126, ch = ["experimental-webgl", "webgl", "webkit-3d", "moz-webgl"];
function xu(s, e) {
  e = Object.assign(
    {
      preserveDrawingBuffer: !0,
      antialias: !qu
      // https://bugs.webkit.org/show_bug.cgi?id=237906
    },
    e
  );
  const t = ch.length;
  for (let i = 0; i < t; ++i)
    try {
      const n = s.getContext(ch[i], e);
      if (n)
        return (
          /** @type {!WebGLRenderingContext} */
          n
        );
    } catch {
    }
  return null;
}
const t0 = {
  STATIC_DRAW: Jy,
  STREAM_DRAW: qy,
  DYNAMIC_DRAW: $s
};
class i0 {
  /**
   * @param {number} type Buffer type, either ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER.
   * @param {number} [usage] Intended usage, either `STATIC_DRAW`, `STREAM_DRAW` or `DYNAMIC_DRAW`.
   * Default is `DYNAMIC_DRAW`.
   */
  constructor(e, t) {
    this.array = null, this.type = e, Z(e === Er || e === ol, 62), this.usage = t !== void 0 ? t : t0.STATIC_DRAW;
  }
  /**
   * Populates the buffer with an array of the given size (all values will be zeroes).
   * @param {number} size Array size
   */
  ofSize(e) {
    this.array = new (go(this.type))(e);
  }
  /**
   * Populates the buffer with an array of the given size.
   * @param {Array<number>} array Numerical array
   */
  fromArray(e) {
    this.array = go(this.type).from(e);
  }
  /**
   * Populates the buffer with a raw binary array buffer.
   * @param {ArrayBuffer} buffer Raw binary buffer to populate the array with. Note that this buffer must have been
   * initialized for the same typed array class.
   */
  fromArrayBuffer(e) {
    this.array = new (go(this.type))(e);
  }
  /**
   * @return {number} Buffer type.
   */
  getType() {
    return this.type;
  }
  /**
   * Will return null if the buffer was not initialized
   * @return {Float32Array|Uint32Array} Array.
   */
  getArray() {
    return this.array;
  }
  /**
   * @return {number} Usage.
   */
  getUsage() {
    return this.usage;
  }
  /**
   * Will return 0 if the buffer is not initialized
   * @return {number} Array size
   */
  getSize() {
    return this.array ? this.array.length : 0;
  }
}
function go(s) {
  switch (s) {
    case Er:
      return Float32Array;
    case ol:
      return Uint32Array;
    default:
      return Float32Array;
  }
}
const _o = i0, Us = {
  LOST: "webglcontextlost",
  RESTORED: "webglcontextrestored"
}, n0 = `
  precision mediump float;
  
  attribute vec2 a_position;
  varying vec2 v_texCoord;
  varying vec2 v_screenCoord;
  
  uniform vec2 u_screenSize;
   
  void main() {
    v_texCoord = a_position * 0.5 + 0.5;
    v_screenCoord = v_texCoord * u_screenSize;
    gl_Position = vec4(a_position, 0.0, 1.0);
  }
`, s0 = `
  precision mediump float;
   
  uniform sampler2D u_image;
  uniform float u_opacity;
   
  varying vec2 v_texCoord;
   
  void main() {
    gl_FragColor = texture2D(u_image, v_texCoord) * u_opacity;
  }
`;
class r0 {
  /**
   * @param {Options} options Options.
   */
  constructor(e) {
    this.gl_ = e.webGlContext;
    const t = this.gl_;
    this.scaleRatio_ = e.scaleRatio || 1, this.renderTargetTexture_ = t.createTexture(), this.renderTargetTextureSize_ = null, this.frameBuffer_ = t.createFramebuffer();
    const i = t.createShader(t.VERTEX_SHADER);
    t.shaderSource(
      i,
      e.vertexShader || n0
    ), t.compileShader(i);
    const n = t.createShader(t.FRAGMENT_SHADER);
    t.shaderSource(
      n,
      e.fragmentShader || s0
    ), t.compileShader(n), this.renderTargetProgram_ = t.createProgram(), t.attachShader(this.renderTargetProgram_, i), t.attachShader(this.renderTargetProgram_, n), t.linkProgram(this.renderTargetProgram_), this.renderTargetVerticesBuffer_ = t.createBuffer();
    const r = [-1, -1, 1, -1, -1, 1, 1, -1, 1, 1, -1, 1];
    t.bindBuffer(t.ARRAY_BUFFER, this.renderTargetVerticesBuffer_), t.bufferData(
      t.ARRAY_BUFFER,
      new Float32Array(r),
      t.STATIC_DRAW
    ), this.renderTargetAttribLocation_ = t.getAttribLocation(
      this.renderTargetProgram_,
      "a_position"
    ), this.renderTargetUniformLocation_ = t.getUniformLocation(
      this.renderTargetProgram_,
      "u_screenSize"
    ), this.renderTargetOpacityLocation_ = t.getUniformLocation(
      this.renderTargetProgram_,
      "u_opacity"
    ), this.renderTargetTextureLocation_ = t.getUniformLocation(
      this.renderTargetProgram_,
      "u_image"
    ), this.uniforms_ = [], e.uniforms && Object.keys(e.uniforms).forEach((o) => {
      this.uniforms_.push({
        value: e.uniforms[o],
        location: t.getUniformLocation(this.renderTargetProgram_, o)
      });
    });
  }
  /**
   * Get the WebGL rendering context
   * @return {WebGLRenderingContext} The rendering context.
   * @api
   */
  getGL() {
    return this.gl_;
  }
  /**
   * Initialize the render target texture of the post process, make sure it is at the
   * right size and bind it as a render target for the next draw calls.
   * The last step to be initialized will be the one where the primitives are rendered.
   * @param {import("../Map.js").FrameState} frameState current frame state
   * @api
   */
  init(e) {
    const t = this.getGL(), i = [
      t.drawingBufferWidth * this.scaleRatio_,
      t.drawingBufferHeight * this.scaleRatio_
    ];
    if (t.bindFramebuffer(t.FRAMEBUFFER, this.getFrameBuffer()), t.viewport(0, 0, i[0], i[1]), !this.renderTargetTextureSize_ || this.renderTargetTextureSize_[0] !== i[0] || this.renderTargetTextureSize_[1] !== i[1]) {
      this.renderTargetTextureSize_ = i;
      const n = 0, r = t.RGBA, o = 0, a = t.RGBA, l = t.UNSIGNED_BYTE, h = null;
      t.bindTexture(t.TEXTURE_2D, this.renderTargetTexture_), t.texImage2D(
        t.TEXTURE_2D,
        n,
        r,
        i[0],
        i[1],
        o,
        a,
        l,
        h
      ), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.LINEAR), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), t.framebufferTexture2D(
        t.FRAMEBUFFER,
        t.COLOR_ATTACHMENT0,
        t.TEXTURE_2D,
        this.renderTargetTexture_,
        0
      );
    }
  }
  /**
   * Render to the next postprocessing pass (or to the canvas if final pass).
   * @param {import("../Map.js").FrameState} frameState current frame state
   * @param {WebGLPostProcessingPass} [nextPass] Next pass, optional
   * @param {function(WebGLRenderingContext, import("../Map.js").FrameState):void} [preCompose] Called before composing.
   * @param {function(WebGLRenderingContext, import("../Map.js").FrameState):void} [postCompose] Called before composing.
   * @api
   */
  apply(e, t, i, n) {
    const r = this.getGL(), o = e.size;
    if (r.bindFramebuffer(
      r.FRAMEBUFFER,
      t ? t.getFrameBuffer() : null
    ), r.activeTexture(r.TEXTURE0), r.bindTexture(r.TEXTURE_2D, this.renderTargetTexture_), !t) {
      const l = B(r.canvas);
      if (!e.renderTargets[l]) {
        const h = r.getContextAttributes();
        h && h.preserveDrawingBuffer && (r.clearColor(0, 0, 0, 0), r.clear(r.COLOR_BUFFER_BIT)), e.renderTargets[l] = !0;
      }
    }
    r.enable(r.BLEND), r.blendFunc(r.ONE, r.ONE_MINUS_SRC_ALPHA), r.viewport(0, 0, r.drawingBufferWidth, r.drawingBufferHeight), r.bindBuffer(r.ARRAY_BUFFER, this.renderTargetVerticesBuffer_), r.useProgram(this.renderTargetProgram_), r.enableVertexAttribArray(this.renderTargetAttribLocation_), r.vertexAttribPointer(
      this.renderTargetAttribLocation_,
      2,
      r.FLOAT,
      !1,
      0,
      0
    ), r.uniform2f(this.renderTargetUniformLocation_, o[0], o[1]), r.uniform1i(this.renderTargetTextureLocation_, 0);
    const a = e.layerStatesArray[e.layerIndex].opacity;
    r.uniform1f(this.renderTargetOpacityLocation_, a), this.applyUniforms(e), i && i(r, e), r.drawArrays(r.TRIANGLES, 0, 6), n && n(r, e);
  }
  /**
   * @return {WebGLFramebuffer} Frame buffer
   * @api
   */
  getFrameBuffer() {
    return this.frameBuffer_;
  }
  /**
   * Sets the custom uniforms based on what was given in the constructor.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @private
   */
  applyUniforms(e) {
    const t = this.getGL();
    let i, n = 1;
    this.uniforms_.forEach(function(r) {
      if (i = typeof r.value == "function" ? r.value(e) : r.value, i instanceof HTMLCanvasElement || i instanceof ImageData)
        r.texture || (r.texture = t.createTexture()), t.activeTexture(t[`TEXTURE${n}`]), t.bindTexture(t.TEXTURE_2D, r.texture), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.LINEAR), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), i instanceof ImageData ? t.texImage2D(
          t.TEXTURE_2D,
          0,
          t.RGBA,
          t.RGBA,
          i.width,
          i.height,
          0,
          t.UNSIGNED_BYTE,
          new Uint8Array(i.data)
        ) : t.texImage2D(
          t.TEXTURE_2D,
          0,
          t.RGBA,
          t.RGBA,
          t.UNSIGNED_BYTE,
          i
        ), t.uniform1i(r.location, n++);
      else if (Array.isArray(i))
        switch (i.length) {
          case 2:
            t.uniform2f(r.location, i[0], i[1]);
            return;
          case 3:
            t.uniform3f(r.location, i[0], i[1], i[2]);
            return;
          case 4:
            t.uniform4f(
              r.location,
              i[0],
              i[1],
              i[2],
              i[3]
            );
            return;
          default:
            return;
        }
      else
        typeof i == "number" && t.uniform1f(r.location, i);
    });
  }
}
const uh = r0;
function o0() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}
function mo(s, e) {
  return s[0] = e[0], s[1] = e[1], s[4] = e[2], s[5] = e[3], s[12] = e[4], s[13] = e[5], s;
}
const jt = {
  PROJECTION_MATRIX: "u_projectionMatrix",
  OFFSET_SCALE_MATRIX: "u_offsetScaleMatrix",
  OFFSET_ROTATION_MATRIX: "u_offsetRotateMatrix",
  TIME: "u_time",
  ZOOM: "u_zoom",
  RESOLUTION: "u_resolution",
  SIZE_PX: "u_sizePx",
  PIXEL_RATIO: "u_pixelRatio"
}, ot = {
  UNSIGNED_BYTE: $y,
  UNSIGNED_SHORT: Qy,
  UNSIGNED_INT: e0,
  FLOAT: yu
}, vr = {};
function dh(s) {
  return "shared/" + s;
}
let fh = 0;
function a0() {
  const s = "unique/" + fh;
  return fh += 1, s;
}
function l0(s) {
  let e = vr[s];
  if (!e) {
    const t = document.createElement("canvas");
    t.style.position = "absolute", t.style.left = "0", e = { users: 0, canvas: t }, vr[s] = e;
  }
  return e.users += 1, e.canvas;
}
function h0(s) {
  const e = vr[s];
  if (!e || (e.users -= 1, e.users > 0))
    return;
  const t = e.canvas, n = xu(t).getExtension("WEBGL_lose_context");
  n && n.loseContext(), delete vr[s];
}
class c0 extends wr {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    super(), e = e || {}, this.boundHandleWebGLContextLost_ = this.handleWebGLContextLost.bind(this), this.boundHandleWebGLContextRestored_ = this.handleWebGLContextRestored.bind(this), this.canvasCacheKey_ = e.canvasCacheKey ? dh(e.canvasCacheKey) : a0(), this.canvas_ = l0(this.canvasCacheKey_), this.gl_ = xu(this.canvas_), this.bufferCache_ = {}, this.extensionCache_ = {}, this.currentProgram_ = null, this.canvas_.addEventListener(
      Us.LOST,
      this.boundHandleWebGLContextLost_
    ), this.canvas_.addEventListener(
      Us.RESTORED,
      this.boundHandleWebGLContextRestored_
    ), this.offsetRotateMatrix_ = Se(), this.offsetScaleMatrix_ = Se(), this.tmpMat4_ = o0(), this.uniformLocations_ = {}, this.attribLocations_ = {}, this.uniforms_ = [], e.uniforms && this.setUniforms(e.uniforms);
    const t = this.getGL();
    this.postProcessPasses_ = e.postProcesses ? e.postProcesses.map(function(i) {
      return new uh({
        webGlContext: t,
        scaleRatio: i.scaleRatio,
        vertexShader: i.vertexShader,
        fragmentShader: i.fragmentShader,
        uniforms: i.uniforms
      });
    }) : [new uh({ webGlContext: t })], this.shaderCompileErrors_ = null, this.startTime_ = Date.now();
  }
  /**
   * @param {Object<string, UniformValue>} uniforms Uniform definitions.
   */
  setUniforms(e) {
    this.uniforms_ = [];
    for (const t in e)
      this.uniforms_.push({
        name: t,
        value: e[t]
      });
    this.uniformLocations_ = {};
  }
  /**
   * @param {string} canvasCacheKey The canvas cache key.
   * @return {boolean} The provided key matches the one this helper was constructed with.
   */
  canvasCacheKeyMatches(e) {
    return this.canvasCacheKey_ === dh(e);
  }
  /**
   * Get a WebGL extension.  If the extension is not supported, null is returned.
   * Extensions are cached after they are enabled for the first time.
   * @param {string} name The extension name.
   * @return {Object|null} The extension or null if not supported.
   */
  getExtension(e) {
    if (e in this.extensionCache_)
      return this.extensionCache_[e];
    const t = this.gl_.getExtension(e);
    return this.extensionCache_[e] = t, t;
  }
  /**
   * Just bind the buffer if it's in the cache. Otherwise create
   * the WebGL buffer, bind it, populate it, and add an entry to
   * the cache.
   * @param {import("./Buffer").default} buffer Buffer.
   */
  bindBuffer(e) {
    const t = this.getGL(), i = B(e);
    let n = this.bufferCache_[i];
    if (!n) {
      const r = t.createBuffer();
      n = {
        buffer: e,
        webGlBuffer: r
      }, this.bufferCache_[i] = n;
    }
    t.bindBuffer(e.getType(), n.webGlBuffer);
  }
  /**
   * Update the data contained in the buffer array; this is required for the
   * new data to be rendered
   * @param {import("./Buffer").default} buffer Buffer.
   */
  flushBufferData(e) {
    const t = this.getGL();
    this.bindBuffer(e), t.bufferData(e.getType(), e.getArray(), e.getUsage());
  }
  /**
   * @param {import("./Buffer.js").default} buf Buffer.
   */
  deleteBuffer(e) {
    const t = this.getGL(), i = B(e), n = this.bufferCache_[i];
    n && !t.isContextLost() && t.deleteBuffer(n.webGlBuffer), delete this.bufferCache_[i];
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    this.canvas_.removeEventListener(
      Us.LOST,
      this.boundHandleWebGLContextLost_
    ), this.canvas_.removeEventListener(
      Us.RESTORED,
      this.boundHandleWebGLContextRestored_
    ), h0(this.canvasCacheKey_), delete this.gl_, delete this.canvas_;
  }
  /**
   * Clear the buffer & set the viewport to draw.
   * Post process passes will be initialized here, the first one being bound as a render target for
   * subsequent draw calls.
   * @param {import("../Map.js").FrameState} frameState current frame state
   * @param {boolean} [disableAlphaBlend] If true, no alpha blending will happen.
   */
  prepareDraw(e, t) {
    const i = this.getGL(), n = this.getCanvas(), r = e.size, o = e.pixelRatio;
    n.width = r[0] * o, n.height = r[1] * o, n.style.width = r[0] + "px", n.style.height = r[1] + "px";
    for (let a = this.postProcessPasses_.length - 1; a >= 0; a--)
      this.postProcessPasses_[a].init(e);
    i.bindTexture(i.TEXTURE_2D, null), i.clearColor(0, 0, 0, 0), i.clear(i.COLOR_BUFFER_BIT), i.enable(i.BLEND), i.blendFunc(i.ONE, t ? i.ZERO : i.ONE_MINUS_SRC_ALPHA);
  }
  /**
   * Clear the render target & bind it for future draw operations.
   * This is similar to `prepareDraw`, only post processes will not be applied.
   * Note: the whole viewport will be drawn to the render target, regardless of its size.
   * @param {import("../Map.js").FrameState} frameState current frame state
   * @param {import("./RenderTarget.js").default} renderTarget Render target to draw to
   * @param {boolean} [disableAlphaBlend] If true, no alpha blending will happen.
   */
  prepareDrawToRenderTarget(e, t, i) {
    const n = this.getGL(), r = t.getSize();
    n.bindFramebuffer(n.FRAMEBUFFER, t.getFramebuffer()), n.viewport(0, 0, r[0], r[1]), n.bindTexture(n.TEXTURE_2D, t.getTexture()), n.clearColor(0, 0, 0, 0), n.clear(n.COLOR_BUFFER_BIT), n.enable(n.BLEND), n.blendFunc(n.ONE, i ? n.ZERO : n.ONE_MINUS_SRC_ALPHA);
  }
  /**
   * Execute a draw call based on the currently bound program, texture, buffers, attributes.
   * @param {number} start Start index.
   * @param {number} end End index.
   */
  drawElements(e, t) {
    const i = this.getGL();
    this.getExtension("OES_element_index_uint");
    const n = i.UNSIGNED_INT, r = 4, o = t - e, a = e * r;
    i.drawElements(i.TRIANGLES, o, n, a);
  }
  /**
   * Apply the successive post process passes which will eventually render to the actual canvas.
   * @param {import("../Map.js").FrameState} frameState current frame state
   * @param {function(WebGLRenderingContext, import("../Map.js").FrameState):void} [preCompose] Called before composing.
   * @param {function(WebGLRenderingContext, import("../Map.js").FrameState):void} [postCompose] Called before composing.
   */
  finalizeDraw(e, t, i) {
    for (let n = 0, r = this.postProcessPasses_.length; n < r; n++)
      n === r - 1 ? this.postProcessPasses_[n].apply(
        e,
        null,
        t,
        i
      ) : this.postProcessPasses_[n].apply(
        e,
        this.postProcessPasses_[n + 1]
      );
  }
  /**
   * @return {HTMLCanvasElement} Canvas.
   */
  getCanvas() {
    return this.canvas_;
  }
  /**
   * Get the WebGL rendering context
   * @return {WebGLRenderingContext} The rendering context.
   */
  getGL() {
    return this.gl_;
  }
  /**
   * Sets the default matrix uniforms for a given frame state. This is called internally in `prepareDraw`.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */
  applyFrameState(e) {
    const t = e.size, i = e.viewState.rotation, n = e.pixelRatio, r = Zr(this.offsetScaleMatrix_);
    id(r, 2 / t[0], 2 / t[1]);
    const o = Zr(this.offsetRotateMatrix_);
    i !== 0 && td(o, -i), this.setUniformMatrixValue(
      jt.OFFSET_SCALE_MATRIX,
      mo(this.tmpMat4_, r)
    ), this.setUniformMatrixValue(
      jt.OFFSET_ROTATION_MATRIX,
      mo(this.tmpMat4_, o)
    ), this.setUniformFloatValue(
      jt.TIME,
      (Date.now() - this.startTime_) * 1e-3
    ), this.setUniformFloatValue(jt.ZOOM, e.viewState.zoom), this.setUniformFloatValue(
      jt.RESOLUTION,
      e.viewState.resolution
    ), this.setUniformFloatValue(jt.PIXEL_RATIO, n), this.setUniformFloatVec2(jt.SIZE_PX, [t[0], t[1]]);
  }
  /**
   * Sets the custom uniforms based on what was given in the constructor. This is called internally in `prepareDraw`.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */
  applyUniforms(e) {
    const t = this.getGL();
    let i, n = 0;
    this.uniforms_.forEach((r) => {
      if (i = typeof r.value == "function" ? r.value(e) : r.value, i instanceof HTMLCanvasElement || i instanceof HTMLImageElement || i instanceof ImageData)
        r.texture || (r.prevValue = void 0, r.texture = t.createTexture()), t.activeTexture(t[`TEXTURE${n}`]), t.bindTexture(t.TEXTURE_2D, r.texture), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.LINEAR), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), (!(i instanceof HTMLImageElement) || /** @type {HTMLImageElement} */
        i.complete) && r.prevValue !== i && (r.prevValue = i, t.texImage2D(
          t.TEXTURE_2D,
          0,
          t.RGBA,
          t.RGBA,
          t.UNSIGNED_BYTE,
          i
        )), t.uniform1i(this.getUniformLocation(r.name), n++);
      else if (Array.isArray(i) && i.length === 6)
        this.setUniformMatrixValue(
          r.name,
          mo(this.tmpMat4_, i)
        );
      else if (Array.isArray(i) && i.length <= 4)
        switch (i.length) {
          case 2:
            t.uniform2f(
              this.getUniformLocation(r.name),
              i[0],
              i[1]
            );
            return;
          case 3:
            t.uniform3f(
              this.getUniformLocation(r.name),
              i[0],
              i[1],
              i[2]
            );
            return;
          case 4:
            t.uniform4f(
              this.getUniformLocation(r.name),
              i[0],
              i[1],
              i[2],
              i[3]
            );
            return;
          default:
            return;
        }
      else
        typeof i == "number" && t.uniform1f(this.getUniformLocation(r.name), i);
    });
  }
  /**
   * Set up a program for use. The program will be set as the current one. Then, the uniforms used
   * in the program will be set based on the current frame state and the helper configuration.
   * @param {WebGLProgram} program Program.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */
  useProgram(e, t) {
    this.getGL().useProgram(e), this.currentProgram_ = e, this.uniformLocations_ = {}, this.attribLocations_ = {}, this.applyFrameState(t), this.applyUniforms(t);
  }
  /**
   * Will attempt to compile a vertex or fragment shader based on source
   * On error, the shader will be returned but
   * `gl.getShaderParameter(shader, gl.COMPILE_STATUS)` will return `true`
   * Use `gl.getShaderInfoLog(shader)` to have details
   * @param {string} source Shader source
   * @param {ShaderType} type VERTEX_SHADER or FRAGMENT_SHADER
   * @return {WebGLShader} Shader object
   */
  compileShader(e, t) {
    const i = this.getGL(), n = i.createShader(t);
    return i.shaderSource(n, e), i.compileShader(n), n;
  }
  /**
   * Create a program for a vertex and fragment shader.  Throws if shader compilation fails.
   * @param {string} fragmentShaderSource Fragment shader source.
   * @param {string} vertexShaderSource Vertex shader source.
   * @return {WebGLProgram} Program
   */
  getProgram(e, t) {
    const i = this.getGL(), n = this.compileShader(
      e,
      i.FRAGMENT_SHADER
    ), r = this.compileShader(
      t,
      i.VERTEX_SHADER
    ), o = i.createProgram();
    if (i.attachShader(o, n), i.attachShader(o, r), i.linkProgram(o), !i.getShaderParameter(n, i.COMPILE_STATUS)) {
      const a = `Fragment shader compilation failed: ${i.getShaderInfoLog(
        n
      )}`;
      throw new Error(a);
    }
    if (i.deleteShader(n), !i.getShaderParameter(r, i.COMPILE_STATUS)) {
      const a = `Vertex shader compilation failed: ${i.getShaderInfoLog(
        r
      )}`;
      throw new Error(a);
    }
    if (i.deleteShader(r), !i.getProgramParameter(o, i.LINK_STATUS)) {
      const a = `GL program linking failed: ${i.getShaderInfoLog(
        r
      )}`;
      throw new Error(a);
    }
    return o;
  }
  /**
   * Will get the location from the shader or the cache
   * @param {string} name Uniform name
   * @return {WebGLUniformLocation} uniformLocation
   */
  getUniformLocation(e) {
    return this.uniformLocations_[e] === void 0 && (this.uniformLocations_[e] = this.getGL().getUniformLocation(
      this.currentProgram_,
      e
    )), this.uniformLocations_[e];
  }
  /**
   * Will get the location from the shader or the cache
   * @param {string} name Attribute name
   * @return {number} attribLocation
   */
  getAttributeLocation(e) {
    return this.attribLocations_[e] === void 0 && (this.attribLocations_[e] = this.getGL().getAttribLocation(
      this.currentProgram_,
      e
    )), this.attribLocations_[e];
  }
  /**
   * Modifies the given transform to apply the rotation/translation/scaling of the given frame state.
   * The resulting transform can be used to convert world space coordinates to view coordinates.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {import("../transform").Transform} transform Transform to update.
   * @return {import("../transform").Transform} The updated transform object.
   */
  makeProjectionTransform(e, t) {
    const i = e.size, n = e.viewState.rotation, r = e.viewState.resolution, o = e.viewState.center;
    return Zr(t), Je(
      t,
      0,
      0,
      2 / (r * i[0]),
      2 / (r * i[1]),
      -n,
      -o[0],
      -o[1]
    ), t;
  }
  /**
   * Give a value for a standard float uniform
   * @param {string} uniform Uniform name
   * @param {number} value Value
   */
  setUniformFloatValue(e, t) {
    this.getGL().uniform1f(this.getUniformLocation(e), t);
  }
  /**
   * Give a value for a vec2 uniform
   * @param {string} uniform Uniform name
   * @param {Array<number>} value Array of length 4.
   */
  setUniformFloatVec2(e, t) {
    this.getGL().uniform2fv(this.getUniformLocation(e), t);
  }
  /**
   * Give a value for a vec4 uniform
   * @param {string} uniform Uniform name
   * @param {Array<number>} value Array of length 4.
   */
  setUniformFloatVec4(e, t) {
    this.getGL().uniform4fv(this.getUniformLocation(e), t);
  }
  /**
   * Give a value for a standard matrix4 uniform
   * @param {string} uniform Uniform name
   * @param {Array<number>} value Matrix value
   */
  setUniformMatrixValue(e, t) {
    this.getGL().uniformMatrix4fv(
      this.getUniformLocation(e),
      !1,
      t
    );
  }
  /**
   * Will set the currently bound buffer to an attribute of the shader program. Used by `#enableAttributes`
   * internally.
   * @param {string} attribName Attribute name
   * @param {number} size Number of components per attributes
   * @param {number} type UNSIGNED_INT, UNSIGNED_BYTE, UNSIGNED_SHORT or FLOAT
   * @param {number} stride Stride in bytes (0 means attribs are packed)
   * @param {number} offset Offset in bytes
   * @private
   */
  enableAttributeArray_(e, t, i, n, r) {
    const o = this.getAttributeLocation(e);
    o < 0 || (this.getGL().enableVertexAttribArray(o), this.getGL().vertexAttribPointer(
      o,
      t,
      i,
      !1,
      n,
      r
    ));
  }
  /**
   * Will enable the following attributes to be read from the currently bound buffer,
   * i.e. tell the GPU where to read the different attributes in the buffer. An error in the
   * size/type/order of attributes will most likely break the rendering and throw a WebGL exception.
   * @param {Array<AttributeDescription>} attributes Ordered list of attributes to read from the buffer
   */
  enableAttributes(e) {
    const t = u0(e);
    let i = 0;
    for (let n = 0; n < e.length; n++) {
      const r = e[n];
      this.enableAttributeArray_(
        r.name,
        r.size,
        r.type || yu,
        t,
        i
      ), i += r.size * Eu(r.type);
    }
  }
  /**
   * WebGL context was lost
   * @private
   */
  handleWebGLContextLost() {
    Ti(this.bufferCache_), this.currentProgram_ = null;
  }
  /**
   * WebGL context was restored
   * @private
   */
  handleWebGLContextRestored() {
  }
  /**
   * Will create or reuse a given webgl texture and apply the given size. If no image data
   * specified, the texture will be empty, otherwise image data will be used and the `size`
   * parameter will be ignored.
   * Note: wrap parameters are set to clamp to edge, min filter is set to linear.
   * @param {Array<number>} size Expected size of the texture
   * @param {ImageData|HTMLImageElement|HTMLCanvasElement} [data] Image data/object to bind to the texture
   * @param {WebGLTexture} [texture] Existing texture to reuse
   * @return {WebGLTexture} The generated texture
   */
  createTexture(e, t, i) {
    const n = this.getGL();
    i = i || n.createTexture();
    const r = 0, o = n.RGBA, a = 0, l = n.RGBA, h = n.UNSIGNED_BYTE;
    return n.bindTexture(n.TEXTURE_2D, i), t ? n.texImage2D(n.TEXTURE_2D, r, o, l, h, t) : n.texImage2D(
      n.TEXTURE_2D,
      r,
      o,
      e[0],
      e[1],
      a,
      l,
      h,
      null
    ), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MIN_FILTER, n.LINEAR), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_S, n.CLAMP_TO_EDGE), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_T, n.CLAMP_TO_EDGE), i;
  }
}
function u0(s) {
  let e = 0;
  for (let t = 0; t < s.length; t++) {
    const i = s[t];
    e += i.size * Eu(i.type);
  }
  return e;
}
function Eu(s) {
  switch (s) {
    case ot.UNSIGNED_BYTE:
      return Uint8Array.BYTES_PER_ELEMENT;
    case ot.UNSIGNED_SHORT:
      return Uint16Array.BYTES_PER_ELEMENT;
    case ot.UNSIGNED_INT:
      return Uint32Array.BYTES_PER_ELEMENT;
    case ot.FLOAT:
    default:
      return Float32Array.BYTES_PER_ELEMENT;
  }
}
class al extends Rc {
  /**
   * @param {LayerType} layer Layer.
   * @param {Options} [options] Options.
   */
  constructor(e, t) {
    super(e), t = t || {}, this.inversePixelTransform_ = Se(), this.pixelContext_ = null, this.postProcesses_ = t.postProcesses, this.uniforms_ = t.uniforms, this.helper, e.addChangeListener(ne.MAP, this.removeHelper.bind(this)), this.dispatchPreComposeEvent = this.dispatchPreComposeEvent.bind(this), this.dispatchPostComposeEvent = this.dispatchPostComposeEvent.bind(this);
  }
  /**
   * @param {WebGLRenderingContext} context The WebGL rendering context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @protected
   */
  dispatchPreComposeEvent(e, t) {
    const i = this.getLayer();
    if (i.hasListener(Xe.PRECOMPOSE)) {
      const n = new An(
        Xe.PRECOMPOSE,
        void 0,
        t,
        e
      );
      i.dispatchEvent(n);
    }
  }
  /**
   * @param {WebGLRenderingContext} context The WebGL rendering context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @protected
   */
  dispatchPostComposeEvent(e, t) {
    const i = this.getLayer();
    if (i.hasListener(Xe.POSTCOMPOSE)) {
      const n = new An(
        Xe.POSTCOMPOSE,
        void 0,
        t,
        e
      );
      i.dispatchEvent(n);
    }
  }
  /**
   * Reset options (only handles uniforms).
   * @param {Options} options Options.
   */
  reset(e) {
    this.uniforms_ = e.uniforms, this.helper && this.helper.setUniforms(this.uniforms_);
  }
  /**
   * @protected
   */
  removeHelper() {
    this.helper && (this.helper.dispose(), delete this.helper);
  }
  /**
   * Determine whether renderFrame should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */
  prepareFrame(e) {
    if (this.getLayer().getRenderSource()) {
      let t = !0, i = -1, n;
      for (let o = 0, a = e.layerStatesArray.length; o < a; o++) {
        const l = e.layerStatesArray[o].layer, h = l.getRenderer();
        if (!(h instanceof al)) {
          t = !0;
          continue;
        }
        const c = l.getClassName();
        if ((t || c !== n) && (i += 1, t = !1), n = c, h === this)
          break;
      }
      const r = "map/" + e.mapId + "/group/" + i;
      (!this.helper || !this.helper.canvasCacheKeyMatches(r)) && (this.removeHelper(), this.helper = new c0({
        postProcesses: this.postProcesses_,
        uniforms: this.uniforms_,
        canvasCacheKey: r
      }), n && (this.helper.getCanvas().className = n), this.afterHelperCreated());
    }
    return this.prepareFrameInternal(e);
  }
  /**
   * @protected
   */
  afterHelperCreated() {
  }
  /**
   * Determine whether renderFrame should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   * @protected
   */
  prepareFrameInternal(e) {
    return !0;
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    this.removeHelper(), super.disposeInternal();
  }
  /**
   * @param {import("../../render/EventType.js").default} type Event type.
   * @param {WebGLRenderingContext} context The rendering context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @private
   */
  dispatchRenderEvent_(e, t, i) {
    const n = this.getLayer();
    if (n.hasListener(e)) {
      Je(
        this.inversePixelTransform_,
        0,
        0,
        i.pixelRatio,
        -i.pixelRatio,
        0,
        0,
        -i.size[1]
      );
      const r = new An(
        e,
        this.inversePixelTransform_,
        i,
        t
      );
      n.dispatchEvent(r);
    }
  }
  /**
   * @param {WebGLRenderingContext} context The rendering context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @protected
   */
  preRender(e, t) {
    this.dispatchRenderEvent_(Xe.PRERENDER, e, t);
  }
  /**
   * @param {WebGLRenderingContext} context The rendering context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @protected
   */
  postRender(e, t) {
    this.dispatchRenderEvent_(Xe.POSTRENDER, e, t);
  }
}
const d0 = al, ut = new Uint8Array(4);
class f0 {
  /**
   * @param {import("./Helper.js").default} helper WebGL helper; mandatory.
   * @param {Array<number>} [size] Expected size of the render target texture; note: this can be changed later on.
   */
  constructor(e, t) {
    this.helper_ = e;
    const i = e.getGL();
    this.texture_ = i.createTexture(), this.framebuffer_ = i.createFramebuffer(), this.size_ = t || [1, 1], this.data_ = new Uint8Array(0), this.dataCacheDirty_ = !0, this.updateSize_();
  }
  /**
   * Changes the size of the render target texture. Note: will do nothing if the size
   * is already the same.
   * @param {Array<number>} size Expected size of the render target texture
   * @api
   */
  setSize(e) {
    xt(e, this.size_) || (this.size_[0] = e[0], this.size_[1] = e[1], this.updateSize_());
  }
  /**
   * Returns the size of the render target texture
   * @return {Array<number>} Size of the render target texture
   * @api
   */
  getSize() {
    return this.size_;
  }
  /**
   * This will cause following calls to `#readAll` or `#readPixel` to download the content of the
   * render target into memory, which is an expensive operation.
   * This content will be kept in cache but should be cleared after each new render.
   * @api
   */
  clearCachedData() {
    this.dataCacheDirty_ = !0;
  }
  /**
   * Returns the full content of the frame buffer as a series of r, g, b, a components
   * in the 0-255 range (unsigned byte).
   * @return {Uint8Array} Integer array of color values
   * @api
   */
  readAll() {
    if (this.dataCacheDirty_) {
      const e = this.size_, t = this.helper_.getGL();
      t.bindFramebuffer(t.FRAMEBUFFER, this.framebuffer_), t.readPixels(
        0,
        0,
        e[0],
        e[1],
        t.RGBA,
        t.UNSIGNED_BYTE,
        this.data_
      ), this.dataCacheDirty_ = !1;
    }
    return this.data_;
  }
  /**
   * Reads one pixel of the frame buffer as an array of r, g, b, a components
   * in the 0-255 range (unsigned byte).
   * If x and/or y are outside of existing data, an array filled with 0 is returned.
   * @param {number} x Pixel coordinate
   * @param {number} y Pixel coordinate
   * @return {Uint8Array} Integer array with one color value (4 components)
   * @api
   */
  readPixel(e, t) {
    if (e < 0 || t < 0 || e > this.size_[0] || t >= this.size_[1])
      return ut[0] = 0, ut[1] = 0, ut[2] = 0, ut[3] = 0, ut;
    this.readAll();
    const i = Math.floor(e) + (this.size_[1] - Math.floor(t) - 1) * this.size_[0];
    return ut[0] = this.data_[i * 4], ut[1] = this.data_[i * 4 + 1], ut[2] = this.data_[i * 4 + 2], ut[3] = this.data_[i * 4 + 3], ut;
  }
  /**
   * @return {WebGLTexture} Texture to render to
   */
  getTexture() {
    return this.texture_;
  }
  /**
   * @return {WebGLFramebuffer} Frame buffer of the render target
   */
  getFramebuffer() {
    return this.framebuffer_;
  }
  /**
   * @private
   */
  updateSize_() {
    const e = this.size_, t = this.helper_.getGL();
    this.texture_ = this.helper_.createTexture(e, null, this.texture_), t.bindFramebuffer(t.FRAMEBUFFER, this.framebuffer_), t.viewport(0, 0, e[0], e[1]), t.framebufferTexture2D(
      t.FRAMEBUFFER,
      t.COLOR_ATTACHMENT0,
      t.TEXTURE_2D,
      this.texture_,
      0
    ), this.data_ = new Uint8Array(e[0] * e[1] * 4);
  }
}
const g0 = f0, po = {
  GENERATE_POLYGON_BUFFERS: "GENERATE_POLYGON_BUFFERS",
  GENERATE_POINT_BUFFERS: "GENERATE_POINT_BUFFERS",
  GENERATE_LINE_STRING_BUFFERS: "GENERATE_LINE_STRING_BUFFERS"
};
var vu = { exports: {} };
vu.exports = Ur;
vu.exports.default = Ur;
function Ur(s, e, t) {
  t = t || 2;
  var i = e && e.length, n = i ? e[0] * t : s.length, r = Cu(s, 0, n, t, !0), o = [];
  if (!r || r.next === r.prev)
    return o;
  var a, l, h, c, u, d, f;
  if (i && (r = x0(s, e, r, t)), s.length > 80 * t) {
    a = h = s[0], l = c = s[1];
    for (var g = t; g < n; g += t)
      u = s[g], d = s[g + 1], u < a && (a = u), d < l && (l = d), u > h && (h = u), d > c && (c = d);
    f = Math.max(h - a, c - l), f = f !== 0 ? 32767 / f : 0;
  }
  return Jn(r, o, t, a, l, f, 0), o;
}
function Cu(s, e, t, i, n) {
  var r, o;
  if (n === sa(s, e, t, i) > 0)
    for (r = e; r < t; r += i)
      o = gh(r, s[r], s[r + 1], o);
  else
    for (r = t - i; r >= e; r -= i)
      o = gh(r, s[r], s[r + 1], o);
  return o && zr(o, o.next) && (Qn(o), o = o.next), o;
}
function wi(s, e) {
  if (!s)
    return s;
  e || (e = s);
  var t = s, i;
  do
    if (i = !1, !t.steiner && (zr(t, t.next) || fe(t.prev, t, t.next) === 0)) {
      if (Qn(t), t = e = t.prev, t === t.next)
        break;
      i = !0;
    } else
      t = t.next;
  while (i || t !== e);
  return e;
}
function Jn(s, e, t, i, n, r, o) {
  if (s) {
    !o && r && T0(s, i, n, r);
    for (var a = s, l, h; s.prev !== s.next; ) {
      if (l = s.prev, h = s.next, r ? m0(s, i, n, r) : _0(s)) {
        e.push(l.i / t | 0), e.push(s.i / t | 0), e.push(h.i / t | 0), Qn(s), s = h.next, a = h.next;
        continue;
      }
      if (s = h, s === a) {
        o ? o === 1 ? (s = p0(wi(s), e, t), Jn(s, e, t, i, n, r, 2)) : o === 2 && y0(s, e, t, i, n, r) : Jn(wi(s), e, t, i, n, r, 1);
        break;
      }
    }
  }
}
function _0(s) {
  var e = s.prev, t = s, i = s.next;
  if (fe(e, t, i) >= 0)
    return !1;
  for (var n = e.x, r = t.x, o = i.x, a = e.y, l = t.y, h = i.y, c = n < r ? n < o ? n : o : r < o ? r : o, u = a < l ? a < h ? a : h : l < h ? l : h, d = n > r ? n > o ? n : o : r > o ? r : o, f = a > l ? a > h ? a : h : l > h ? l : h, g = i.next; g !== e; ) {
    if (g.x >= c && g.x <= d && g.y >= u && g.y <= f && Vi(n, a, r, l, o, h, g.x, g.y) && fe(g.prev, g, g.next) >= 0)
      return !1;
    g = g.next;
  }
  return !0;
}
function m0(s, e, t, i) {
  var n = s.prev, r = s, o = s.next;
  if (fe(n, r, o) >= 0)
    return !1;
  for (var a = n.x, l = r.x, h = o.x, c = n.y, u = r.y, d = o.y, f = a < l ? a < h ? a : h : l < h ? l : h, g = c < u ? c < d ? c : d : u < d ? u : d, _ = a > l ? a > h ? a : h : l > h ? l : h, m = c > u ? c > d ? c : d : u > d ? u : d, p = ia(f, g, e, t, i), x = ia(_, m, e, t, i), y = s.prevZ, E = s.nextZ; y && y.z >= p && E && E.z <= x; ) {
    if (y.x >= f && y.x <= _ && y.y >= g && y.y <= m && y !== n && y !== o && Vi(a, c, l, u, h, d, y.x, y.y) && fe(y.prev, y, y.next) >= 0 || (y = y.prevZ, E.x >= f && E.x <= _ && E.y >= g && E.y <= m && E !== n && E !== o && Vi(a, c, l, u, h, d, E.x, E.y) && fe(E.prev, E, E.next) >= 0))
      return !1;
    E = E.nextZ;
  }
  for (; y && y.z >= p; ) {
    if (y.x >= f && y.x <= _ && y.y >= g && y.y <= m && y !== n && y !== o && Vi(a, c, l, u, h, d, y.x, y.y) && fe(y.prev, y, y.next) >= 0)
      return !1;
    y = y.prevZ;
  }
  for (; E && E.z <= x; ) {
    if (E.x >= f && E.x <= _ && E.y >= g && E.y <= m && E !== n && E !== o && Vi(a, c, l, u, h, d, E.x, E.y) && fe(E.prev, E, E.next) >= 0)
      return !1;
    E = E.nextZ;
  }
  return !0;
}
function p0(s, e, t) {
  var i = s;
  do {
    var n = i.prev, r = i.next.next;
    !zr(n, r) && wu(n, i, i.next, r) && $n(n, r) && $n(r, n) && (e.push(n.i / t | 0), e.push(i.i / t | 0), e.push(r.i / t | 0), Qn(i), Qn(i.next), i = s = r), i = i.next;
  } while (i !== s);
  return wi(i);
}
function y0(s, e, t, i, n, r) {
  var o = s;
  do {
    for (var a = o.next.next; a !== o.prev; ) {
      if (o.i !== a.i && I0(o, a)) {
        var l = Tu(o, a);
        o = wi(o, o.next), l = wi(l, l.next), Jn(o, e, t, i, n, r, 0), Jn(l, e, t, i, n, r, 0);
        return;
      }
      a = a.next;
    }
    o = o.next;
  } while (o !== s);
}
function x0(s, e, t, i) {
  var n = [], r, o, a, l, h;
  for (r = 0, o = e.length; r < o; r++)
    a = e[r] * i, l = r < o - 1 ? e[r + 1] * i : s.length, h = Cu(s, a, l, i, !1), h === h.next && (h.steiner = !0), n.push(R0(h));
  for (n.sort(E0), r = 0; r < n.length; r++)
    t = v0(n[r], t);
  return t;
}
function E0(s, e) {
  return s.x - e.x;
}
function v0(s, e) {
  var t = C0(s, e);
  if (!t)
    return e;
  var i = Tu(t, s);
  return wi(i, i.next), wi(t, t.next);
}
function C0(s, e) {
  var t = e, i = s.x, n = s.y, r = -1 / 0, o;
  do {
    if (n <= t.y && n >= t.next.y && t.next.y !== t.y) {
      var a = t.x + (n - t.y) * (t.next.x - t.x) / (t.next.y - t.y);
      if (a <= i && a > r && (r = a, o = t.x < t.next.x ? t : t.next, a === i))
        return o;
    }
    t = t.next;
  } while (t !== e);
  if (!o)
    return null;
  var l = o, h = o.x, c = o.y, u = 1 / 0, d;
  t = o;
  do
    i >= t.x && t.x >= h && i !== t.x && Vi(n < c ? i : r, n, h, c, n < c ? r : i, n, t.x, t.y) && (d = Math.abs(n - t.y) / (i - t.x), $n(t, s) && (d < u || d === u && (t.x > o.x || t.x === o.x && w0(o, t))) && (o = t, u = d)), t = t.next;
  while (t !== l);
  return o;
}
function w0(s, e) {
  return fe(s.prev, s, e.prev) < 0 && fe(e.next, s, s.next) < 0;
}
function T0(s, e, t, i) {
  var n = s;
  do
    n.z === 0 && (n.z = ia(n.x, n.y, e, t, i)), n.prevZ = n.prev, n.nextZ = n.next, n = n.next;
  while (n !== s);
  n.prevZ.nextZ = null, n.prevZ = null, S0(n);
}
function S0(s) {
  var e, t, i, n, r, o, a, l, h = 1;
  do {
    for (t = s, s = null, r = null, o = 0; t; ) {
      for (o++, i = t, a = 0, e = 0; e < h && (a++, i = i.nextZ, !!i); e++)
        ;
      for (l = h; a > 0 || l > 0 && i; )
        a !== 0 && (l === 0 || !i || t.z <= i.z) ? (n = t, t = t.nextZ, a--) : (n = i, i = i.nextZ, l--), r ? r.nextZ = n : s = n, n.prevZ = r, r = n;
      t = i;
    }
    r.nextZ = null, h *= 2;
  } while (o > 1);
  return s;
}
function ia(s, e, t, i, n) {
  return s = (s - t) * n | 0, e = (e - i) * n | 0, s = (s | s << 8) & 16711935, s = (s | s << 4) & 252645135, s = (s | s << 2) & 858993459, s = (s | s << 1) & 1431655765, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, s | e << 1;
}
function R0(s) {
  var e = s, t = s;
  do
    (e.x < t.x || e.x === t.x && e.y < t.y) && (t = e), e = e.next;
  while (e !== s);
  return t;
}
function Vi(s, e, t, i, n, r, o, a) {
  return (n - o) * (e - a) >= (s - o) * (r - a) && (s - o) * (i - a) >= (t - o) * (e - a) && (t - o) * (r - a) >= (n - o) * (i - a);
}
function I0(s, e) {
  return s.next.i !== e.i && s.prev.i !== e.i && !L0(s, e) && // dones't intersect other edges
  ($n(s, e) && $n(e, s) && A0(s, e) && // locally visible
  (fe(s.prev, s, e.prev) || fe(s, e.prev, e)) || // does not create opposite-facing sectors
  zr(s, e) && fe(s.prev, s, s.next) > 0 && fe(e.prev, e, e.next) > 0);
}
function fe(s, e, t) {
  return (e.y - s.y) * (t.x - e.x) - (e.x - s.x) * (t.y - e.y);
}
function zr(s, e) {
  return s.x === e.x && s.y === e.y;
}
function wu(s, e, t, i) {
  var n = Bs(fe(s, e, t)), r = Bs(fe(s, e, i)), o = Bs(fe(t, i, s)), a = Bs(fe(t, i, e));
  return !!(n !== r && o !== a || n === 0 && zs(s, t, e) || r === 0 && zs(s, i, e) || o === 0 && zs(t, s, i) || a === 0 && zs(t, e, i));
}
function zs(s, e, t) {
  return e.x <= Math.max(s.x, t.x) && e.x >= Math.min(s.x, t.x) && e.y <= Math.max(s.y, t.y) && e.y >= Math.min(s.y, t.y);
}
function Bs(s) {
  return s > 0 ? 1 : s < 0 ? -1 : 0;
}
function L0(s, e) {
  var t = s;
  do {
    if (t.i !== s.i && t.next.i !== s.i && t.i !== e.i && t.next.i !== e.i && wu(t, t.next, s, e))
      return !0;
    t = t.next;
  } while (t !== s);
  return !1;
}
function $n(s, e) {
  return fe(s.prev, s, s.next) < 0 ? fe(s, e, s.next) >= 0 && fe(s, s.prev, e) >= 0 : fe(s, e, s.prev) < 0 || fe(s, s.next, e) < 0;
}
function A0(s, e) {
  var t = s, i = !1, n = (s.x + e.x) / 2, r = (s.y + e.y) / 2;
  do
    t.y > r != t.next.y > r && t.next.y !== t.y && n < (t.next.x - t.x) * (r - t.y) / (t.next.y - t.y) + t.x && (i = !i), t = t.next;
  while (t !== s);
  return i;
}
function Tu(s, e) {
  var t = new na(s.i, s.x, s.y), i = new na(e.i, e.x, e.y), n = s.next, r = e.prev;
  return s.next = e, e.prev = s, t.next = n, n.prev = t, i.next = t, t.prev = i, r.next = i, i.prev = r, i;
}
function gh(s, e, t, i) {
  var n = new na(s, e, t);
  return i ? (n.next = i.next, n.prev = i, i.next.prev = n, i.next = n) : (n.prev = n, n.next = n), n;
}
function Qn(s) {
  s.next.prev = s.prev, s.prev.next = s.next, s.prevZ && (s.prevZ.nextZ = s.nextZ), s.nextZ && (s.nextZ.prevZ = s.prevZ);
}
function na(s, e, t) {
  this.i = s, this.x = e, this.y = t, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1;
}
Ur.deviation = function(s, e, t, i) {
  var n = e && e.length, r = n ? e[0] * t : s.length, o = Math.abs(sa(s, 0, r, t));
  if (n)
    for (var a = 0, l = e.length; a < l; a++) {
      var h = e[a] * t, c = a < l - 1 ? e[a + 1] * t : s.length;
      o -= Math.abs(sa(s, h, c, t));
    }
  var u = 0;
  for (a = 0; a < i.length; a += 3) {
    var d = i[a] * t, f = i[a + 1] * t, g = i[a + 2] * t;
    u += Math.abs(
      (s[d] - s[g]) * (s[f + 1] - s[d + 1]) - (s[d] - s[f]) * (s[g + 1] - s[d + 1])
    );
  }
  return o === 0 && u === 0 ? 0 : Math.abs((u - o) / o);
};
function sa(s, e, t, i) {
  for (var n = 0, r = e, o = t - i; r < t; r += i)
    n += (s[o] - s[r]) * (s[r + 1] + s[o + 1]), o = r;
  return n;
}
Ur.flatten = function(s) {
  for (var e = s[0][0].length, t = { vertices: [], holes: [], dimensions: e }, i = 0, n = 0; n < s.length; n++) {
    for (var r = 0; r < s[n].length; r++)
      for (var o = 0; o < e; o++)
        t.vertices.push(s[n][r][o]);
    n > 0 && (i += s[n - 1].length, t.holes.push(i));
  }
  return t;
};
function F0(s, e) {
  e = e || [];
  const t = 256, i = t - 1;
  return e[0] = Math.floor(s / t / t / t) / i, e[1] = Math.floor(s / t / t) % t / i, e[2] = Math.floor(s / t) % t / i, e[3] = s % t / i, e;
}
function b0(s) {
  let e = 0;
  const t = 256, i = t - 1;
  return e += Math.round(s[0] * t * t * t * i), e += Math.round(s[1] * t * t * i), e += Math.round(s[2] * t * i), e += Math.round(s[3] * i), e;
}
function P0() {
  const s = 'const e="GENERATE_POLYGON_BUFFERS",t="GENERATE_POINT_BUFFERS",n="GENERATE_LINE_STRING_BUFFERS",r={1:"The view center is not defined",2:"The view resolution is not defined",3:"The view rotation is not defined",4:"`image` and `src` cannot be provided at the same time",5:"`imgSize` must be set when `image` is provided",7:"`format` must be set when `url` is set",8:"Unknown `serverType` configured",9:"`url` must be configured or set using `#setUrl()`",10:"The default `geometryFunction` can only handle `Point` geometries",11:"`options.featureTypes` must be an Array",12:"`options.geometryName` must also be provided when `options.bbox` is set",13:"Invalid corner",14:"Invalid color",15:"Tried to get a value for a key that does not exist in the cache",16:"Tried to set a value for a key that is used already",17:"`resolutions` must be sorted in descending order",18:"Either `origin` or `origins` must be configured, never both",19:"Number of `tileSizes` and `resolutions` must be equal",20:"Number of `origins` and `resolutions` must be equal",22:"Either `tileSize` or `tileSizes` must be configured, never both",24:"Invalid extent or geometry provided as `geometry`",25:"Cannot fit empty extent provided as `geometry`",26:"Features must have an id set",27:"Features must have an id set",28:\'`renderMode` must be `"hybrid"` or `"vector"`\',30:"The passed `feature` was already added to the source",31:"Tried to enqueue an `element` that was already added to the queue",32:"Transformation matrix cannot be inverted",33:"Invalid units",34:"Invalid geometry layout",36:"Unknown SRS type",37:"Unknown geometry type found",38:"`styleMapValue` has an unknown type",39:"Unknown geometry type",40:"Expected `feature` to have a geometry",41:"Expected an `ol/style/Style` or an array of `ol/style/Style.js`",42:"Question unknown, the answer is 42",43:"Expected `layers` to be an array or a `Collection`",47:"Expected `controls` to be an array or an `ol/Collection`",48:"Expected `interactions` to be an array or an `ol/Collection`",49:"Expected `overlays` to be an array or an `ol/Collection`",50:"`options.featureTypes` should be an Array",51:"Either `url` or `tileJSON` options must be provided",52:"Unknown `serverType` configured",53:"Unknown `tierSizeCalculation` configured",55:"The {-y} placeholder requires a tile grid with extent",56:"mapBrowserEvent must originate from a pointer event",57:"At least 2 conditions are required",59:"Invalid command found in the PBF",60:"Missing or invalid `size`",61:"Cannot determine IIIF Image API version from provided image information JSON",62:"A `WebGLArrayBuffer` must either be of type `ELEMENT_ARRAY_BUFFER` or `ARRAY_BUFFER`",64:"Layer opacity must be a number",66:"`forEachFeatureAtCoordinate` cannot be used on a WebGL layer if the hit detection logic has not been enabled. This is done by providing adequate shaders using the `hitVertexShader` and `hitFragmentShader` properties of `WebGLPointsLayerRenderer`",67:"A layer can only be added to the map once. Use either `layer.setMap()` or `map.addLayer()`, not both",68:"A VectorTile source can only be rendered if it has a projection compatible with the view projection",69:"`width` or `height` cannot be provided together with `scale`"};class o extends Error{constructor(e){const t=r[e];super(t),this.code=e,this.name="AssertionError",this.message=t}}var i=o;function a(e,t){const n=t[0],r=t[1];return t[0]=e[0]*n+e[2]*r+e[4],t[1]=e[1]*n+e[3]*r+e[5],t}function s(e,t){const n=(r=t)[0]*r[3]-r[1]*r[2];var r;!function(e,t){if(!e)throw new i(t)}(0!==n,32);const o=t[0],a=t[1],s=t[2],u=t[3],f=t[4],x=t[5];return e[0]=u/n,e[1]=-a/n,e[2]=-s/n,e[3]=o/n,e[4]=(s*x-u*f)/n,e[5]=-(o*x-a*f)/n,e}new Array(6);var u={};function f(e,t,n){n=n||2;var r,o,i,a,s,u,f,l=t&&t.length,c=l?t[0]*n:e.length,v=x(e,0,c,n,!0),d=[];if(!v||v.next===v.prev)return d;if(l&&(v=function(e,t,n,r){var o,i,a,s=[];for(o=0,i=t.length;o<i;o++)(a=x(e,t[o]*r,o<i-1?t[o+1]*r:e.length,r,!1))===a.next&&(a.steiner=!0),s.push(w(a));for(s.sort(p),o=0;o<s.length;o++)n=b(s[o],n);return n}(e,t,v,n)),e.length>80*n){r=i=e[0],o=a=e[1];for(var y=n;y<c;y+=n)(s=e[y])<r&&(r=s),(u=e[y+1])<o&&(o=u),s>i&&(i=s),u>a&&(a=u);f=0!==(f=Math.max(i-r,a-o))?32767/f:0}return h(v,d,n,r,o,f,0),d}function x(e,t,n,r,o){var i,a;if(o===B(e,t,n,r)>0)for(i=t;i<n;i+=r)a=k(i,e[i],e[i+1],a);else for(i=n-r;i>=t;i-=r)a=k(i,e[i],e[i+1],a);return a&&M(a,a.next)&&(z(a),a=a.next),a}function l(e,t){if(!e)return e;t||(t=e);var n,r=e;do{if(n=!1,r.steiner||!M(r,r.next)&&0!==Z(r.prev,r,r.next))r=r.next;else{if(z(r),(r=t=r.prev)===r.next)break;n=!0}}while(n||r!==t);return t}function h(e,t,n,r,o,i,a){if(e){!a&&i&&function(e,t,n,r){var o=e;do{0===o.z&&(o.z=m(o.x,o.y,t,n,r)),o.prevZ=o.prev,o.nextZ=o.next,o=o.next}while(o!==e);o.prevZ.nextZ=null,o.prevZ=null,function(e){var t,n,r,o,i,a,s,u,f=1;do{for(n=e,e=null,i=null,a=0;n;){for(a++,r=n,s=0,t=0;t<f&&(s++,r=r.nextZ);t++);for(u=f;s>0||u>0&&r;)0!==s&&(0===u||!r||n.z<=r.z)?(o=n,n=n.nextZ,s--):(o=r,r=r.nextZ,u--),i?i.nextZ=o:e=o,o.prevZ=i,i=o;n=r}i.nextZ=null,f*=2}while(a>1)}(o)}(e,r,o,i);for(var s,u,f=e;e.prev!==e.next;)if(s=e.prev,u=e.next,i?v(e,r,o,i):c(e))t.push(s.i/n|0),t.push(e.i/n|0),t.push(u.i/n|0),z(e),e=u.next,f=u.next;else if((e=u)===f){a?1===a?h(e=d(l(e),t,n),t,n,r,o,i,2):2===a&&y(e,t,n,r,o,i):h(l(e),t,n,r,o,i,1);break}}}function c(e){var t=e.prev,n=e,r=e.next;if(Z(t,n,r)>=0)return!1;for(var o=t.x,i=n.x,a=r.x,s=t.y,u=n.y,f=r.y,x=o<i?o<a?o:a:i<a?i:a,l=s<u?s<f?s:f:u<f?u:f,h=o>i?o>a?o:a:i>a?i:a,c=s>u?s>f?s:f:u>f?u:f,v=r.next;v!==t;){if(v.x>=x&&v.x<=h&&v.y>=l&&v.y<=c&&A(o,s,i,u,a,f,v.x,v.y)&&Z(v.prev,v,v.next)>=0)return!1;v=v.next}return!0}function v(e,t,n,r){var o=e.prev,i=e,a=e.next;if(Z(o,i,a)>=0)return!1;for(var s=o.x,u=i.x,f=a.x,x=o.y,l=i.y,h=a.y,c=s<u?s<f?s:f:u<f?u:f,v=x<l?x<h?x:h:l<h?l:h,d=s>u?s>f?s:f:u>f?u:f,y=x>l?x>h?x:h:l>h?l:h,p=m(c,v,t,n,r),b=m(d,y,t,n,r),g=e.prevZ,w=e.nextZ;g&&g.z>=p&&w&&w.z<=b;){if(g.x>=c&&g.x<=d&&g.y>=v&&g.y<=y&&g!==o&&g!==a&&A(s,x,u,l,f,h,g.x,g.y)&&Z(g.prev,g,g.next)>=0)return!1;if(g=g.prevZ,w.x>=c&&w.x<=d&&w.y>=v&&w.y<=y&&w!==o&&w!==a&&A(s,x,u,l,f,h,w.x,w.y)&&Z(w.prev,w,w.next)>=0)return!1;w=w.nextZ}for(;g&&g.z>=p;){if(g.x>=c&&g.x<=d&&g.y>=v&&g.y<=y&&g!==o&&g!==a&&A(s,x,u,l,f,h,g.x,g.y)&&Z(g.prev,g,g.next)>=0)return!1;g=g.prevZ}for(;w&&w.z<=b;){if(w.x>=c&&w.x<=d&&w.y>=v&&w.y<=y&&w!==o&&w!==a&&A(s,x,u,l,f,h,w.x,w.y)&&Z(w.prev,w,w.next)>=0)return!1;w=w.nextZ}return!0}function d(e,t,n){var r=e;do{var o=r.prev,i=r.next.next;!M(o,i)&&F(o,r,r.next,i)&&S(o,i)&&S(i,o)&&(t.push(o.i/n|0),t.push(r.i/n|0),t.push(i.i/n|0),z(r),z(r.next),r=e=i),r=r.next}while(r!==e);return l(r)}function y(e,t,n,r,o,i){var a=e;do{for(var s=a.next.next;s!==a.prev;){if(a.i!==s.i&&E(a,s)){var u=U(a,s);return a=l(a,a.next),u=l(u,u.next),h(a,t,n,r,o,i,0),void h(u,t,n,r,o,i,0)}s=s.next}a=a.next}while(a!==e)}function p(e,t){return e.x-t.x}function b(e,t){var n=function(e,t){var n,r=t,o=e.x,i=e.y,a=-1/0;do{if(i<=r.y&&i>=r.next.y&&r.next.y!==r.y){var s=r.x+(i-r.y)*(r.next.x-r.x)/(r.next.y-r.y);if(s<=o&&s>a&&(a=s,n=r.x<r.next.x?r:r.next,s===o))return n}r=r.next}while(r!==t);if(!n)return null;var u,f=n,x=n.x,l=n.y,h=1/0;r=n;do{o>=r.x&&r.x>=x&&o!==r.x&&A(i<l?o:a,i,x,l,i<l?a:o,i,r.x,r.y)&&(u=Math.abs(i-r.y)/(o-r.x),S(r,e)&&(u<h||u===h&&(r.x>n.x||r.x===n.x&&g(n,r)))&&(n=r,h=u)),r=r.next}while(r!==f);return n}(e,t);if(!n)return t;var r=U(n,e);return l(r,r.next),l(n,n.next)}function g(e,t){return Z(e.prev,e,t.prev)<0&&Z(t.next,e,e.next)<0}function m(e,t,n,r,o){return(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=(e-n)*o|0)|e<<8))|e<<4))|e<<2))|e<<1))|(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=(t-r)*o|0)|t<<8))|t<<4))|t<<2))|t<<1))<<1}function w(e){var t=e,n=e;do{(t.x<n.x||t.x===n.x&&t.y<n.y)&&(n=t),t=t.next}while(t!==e);return n}function A(e,t,n,r,o,i,a,s){return(o-a)*(t-s)>=(e-a)*(i-s)&&(e-a)*(r-s)>=(n-a)*(t-s)&&(n-a)*(i-s)>=(o-a)*(r-s)}function E(e,t){return e.next.i!==t.i&&e.prev.i!==t.i&&!function(e,t){var n=e;do{if(n.i!==e.i&&n.next.i!==e.i&&n.i!==t.i&&n.next.i!==t.i&&F(n,n.next,e,t))return!0;n=n.next}while(n!==e);return!1}(e,t)&&(S(e,t)&&S(t,e)&&function(e,t){var n=e,r=!1,o=(e.x+t.x)/2,i=(e.y+t.y)/2;do{n.y>i!=n.next.y>i&&n.next.y!==n.y&&o<(n.next.x-n.x)*(i-n.y)/(n.next.y-n.y)+n.x&&(r=!r),n=n.next}while(n!==e);return r}(e,t)&&(Z(e.prev,e,t.prev)||Z(e,t.prev,t))||M(e,t)&&Z(e.prev,e,e.next)>0&&Z(t.prev,t,t.next)>0)}function Z(e,t,n){return(t.y-e.y)*(n.x-t.x)-(t.x-e.x)*(n.y-t.y)}function M(e,t){return e.x===t.x&&e.y===t.y}function F(e,t,n,r){var o=I(Z(e,t,n)),i=I(Z(e,t,r)),a=I(Z(n,r,e)),s=I(Z(n,r,t));return o!==i&&a!==s||(!(0!==o||!T(e,n,t))||(!(0!==i||!T(e,r,t))||(!(0!==a||!T(n,e,r))||!(0!==s||!T(n,t,r)))))}function T(e,t,n){return t.x<=Math.max(e.x,n.x)&&t.x>=Math.min(e.x,n.x)&&t.y<=Math.max(e.y,n.y)&&t.y>=Math.min(e.y,n.y)}function I(e){return e>0?1:e<0?-1:0}function S(e,t){return Z(e.prev,e,e.next)<0?Z(e,t,e.next)>=0&&Z(e,e.prev,t)>=0:Z(e,t,e.prev)<0||Z(e,e.next,t)<0}function U(e,t){var n=new R(e.i,e.x,e.y),r=new R(t.i,t.x,t.y),o=e.next,i=t.prev;return e.next=t,t.prev=e,n.next=o,o.prev=n,r.next=n,n.prev=r,i.next=r,r.prev=i,r}function k(e,t,n,r){var o=new R(e,t,n);return r?(o.next=r.next,o.prev=r,r.next.prev=o,r.next=o):(o.prev=o,o.next=o),o}function z(e){e.next.prev=e.prev,e.prev.next=e.next,e.prevZ&&(e.prevZ.nextZ=e.nextZ),e.nextZ&&(e.nextZ.prevZ=e.prevZ)}function R(e,t,n){this.i=e,this.x=t,this.y=n,this.prev=null,this.next=null,this.z=0,this.prevZ=null,this.nextZ=null,this.steiner=!1}function B(e,t,n,r){for(var o=0,i=t,a=n-r;i<n;i+=r)o+=(e[a]-e[i])*(e[i+1]+e[a+1]),a=i;return o}({get exports(){return u},set exports(e){u=e}}).exports=f,u.default=f,f.deviation=function(e,t,n,r){var o=t&&t.length,i=o?t[0]*n:e.length,a=Math.abs(B(e,0,i,n));if(o)for(var s=0,u=t.length;s<u;s++){var f=t[s]*n,x=s<u-1?t[s+1]*n:e.length;a-=Math.abs(B(e,f,x,n))}var l=0;for(s=0;s<r.length;s+=3){var h=r[s]*n,c=r[s+1]*n,v=r[s+2]*n;l+=Math.abs((e[h]-e[v])*(e[c+1]-e[h+1])-(e[h]-e[c])*(e[v+1]-e[h+1]))}return 0===a&&0===l?0:Math.abs((l-a)/a)},f.flatten=function(e){for(var t=e[0][0].length,n={vertices:[],holes:[],dimensions:t},r=0,o=0;o<e.length;o++){for(var i=0;i<e[o].length;i++)for(var a=0;a<t;a++)n.vertices.push(e[o][i][a]);o>0&&(r+=e[o-1].length,n.holes.push(r))}return n};const N=[],P={vertexPosition:0,indexPosition:0};function C(e,t,n,r,o){e[t+0]=n,e[t+1]=r,e[t+2]=o}function _(e,t,n,r,o,i){const a=3+o,s=e[t+0],u=e[t+1],f=N;f.length=o;for(let n=0;n<f.length;n++)f[n]=e[t+2+n];let x=i?i.vertexPosition:0,l=i?i.indexPosition:0;const h=x/a;return C(n,x,s,u,0),f.length&&n.set(f,x+3),x+=a,C(n,x,s,u,1),f.length&&n.set(f,x+3),x+=a,C(n,x,s,u,2),f.length&&n.set(f,x+3),x+=a,C(n,x,s,u,3),f.length&&n.set(f,x+3),x+=a,r[l++]=h,r[l++]=h+1,r[l++]=h+3,r[l++]=h+1,r[l++]=h+2,r[l++]=h+3,P.vertexPosition=x,P.indexPosition=l,P}function q(e,t,n,r,o,i,s,u,f,x){const l=5+u.length,h=i.length/l,c=[e[t+0],e[t+1]],v=[e[n],e[n+1]],d=a(x,[...c]),y=a(x,[...v]);function p(e,t,n){const r=1e4;return Math.round(1500*t)+Math.round(1500*n)*r+e*r*r}function b(e,t,n){const r=Math.sqrt((t[0]-e[0])*(t[0]-e[0])+(t[1]-e[1])*(t[1]-e[1])),o=[(t[0]-e[0])/r,(t[1]-e[1])/r],i=[-o[1],o[0]],a=Math.sqrt((n[0]-e[0])*(n[0]-e[0])+(n[1]-e[1])*(n[1]-e[1])),s=[(n[0]-e[0])/a,(n[1]-e[1])/a],u=0===r||0===a?0:Math.acos((f=s[0]*o[0]+s[1]*o[1],x=-1,l=1,Math.min(Math.max(f,x),l)));var f,x,l;return s[0]*i[0]+s[1]*i[1]>0?u:2*Math.PI-u}const g=null!==o;let m=0,w=0;if(null!==r){m=b(d,y,a(x,[...[e[r],e[r+1]]]))}if(g){w=b(y,d,a(x,[...[e[o],e[o+1]]]))}i.push(c[0],c[1],v[0],v[1],p(0,m,w)),i.push(...u),i.push(c[0],c[1],v[0],v[1],p(1,m,w)),i.push(...u),i.push(c[0],c[1],v[0],v[1],p(2,m,w)),i.push(...u),i.push(c[0],c[1],v[0],v[1],p(3,m,w)),i.push(...u),s.push(h,h+1,h+2,h+1,h+3,h+2)}function L(e,t,n,r,o){const i=2+o;let a=t;const s=e.slice(a,a+o);a+=o;const f=e[a++];let x=0;const l=new Array(f-1);for(let t=0;t<f;t++)x+=e[a++],t<f-1&&(l[t]=x);const h=e.slice(a,a+2*x),c=u(h,l,2);for(let e=0;e<c.length;e++)r.push(c[e]+n.length/i);for(let e=0;e<h.length;e+=2)n.push(h[e],h[e+1],...s);return a+2*x}const G=self;G.onmessage=r=>{const o=r.data;switch(o.type){case t:{const e=3,t=2,n=o.customAttributesCount,r=t+n,i=new Float32Array(o.renderInstructions),a=i.length/r,s=4*a*(n+e),u=new Uint32Array(6*a),f=new Float32Array(s);let x;for(let e=0;e<i.length;e+=r)x=_(i,e,f,u,n,x);const l=Object.assign({vertexBuffer:f.buffer,indexBuffer:u.buffer,renderInstructions:i.buffer},o);G.postMessage(l,[f.buffer,u.buffer,i.buffer]);break}case n:{const e=[],t=[],n=o.customAttributesCount,r=2,i=new Float32Array(o.renderInstructions);let a=0;const u=o.renderInstructionsTransform,f=[1,0,0,1,0,0];let x,l;for(s(f,u);a<i.length;){l=Array.from(i.slice(a,a+n)),a+=n,x=i[a++];for(let n=0;n<x-1;n++)q(i,a+n*r,a+(n+1)*r,n>0?a+(n-1)*r:null,n<x-2?a+(n+2)*r:null,e,t,l,0,f);a+=x*r}const h=Uint32Array.from(t),c=Float32Array.from(e),v=Object.assign({vertexBuffer:c.buffer,indexBuffer:h.buffer,renderInstructions:i.buffer},o);G.postMessage(v,[c.buffer,h.buffer,i.buffer]);break}case e:{const e=[],t=[],n=o.customAttributesCount,r=new Float32Array(o.renderInstructions);let i=0;for(;i<r.length;)i=L(r,i,e,t,n);const a=Uint32Array.from(t),s=Float32Array.from(e),u=Object.assign({vertexBuffer:s.buffer,indexBuffer:a.buffer,renderInstructions:r.buffer},o);G.postMessage(u,[s.buffer,a.buffer,r.buffer]);break}}};';
  return new Worker(typeof Blob > "u" ? "data:application/javascript;base64," + Buffer.from(s, "binary").toString("base64") : URL.createObjectURL(new Blob([s], { type: "application/javascript" })));
}
class M0 extends d0 {
  /**
   * @param {import("../../layer/Layer.js").default} layer Layer.
   * @param {Options} options Options.
   */
  constructor(e, t) {
    const i = t.uniforms || {}, n = Se();
    i[jt.PROJECTION_MATRIX] = n, super(e, {
      uniforms: i,
      postProcesses: t.postProcesses
    }), this.ready = !1, this.sourceRevision_ = -1, this.verticesBuffer_ = new _o(Er, $s), this.hitVerticesBuffer_ = new _o(Er, $s), this.indicesBuffer_ = new _o(
      ol,
      $s
    ), this.vertexShader_ = t.vertexShader, this.fragmentShader_ = t.fragmentShader, this.program_, this.hitDetectionEnabled_ = !!(t.hitFragmentShader && t.hitVertexShader), this.hitVertexShader_ = t.hitVertexShader, this.hitFragmentShader_ = t.hitFragmentShader, this.hitProgram_;
    const r = t.attributes ? t.attributes.map(function(a) {
      return {
        name: "a_" + a.name,
        size: 1,
        type: ot.FLOAT
      };
    }) : [];
    this.attributes = [
      {
        name: "a_position",
        size: 2,
        type: ot.FLOAT
      },
      {
        name: "a_index",
        size: 1,
        type: ot.FLOAT
      }
    ].concat(r), this.hitDetectionAttributes = [
      {
        name: "a_position",
        size: 2,
        type: ot.FLOAT
      },
      {
        name: "a_index",
        size: 1,
        type: ot.FLOAT
      },
      {
        name: "a_hitColor",
        size: 4,
        type: ot.FLOAT
      },
      {
        name: "a_featureUid",
        size: 1,
        type: ot.FLOAT
      }
    ].concat(r), this.customAttributes = t.attributes ? t.attributes : [], this.previousExtent_ = Me(), this.currentTransform_ = n, this.renderTransform_ = Se(), this.invertRenderTransform_ = Se(), this.renderInstructions_ = new Float32Array(0), this.hitRenderInstructions_ = new Float32Array(0), this.hitRenderTarget_, this.generateBuffersRun_ = 0, this.worker_ = P0(), this.worker_.addEventListener(
      "message",
      /**
       * @param {*} event Event.
       */
      (a) => {
        const l = a.data;
        if (l.type === po.GENERATE_POINT_BUFFERS) {
          const h = l.projectionTransform;
          l.hitDetection ? (this.hitVerticesBuffer_.fromArrayBuffer(l.vertexBuffer), this.helper.flushBufferData(this.hitVerticesBuffer_)) : (this.verticesBuffer_.fromArrayBuffer(l.vertexBuffer), this.helper.flushBufferData(this.verticesBuffer_)), this.indicesBuffer_.fromArrayBuffer(l.indexBuffer), this.helper.flushBufferData(this.indicesBuffer_), this.renderTransform_ = h, ns(
            this.invertRenderTransform_,
            this.renderTransform_
          ), l.hitDetection ? this.hitRenderInstructions_ = new Float32Array(
            a.data.renderInstructions
          ) : (this.renderInstructions_ = new Float32Array(
            a.data.renderInstructions
          ), l.generateBuffersRun === this.generateBuffersRun_ && (this.ready = !0)), this.getLayer().changed();
        }
      }
    ), this.featureCache_ = {}, this.featureCount_ = 0;
    const o = this.getLayer().getSource();
    this.sourceListenKeys_ = [
      H(
        o,
        Le.ADDFEATURE,
        this.handleSourceFeatureAdded_,
        this
      ),
      H(
        o,
        Le.CHANGEFEATURE,
        this.handleSourceFeatureChanged_,
        this
      ),
      H(
        o,
        Le.REMOVEFEATURE,
        this.handleSourceFeatureDelete_,
        this
      ),
      H(
        o,
        Le.CLEAR,
        this.handleSourceFeatureClear_,
        this
      )
    ], o.forEachFeature((a) => {
      this.featureCache_[B(a)] = {
        feature: a,
        properties: a.getProperties(),
        geometry: a.getGeometry()
      }, this.featureCount_++;
    });
  }
  afterHelperCreated() {
    this.program_ = this.helper.getProgram(
      this.fragmentShader_,
      this.vertexShader_
    ), this.hitDetectionEnabled_ && (this.hitProgram_ = this.helper.getProgram(
      this.hitFragmentShader_,
      this.hitVertexShader_
    ), this.hitRenderTarget_ = new g0(this.helper));
  }
  /**
   * @param {import("../../source/Vector.js").VectorSourceEvent} event Event.
   * @private
   */
  handleSourceFeatureAdded_(e) {
    const t = e.feature;
    this.featureCache_[B(t)] = {
      feature: t,
      properties: t.getProperties(),
      geometry: t.getGeometry()
    }, this.featureCount_++;
  }
  /**
   * @param {import("../../source/Vector.js").VectorSourceEvent} event Event.
   * @private
   */
  handleSourceFeatureChanged_(e) {
    const t = e.feature;
    this.featureCache_[B(t)] = {
      feature: t,
      properties: t.getProperties(),
      geometry: t.getGeometry()
    };
  }
  /**
   * @param {import("../../source/Vector.js").VectorSourceEvent} event Event.
   * @private
   */
  handleSourceFeatureDelete_(e) {
    const t = e.feature;
    delete this.featureCache_[B(t)], this.featureCount_--;
  }
  /**
   * @private
   */
  handleSourceFeatureClear_() {
    this.featureCache_ = {}, this.featureCount_ = 0;
  }
  /**
   * Render the layer.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {HTMLElement} The rendered element.
   */
  renderFrame(e) {
    const t = this.helper.getGL();
    this.preRender(t, e);
    const i = e.viewState.projection, o = this.getLayer().getSource().getWrapX() && i.canWrapX(), a = i.getExtent(), l = e.extent, h = o ? te(a) : null, c = o ? Math.ceil((l[2] - a[2]) / h) + 1 : 1, u = o ? Math.floor((l[0] - a[0]) / h) : 0;
    let d = u;
    const f = this.indicesBuffer_.getSize();
    do
      this.helper.makeProjectionTransform(e, this.currentTransform_), ml(this.currentTransform_, d * h, 0), Nn(this.currentTransform_, this.invertRenderTransform_), this.helper.applyUniforms(e), this.helper.drawElements(0, f);
    while (++d < c);
    this.helper.finalizeDraw(
      e,
      this.dispatchPreComposeEvent,
      this.dispatchPostComposeEvent
    );
    const g = this.helper.getCanvas();
    return this.hitDetectionEnabled_ && (this.renderHitDetection(e, u, c, h), this.hitRenderTarget_.clearCachedData()), this.postRender(t, e), g;
  }
  /**
   * Determine whether renderFrame should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */
  prepareFrameInternal(e) {
    const t = this.getLayer(), i = t.getSource(), n = e.viewState, r = !e.viewHints[ge.ANIMATING] && !e.viewHints[ge.INTERACTING], o = !ti(this.previousExtent_, e.extent), a = this.sourceRevision_ < i.getRevision();
    if (a && (this.sourceRevision_ = i.getRevision()), r && (o || a)) {
      const l = n.projection, h = n.resolution, c = t instanceof br ? t.getRenderBuffer() : 0, u = Si(e.extent, c * h);
      i.loadFeatures(u, h, l), this.rebuildBuffers_(e), this.previousExtent_ = e.extent.slice();
    }
    return this.helper.useProgram(this.program_, e), this.helper.prepareDraw(e), this.helper.bindBuffer(this.verticesBuffer_), this.helper.bindBuffer(this.indicesBuffer_), this.helper.enableAttributes(this.attributes), !0;
  }
  /**
   * Rebuild internal webgl buffers based on current view extent; costly, should not be called too much
   * @param {import("../../Map").FrameState} frameState Frame state.
   * @private
   */
  rebuildBuffers_(e) {
    const t = Se();
    this.helper.makeProjectionTransform(e, t);
    const i = (2 + this.customAttributes.length) * this.featureCount_;
    if ((!this.renderInstructions_ || this.renderInstructions_.length !== i) && (this.renderInstructions_ = new Float32Array(i)), this.hitDetectionEnabled_) {
      const d = (7 + this.customAttributes.length) * this.featureCount_;
      (!this.hitRenderInstructions_ || this.hitRenderInstructions_.length !== d) && (this.hitRenderInstructions_ = new Float32Array(
        d
      ));
    }
    let n, r;
    const o = [], a = [];
    let l = 0, h = 0, c;
    for (const d in this.featureCache_) {
      if (n = this.featureCache_[d], r = /** @type {import("../../geom").Point} */
      n.geometry, !r || r.getType() !== "Point")
        continue;
      o[0] = r.getFlatCoordinates()[0], o[1] = r.getFlatCoordinates()[1], de(t, o), c = F0(h + 6, a), this.renderInstructions_[l++] = o[0], this.renderInstructions_[l++] = o[1], this.hitDetectionEnabled_ && (this.hitRenderInstructions_[h++] = o[0], this.hitRenderInstructions_[h++] = o[1], this.hitRenderInstructions_[h++] = c[0], this.hitRenderInstructions_[h++] = c[1], this.hitRenderInstructions_[h++] = c[2], this.hitRenderInstructions_[h++] = c[3], this.hitRenderInstructions_[h++] = Number(d));
      let f;
      for (let g = 0; g < this.customAttributes.length; g++)
        f = this.customAttributes[g].callback(
          n.feature,
          n.properties
        ), this.renderInstructions_[l++] = f, this.hitDetectionEnabled_ && (this.hitRenderInstructions_[h++] = f);
    }
    const u = {
      id: 0,
      type: po.GENERATE_POINT_BUFFERS,
      renderInstructions: this.renderInstructions_.buffer,
      customAttributesCount: this.customAttributes.length
    };
    if (u.projectionTransform = t, u.generateBuffersRun = ++this.generateBuffersRun_, this.ready = !1, this.worker_.postMessage(u, [this.renderInstructions_.buffer]), this.renderInstructions_ = null, this.hitDetectionEnabled_) {
      const d = {
        id: 0,
        type: po.GENERATE_POINT_BUFFERS,
        renderInstructions: this.hitRenderInstructions_.buffer,
        customAttributesCount: 5 + this.customAttributes.length
      };
      d.projectionTransform = t, d.hitDetection = !0, this.worker_.postMessage(d, [
        this.hitRenderInstructions_.buffer
      ]), this.hitRenderInstructions_ = null;
    }
  }
  /**
   * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {import("../vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {Array<import("../Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
   * @return {T|undefined} Callback result.
   * @template T
   */
  forEachFeatureAtCoordinate(e, t, i, n, r) {
    if (Z(this.hitDetectionEnabled_, 66), !this.hitRenderInstructions_)
      return;
    const o = de(
      t.coordinateToPixelTransform,
      e.slice()
    ), a = this.hitRenderTarget_.readPixel(o[0] / 2, o[1] / 2), l = [a[0] / 255, a[1] / 255, a[2] / 255, a[3] / 255], h = b0(l), c = this.hitRenderInstructions_[h], u = Math.floor(c).toString(), f = this.getLayer().getSource().getFeatureByUid(u);
    if (f)
      return n(f, this.getLayer(), null);
  }
  /**
   * Render the hit detection data to the corresponding render target
   * @param {import("../../Map.js").FrameState} frameState current frame state
   * @param {number} startWorld the world to render in the first iteration
   * @param {number} endWorld the last world to render
   * @param {number} worldWidth the width of the worlds being rendered
   */
  renderHitDetection(e, t, i, n) {
    if (!this.hitVerticesBuffer_.getSize())
      return;
    let r = t;
    this.hitRenderTarget_.setSize([
      Math.floor(e.size[0] / 2),
      Math.floor(e.size[1] / 2)
    ]), this.helper.useProgram(this.hitProgram_, e), this.helper.prepareDrawToRenderTarget(
      e,
      this.hitRenderTarget_,
      !0
    ), this.helper.bindBuffer(this.hitVerticesBuffer_), this.helper.bindBuffer(this.indicesBuffer_), this.helper.enableAttributes(this.hitDetectionAttributes);
    do {
      this.helper.makeProjectionTransform(e, this.currentTransform_), ml(this.currentTransform_, r * n, 0), Nn(this.currentTransform_, this.invertRenderTransform_), this.helper.applyUniforms(e);
      const o = this.indicesBuffer_.getSize();
      this.helper.drawElements(0, o);
    } while (++r < i);
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    this.worker_.terminate(), this.layer_ = null, this.sourceListenKeys_.forEach(function(e) {
      re(e);
    }), this.sourceListenKeys_ = null, super.disposeInternal();
  }
}
const O0 = M0, st = {
  BLUR: "blur",
  GRADIENT: "gradient",
  RADIUS: "radius"
}, D0 = ["#00f", "#0ff", "#0f0", "#ff0", "#f00"];
class k0 extends br {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {};
    const t = Object.assign({}, e);
    delete t.gradient, delete t.radius, delete t.blur, delete t.weight, super(t), this.gradient_ = null, this.addChangeListener(st.GRADIENT, this.handleGradientChanged_), this.setGradient(e.gradient ? e.gradient : D0), this.setBlur(e.blur !== void 0 ? e.blur : 15), this.setRadius(e.radius !== void 0 ? e.radius : 8);
    const i = e.weight ? e.weight : "weight";
    typeof i == "string" ? this.weightFunction_ = function(n) {
      return n.get(i);
    } : this.weightFunction_ = i, this.setRenderOrder(null);
  }
  /**
   * Return the blur size in pixels.
   * @return {number} Blur size in pixels.
   * @api
   * @observable
   */
  getBlur() {
    return (
      /** @type {number} */
      this.get(st.BLUR)
    );
  }
  /**
   * Return the gradient colors as array of strings.
   * @return {Array<string>} Colors.
   * @api
   * @observable
   */
  getGradient() {
    return (
      /** @type {Array<string>} */
      this.get(st.GRADIENT)
    );
  }
  /**
   * Return the size of the radius in pixels.
   * @return {number} Radius size in pixel.
   * @api
   * @observable
   */
  getRadius() {
    return (
      /** @type {number} */
      this.get(st.RADIUS)
    );
  }
  /**
   * @private
   */
  handleGradientChanged_() {
    this.gradient_ = N0(this.getGradient());
  }
  /**
   * Set the blur size in pixels.
   * @param {number} blur Blur size in pixels.
   * @api
   * @observable
   */
  setBlur(e) {
    this.set(st.BLUR, e);
  }
  /**
   * Set the gradient colors as array of strings.
   * @param {Array<string>} colors Gradient.
   * @api
   * @observable
   */
  setGradient(e) {
    this.set(st.GRADIENT, e);
  }
  /**
   * Set the size of the radius in pixels.
   * @param {number} radius Radius size in pixel.
   * @api
   * @observable
   */
  setRadius(e) {
    this.set(st.RADIUS, e);
  }
  createRenderer() {
    return new O0(this, {
      className: this.getClassName(),
      attributes: [
        {
          name: "weight",
          callback: (e) => {
            const t = this.weightFunction_(e);
            return t !== void 0 ? _e(t, 0, 1) : 1;
          }
        }
      ],
      vertexShader: `
        precision mediump float;
        uniform mat4 u_projectionMatrix;
        uniform mat4 u_offsetScaleMatrix;
        uniform float u_size;
        attribute vec2 a_position;
        attribute float a_index;
        attribute float a_weight;

        varying vec2 v_texCoord;
        varying float v_weight;

        void main(void) {
          mat4 offsetMatrix = u_offsetScaleMatrix;
          float offsetX = a_index == 0.0 || a_index == 3.0 ? -u_size / 2.0 : u_size / 2.0;
          float offsetY = a_index == 0.0 || a_index == 1.0 ? -u_size / 2.0 : u_size / 2.0;
          vec4 offsets = offsetMatrix * vec4(offsetX, offsetY, 0.0, 0.0);
          gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0) + offsets;
          float u = a_index == 0.0 || a_index == 3.0 ? 0.0 : 1.0;
          float v = a_index == 0.0 || a_index == 1.0 ? 0.0 : 1.0;
          v_texCoord = vec2(u, v);
          v_weight = a_weight;
        }`,
      fragmentShader: `
        precision mediump float;
        uniform float u_blurSlope;

        varying vec2 v_texCoord;
        varying float v_weight;

        void main(void) {
          vec2 texCoord = v_texCoord * 2.0 - vec2(1.0, 1.0);
          float sqRadius = texCoord.x * texCoord.x + texCoord.y * texCoord.y;
          float value = (1.0 - sqrt(sqRadius)) * u_blurSlope;
          float alpha = smoothstep(0.0, 1.0, value) * v_weight;
          gl_FragColor = vec4(alpha, alpha, alpha, alpha);
        }`,
      hitVertexShader: `
        precision mediump float;
        uniform mat4 u_projectionMatrix;
        uniform mat4 u_offsetScaleMatrix;
        uniform float u_size;
        attribute vec2 a_position;
        attribute float a_index;
        attribute float a_weight;
        attribute vec4 a_hitColor;

        varying vec2 v_texCoord;
        varying float v_weight;
        varying vec4 v_hitColor;

        void main(void) {
          mat4 offsetMatrix = u_offsetScaleMatrix;
          float offsetX = a_index == 0.0 || a_index == 3.0 ? -u_size / 2.0 : u_size / 2.0;
          float offsetY = a_index == 0.0 || a_index == 1.0 ? -u_size / 2.0 : u_size / 2.0;
          vec4 offsets = offsetMatrix * vec4(offsetX, offsetY, 0.0, 0.0);
          gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0) + offsets;
          float u = a_index == 0.0 || a_index == 3.0 ? 0.0 : 1.0;
          float v = a_index == 0.0 || a_index == 1.0 ? 0.0 : 1.0;
          v_texCoord = vec2(u, v);
          v_hitColor = a_hitColor;
          v_weight = a_weight;
        }`,
      hitFragmentShader: `
        precision mediump float;
        uniform float u_blurSlope;

        varying vec2 v_texCoord;
        varying float v_weight;
        varying vec4 v_hitColor;

        void main(void) {
          vec2 texCoord = v_texCoord * 2.0 - vec2(1.0, 1.0);
          float sqRadius = texCoord.x * texCoord.x + texCoord.y * texCoord.y;
          float value = (1.0 - sqrt(sqRadius)) * u_blurSlope;
          float alpha = smoothstep(0.0, 1.0, value) * v_weight;
          if (alpha < 0.05) {
            discard;
          }

          gl_FragColor = v_hitColor;
        }`,
      uniforms: {
        u_size: () => (this.get(st.RADIUS) + this.get(st.BLUR)) * 2,
        u_blurSlope: () => this.get(st.RADIUS) / Math.max(1, this.get(st.BLUR))
      },
      postProcesses: [
        {
          fragmentShader: `
            precision mediump float;

            uniform sampler2D u_image;
            uniform sampler2D u_gradientTexture;
            uniform float u_opacity;

            varying vec2 v_texCoord;

            void main() {
              vec4 color = texture2D(u_image, v_texCoord);
              gl_FragColor.a = color.a * u_opacity;
              gl_FragColor.rgb = texture2D(u_gradientTexture, vec2(0.5, color.a)).rgb;
              gl_FragColor.rgb *= gl_FragColor.a;
            }`,
          uniforms: {
            u_gradientTexture: () => this.gradient_,
            u_opacity: () => this.getOpacity()
          }
        }
      ]
    });
  }
  renderDeclutter() {
  }
}
function N0(s) {
  const i = Re(1, 256), n = i.createLinearGradient(0, 0, 1, 256), r = 1 / (s.length - 1);
  for (let o = 0, a = s.length; o < a; ++o)
    n.addColorStop(o * r, s[o]);
  return i.fillStyle = n, i.fillRect(0, 0, 1, 256), i.canvas;
}
const G0 = k0, Br = {};
Br["zh-cn"] = {
  measure_start_point: "起点"
};
Br["en-us"] = {
  measure_start_point: "starting point"
};
Br["zh-tw"] = {
  measure_start_point: "起點"
};
function U0(s = "zh-cn") {
  return Br[s];
}
const Xs = {
  /**
   * Triggered upon feature draw start
   * @event DrawEvent#drawstart
   * @api
   */
  DRAWSTART: "drawstart",
  /**
   * Triggered upon feature draw end
   * @event DrawEvent#drawend
   * @api
   */
  DRAWEND: "drawend",
  /**
   * Triggered upon feature draw abortion
   * @event DrawEvent#drawabort
   * @api
   */
  DRAWABORT: "drawabort"
};
class Ws extends Ye {
  /**
   * @param {DrawEventType} type Type.
   * @param {Feature} feature The feature drawn.
   */
  constructor(e, t) {
    super(e), this.feature = t;
  }
}
function z0(s, e) {
  const t = [];
  for (let i = 0; i < e.length; ++i) {
    const r = e[i].getGeometry();
    Su(s, r, t);
  }
  return t;
}
function Ys(s, e) {
  return bt(s[0], s[1], e[0], e[1]);
}
function Zi(s, e) {
  const t = s.length;
  return e < 0 ? s[e + t] : e >= t ? s[e - t] : s[e];
}
function Vs(s, e, t) {
  let i, n;
  e < t ? (i = e, n = t) : (i = t, n = e);
  const r = Math.ceil(i), o = Math.floor(n);
  if (r > o) {
    const l = ji(s, i), h = ji(s, n);
    return Ys(l, h);
  }
  let a = 0;
  if (i < r) {
    const l = ji(s, i), h = Zi(s, r);
    a += Ys(l, h);
  }
  if (o < n) {
    const l = Zi(s, o), h = ji(s, n);
    a += Ys(l, h);
  }
  for (let l = r; l < o - 1; ++l) {
    const h = Zi(s, l), c = Zi(s, l + 1);
    a += Ys(h, c);
  }
  return a;
}
function Su(s, e, t) {
  if (e instanceof qe) {
    Zs(s, e.getCoordinates(), !1, t);
    return;
  }
  if (e instanceof fs) {
    const i = e.getCoordinates();
    for (let n = 0, r = i.length; n < r; ++n)
      Zs(s, i[n], !1, t);
    return;
  }
  if (e instanceof We) {
    const i = e.getCoordinates();
    for (let n = 0, r = i.length; n < r; ++n)
      Zs(s, i[n], !0, t);
    return;
  }
  if (e instanceof Pr) {
    const i = e.getCoordinates();
    for (let n = 0, r = i.length; n < r; ++n) {
      const o = i[n];
      for (let a = 0, l = o.length; a < l; ++a)
        Zs(s, o[a], !0, t);
    }
    return;
  }
  if (e instanceof Mt) {
    const i = e.getGeometries();
    for (let n = 0; n < i.length; ++n)
      Su(s, i[n], t);
    return;
  }
}
const yo = { index: -1, endIndex: NaN };
function B0(s, e, t, i) {
  const n = s[0], r = s[1];
  let o = 1 / 0, a = -1, l = NaN;
  for (let u = 0; u < e.targets.length; ++u) {
    const d = e.targets[u], f = d.coordinates;
    let g = 1 / 0, _;
    for (let m = 0; m < f.length - 1; ++m) {
      const p = f[m], x = f[m + 1], y = Ru(n, r, p, x);
      y.squaredDistance < g && (g = y.squaredDistance, _ = m + y.along);
    }
    g < o && (o = g, d.ring && e.targetIndex === u && (d.endIndex > d.startIndex ? _ < d.startIndex && (_ += f.length) : d.endIndex < d.startIndex && _ > d.startIndex && (_ -= f.length)), l = _, a = u);
  }
  const h = e.targets[a];
  let c = h.ring;
  if (e.targetIndex === a && c) {
    const u = ji(
      h.coordinates,
      l
    ), d = t.getPixelFromCoordinate(u);
    ir(d, e.startPx) > i && (c = !1);
  }
  if (c) {
    const u = h.coordinates, d = u.length, f = h.startIndex, g = l;
    if (f < g) {
      const _ = Vs(
        u,
        f,
        g
      );
      Vs(
        u,
        f,
        g - d
      ) < _ && (l -= d);
    } else {
      const _ = Vs(
        u,
        f,
        g
      );
      Vs(
        u,
        f,
        g + d
      ) < _ && (l += d);
    }
  }
  return yo.index = a, yo.endIndex = l, yo;
}
function Zs(s, e, t, i) {
  const n = s[0], r = s[1];
  for (let o = 0, a = e.length - 1; o < a; ++o) {
    const l = e[o], h = e[o + 1], c = Ru(n, r, l, h);
    if (c.squaredDistance === 0) {
      const u = o + c.along;
      i.push({
        coordinates: e,
        ring: t,
        startIndex: u,
        endIndex: u
      });
      return;
    }
  }
}
const xo = { along: 0, squaredDistance: 0 };
function Ru(s, e, t, i) {
  const n = t[0], r = t[1], o = i[0], a = i[1], l = o - n, h = a - r;
  let c = 0, u = n, d = r;
  return (l !== 0 || h !== 0) && (c = _e(((s - n) * l + (e - r) * h) / (l * l + h * h), 0, 1), u += l * c, d += h * c), xo.along = c, xo.squaredDistance = Sr(bt(s, e, u, d), 10), xo;
}
function ji(s, e) {
  const t = s.length;
  let i = Math.floor(e);
  const n = e - i;
  i >= t ? i -= t : i < 0 && (i += t);
  let r = i + 1;
  r >= t && (r -= t);
  const o = s[i], a = o[0], l = o[1], h = s[r], c = h[0] - a, u = h[1] - l;
  return [a + c * n, l + u * n];
}
class X0 extends Dt {
  /**
   * @param {Options} options Options.
   */
  constructor(e) {
    const t = (
      /** @type {import("./Pointer.js").Options} */
      e
    );
    t.stopDown || (t.stopDown = cn), super(t), this.on, this.once, this.un, this.shouldHandle_ = !1, this.downPx_ = null, this.downTimeout_, this.lastDragTime_, this.pointerType_, this.freehand_ = !1, this.source_ = e.source ? e.source : null, this.features_ = e.features ? e.features : null, this.snapTolerance_ = e.snapTolerance ? e.snapTolerance : 12, this.type_ = /** @type {import("../geom/Geometry.js").Type} */
    e.type, this.mode_ = Z0(this.type_), this.stopClick_ = !!e.stopClick, this.minPoints_ = e.minPoints ? e.minPoints : this.mode_ === "Polygon" ? 3 : 2, this.maxPoints_ = this.mode_ === "Circle" ? 2 : e.maxPoints ? e.maxPoints : 1 / 0, this.finishCondition_ = e.finishCondition ? e.finishCondition : mt, this.geometryLayout_ = e.geometryLayout ? e.geometryLayout : "XY";
    let i = e.geometryFunction;
    if (!i) {
      const n = this.mode_;
      if (n === "Circle")
        i = function(r, o, a) {
          const l = o || new rl([NaN, NaN]), h = he(r[0]), c = Ci(
            h,
            he(r[r.length - 1])
          );
          return l.setCenterAndRadius(
            h,
            Math.sqrt(c),
            this.geometryLayout_
          ), l;
        };
      else {
        let r;
        n === "Point" ? r = Ee : n === "LineString" ? r = qe : n === "Polygon" && (r = We), i = function(o, a, l) {
          return a ? n === "Polygon" ? o[0].length ? a.setCoordinates(
            [o[0].concat([o[0][0]])],
            this.geometryLayout_
          ) : a.setCoordinates([], this.geometryLayout_) : a.setCoordinates(o, this.geometryLayout_) : a = new r(o, this.geometryLayout_), a;
        };
      }
    }
    this.geometryFunction_ = i, this.dragVertexDelay_ = e.dragVertexDelay !== void 0 ? e.dragVertexDelay : 500, this.finishCoordinate_ = null, this.sketchFeature_ = null, this.sketchPoint_ = null, this.sketchCoords_ = null, this.sketchLine_ = null, this.sketchLineCoords_ = null, this.squaredClickTolerance_ = e.clickTolerance ? e.clickTolerance * e.clickTolerance : 36, this.overlay_ = new Be({
      source: new we({
        useSpatialIndex: !1,
        wrapX: e.wrapX ? e.wrapX : !1
      }),
      style: e.style ? e.style : W0(),
      updateWhileInteracting: !0
    }), this.geometryName_ = e.geometryName, this.condition_ = e.condition ? e.condition : Na, this.freehandCondition_, e.freehand ? this.freehandCondition_ = Hn : this.freehandCondition_ = e.freehandCondition ? e.freehandCondition : Ga, this.traceCondition_, this.setTrace(e.trace || !1), this.traceState_ = { active: !1 }, this.traceSource_ = e.traceSource || e.source || null, this.addChangeListener(fr.ACTIVE, this.updateState_);
  }
  /**
   * Toggle tracing mode or set a tracing condition.
   *
   * @param {boolean|import("../events/condition.js").Condition} trace A boolean to toggle tracing mode or an event
   *     condition that will be checked when a feature is clicked to determine if tracing should be active.
   */
  setTrace(e) {
    let t;
    e ? e === !0 ? t = Hn : t = e : t = Xo, this.traceCondition_ = t;
  }
  /**
   * Remove the interaction from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default} map Map.
   */
  setMap(e) {
    super.setMap(e), this.updateState_();
  }
  /**
   * Get the overlay layer that this interaction renders sketch features to.
   * @return {VectorLayer} Overlay layer.
   * @api
   */
  getOverlay() {
    return this.overlay_;
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may actually draw or finish the drawing.
   * @param {import("../MapBrowserEvent.js").default} event Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @api
   */
  handleEvent(e) {
    e.originalEvent.type === z.CONTEXTMENU && e.originalEvent.preventDefault(), this.freehand_ = this.mode_ !== "Point" && this.freehandCondition_(e);
    let t = e.type === J.POINTERMOVE, i = !0;
    return !this.freehand_ && this.lastDragTime_ && e.type === J.POINTERDRAG && (Date.now() - this.lastDragTime_ >= this.dragVertexDelay_ ? (this.downPx_ = e.pixel, this.shouldHandle_ = !this.freehand_, t = !0) : this.lastDragTime_ = void 0, this.shouldHandle_ && this.downTimeout_ !== void 0 && (clearTimeout(this.downTimeout_), this.downTimeout_ = void 0)), this.freehand_ && e.type === J.POINTERDRAG && this.sketchFeature_ !== null ? (this.addToDrawing_(e.coordinate), i = !1) : this.freehand_ && e.type === J.POINTERDOWN ? i = !1 : t && this.getPointerCount() < 2 ? (i = e.type === J.POINTERMOVE, i && this.freehand_ ? (this.handlePointerMove_(e), this.shouldHandle_ && e.originalEvent.preventDefault()) : (e.originalEvent.pointerType === "mouse" || e.type === J.POINTERDRAG && this.downTimeout_ === void 0) && this.handlePointerMove_(e)) : e.type === J.DBLCLICK && (i = !1), super.handleEvent(e) && i;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @return {boolean} If the event was consumed.
   */
  handleDownEvent(e) {
    return this.shouldHandle_ = !this.freehand_, this.freehand_ ? (this.downPx_ = e.pixel, this.finishCoordinate_ || this.startDrawing_(e.coordinate), !0) : this.condition_(e) ? (this.lastDragTime_ = Date.now(), this.downTimeout_ = setTimeout(() => {
      this.handlePointerMove_(
        new Lt(
          J.POINTERMOVE,
          e.map,
          e.originalEvent,
          !1,
          e.frameState
        )
      );
    }, this.dragVertexDelay_), this.downPx_ = e.pixel, !0) : (this.lastDragTime_ = void 0, !1);
  }
  /**
   * @private
   */
  deactivateTrace_() {
    this.traceState_ = { active: !1 };
  }
  /**
   * Activate or deactivate trace state based on a browser event.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @private
   */
  toggleTraceState_(e) {
    if (!this.traceSource_ || !this.traceCondition_(e))
      return;
    if (this.traceState_.active) {
      this.deactivateTrace_();
      return;
    }
    const t = this.getMap(), i = t.getCoordinateFromPixel([
      e.pixel[0] - this.snapTolerance_,
      e.pixel[1] + this.snapTolerance_
    ]), n = t.getCoordinateFromPixel([
      e.pixel[0] + this.snapTolerance_,
      e.pixel[1] - this.snapTolerance_
    ]), r = ze([i, n]), o = this.traceSource_.getFeaturesInExtent(r);
    if (o.length === 0)
      return;
    const a = z0(e.coordinate, o);
    a.length && (this.traceState_ = {
      active: !0,
      startPx: e.pixel.slice(),
      targets: a,
      targetIndex: -1
    });
  }
  /**
   * @param {TraceTarget} target The trace target.
   * @param {number} endIndex The new end index of the trace.
   * @private
   */
  addOrRemoveTracedCoordinates_(e, t) {
    const i = e.startIndex <= e.endIndex, n = e.startIndex <= t;
    i === n ? i && t > e.endIndex || !i && t < e.endIndex ? this.addTracedCoordinates_(e, e.endIndex, t) : (i && t < e.endIndex || !i && t > e.endIndex) && this.removeTracedCoordinates_(t, e.endIndex) : (this.removeTracedCoordinates_(e.startIndex, e.endIndex), this.addTracedCoordinates_(e, e.startIndex, t));
  }
  /**
   * @param {number} fromIndex The start index.
   * @param {number} toIndex The end index.
   * @private
   */
  removeTracedCoordinates_(e, t) {
    if (e === t)
      return;
    let i = 0;
    if (e < t) {
      const n = Math.ceil(e);
      let r = Math.floor(t);
      r === t && (r -= 1), i = r - n + 1;
    } else {
      const n = Math.floor(e);
      let r = Math.ceil(t);
      r === t && (r += 1), i = n - r + 1;
    }
    i > 0 && this.removeLastPoints_(i);
  }
  /**
   * @param {TraceTarget} target The trace target.
   * @param {number} fromIndex The start index.
   * @param {number} toIndex The end index.
   * @private
   */
  addTracedCoordinates_(e, t, i) {
    if (t === i)
      return;
    const n = [];
    if (t < i) {
      const r = Math.ceil(t);
      let o = Math.floor(i);
      o === i && (o -= 1);
      for (let a = r; a <= o; ++a)
        n.push(Zi(e.coordinates, a));
    } else {
      const r = Math.floor(t);
      let o = Math.ceil(i);
      o === i && (o += 1);
      for (let a = r; a >= o; --a)
        n.push(Zi(e.coordinates, a));
    }
    n.length && this.appendCoordinates(n);
  }
  /**
   * Update the trace.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @private
   */
  updateTrace_(e) {
    const t = this.traceState_;
    if (!t.active || t.targetIndex === -1 && ir(t.startPx, e.pixel) < this.snapTolerance_)
      return;
    const i = B0(
      e.coordinate,
      t,
      this.getMap(),
      this.snapTolerance_
    );
    if (t.targetIndex !== i.index) {
      if (t.targetIndex !== -1) {
        const l = t.targets[t.targetIndex];
        this.removeTracedCoordinates_(l.startIndex, l.endIndex);
      }
      const a = t.targets[i.index];
      this.addTracedCoordinates_(
        a,
        a.startIndex,
        i.endIndex
      );
    } else {
      const a = t.targets[t.targetIndex];
      this.addOrRemoveTracedCoordinates_(a, i.endIndex);
    }
    t.targetIndex = i.index;
    const n = t.targets[t.targetIndex];
    n.endIndex = i.endIndex;
    const r = ji(
      n.coordinates,
      n.endIndex
    ), o = this.getMap().getPixelFromCoordinate(r);
    e.coordinate = r, e.pixel = [Math.round(o[0]), Math.round(o[1])];
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @return {boolean} If the event was consumed.
   */
  handleUpEvent(e) {
    let t = !0;
    if (this.getPointerCount() === 0) {
      this.downTimeout_ && (clearTimeout(this.downTimeout_), this.downTimeout_ = void 0), this.handlePointerMove_(e);
      const i = this.traceState_.active;
      if (this.toggleTraceState_(e), this.shouldHandle_) {
        const n = !this.finishCoordinate_;
        n && this.startDrawing_(e.coordinate), !n && this.freehand_ ? this.finishDrawing() : !this.freehand_ && (!n || this.mode_ === "Point") && (this.atFinish_(e.pixel, i) ? this.finishCondition_(e) && this.finishDrawing() : this.addToDrawing_(e.coordinate)), t = !1;
      } else
        this.freehand_ && this.abortDrawing();
    }
    return !t && this.stopClick_ && e.preventDefault(), t;
  }
  /**
   * Handle move events.
   * @param {import("../MapBrowserEvent.js").default} event A move event.
   * @private
   */
  handlePointerMove_(e) {
    if (this.pointerType_ = e.originalEvent.pointerType, this.downPx_ && (!this.freehand_ && this.shouldHandle_ || this.freehand_ && !this.shouldHandle_)) {
      const t = this.downPx_, i = e.pixel, n = t[0] - i[0], r = t[1] - i[1], o = n * n + r * r;
      if (this.shouldHandle_ = this.freehand_ ? o > this.squaredClickTolerance_ : o <= this.squaredClickTolerance_, !this.shouldHandle_)
        return;
    }
    if (!this.finishCoordinate_) {
      this.createOrUpdateSketchPoint_(e.coordinate.slice());
      return;
    }
    this.updateTrace_(e), this.modifyDrawing_(e.coordinate);
  }
  /**
   * Determine if an event is within the snapping tolerance of the start coord.
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @param {boolean} [tracing] Drawing in trace mode (only stop if at the starting point).
   * @return {boolean} The event is within the snapping tolerance of the start.
   * @private
   */
  atFinish_(e, t) {
    let i = !1;
    if (this.sketchFeature_) {
      let n = !1, r = [this.finishCoordinate_];
      const o = this.mode_;
      if (o === "Point")
        i = !0;
      else if (o === "Circle")
        i = this.sketchCoords_.length === 2;
      else if (o === "LineString")
        n = !t && this.sketchCoords_.length > this.minPoints_;
      else if (o === "Polygon") {
        const a = (
          /** @type {PolyCoordType} */
          this.sketchCoords_
        );
        n = a[0].length > this.minPoints_, r = [
          a[0][0],
          a[0][a[0].length - 2]
        ], t ? r = [a[0][0]] : r = [
          a[0][0],
          a[0][a[0].length - 2]
        ];
      }
      if (n) {
        const a = this.getMap();
        for (let l = 0, h = r.length; l < h; l++) {
          const c = r[l], u = a.getPixelFromCoordinate(c), d = e[0] - u[0], f = e[1] - u[1], g = this.freehand_ ? 1 : this.snapTolerance_;
          if (i = Math.sqrt(d * d + f * f) <= g, i) {
            this.finishCoordinate_ = c;
            break;
          }
        }
      }
    }
    return i;
  }
  /**
   * @param {import("../coordinate").Coordinate} coordinates Coordinate.
   * @private
   */
  createOrUpdateSketchPoint_(e) {
    this.sketchPoint_ ? this.sketchPoint_.getGeometry().setCoordinates(e) : (this.sketchPoint_ = new $(new Ee(e)), this.updateSketchFeatures_());
  }
  /**
   * @param {import("../geom/Polygon.js").default} geometry Polygon geometry.
   * @private
   */
  createOrUpdateCustomSketchLine_(e) {
    this.sketchLine_ || (this.sketchLine_ = new $());
    const t = e.getLinearRing(0);
    let i = this.sketchLine_.getGeometry();
    i ? (i.setFlatCoordinates(
      t.getLayout(),
      t.getFlatCoordinates()
    ), i.changed()) : (i = new qe(
      t.getFlatCoordinates(),
      t.getLayout()
    ), this.sketchLine_.setGeometry(i));
  }
  /**
   * Start the drawing.
   * @param {import("../coordinate.js").Coordinate} start Start coordinate.
   * @private
   */
  startDrawing_(e) {
    const t = this.getMap().getView().getProjection(), i = rr(this.geometryLayout_);
    for (; e.length < i; )
      e.push(0);
    this.finishCoordinate_ = e, this.mode_ === "Point" ? this.sketchCoords_ = e.slice() : this.mode_ === "Polygon" ? (this.sketchCoords_ = [[e.slice(), e.slice()]], this.sketchLineCoords_ = this.sketchCoords_[0]) : this.sketchCoords_ = [e.slice(), e.slice()], this.sketchLineCoords_ && (this.sketchLine_ = new $(new qe(this.sketchLineCoords_)));
    const n = this.geometryFunction_(
      this.sketchCoords_,
      void 0,
      t
    );
    this.sketchFeature_ = new $(), this.geometryName_ && this.sketchFeature_.setGeometryName(this.geometryName_), this.sketchFeature_.setGeometry(n), this.updateSketchFeatures_(), this.dispatchEvent(
      new Ws(Xs.DRAWSTART, this.sketchFeature_)
    );
  }
  /**
   * Modify the drawing.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @private
   */
  modifyDrawing_(e) {
    const t = this.getMap(), i = this.sketchFeature_.getGeometry(), n = t.getView().getProjection(), r = rr(this.geometryLayout_);
    let o, a;
    for (; e.length < r; )
      e.push(0);
    this.mode_ === "Point" ? a = this.sketchCoords_ : this.mode_ === "Polygon" ? (o = /** @type {PolyCoordType} */
    this.sketchCoords_[0], a = o[o.length - 1], this.atFinish_(t.getPixelFromCoordinate(e)) && (e = this.finishCoordinate_.slice())) : (o = this.sketchCoords_, a = o[o.length - 1]), a[0] = e[0], a[1] = e[1], this.geometryFunction_(
      /** @type {!LineCoordType} */
      this.sketchCoords_,
      i,
      n
    ), this.sketchPoint_ && this.sketchPoint_.getGeometry().setCoordinates(e), i.getType() === "Polygon" && this.mode_ !== "Polygon" ? this.createOrUpdateCustomSketchLine_(
      /** @type {Polygon} */
      i
    ) : this.sketchLineCoords_ && this.sketchLine_.getGeometry().setCoordinates(this.sketchLineCoords_), this.updateSketchFeatures_();
  }
  /**
   * Add a new coordinate to the drawing.
   * @param {!PointCoordType} coordinate Coordinate
   * @private
   */
  addToDrawing_(e) {
    const t = this.sketchFeature_.getGeometry(), i = this.getMap().getView().getProjection();
    let n, r;
    const o = this.mode_;
    o === "LineString" || o === "Circle" ? (this.finishCoordinate_ = e.slice(), r = /** @type {LineCoordType} */
    this.sketchCoords_, r.length >= this.maxPoints_ && (this.freehand_ ? r.pop() : n = !0), r.push(e.slice()), this.geometryFunction_(r, t, i)) : o === "Polygon" && (r = /** @type {PolyCoordType} */
    this.sketchCoords_[0], r.length >= this.maxPoints_ && (this.freehand_ ? r.pop() : n = !0), r.push(e.slice()), n && (this.finishCoordinate_ = r[0]), this.geometryFunction_(this.sketchCoords_, t, i)), this.createOrUpdateSketchPoint_(e.slice()), this.updateSketchFeatures_(), n && this.finishDrawing();
  }
  /**
   * @param {number} n The number of points to remove.
   */
  removeLastPoints_(e) {
    if (!this.sketchFeature_)
      return;
    const t = this.sketchFeature_.getGeometry(), i = this.getMap().getView().getProjection(), n = this.mode_;
    for (let r = 0; r < e; ++r) {
      let o;
      if (n === "LineString" || n === "Circle") {
        if (o = /** @type {LineCoordType} */
        this.sketchCoords_, o.splice(-2, 1), o.length >= 2) {
          this.finishCoordinate_ = o[o.length - 2].slice();
          const a = this.finishCoordinate_.slice();
          o[o.length - 1] = a, this.createOrUpdateSketchPoint_(a);
        }
        this.geometryFunction_(o, t, i), t.getType() === "Polygon" && this.sketchLine_ && this.createOrUpdateCustomSketchLine_(
          /** @type {Polygon} */
          t
        );
      } else if (n === "Polygon") {
        o = /** @type {PolyCoordType} */
        this.sketchCoords_[0], o.splice(-2, 1);
        const a = this.sketchLine_.getGeometry();
        if (o.length >= 2) {
          const l = o[o.length - 2].slice();
          o[o.length - 1] = l, this.createOrUpdateSketchPoint_(l);
        }
        a.setCoordinates(o), this.geometryFunction_(this.sketchCoords_, t, i);
      }
      if (o.length === 1) {
        this.abortDrawing();
        break;
      }
    }
    this.updateSketchFeatures_();
  }
  /**
   * Remove last point of the feature currently being drawn. Does not do anything when
   * drawing POINT or MULTI_POINT geometries.
   * @api
   */
  removeLastPoint() {
    this.removeLastPoints_(1);
  }
  /**
   * Stop drawing and add the sketch feature to the target layer.
   * The {@link module:ol/interaction/Draw~DrawEventType.DRAWEND} event is
   * dispatched before inserting the feature.
   * @api
   */
  finishDrawing() {
    const e = this.abortDrawing_();
    if (!e)
      return;
    let t = this.sketchCoords_;
    const i = e.getGeometry(), n = this.getMap().getView().getProjection();
    this.mode_ === "LineString" ? (t.pop(), this.geometryFunction_(t, i, n)) : this.mode_ === "Polygon" && (t[0].pop(), this.geometryFunction_(t, i, n), t = i.getCoordinates()), this.type_ === "MultiPoint" ? e.setGeometry(
      new gs([
        /** @type {PointCoordType} */
        t
      ])
    ) : this.type_ === "MultiLineString" ? e.setGeometry(
      new fs([
        /** @type {LineCoordType} */
        t
      ])
    ) : this.type_ === "MultiPolygon" && e.setGeometry(
      new Pr([
        /** @type {PolyCoordType} */
        t
      ])
    ), this.dispatchEvent(new Ws(Xs.DRAWEND, e)), this.features_ && this.features_.push(e), this.source_ && this.source_.addFeature(e);
  }
  /**
   * Stop drawing without adding the sketch feature to the target layer.
   * @return {Feature<import("../geom/SimpleGeometry.js").default>|null} The sketch feature (or null if none).
   * @private
   */
  abortDrawing_() {
    this.finishCoordinate_ = null;
    const e = this.sketchFeature_;
    return this.sketchFeature_ = null, this.sketchPoint_ = null, this.sketchLine_ = null, this.overlay_.getSource().clear(!0), this.deactivateTrace_(), e;
  }
  /**
   * Stop drawing without adding the sketch feature to the target layer.
   * @api
   */
  abortDrawing() {
    const e = this.abortDrawing_();
    e && this.dispatchEvent(new Ws(Xs.DRAWABORT, e));
  }
  /**
   * Append coordinates to the end of the geometry that is currently being drawn.
   * This can be used when drawing LineStrings or Polygons. Coordinates will
   * either be appended to the current LineString or the outer ring of the current
   * Polygon. If no geometry is being drawn, a new one will be created.
   * @param {!LineCoordType} coordinates Linear coordinates to be appended to
   * the coordinate array.
   * @api
   */
  appendCoordinates(e) {
    const t = this.mode_, i = !this.sketchFeature_;
    i && this.startDrawing_(e[0]);
    let n;
    if (t === "LineString" || t === "Circle")
      n = /** @type {LineCoordType} */
      this.sketchCoords_;
    else if (t === "Polygon")
      n = this.sketchCoords_ && this.sketchCoords_.length ? (
        /** @type {PolyCoordType} */
        this.sketchCoords_[0]
      ) : [];
    else
      return;
    i && n.shift(), n.pop();
    for (let o = 0; o < e.length; o++)
      this.addToDrawing_(e[o]);
    const r = e[e.length - 1];
    this.addToDrawing_(r), this.modifyDrawing_(r);
  }
  /**
   * Initiate draw mode by starting from an existing geometry which will
   * receive new additional points. This only works on features with
   * `LineString` geometries, where the interaction will extend lines by adding
   * points to the end of the coordinates array.
   * This will change the original feature, instead of drawing a copy.
   *
   * The function will dispatch a `drawstart` event.
   *
   * @param {!Feature<LineString>} feature Feature to be extended.
   * @api
   */
  extend(e) {
    const i = e.getGeometry();
    this.sketchFeature_ = e, this.sketchCoords_ = i.getCoordinates();
    const n = this.sketchCoords_[this.sketchCoords_.length - 1];
    this.finishCoordinate_ = n.slice(), this.sketchCoords_.push(n.slice()), this.sketchPoint_ = new $(new Ee(n)), this.updateSketchFeatures_(), this.dispatchEvent(
      new Ws(Xs.DRAWSTART, this.sketchFeature_)
    );
  }
  /**
   * Redraw the sketch features.
   * @private
   */
  updateSketchFeatures_() {
    const e = [];
    this.sketchFeature_ && e.push(this.sketchFeature_), this.sketchLine_ && e.push(this.sketchLine_), this.sketchPoint_ && e.push(this.sketchPoint_);
    const t = this.overlay_.getSource();
    t.clear(!0), t.addFeatures(e);
  }
  /**
   * @private
   */
  updateState_() {
    const e = this.getMap(), t = this.getActive();
    (!e || !t) && this.abortDrawing(), this.overlay_.setMap(t ? e : null);
  }
}
function W0() {
  const s = Va();
  return function(e, t) {
    return s[e.getGeometry().getType()];
  };
}
function Y0(s, e) {
  return function(t, i, n) {
    const r = he(
      /** @type {LineCoordType} */
      t[0]
    ), o = he(
      /** @type {LineCoordType} */
      t[t.length - 1]
    ), a = Math.sqrt(Ci(r, o));
    i = i || ff(new rl(r), s);
    let l = e;
    if (!e && e !== 0) {
      const h = o[0] - r[0], c = o[1] - r[1];
      l = Math.atan2(c, h);
    }
    return oc(
      /** @type {Polygon} */
      i,
      r,
      a,
      l
    ), i;
  };
}
function V0() {
  return function(s, e, t) {
    const i = ze(
      /** @type {LineCoordType} */
      [
        s[0],
        s[s.length - 1]
      ].map(function(r) {
        return he(r);
      })
    ), n = [
      [
        rn(i),
        un(i),
        os(i),
        Ot(i),
        rn(i)
      ]
    ];
    return e ? e.setCoordinates(n) : e = new We(n), e;
  };
}
function Z0(s) {
  switch (s) {
    case "Point":
    case "MultiPoint":
      return "Point";
    case "LineString":
    case "MultiLineString":
      return "LineString";
    case "Polygon":
    case "MultiPolygon":
      return "Polygon";
    case "Circle":
      return "Circle";
    default:
      throw new Error("Invalid type: " + s);
  }
}
const _n = X0, _h = 0, Dn = 1, mh = [0, 0, 0, 0], en = [], Eo = {
  /**
   * Triggered upon feature modification start
   * @event ModifyEvent#modifystart
   * @api
   */
  MODIFYSTART: "modifystart",
  /**
   * Triggered upon feature modification end
   * @event ModifyEvent#modifyend
   * @api
   */
  MODIFYEND: "modifyend"
};
class vo extends Ye {
  /**
   * @param {ModifyEventType} type Type.
   * @param {Collection<Feature>} features
   * The features modified.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent
   * Associated {@link module:ol/MapBrowserEvent~MapBrowserEvent}.
   */
  constructor(e, t, i) {
    super(e), this.features = t, this.mapBrowserEvent = i;
  }
}
let j0 = class extends Dt {
  /**
   * @param {Options} options Options.
   */
  constructor(e) {
    super(
      /** @type {import("./Pointer.js").Options} */
      e
    ), this.on, this.once, this.un, this.boundHandleFeatureChange_ = this.handleFeatureChange_.bind(this), this.condition_ = e.condition ? e.condition : mc, this.defaultDeleteCondition_ = function(i) {
      return uc(i) && gc(i);
    }, this.deleteCondition_ = e.deleteCondition ? e.deleteCondition : this.defaultDeleteCondition_, this.insertVertexCondition_ = e.insertVertexCondition ? e.insertVertexCondition : Hn, this.vertexFeature_ = null, this.vertexSegments_ = null, this.lastPixel_ = [0, 0], this.ignoreNextSingleClick_ = !1, this.featuresBeingModified_ = null, this.rBush_ = new Yo(), this.pixelTolerance_ = e.pixelTolerance !== void 0 ? e.pixelTolerance : 10, this.snappedToVertex_ = !1, this.changingFeature_ = !1, this.dragSegments_ = [], this.overlay_ = new Be({
      source: new we({
        useSpatialIndex: !1,
        wrapX: !!e.wrapX
      }),
      style: e.style ? e.style : K0(),
      updateWhileAnimating: !0,
      updateWhileInteracting: !0
    }), this.SEGMENT_WRITERS_ = {
      Point: this.writePointGeometry_.bind(this),
      LineString: this.writeLineStringGeometry_.bind(this),
      LinearRing: this.writeLineStringGeometry_.bind(this),
      Polygon: this.writePolygonGeometry_.bind(this),
      MultiPoint: this.writeMultiPointGeometry_.bind(this),
      MultiLineString: this.writeMultiLineStringGeometry_.bind(this),
      MultiPolygon: this.writeMultiPolygonGeometry_.bind(this),
      Circle: this.writeCircleGeometry_.bind(this),
      GeometryCollection: this.writeGeometryCollectionGeometry_.bind(this)
    }, this.source_ = null, this.hitDetection_ = null;
    let t;
    if (e.features ? t = e.features : e.source && (this.source_ = e.source, t = new ce(this.source_.getFeatures()), this.source_.addEventListener(
      Le.ADDFEATURE,
      this.handleSourceAdd_.bind(this)
    ), this.source_.addEventListener(
      Le.REMOVEFEATURE,
      this.handleSourceRemove_.bind(this)
    )), !t)
      throw new Error(
        "The modify interaction requires features, a source or a layer"
      );
    e.hitDetection && (this.hitDetection_ = e.hitDetection), this.features_ = t, this.features_.forEach(this.addFeature_.bind(this)), this.features_.addEventListener(
      ve.ADD,
      this.handleFeatureAdd_.bind(this)
    ), this.features_.addEventListener(
      ve.REMOVE,
      this.handleFeatureRemove_.bind(this)
    ), this.lastPointerEvent_ = null, this.delta_ = [0, 0], this.snapToPointer_ = e.snapToPointer === void 0 ? !this.hitDetection_ : e.snapToPointer;
  }
  /**
   * @param {Feature} feature Feature.
   * @private
   */
  addFeature_(e) {
    const t = e.getGeometry();
    if (t) {
      const n = this.SEGMENT_WRITERS_[t.getType()];
      n && n(e, t);
    }
    const i = this.getMap();
    i && i.isRendered() && this.getActive() && this.handlePointerAtPixel_(this.lastPixel_, i), e.addEventListener(z.CHANGE, this.boundHandleFeatureChange_);
  }
  /**
   * @param {import("../MapBrowserEvent.js").default} evt Map browser event.
   * @param {Array<Array<SegmentData>>} segments The segments subject to modification.
   * @private
   */
  willModifyFeatures_(e, t) {
    if (!this.featuresBeingModified_) {
      this.featuresBeingModified_ = new ce();
      const i = this.featuresBeingModified_.getArray();
      for (let n = 0, r = t.length; n < r; ++n) {
        const o = t[n];
        for (let a = 0, l = o.length; a < l; ++a) {
          const h = o[a].feature;
          h && !i.includes(h) && this.featuresBeingModified_.push(h);
        }
      }
      this.featuresBeingModified_.getLength() === 0 ? this.featuresBeingModified_ = null : this.dispatchEvent(
        new vo(
          Eo.MODIFYSTART,
          this.featuresBeingModified_,
          e
        )
      );
    }
  }
  /**
   * @param {Feature} feature Feature.
   * @private
   */
  removeFeature_(e) {
    this.removeFeatureSegmentData_(e), this.vertexFeature_ && this.features_.getLength() === 0 && (this.overlay_.getSource().removeFeature(this.vertexFeature_), this.vertexFeature_ = null), e.removeEventListener(
      z.CHANGE,
      this.boundHandleFeatureChange_
    );
  }
  /**
   * @param {Feature} feature Feature.
   * @private
   */
  removeFeatureSegmentData_(e) {
    const t = this.rBush_, i = [];
    t.forEach(
      /**
       * @param {SegmentData} node RTree node.
       */
      function(n) {
        e === n.feature && i.push(n);
      }
    );
    for (let n = i.length - 1; n >= 0; --n) {
      const r = i[n];
      for (let o = this.dragSegments_.length - 1; o >= 0; --o)
        this.dragSegments_[o][0] === r && this.dragSegments_.splice(o, 1);
      t.remove(r);
    }
  }
  /**
   * Activate or deactivate the interaction.
   * @param {boolean} active Active.
   * @observable
   * @api
   */
  setActive(e) {
    this.vertexFeature_ && !e && (this.overlay_.getSource().removeFeature(this.vertexFeature_), this.vertexFeature_ = null), super.setActive(e);
  }
  /**
   * Remove the interaction from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default} map Map.
   */
  setMap(e) {
    this.overlay_.setMap(e), super.setMap(e);
  }
  /**
   * Get the overlay layer that this interaction renders the modification point or vertex to.
   * @return {VectorLayer} Overlay layer.
   * @api
   */
  getOverlay() {
    return this.overlay_;
  }
  /**
   * @param {import("../source/Vector.js").VectorSourceEvent} event Event.
   * @private
   */
  handleSourceAdd_(e) {
    e.feature && this.features_.push(e.feature);
  }
  /**
   * @param {import("../source/Vector.js").VectorSourceEvent} event Event.
   * @private
   */
  handleSourceRemove_(e) {
    e.feature && this.features_.remove(e.feature);
  }
  /**
   * @param {import("../Collection.js").CollectionEvent<Feature>} evt Event.
   * @private
   */
  handleFeatureAdd_(e) {
    this.addFeature_(e.element);
  }
  /**
   * @param {import("../events/Event.js").default} evt Event.
   * @private
   */
  handleFeatureChange_(e) {
    if (!this.changingFeature_) {
      const t = (
        /** @type {Feature} */
        e.target
      );
      this.removeFeature_(t), this.addFeature_(t);
    }
  }
  /**
   * @param {import("../Collection.js").CollectionEvent<Feature>} evt Event.
   * @private
   */
  handleFeatureRemove_(e) {
    this.removeFeature_(e.element);
  }
  /**
   * @param {Feature} feature Feature
   * @param {Point} geometry Geometry.
   * @private
   */
  writePointGeometry_(e, t) {
    const i = t.getCoordinates(), n = {
      feature: e,
      geometry: t,
      segment: [i, i]
    };
    this.rBush_.insert(t.getExtent(), n);
  }
  /**
   * @param {Feature} feature Feature
   * @param {import("../geom/MultiPoint.js").default} geometry Geometry.
   * @private
   */
  writeMultiPointGeometry_(e, t) {
    const i = t.getCoordinates();
    for (let n = 0, r = i.length; n < r; ++n) {
      const o = i[n], a = {
        feature: e,
        geometry: t,
        depth: [n],
        index: n,
        segment: [o, o]
      };
      this.rBush_.insert(t.getExtent(), a);
    }
  }
  /**
   * @param {Feature} feature Feature
   * @param {import("../geom/LineString.js").default} geometry Geometry.
   * @private
   */
  writeLineStringGeometry_(e, t) {
    const i = t.getCoordinates();
    for (let n = 0, r = i.length - 1; n < r; ++n) {
      const o = i.slice(n, n + 2), a = {
        feature: e,
        geometry: t,
        index: n,
        segment: o
      };
      this.rBush_.insert(ze(o), a);
    }
  }
  /**
   * @param {Feature} feature Feature
   * @param {import("../geom/MultiLineString.js").default} geometry Geometry.
   * @private
   */
  writeMultiLineStringGeometry_(e, t) {
    const i = t.getCoordinates();
    for (let n = 0, r = i.length; n < r; ++n) {
      const o = i[n];
      for (let a = 0, l = o.length - 1; a < l; ++a) {
        const h = o.slice(a, a + 2), c = {
          feature: e,
          geometry: t,
          depth: [n],
          index: a,
          segment: h
        };
        this.rBush_.insert(ze(h), c);
      }
    }
  }
  /**
   * @param {Feature} feature Feature
   * @param {import("../geom/Polygon.js").default} geometry Geometry.
   * @private
   */
  writePolygonGeometry_(e, t) {
    const i = t.getCoordinates();
    for (let n = 0, r = i.length; n < r; ++n) {
      const o = i[n];
      for (let a = 0, l = o.length - 1; a < l; ++a) {
        const h = o.slice(a, a + 2), c = {
          feature: e,
          geometry: t,
          depth: [n],
          index: a,
          segment: h
        };
        this.rBush_.insert(ze(h), c);
      }
    }
  }
  /**
   * @param {Feature} feature Feature
   * @param {import("../geom/MultiPolygon.js").default} geometry Geometry.
   * @private
   */
  writeMultiPolygonGeometry_(e, t) {
    const i = t.getCoordinates();
    for (let n = 0, r = i.length; n < r; ++n) {
      const o = i[n];
      for (let a = 0, l = o.length; a < l; ++a) {
        const h = o[a];
        for (let c = 0, u = h.length - 1; c < u; ++c) {
          const d = h.slice(c, c + 2), f = {
            feature: e,
            geometry: t,
            depth: [a, n],
            index: c,
            segment: d
          };
          this.rBush_.insert(ze(d), f);
        }
      }
    }
  }
  /**
   * We convert a circle into two segments.  The segment at index
   * {@link CIRCLE_CENTER_INDEX} is the
   * circle's center (a point).  The segment at index
   * {@link CIRCLE_CIRCUMFERENCE_INDEX} is
   * the circumference, and is not a line segment.
   *
   * @param {Feature} feature Feature.
   * @param {import("../geom/Circle.js").default} geometry Geometry.
   * @private
   */
  writeCircleGeometry_(e, t) {
    const i = t.getCenter(), n = {
      feature: e,
      geometry: t,
      index: _h,
      segment: [i, i]
    }, r = {
      feature: e,
      geometry: t,
      index: Dn,
      segment: [i, i]
    }, o = [n, r];
    n.featureSegments = o, r.featureSegments = o, this.rBush_.insert(Rn(i), n);
    let a = (
      /** @type {import("../geom/Geometry.js").default} */
      t
    );
    this.rBush_.insert(a.getExtent(), r);
  }
  /**
   * @param {Feature} feature Feature
   * @param {import("../geom/GeometryCollection.js").default} geometry Geometry.
   * @private
   */
  writeGeometryCollectionGeometry_(e, t) {
    const i = t.getGeometriesArray();
    for (let n = 0; n < i.length; ++n) {
      const r = i[n], o = this.SEGMENT_WRITERS_[r.getType()];
      o(e, r);
    }
  }
  /**
   * @param {import("../coordinate.js").Coordinate} coordinates Coordinates.
   * @param {Array<Feature>} features The features being modified.
   * @param {Array<import("../geom/SimpleGeometry.js").default>} geometries The geometries being modified.
   * @return {Feature} Vertex feature.
   * @private
   */
  createOrUpdateVertexFeature_(e, t, i) {
    let n = this.vertexFeature_;
    return n ? n.getGeometry().setCoordinates(e) : (n = new $(new Ee(e)), this.vertexFeature_ = n, this.overlay_.getSource().addFeature(n)), n.set("features", t), n.set("geometries", i), n;
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may modify the geometry.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   */
  handleEvent(e) {
    if (!e.originalEvent)
      return !0;
    this.lastPointerEvent_ = e;
    let t;
    return !e.map.getView().getInteracting() && e.type == J.POINTERMOVE && !this.handlingDownUpSequence && this.handlePointerMove_(e), this.vertexFeature_ && this.deleteCondition_(e) && (e.type != J.SINGLECLICK || !this.ignoreNextSingleClick_ ? t = this.removePoint() : t = !0), e.type == J.SINGLECLICK && (this.ignoreNextSingleClick_ = !1), super.handleEvent(e) && !t;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} evt Event.
   */
  handleDragEvent(e) {
    this.ignoreNextSingleClick_ = !1, this.willModifyFeatures_(e, this.dragSegments_);
    const t = [
      e.coordinate[0] + this.delta_[0],
      e.coordinate[1] + this.delta_[1]
    ], i = [], n = [];
    for (let r = 0, o = this.dragSegments_.length; r < o; ++r) {
      const a = this.dragSegments_[r], l = a[0], h = l.feature;
      i.includes(h) || i.push(h);
      const c = l.geometry;
      n.includes(c) || n.push(c);
      const u = l.depth;
      let d;
      const f = l.segment, g = a[1];
      for (; t.length < c.getStride(); )
        t.push(f[g][t.length]);
      switch (c.getType()) {
        case "Point":
          d = t, f[0] = t, f[1] = t;
          break;
        case "MultiPoint":
          d = c.getCoordinates(), d[l.index] = t, f[0] = t, f[1] = t;
          break;
        case "LineString":
          d = c.getCoordinates(), d[l.index + g] = t, f[g] = t;
          break;
        case "MultiLineString":
          d = c.getCoordinates(), d[u[0]][l.index + g] = t, f[g] = t;
          break;
        case "Polygon":
          d = c.getCoordinates(), d[u[0]][l.index + g] = t, f[g] = t;
          break;
        case "MultiPolygon":
          d = c.getCoordinates(), d[u[1]][u[0]][l.index + g] = t, f[g] = t;
          break;
        case "Circle":
          if (f[0] = t, f[1] = t, l.index === _h)
            this.changingFeature_ = !0, c.setCenter(t), this.changingFeature_ = !1;
          else {
            this.changingFeature_ = !0, e.map.getView().getProjection();
            let _ = ir(
              he(c.getCenter()),
              he(t)
            );
            c.setRadius(_), this.changingFeature_ = !1;
          }
          break;
      }
      d && this.setGeometryCoordinates_(c, d);
    }
    this.createOrUpdateVertexFeature_(t, i, n);
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} evt Event.
   * @return {boolean} If the event was consumed.
   */
  handleDownEvent(e) {
    if (!this.condition_(e))
      return !1;
    const t = e.coordinate;
    this.handlePointerAtPixel_(e.pixel, e.map, t), this.dragSegments_.length = 0, this.featuresBeingModified_ = null;
    const i = this.vertexFeature_;
    if (i) {
      e.map.getView().getProjection();
      const n = [], r = i.getGeometry().getCoordinates(), o = ze([r]), a = this.rBush_.getInExtent(o), l = {};
      a.sort(H0);
      for (let h = 0, c = a.length; h < c; ++h) {
        const u = a[h], d = u.segment;
        let f = B(u.geometry);
        const g = u.depth;
        if (g && (f += "-" + g.join("-")), l[f] || (l[f] = new Array(2)), u.geometry.getType() === "Circle" && u.index === Dn) {
          const _ = yh(
            t,
            u
          );
          rt(_, r) && !l[f][0] && (this.dragSegments_.push([u, 0]), l[f][0] = u);
          continue;
        }
        if (rt(d[0], r) && !l[f][0]) {
          this.dragSegments_.push([u, 0]), l[f][0] = u;
          continue;
        }
        if (rt(d[1], r) && !l[f][1]) {
          if (l[f][0] && l[f][0].index === 0) {
            let _ = u.geometry.getCoordinates();
            switch (u.geometry.getType()) {
              case "LineString":
              case "MultiLineString":
                continue;
              case "MultiPolygon":
                _ = _[g[1]];
              case "Polygon":
                if (u.index !== _[g[0]].length - 2)
                  continue;
                break;
            }
          }
          this.dragSegments_.push([u, 1]), l[f][1] = u;
          continue;
        }
        B(d) in this.vertexSegments_ && !l[f][0] && !l[f][1] && this.insertVertexCondition_(e) && n.push(u);
      }
      n.length && this.willModifyFeatures_(e, [n]);
      for (let h = n.length - 1; h >= 0; --h)
        this.insertVertex_(n[h], r);
    }
    return !!this.vertexFeature_;
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} evt Event.
   * @return {boolean} If the event was consumed.
   */
  handleUpEvent(e) {
    for (let t = this.dragSegments_.length - 1; t >= 0; --t) {
      const i = this.dragSegments_[t][0], n = i.geometry;
      if (n.getType() === "Circle") {
        const r = n.getCenter(), o = i.featureSegments[0], a = i.featureSegments[1];
        o.segment[0] = r, o.segment[1] = r, a.segment[0] = r, a.segment[1] = r, this.rBush_.update(Rn(r), o);
        let l = n;
        this.rBush_.update(
          l.getExtent(),
          a
        );
      } else
        this.rBush_.update(ze(i.segment), i);
    }
    return this.featuresBeingModified_ && (this.dispatchEvent(
      new vo(
        Eo.MODIFYEND,
        this.featuresBeingModified_,
        e
      )
    ), this.featuresBeingModified_ = null), !1;
  }
  /**
   * @param {import("../MapBrowserEvent.js").default} evt Event.
   * @private
   */
  handlePointerMove_(e) {
    this.lastPixel_ = e.pixel, this.handlePointerAtPixel_(e.pixel, e.map, e.coordinate);
  }
  /**
   * @param {import("../pixel.js").Pixel} pixel Pixel
   * @param {import("../Map.js").default} map Map.
   * @param {import("../coordinate.js").Coordinate} [coordinate] The pixel Coordinate.
   * @private
   */
  handlePointerAtPixel_(e, t, i) {
    const n = i || t.getCoordinateFromPixel(e);
    t.getView().getProjection();
    const r = function(l, h) {
      return ph(n, l) - ph(n, h);
    };
    let o, a;
    if (this.hitDetection_) {
      const l = typeof this.hitDetection_ == "object" ? (h) => h === this.hitDetection_ : void 0;
      t.forEachFeatureAtPixel(
        e,
        (h, c, u) => {
          const d = u || h.getGeometry();
          if (d.getType() === "Point" && h instanceof $ && this.features_.getArray().includes(h)) {
            a = /** @type {Point} */
            d;
            const f = a.getFlatCoordinates().slice(0, 2);
            o = [
              {
                feature: h,
                geometry: a,
                segment: [f, f]
              }
            ];
          }
          return !0;
        },
        { layerFilter: l }
      );
    }
    if (!o) {
      const l = gt(
        Rn(n, mh)
      ), h = t.getView().getResolution() * this.pixelTolerance_, c = Ea(
        Si(l, h, mh)
      );
      o = this.rBush_.getInExtent(c);
    }
    if (o && o.length > 0) {
      const l = o.sort(r)[0], h = l.segment;
      let c = yh(n, l);
      const u = t.getPixelFromCoordinate(c);
      let d = ir(e, u);
      if (a || d <= this.pixelTolerance_) {
        const f = {};
        if (f[B(h)] = !0, this.snapToPointer_ || (this.delta_[0] = c[0] - n[0], this.delta_[1] = c[1] - n[1]), l.geometry.getType() === "Circle" && l.index === Dn)
          this.snappedToVertex_ = !0, this.createOrUpdateVertexFeature_(
            c,
            [l.feature],
            [l.geometry]
          );
        else {
          const g = t.getPixelFromCoordinate(h[0]), _ = t.getPixelFromCoordinate(h[1]), m = Ci(u, g), p = Ci(u, _);
          d = Math.sqrt(Math.min(m, p)), this.snappedToVertex_ = d <= this.pixelTolerance_, this.snappedToVertex_ && (c = m > p ? h[1] : h[0]), this.createOrUpdateVertexFeature_(
            c,
            [l.feature],
            [l.geometry]
          );
          const x = {};
          x[B(l.geometry)] = !0;
          for (let y = 1, E = o.length; y < E; ++y) {
            const C = o[y].segment;
            if (rt(h[0], C[0]) && rt(h[1], C[1]) || rt(h[0], C[1]) && rt(h[1], C[0])) {
              const T = B(o[y].geometry);
              T in x || (x[T] = !0, f[B(C)] = !0);
            } else
              break;
          }
        }
        this.vertexSegments_ = f;
        return;
      }
    }
    this.vertexFeature_ && (this.overlay_.getSource().removeFeature(this.vertexFeature_), this.vertexFeature_ = null);
  }
  /**
   * @param {SegmentData} segmentData Segment data.
   * @param {import("../coordinate.js").Coordinate} vertex Vertex.
   * @private
   */
  insertVertex_(e, t) {
    const i = e.segment, n = e.feature, r = e.geometry, o = e.depth, a = e.index;
    let l;
    for (; t.length < r.getStride(); )
      t.push(0);
    switch (r.getType()) {
      case "MultiLineString":
        l = r.getCoordinates(), l[o[0]].splice(a + 1, 0, t);
        break;
      case "Polygon":
        l = r.getCoordinates(), l[o[0]].splice(a + 1, 0, t);
        break;
      case "MultiPolygon":
        l = r.getCoordinates(), l[o[1]][o[0]].splice(a + 1, 0, t);
        break;
      case "LineString":
        l = r.getCoordinates(), l.splice(a + 1, 0, t);
        break;
      default:
        return;
    }
    this.setGeometryCoordinates_(r, l);
    const h = this.rBush_;
    h.remove(e), this.updateSegmentIndices_(r, a, o, 1);
    const c = {
      segment: [i[0], t],
      feature: n,
      geometry: r,
      depth: o,
      index: a
    };
    h.insert(ze(c.segment), c), this.dragSegments_.push([c, 1]);
    const u = {
      segment: [t, i[1]],
      feature: n,
      geometry: r,
      depth: o,
      index: a + 1
    };
    h.insert(ze(u.segment), u), this.dragSegments_.push([u, 0]), this.ignoreNextSingleClick_ = !0;
  }
  /**
   * Removes the vertex currently being pointed.
   * @return {boolean} True when a vertex was removed.
   * @api
   */
  removePoint() {
    if (this.lastPointerEvent_ && this.lastPointerEvent_.type != J.POINTERDRAG) {
      const e = this.lastPointerEvent_;
      this.willModifyFeatures_(e, this.dragSegments_);
      const t = this.removeVertex_();
      return this.featuresBeingModified_ && this.dispatchEvent(
        new vo(
          Eo.MODIFYEND,
          this.featuresBeingModified_,
          e
        )
      ), this.featuresBeingModified_ = null, t;
    }
    return !1;
  }
  /**
   * Removes a vertex from all matching features.
   * @return {boolean} True when a vertex was removed.
   * @private
   */
  removeVertex_() {
    const e = this.dragSegments_, t = {};
    let i = !1, n, r, o, a, l, h, c, u, d, f, g;
    for (l = e.length - 1; l >= 0; --l)
      o = e[l], f = o[0], g = B(f.feature), f.depth && (g += "-" + f.depth.join("-")), g in t || (t[g] = {}), o[1] === 0 ? (t[g].right = f, t[g].index = f.index) : o[1] == 1 && (t[g].left = f, t[g].index = f.index + 1);
    for (g in t) {
      switch (d = t[g].right, c = t[g].left, h = t[g].index, u = h - 1, c !== void 0 ? f = c : f = d, u < 0 && (u = 0), a = f.geometry, r = a.getCoordinates(), n = r, i = !1, a.getType()) {
        case "MultiLineString":
          r[f.depth[0]].length > 2 && (r[f.depth[0]].splice(h, 1), i = !0);
          break;
        case "LineString":
          r.length > 2 && (r.splice(h, 1), i = !0);
          break;
        case "MultiPolygon":
          n = n[f.depth[1]];
        case "Polygon":
          n = n[f.depth[0]], n.length > 4 && (h == n.length - 1 && (h = 0), n.splice(h, 1), i = !0, h === 0 && (n.pop(), n.push(n[0]), u = n.length - 1));
          break;
      }
      if (i) {
        this.setGeometryCoordinates_(a, r);
        const _ = [];
        if (c !== void 0 && (this.rBush_.remove(c), _.push(c.segment[0])), d !== void 0 && (this.rBush_.remove(d), _.push(d.segment[1])), c !== void 0 && d !== void 0) {
          const m = {
            depth: f.depth,
            feature: f.feature,
            geometry: f.geometry,
            index: u,
            segment: _
          };
          this.rBush_.insert(
            ze(m.segment),
            m
          );
        }
        this.updateSegmentIndices_(a, h, f.depth, -1), this.vertexFeature_ && (this.overlay_.getSource().removeFeature(this.vertexFeature_), this.vertexFeature_ = null), e.length = 0;
      }
    }
    return i;
  }
  /**
   * @param {import("../geom/SimpleGeometry.js").default} geometry Geometry.
   * @param {Array} coordinates Coordinates.
   * @private
   */
  setGeometryCoordinates_(e, t) {
    this.changingFeature_ = !0, e.setCoordinates(t), this.changingFeature_ = !1;
  }
  /**
   * @param {import("../geom/SimpleGeometry.js").default} geometry Geometry.
   * @param {number} index Index.
   * @param {Array<number>|undefined} depth Depth.
   * @param {number} delta Delta (1 or -1).
   * @private
   */
  updateSegmentIndices_(e, t, i, n) {
    this.rBush_.forEachInExtent(
      e.getExtent(),
      function(r) {
        r.geometry === e && (i === void 0 || r.depth === void 0 || xt(r.depth, i)) && r.index > t && (r.index += n);
      }
    );
  }
};
function H0(s, e) {
  return s.index - e.index;
}
function ph(s, e, t) {
  const i = e.geometry;
  if (i.getType() === "Circle") {
    let r = (
      /** @type {import("../geom/Circle.js").default} */
      i
    );
    if (e.index === Dn) {
      const o = Ci(
        r.getCenter(),
        he(s)
      ), a = Math.sqrt(o) - r.getRadius();
      return a * a;
    }
  }
  const n = he(s);
  return en[0] = he(e.segment[0]), en[1] = he(e.segment[1]), Fd(n, en);
}
function yh(s, e, t) {
  const i = e.geometry;
  if (i.getType() === "Circle" && e.index === Dn)
    return Un(
      /** @type {import("../geom/Circle.js").default} */
      i.getClosestPoint(
        he(s)
      )
    );
  const n = he(s);
  return en[0] = he(e.segment[0]), en[1] = he(e.segment[1]), Un(
    zh(n, en)
  );
}
function K0() {
  const s = Va();
  return function(e, t) {
    return s.Point;
  };
}
const Iu = j0, q0 = {
  /**
   * Triggered when feature(s) has been (de)selected.
   * @event SelectEvent#select
   * @api
   */
  SELECT: "select"
};
class J0 extends Ye {
  /**
   * @param {SelectEventType} type The event type.
   * @param {Array<import("../Feature.js").default>} selected Selected features.
   * @param {Array<import("../Feature.js").default>} deselected Deselected features.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Associated
   *     {@link module:ol/MapBrowserEvent~MapBrowserEvent}.
   */
  constructor(e, t, i, n) {
    super(e), this.selected = t, this.deselected = i, this.mapBrowserEvent = n;
  }
}
const js = {};
let $0 = class Lu extends fn {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    super(), this.on, this.once, this.un, e = e || {}, this.boundAddFeature_ = this.addFeature_.bind(this), this.boundRemoveFeature_ = this.removeFeature_.bind(this), this.condition_ = e.condition ? e.condition : gc, this.addCondition_ = e.addCondition ? e.addCondition : Xo, this.removeCondition_ = e.removeCondition ? e.removeCondition : Xo, this.toggleCondition_ = e.toggleCondition ? e.toggleCondition : Ga, this.multi_ = e.multi ? e.multi : !1, this.filter_ = e.filter ? e.filter : mt, this.hitTolerance_ = e.hitTolerance ? e.hitTolerance : 0, this.style_ = e.style !== void 0 ? e.style : Q0(), this.features_ = e.features || new ce();
    let t;
    if (e.layers)
      if (typeof e.layers == "function")
        t = e.layers;
      else {
        const i = e.layers;
        t = function(n) {
          return i.includes(n);
        };
      }
    else
      t = mt;
    this.layerFilter_ = t, this.featureLayerAssociation_ = {};
  }
  /**
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("../layer/Layer.js").default} layer Layer.
   * @private
   */
  addFeatureLayerAssociation_(e, t) {
    this.featureLayerAssociation_[B(e)] = t;
  }
  /**
   * Get the selected features.
   * @return {Collection<Feature>} Features collection.
   * @api
   */
  getFeatures() {
    return this.features_;
  }
  /**
   * Returns the Hit-detection tolerance.
   * @return {number} Hit tolerance in pixels.
   * @api
   */
  getHitTolerance() {
    return this.hitTolerance_;
  }
  /**
   * Returns the associated {@link module:ol/layer/Vector~VectorLayer vector layer} of
   * a selected feature.
   * @param {import("../Feature.js").default} feature Feature
   * @return {import('../layer/Vector.js').default} Layer.
   * @api
   */
  getLayer(e) {
    return (
      /** @type {import('../layer/Vector.js').default} */
      this.featureLayerAssociation_[B(e)]
    );
  }
  /**
   * Hit-detection tolerance. Pixels inside the radius around the given position
   * will be checked for features.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @api
   */
  setHitTolerance(e) {
    this.hitTolerance_ = e;
  }
  /**
   * Remove the interaction from its current map, if any,  and attach it to a new
   * map, if any. Pass `null` to just remove the interaction from the current map.
   * @param {import("../Map.js").default|null} map Map.
   * @api
   */
  setMap(e) {
    this.getMap() && this.style_ && this.features_.forEach(this.restorePreviousStyle_.bind(this)), super.setMap(e), e ? (this.features_.addEventListener(
      ve.ADD,
      this.boundAddFeature_
    ), this.features_.addEventListener(
      ve.REMOVE,
      this.boundRemoveFeature_
    ), this.style_ && this.features_.forEach(this.applySelectedStyle_.bind(this))) : (this.features_.removeEventListener(
      ve.ADD,
      this.boundAddFeature_
    ), this.features_.removeEventListener(
      ve.REMOVE,
      this.boundRemoveFeature_
    ));
  }
  /**
   * @param {import("../Collection.js").CollectionEvent<Feature>} evt Event.
   * @private
   */
  addFeature_(e) {
    const t = e.element;
    if (this.style_ && this.applySelectedStyle_(t), !this.getLayer(t)) {
      const i = (
        /** @type {VectorLayer} */
        this.getMap().getAllLayers().find(function(n) {
          if (n instanceof Be && n.getSource() && n.getSource().hasFeature(t))
            return n;
        })
      );
      i && this.addFeatureLayerAssociation_(t, i);
    }
  }
  /**
   * @param {import("../Collection.js").CollectionEvent<Feature>} evt Event.
   * @private
   */
  removeFeature_(e) {
    this.style_ && this.restorePreviousStyle_(e.element);
  }
  /**
   * @return {import("../style/Style.js").StyleLike|null} Select style.
   */
  getStyle() {
    return this.style_;
  }
  /**
   * @param {Feature} feature Feature
   * @private
   */
  applySelectedStyle_(e) {
    const t = B(e);
    t in js || (js[t] = e.getStyle()), e.setStyle(this.style_);
  }
  /**
   * @param {Feature} feature Feature
   * @private
   */
  restorePreviousStyle_(e) {
    const t = this.getMap().getInteractions().getArray();
    for (let n = t.length - 1; n >= 0; --n) {
      const r = t[n];
      if (r !== this && r instanceof Lu && r.getStyle() && r.getFeatures().getArray().lastIndexOf(e) !== -1) {
        e.setStyle(r.getStyle());
        return;
      }
    }
    const i = B(e);
    e.setStyle(js[i]), delete js[i];
  }
  /**
   * @param {Feature} feature Feature.
   * @private
   */
  removeFeatureLayerAssociation_(e) {
    delete this.featureLayerAssociation_[B(e)];
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may change the
   * selected state of features.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   */
  handleEvent(e) {
    if (!this.condition_(e))
      return !0;
    const t = this.addCondition_(e), i = this.removeCondition_(e), n = this.toggleCondition_(e), r = !t && !i && !n, o = e.map, a = this.getFeatures(), l = [], h = [];
    if (r) {
      Ti(this.featureLayerAssociation_), o.forEachFeatureAtPixel(
        e.pixel,
        /**
         * @param {import("../Feature.js").FeatureLike} feature Feature.
         * @param {import("../layer/Layer.js").default} layer Layer.
         * @return {boolean|undefined} Continue to iterate over the features.
         */
        (c, u) => {
          if (!(!(c instanceof $) || !this.filter_(c, u)))
            return this.addFeatureLayerAssociation_(c, u), h.push(c), !this.multi_;
        },
        {
          layerFilter: this.layerFilter_,
          hitTolerance: this.hitTolerance_
        }
      );
      for (let c = a.getLength() - 1; c >= 0; --c) {
        const u = a.item(c), d = h.indexOf(u);
        d > -1 ? h.splice(d, 1) : (a.remove(u), l.push(u));
      }
      h.length !== 0 && a.extend(h);
    } else {
      o.forEachFeatureAtPixel(
        e.pixel,
        /**
         * @param {import("../Feature.js").FeatureLike} feature Feature.
         * @param {import("../layer/Layer.js").default} layer Layer.
         * @return {boolean|undefined} Continue to iterate over the features.
         */
        (c, u) => {
          if (!(!(c instanceof $) || !this.filter_(c, u)))
            return (t || n) && !a.getArray().includes(c) ? (this.addFeatureLayerAssociation_(c, u), h.push(c)) : (i || n) && a.getArray().includes(c) && (l.push(c), this.removeFeatureLayerAssociation_(c)), !this.multi_;
        },
        {
          layerFilter: this.layerFilter_,
          hitTolerance: this.hitTolerance_
        }
      );
      for (let c = l.length - 1; c >= 0; --c)
        a.remove(l[c]);
      a.extend(h);
    }
    return (h.length > 0 || l.length > 0) && this.dispatchEvent(
      new J0(
        q0.SELECT,
        h,
        l,
        e
      )
    ), !0;
  }
};
function Q0() {
  const s = Va();
  return ae(s.Polygon, s.LineString), ae(s.GeometryCollection, s.LineString), function(e) {
    return e.getGeometry() ? s[e.getGeometry().getType()] : null;
  };
}
const ex = $0, Co = {
  /**
   * Triggered upon feature translation start.
   * @event TranslateEvent#translatestart
   * @api
   */
  TRANSLATESTART: "translatestart",
  /**
   * Triggered upon feature translation.
   * @event TranslateEvent#translating
   * @api
   */
  TRANSLATING: "translating",
  /**
   * Triggered upon feature translation end.
   * @event TranslateEvent#translateend
   * @api
   */
  TRANSLATEEND: "translateend"
};
class wo extends Ye {
  /**
   * @param {TranslateEventType} type Type.
   * @param {Collection<Feature>} features The features translated.
   * @param {import("../coordinate.js").Coordinate} coordinate The event coordinate.
   * @param {import("../coordinate.js").Coordinate} startCoordinate The original coordinates before.translation started
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   */
  constructor(e, t, i, n, r) {
    super(e), this.features = t, this.coordinate = i, this.startCoordinate = n, this.mapBrowserEvent = r;
  }
}
let tx = class extends Dt {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {}, super(
      /** @type {import("./Pointer.js").Options} */
      e
    ), this.on, this.once, this.un, this.lastCoordinate_ = null, this.startCoordinate_ = null, this.features_ = e.features !== void 0 ? e.features : null;
    let t;
    if (e.layers && !this.features_)
      if (typeof e.layers == "function")
        t = e.layers;
      else {
        const i = e.layers;
        t = function(n) {
          return i.includes(n);
        };
      }
    else
      t = mt;
    this.layerFilter_ = t, this.filter_ = e.filter && !this.features_ ? e.filter : mt, this.hitTolerance_ = e.hitTolerance ? e.hitTolerance : 0, this.condition_ = e.condition ? e.condition : Hn, this.lastFeature_ = null, this.addChangeListener(
      fr.ACTIVE,
      this.handleActiveChanged_
    );
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @return {boolean} If the event was consumed.
   */
  handleDownEvent(e) {
    if (!e.originalEvent || !this.condition_(e))
      return !1;
    if (this.lastFeature_ = this.featuresAtPixel_(e.pixel, e.map), !this.lastCoordinate_ && this.lastFeature_) {
      this.startCoordinate_ = e.coordinate, this.lastCoordinate_ = e.coordinate, this.handleMoveEvent(e);
      const t = this.features_ || new ce([this.lastFeature_]);
      return this.dispatchEvent(
        new wo(
          Co.TRANSLATESTART,
          t,
          e.coordinate,
          this.startCoordinate_,
          e
        )
      ), !0;
    }
    return !1;
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @return {boolean} If the event was consumed.
   */
  handleUpEvent(e) {
    if (this.lastCoordinate_) {
      this.lastCoordinate_ = null, this.handleMoveEvent(e);
      const t = this.features_ || new ce([this.lastFeature_]);
      return this.dispatchEvent(
        new wo(
          Co.TRANSLATEEND,
          t,
          e.coordinate,
          this.startCoordinate_,
          e
        )
      ), this.startCoordinate_ = null, !0;
    }
    return !1;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   */
  handleDragEvent(e) {
    if (this.lastCoordinate_) {
      const t = e.coordinate, i = t[0] - this.lastCoordinate_[0], n = t[1] - this.lastCoordinate_[1], r = this.features_ || new ce([this.lastFeature_]);
      r.forEach(function(o) {
        const a = o.getGeometry();
        a.translate(i, n), o.setGeometry(a);
      }), this.lastCoordinate_ = t, this.dispatchEvent(
        new wo(
          Co.TRANSLATING,
          r,
          t,
          this.startCoordinate_,
          e
        )
      );
    }
  }
  /**
   * Handle pointer move events.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   */
  handleMoveEvent(e) {
    const t = e.map.getViewport();
    this.featuresAtPixel_(e.pixel, e.map) ? (t.classList.remove(this.lastCoordinate_ ? "ol-grab" : "ol-grabbing"), t.classList.add(this.lastCoordinate_ ? "ol-grabbing" : "ol-grab")) : t.classList.remove("ol-grab", "ol-grabbing");
  }
  /**
   * Tests to see if the given coordinates intersects any of our selected
   * features.
   * @param {import("../pixel.js").Pixel} pixel Pixel coordinate to test for intersection.
   * @param {import("../Map.js").default} map Map to test the intersection on.
   * @return {Feature} Returns the feature found at the specified pixel
   * coordinates.
   * @private
   */
  featuresAtPixel_(e, t) {
    return t.forEachFeatureAtPixel(
      e,
      (i, n) => {
        if (!(!(i instanceof $) || !this.filter_(i, n)) && !(this.features_ && !this.features_.getArray().includes(i)))
          return i;
      },
      {
        layerFilter: this.layerFilter_,
        hitTolerance: this.hitTolerance_
      }
    );
  }
  /**
   * Returns the Hit-detection tolerance.
   * @return {number} Hit tolerance in pixels.
   * @api
   */
  getHitTolerance() {
    return this.hitTolerance_;
  }
  /**
   * Hit-detection tolerance. Pixels inside the radius around the given position
   * will be checked for features.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @api
   */
  setHitTolerance(e) {
    this.hitTolerance_ = e;
  }
  /**
   * Remove the interaction from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default} map Map.
   */
  setMap(e) {
    const t = this.getMap();
    super.setMap(e), this.updateState_(t);
  }
  /**
   * @private
   */
  handleActiveChanged_() {
    this.updateState_(null);
  }
  /**
   * @param {import("../Map.js").default} oldMap Old map.
   * @private
   */
  updateState_(e) {
    let t = this.getMap();
    const i = this.getActive();
    (!t || !i) && (t = t || e, t && t.getViewport().classList.remove("ol-grab", "ol-grabbing"));
  }
};
const Au = tx, xh = [
  "fullscreenchange",
  "webkitfullscreenchange",
  "MSFullscreenChange"
], Eh = {
  /**
   * Triggered after the map entered fullscreen.
   * @event FullScreenEventType#enterfullscreen
   * @api
   */
  ENTERFULLSCREEN: "enterfullscreen",
  /**
   * Triggered after the map leave fullscreen.
   * @event FullScreenEventType#leavefullscreen
   * @api
   */
  LEAVEFULLSCREEN: "leavefullscreen"
};
let ix = class extends Li {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {}, super({
      element: document.createElement("div"),
      target: e.target
    }), this.on, this.once, this.un, this.keys_ = e.keys !== void 0 ? e.keys : !1, this.source_ = e.source, this.isInFullscreen_ = !1, this.boundHandleMapTargetChange_ = this.handleMapTargetChange_.bind(this), this.cssClassName_ = e.className !== void 0 ? e.className : "ol-full-screen", this.documentListeners_ = [], this.activeClassName_ = e.activeClassName !== void 0 ? e.activeClassName.split(" ") : [this.cssClassName_ + "-true"], this.inactiveClassName_ = e.inactiveClassName !== void 0 ? e.inactiveClassName.split(" ") : [this.cssClassName_ + "-false"];
    const t = e.label !== void 0 ? e.label : "⤢";
    this.labelNode_ = typeof t == "string" ? document.createTextNode(t) : t;
    const i = e.labelActive !== void 0 ? e.labelActive : "×";
    this.labelActiveNode_ = typeof i == "string" ? document.createTextNode(i) : i;
    const n = e.tipLabel ? e.tipLabel : "Toggle full-screen";
    this.button_ = document.createElement("button"), this.button_.title = n, this.button_.setAttribute("type", "button"), this.button_.appendChild(this.labelNode_), this.button_.addEventListener(
      z.CLICK,
      this.handleClick_.bind(this),
      !1
    ), this.setClassName_(this.button_, this.isInFullscreen_), this.element.className = `${this.cssClassName_} ${Ii} ${cs}`, this.element.appendChild(this.button_);
  }
  /**
   * @param {MouseEvent} event The event to handle
   * @private
   */
  handleClick_(e) {
    e.preventDefault(), this.handleFullScreen_();
  }
  /**
   * @private
   */
  handleFullScreen_() {
    const e = this.getMap();
    if (!e)
      return;
    const t = e.getOwnerDocument();
    if (vh(t))
      if (Ch(t))
        sx(t);
      else {
        let i;
        this.source_ ? i = typeof this.source_ == "string" ? t.getElementById(this.source_) : this.source_ : i = e.getTargetElement(), this.keys_ ? nx(i) : Fu(i);
      }
  }
  /**
   * @private
   */
  handleFullScreenChange_() {
    const e = this.getMap();
    if (!e)
      return;
    const t = this.isInFullscreen_;
    this.isInFullscreen_ = Ch(e.getOwnerDocument()), t !== this.isInFullscreen_ && (this.setClassName_(this.button_, this.isInFullscreen_), this.isInFullscreen_ ? (an(this.labelActiveNode_, this.labelNode_), this.dispatchEvent(Eh.ENTERFULLSCREEN)) : (an(this.labelNode_, this.labelActiveNode_), this.dispatchEvent(Eh.LEAVEFULLSCREEN)), e.updateSize());
  }
  /**
   * @param {HTMLElement} element Target element
   * @param {boolean} fullscreen True if fullscreen class name should be active
   * @private
   */
  setClassName_(e, t) {
    t ? (e.classList.remove(...this.inactiveClassName_), e.classList.add(...this.activeClassName_)) : (e.classList.remove(...this.activeClassName_), e.classList.add(...this.inactiveClassName_));
  }
  /**
   * Remove the control from its current map and attach it to the new map.
   * Pass `null` to just remove the control from the current map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default|null} map Map.
   * @api
   */
  setMap(e) {
    const t = this.getMap();
    t && t.removeChangeListener(
      pe.TARGET,
      this.boundHandleMapTargetChange_
    ), super.setMap(e), this.handleMapTargetChange_(), e && e.addChangeListener(
      pe.TARGET,
      this.boundHandleMapTargetChange_
    );
  }
  /**
   * @private
   */
  handleMapTargetChange_() {
    const e = this.documentListeners_;
    for (let i = 0, n = e.length; i < n; ++i)
      re(e[i]);
    e.length = 0;
    const t = this.getMap();
    if (t) {
      const i = t.getOwnerDocument();
      vh(i) ? this.element.classList.remove(bl) : this.element.classList.add(bl);
      for (let n = 0, r = xh.length; n < r; ++n)
        e.push(
          H(i, xh[n], this.handleFullScreenChange_, this)
        );
      this.handleFullScreenChange_();
    }
  }
};
function vh(s) {
  const e = s.body;
  return !!(e.webkitRequestFullscreen || e.requestFullscreen && s.fullscreenEnabled);
}
function Ch(s) {
  return !!(s.webkitIsFullScreen || s.fullscreenElement);
}
function Fu(s) {
  s.requestFullscreen ? s.requestFullscreen() : s.webkitRequestFullscreen && s.webkitRequestFullscreen();
}
function nx(s) {
  s.webkitRequestFullscreen ? s.webkitRequestFullscreen() : Fu(s);
}
function sx(s) {
  s.exitFullscreen ? s.exitFullscreen() : s.webkitExitFullscreen && s.webkitExitFullscreen();
}
const rx = ix, To = "projection", wh = "coordinateFormat";
let ox = class extends Li {
  /**
   * @param {Options} [options] Mouse position options.
   */
  constructor(e) {
    e = e || {};
    const t = document.createElement("div");
    t.className = e.className !== void 0 ? e.className : "ol-mouse-position", super({
      element: t,
      render: e.render,
      target: e.target
    }), this.on, this.once, this.un, this.addChangeListener(To, this.handleProjectionChanged_), e.coordinateFormat && this.setCoordinateFormat(e.coordinateFormat), e.projection && this.setProjection(e.projection), this.renderOnMouseOut_ = e.placeholder !== void 0, this.placeholder_ = this.renderOnMouseOut_ ? e.placeholder : "&#160;", this.renderedHTML_ = t.innerHTML, this.mapProjection_ = null, this.transform_ = null, this.wrapX_ = e.wrapX !== !1;
  }
  /**
   * @private
   */
  handleProjectionChanged_() {
    this.transform_ = null;
  }
  /**
   * Return the coordinate format type used to render the current position or
   * undefined.
   * @return {import("../coordinate.js").CoordinateFormat|undefined} The format to render the current
   *     position in.
   * @observable
   * @api
   */
  getCoordinateFormat() {
    return (
      /** @type {import("../coordinate.js").CoordinateFormat|undefined} */
      this.get(wh)
    );
  }
  /**
   * Return the projection that is used to report the mouse position.
   * @return {import("../proj/Projection.js").default|undefined} The projection to report mouse
   *     position in.
   * @observable
   * @api
   */
  getProjection() {
    return (
      /** @type {import("../proj/Projection.js").default|undefined} */
      this.get(To)
    );
  }
  /**
   * @param {MouseEvent} event Browser event.
   * @protected
   */
  handleMouseMove(e) {
    const t = this.getMap();
    this.updateHTML_(t.getEventPixel(e));
  }
  /**
   * @param {Event} event Browser event.
   * @protected
   */
  handleMouseOut(e) {
    this.updateHTML_(null);
  }
  /**
   * Remove the control from its current map and attach it to the new map.
   * Pass `null` to just remove the control from the current map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default|null} map Map.
   * @api
   */
  setMap(e) {
    if (super.setMap(e), e) {
      const t = e.getViewport();
      this.listenerKeys.push(
        H(t, jn.POINTERMOVE, this.handleMouseMove, this)
      ), this.renderOnMouseOut_ && this.listenerKeys.push(
        H(t, jn.POINTEROUT, this.handleMouseOut, this)
      ), this.updateHTML_(null);
    }
  }
  /**
   * Set the coordinate format type used to render the current position.
   * @param {import("../coordinate.js").CoordinateFormat} format The format to render the current
   *     position in.
   * @observable
   * @api
   */
  setCoordinateFormat(e) {
    this.set(wh, e);
  }
  /**
   * Set the projection that is used to report the mouse position.
   * @param {import("../proj.js").ProjectionLike} projection The projection to report mouse
   *     position in.
   * @observable
   * @api
   */
  setProjection(e) {
    this.set(To, ye(e));
  }
  /**
   * @param {?import("../pixel.js").Pixel} pixel Pixel.
   * @private
   */
  updateHTML_(e) {
    let t = this.placeholder_;
    if (e && this.mapProjection_) {
      if (!this.transform_) {
        const r = this.getProjection();
        r ? this.transform_ = Rr(
          this.mapProjection_,
          r
        ) : this.transform_ = ya;
      }
      const n = this.getMap().getCoordinateFromPixelInternal(e);
      if (n) {
        if (this.transform_(n, n), this.wrapX_) {
          const o = this.getProjection() || this.mapProjection_;
          _a(n, o);
        }
        const r = this.getCoordinateFormat();
        r ? t = r(n) : t = n.toString();
      }
    }
    (!this.renderedHTML_ || t !== this.renderedHTML_) && (this.element.innerHTML = t, this.renderedHTML_ = t);
  }
  /**
   * Update the projection. Rendering of the coordinates is done in
   * `handleMouseMove` and `handleMouseUp`.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @override
   */
  render(e) {
    const t = e.frameState;
    t ? this.mapProjection_ != t.viewState.projection && (this.mapProjection_ = t.viewState.projection, this.transform_ = null) : this.mapProjection_ = null;
  }
};
const ax = ox, So = 0.75, Hs = 0.1;
class lx extends Li {
  /**
   * @param {Options} [options] OverviewMap options.
   */
  constructor(e) {
    e = e || {}, super({
      element: document.createElement("div"),
      render: e.render,
      target: e.target
    }), this.boundHandleRotationChanged_ = this.handleRotationChanged_.bind(this), this.collapsed_ = e.collapsed !== void 0 ? e.collapsed : !0, this.collapsible_ = e.collapsible !== void 0 ? e.collapsible : !0, this.collapsible_ || (this.collapsed_ = !1), this.rotateWithView_ = e.rotateWithView !== void 0 ? e.rotateWithView : !1, this.viewExtent_ = void 0;
    const t = e.className !== void 0 ? e.className : "ol-overviewmap", i = e.tipLabel !== void 0 ? e.tipLabel : "Overview map", n = e.collapseLabel !== void 0 ? e.collapseLabel : "‹";
    typeof n == "string" ? (this.collapseLabel_ = document.createElement("span"), this.collapseLabel_.textContent = n) : this.collapseLabel_ = n;
    const r = e.label !== void 0 ? e.label : "›";
    typeof r == "string" ? (this.label_ = document.createElement("span"), this.label_.textContent = r) : this.label_ = r;
    const o = this.collapsible_ && !this.collapsed_ ? this.collapseLabel_ : this.label_, a = document.createElement("button");
    a.setAttribute("type", "button"), a.title = i, a.appendChild(o), a.addEventListener(
      z.CLICK,
      this.handleClick_.bind(this),
      !1
    ), this.ovmapDiv_ = document.createElement("div"), this.ovmapDiv_.className = "ol-overviewmap-map", this.view_ = e.view;
    const l = new wc({
      view: e.view,
      controls: new ce(),
      interactions: new ce()
    });
    this.ovmap_ = l, e.layers && e.layers.forEach(function(x) {
      l.addLayer(x);
    });
    const h = document.createElement("div");
    h.className = "ol-overviewmap-box", h.style.boxSizing = "border-box", this.boxOverlay_ = new ta({
      position: [0, 0],
      positioning: "center-center",
      element: h
    }), this.ovmap_.addOverlay(this.boxOverlay_);
    const c = t + " " + Ii + " " + cs + (this.collapsed_ && this.collapsible_ ? " " + ar : "") + (this.collapsible_ ? "" : " ol-uncollapsible"), u = this.element;
    u.className = c, u.appendChild(this.ovmapDiv_), u.appendChild(a);
    const d = this, f = this.boxOverlay_, g = this.boxOverlay_.getElement(), _ = function(x) {
      return {
        clientX: x.clientX,
        clientY: x.clientY
      };
    }, m = function(x) {
      const y = (
        /** @type {?} */
        _(x)
      ), E = l.getEventCoordinateInternal(
        /** @type {MouseEvent} */
        y
      );
      f.setPosition(E);
    }, p = function(x) {
      const y = l.getEventCoordinateInternal(x);
      d.getMap().getView().setCenterInternal(y), window.removeEventListener("mousemove", m), window.removeEventListener("mouseup", p);
    };
    g.addEventListener("mousedown", function() {
      window.addEventListener("mousemove", m), window.addEventListener("mouseup", p);
    });
  }
  /**
   * Remove the control from its current map and attach it to the new map.
   * Pass `null` to just remove the control from the current map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default|null} map Map.
   * @api
   */
  setMap(e) {
    const t = this.getMap();
    if (e !== t) {
      if (t) {
        const i = t.getView();
        i && this.unbindView_(i), this.ovmap_.setTarget(null);
      }
      if (super.setMap(e), e) {
        this.ovmap_.setTarget(this.ovmapDiv_), this.listenerKeys.push(
          H(
            e,
            Ei.PROPERTYCHANGE,
            this.handleMapPropertyChange_,
            this
          )
        );
        const i = e.getView();
        i && (this.bindView_(i), i.isDef() && (this.ovmap_.updateSize(), this.resetExtent_())), this.ovmap_.isRendered() || this.updateBoxAfterOvmapIsRendered_();
      }
    }
  }
  /**
   * Handle map property changes.  This only deals with changes to the map's view.
   * @param {import("../Object.js").ObjectEvent} event The propertychange event.
   * @private
   */
  handleMapPropertyChange_(e) {
    if (e.key === pe.VIEW) {
      const t = (
        /** @type {import("../View.js").default} */
        e.oldValue
      );
      t && this.unbindView_(t);
      const i = this.getMap().getView();
      this.bindView_(i);
    } else
      !this.ovmap_.isRendered() && (e.key === pe.TARGET || e.key === pe.SIZE) && this.ovmap_.updateSize();
  }
  /**
   * Register listeners for view property changes.
   * @param {import("../View.js").default} view The view.
   * @private
   */
  bindView_(e) {
    if (!this.view_) {
      const t = new Pe({
        projection: e.getProjection()
      });
      this.ovmap_.setView(t);
    }
    e.addChangeListener(
      je.ROTATION,
      this.boundHandleRotationChanged_
    ), this.handleRotationChanged_();
  }
  /**
   * Unregister listeners for view property changes.
   * @param {import("../View.js").default} view The view.
   * @private
   */
  unbindView_(e) {
    e.removeChangeListener(
      je.ROTATION,
      this.boundHandleRotationChanged_
    );
  }
  /**
   * Handle rotation changes to the main map.
   * @private
   */
  handleRotationChanged_() {
    this.rotateWithView_ && this.ovmap_.getView().setRotation(this.getMap().getView().getRotation());
  }
  /**
   * Reset the overview map extent if the box size (width or
   * height) is less than the size of the overview map size times minRatio
   * or is greater than the size of the overview size times maxRatio.
   *
   * If the map extent was not reset, the box size can fits in the defined
   * ratio sizes. This method then checks if is contained inside the overview
   * map current extent. If not, recenter the overview map to the current
   * main map center location.
   * @private
   */
  validateExtent_() {
    const e = this.getMap(), t = this.ovmap_;
    if (!e.isRendered() || !t.isRendered())
      return;
    const i = (
      /** @type {import("../size.js").Size} */
      e.getSize()
    ), r = e.getView().calculateExtentInternal(i);
    if (this.viewExtent_ && ti(r, this.viewExtent_))
      return;
    this.viewExtent_ = r;
    const o = (
      /** @type {import("../size.js").Size} */
      t.getSize()
    ), l = t.getView().calculateExtentInternal(o), h = t.getPixelFromCoordinateInternal(
      Ot(r)
    ), c = t.getPixelFromCoordinateInternal(
      un(r)
    ), u = Math.abs(h[0] - c[0]), d = Math.abs(h[1] - c[1]), f = o[0], g = o[1];
    u < f * Hs || d < g * Hs || u > f * So || d > g * So ? this.resetExtent_() : Ft(l, r) || this.recenter_();
  }
  /**
   * Reset the overview map extent to half calculated min and max ratio times
   * the extent of the main map.
   * @private
   */
  resetExtent_() {
    const e = this.getMap(), t = this.ovmap_, i = (
      /** @type {import("../size.js").Size} */
      e.getSize()
    ), r = e.getView().calculateExtentInternal(i), o = t.getView(), a = Math.log(So / Hs) / Math.LN2, l = 1 / (Math.pow(2, a / 2) * Hs);
    Oh(r, l), o.fitInternal(ci(r));
  }
  /**
   * Set the center of the overview map to the map center without changing its
   * resolution.
   * @private
   */
  recenter_() {
    const e = this.getMap(), t = this.ovmap_, i = e.getView();
    t.getView().setCenterInternal(i.getCenterInternal());
  }
  /**
   * Update the box using the main map extent
   * @private
   */
  updateBox_() {
    const e = this.getMap(), t = this.ovmap_;
    if (!e.isRendered() || !t.isRendered())
      return;
    const i = (
      /** @type {import("../size.js").Size} */
      e.getSize()
    ), n = e.getView(), r = t.getView(), o = this.rotateWithView_ ? 0 : -n.getRotation(), a = this.boxOverlay_, l = this.boxOverlay_.getElement(), h = n.getCenterInternal(), c = n.getResolution(), u = r.getResolution(), d = i[0] * c / u, f = i[1] * c / u;
    if (a.setPosition(h), l) {
      l.style.width = d + "px", l.style.height = f + "px";
      const g = "rotate(" + o + "rad)";
      l.style.transform = g;
    }
  }
  /**
   * @private
   */
  updateBoxAfterOvmapIsRendered_() {
    this.ovmapPostrenderKey_ || (this.ovmapPostrenderKey_ = kn(
      this.ovmap_,
      dt.POSTRENDER,
      function(e) {
        delete this.ovmapPostrenderKey_, this.updateBox_();
      },
      this
    ));
  }
  /**
   * @param {MouseEvent} event The event to handle
   * @private
   */
  handleClick_(e) {
    e.preventDefault(), this.handleToggle_();
  }
  /**
   * @private
   */
  handleToggle_() {
    this.element.classList.toggle(ar), this.collapsed_ ? an(this.collapseLabel_, this.label_) : an(this.label_, this.collapseLabel_), this.collapsed_ = !this.collapsed_;
    const e = this.ovmap_;
    if (!this.collapsed_) {
      if (e.isRendered()) {
        this.viewExtent_ = void 0, e.render();
        return;
      }
      e.updateSize(), this.resetExtent_(), this.updateBoxAfterOvmapIsRendered_();
    }
  }
  /**
   * Return `true` if the overview map is collapsible, `false` otherwise.
   * @return {boolean} True if the widget is collapsible.
   * @api
   */
  getCollapsible() {
    return this.collapsible_;
  }
  /**
   * Set whether the overview map should be collapsible.
   * @param {boolean} collapsible True if the widget is collapsible.
   * @api
   */
  setCollapsible(e) {
    this.collapsible_ !== e && (this.collapsible_ = e, this.element.classList.toggle("ol-uncollapsible"), !e && this.collapsed_ && this.handleToggle_());
  }
  /**
   * Collapse or expand the overview map according to the passed parameter. Will
   * not do anything if the overview map isn't collapsible or if the current
   * collapsed state is already the one requested.
   * @param {boolean} collapsed True if the widget is collapsed.
   * @api
   */
  setCollapsed(e) {
    !this.collapsible_ || this.collapsed_ === e || this.handleToggle_();
  }
  /**
   * Determine if the overview map is collapsed.
   * @return {boolean} The overview map is collapsed.
   * @api
   */
  getCollapsed() {
    return this.collapsed_;
  }
  /**
   * Return `true` if the overview map view can rotate, `false` otherwise.
   * @return {boolean} True if the control view can rotate.
   * @api
   */
  getRotateWithView() {
    return this.rotateWithView_;
  }
  /**
   * Set whether the overview map view should rotate with the main map view.
   * @param {boolean} rotateWithView True if the control view should rotate.
   * @api
   */
  setRotateWithView(e) {
    this.rotateWithView_ !== e && (this.rotateWithView_ = e, this.getMap().getView().getRotation() !== 0 && (this.rotateWithView_ ? this.handleRotationChanged_() : this.ovmap_.getView().setRotation(0), this.viewExtent_ = void 0, this.validateExtent_(), this.updateBox_()));
  }
  /**
   * Return the overview map.
   * @return {import("../Map.js").default} Overview map.
   * @api
   */
  getOverviewMap() {
    return this.ovmap_;
  }
  /**
   * Update the overview map element.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @override
   */
  render(e) {
    this.validateExtent_(), this.updateBox_();
  }
}
const hx = lx, Ro = "units", cx = [1, 2, 5], Cn = 25.4 / 0.28;
let ux = class extends Li {
  /**
   * @param {Options} [options] Scale line options.
   */
  constructor(e) {
    e = e || {};
    const t = document.createElement("div");
    t.style.pointerEvents = "none", super({
      element: t,
      render: e.render,
      target: e.target
    }), this.on, this.once, this.un;
    const i = e.className !== void 0 ? e.className : e.bar ? "ol-scale-bar" : "ol-scale-line";
    this.innerElement_ = document.createElement("div"), this.innerElement_.className = i + "-inner", this.element.className = i + " " + Ii, this.element.appendChild(this.innerElement_), this.viewState_ = null, this.minWidth_ = e.minWidth !== void 0 ? e.minWidth : 64, this.maxWidth_ = e.maxWidth, this.renderedVisible_ = !1, this.renderedWidth_ = void 0, this.renderedHTML_ = "", this.addChangeListener(Ro, this.handleUnitsChanged_), this.setUnits(e.units || "metric"), this.scaleBar_ = e.bar || !1, this.scaleBarSteps_ = e.steps || 4, this.scaleBarText_ = e.text || !1, this.dpi_ = e.dpi || void 0;
  }
  /**
   * Return the units to use in the scale line.
   * @return {Units} The units
   * to use in the scale line.
   * @observable
   * @api
   */
  getUnits() {
    return this.get(Ro);
  }
  /**
   * @private
   */
  handleUnitsChanged_() {
    this.updateElement_();
  }
  /**
   * Set the units to use in the scale line.
   * @param {Units} units The units to use in the scale line.
   * @observable
   * @api
   */
  setUnits(e) {
    this.set(Ro, e);
  }
  /**
   * Specify the dpi of output device such as printer.
   * @param {number|undefined} dpi The dpi of output device.
   * @api
   */
  setDpi(e) {
    this.dpi_ = e;
  }
  /**
   * @private
   */
  updateElement_() {
    const e = this.viewState_;
    if (!e) {
      this.renderedVisible_ && (this.element.style.display = "none", this.renderedVisible_ = !1);
      return;
    }
    const t = e.center, i = e.projection, n = this.getUnits(), r = n == "degrees" ? "degrees" : "m";
    let o = nr(
      i,
      e.resolution,
      t,
      r
    );
    const a = this.minWidth_ * (this.dpi_ || Cn) / Cn, l = this.maxWidth_ !== void 0 ? this.maxWidth_ * (this.dpi_ || Cn) / Cn : void 0;
    let h = a * o, c = "";
    if (n == "degrees") {
      const y = on.degrees;
      h *= y, h < y / 60 ? (c = "″", o *= 3600) : h < y ? (c = "′", o *= 60) : c = "°";
    } else
      n == "imperial" ? h < 0.9144 ? (c = "in", o /= 0.0254) : h < 1609.344 ? (c = "ft", o /= 0.3048) : (c = "mi", o /= 1609.344) : n == "nautical" ? (o /= 1852, c = "NM") : n == "metric" ? h < 1e-3 ? (c = "μm", o *= 1e6) : h < 1 ? (c = "mm", o *= 1e3) : h < 1e3 ? c = "m" : (c = "km", o /= 1e3) : n == "us" ? h < 0.9144 ? (c = "in", o *= 39.37) : h < 1609.344 ? (c = "ft", o /= 0.30480061) : (c = "mi", o /= 1609.3472) : Z(!1, 33);
    let u = 3 * Math.floor(Math.log(a * o) / Math.log(10)), d, f, g, _, m, p;
    for (; ; ) {
      g = Math.floor(u / 3);
      const y = Math.pow(10, g);
      if (d = cx[(u % 3 + 3) % 3] * y, f = Math.round(d / o), isNaN(f)) {
        this.element.style.display = "none", this.renderedVisible_ = !1;
        return;
      }
      if (l !== void 0 && f >= l) {
        d = _, f = m, g = p;
        break;
      } else if (f >= a)
        break;
      _ = d, m = f, p = g, ++u;
    }
    const x = this.scaleBar_ ? this.createScaleBar(f, d, c) : d.toFixed(g < 0 ? -g : 0) + " " + c;
    this.renderedHTML_ != x && (this.innerElement_.innerHTML = x, this.renderedHTML_ = x), this.renderedWidth_ != f && (this.innerElement_.style.width = f + "px", this.renderedWidth_ = f), this.renderedVisible_ || (this.element.style.display = "", this.renderedVisible_ = !0);
  }
  /**
   * @private
   * @param {number} width The current width of the scalebar.
   * @param {number} scale The current scale.
   * @param {string} suffix The suffix to append to the scale text.
   * @return {string} The stringified HTML of the scalebar.
   */
  createScaleBar(e, t, i) {
    const n = this.getScaleForResolution(), r = n < 1 ? Math.round(1 / n).toLocaleString() + " : 1" : "1 : " + Math.round(n).toLocaleString(), o = this.scaleBarSteps_, a = e / o, l = [this.createMarker("absolute")];
    for (let c = 0; c < o; ++c) {
      const u = c % 2 === 0 ? "ol-scale-singlebar-odd" : "ol-scale-singlebar-even";
      l.push(
        `<div><div class="ol-scale-singlebar ${u}" style="width: ${a}px;"></div>` + this.createMarker("relative") + // render text every second step, except when only 2 steps
        (c % 2 === 0 || o === 2 ? this.createStepText(c, e, !1, t, i) : "") + "</div>"
      );
    }
    return l.push(this.createStepText(o, e, !0, t, i)), (this.scaleBarText_ ? `<div class="ol-scale-text" style="width: ${e}px;">` + r + "</div>" : "") + l.join("");
  }
  /**
   * Creates a marker at given position
   * @param {'absolute'|'relative'} position The position, absolute or relative
   * @return {string} The stringified div containing the marker
   */
  createMarker(e) {
    return `<div class="ol-scale-step-marker" style="position: ${e}; top: ${e === "absolute" ? 3 : -10}px;"></div>`;
  }
  /**
   * Creates the label for a marker marker at given position
   * @param {number} i The iterator
   * @param {number} width The width the scalebar will currently use
   * @param {boolean} isLast Flag indicating if we add the last step text
   * @param {number} scale The current scale for the whole scalebar
   * @param {string} suffix The suffix for the scale
   * @return {string} The stringified div containing the step text
   */
  createStepText(e, t, i, n, r) {
    const a = (e === 0 ? 0 : Math.round(n / this.scaleBarSteps_ * e * 100) / 100) + (e === 0 ? "" : " " + r), l = e === 0 ? -3 : t / this.scaleBarSteps_ * -1, h = e === 0 ? 0 : t / this.scaleBarSteps_ * 2;
    return `<div class="ol-scale-step-text" style="margin-left: ${l}px;text-align: ${e === 0 ? "left" : "center"};min-width: ${h}px;left: ${i ? t + "px" : "unset"};">` + a + "</div>";
  }
  /**
   * Returns the appropriate scale for the given resolution and units.
   * @return {number} The appropriate scale.
   */
  getScaleForResolution() {
    const e = nr(
      this.viewState_.projection,
      this.viewState_.resolution,
      this.viewState_.center,
      "m"
    ), t = this.dpi_ || Cn, i = 1e3 / 25.4;
    return e * i * t;
  }
  /**
   * Update the scale line element.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @override
   */
  render(e) {
    const t = e.frameState;
    t ? this.viewState_ = t.viewState : this.viewState_ = null, this.updateElement_();
  }
};
const dx = ux, Th = (s) => s instanceof qe, Io = (s) => s instanceof We;
class fx extends Iu {
  constructor(t) {
    const i = new ce();
    super({
      features: i,
      insertVertexCondition: function(n) {
        const o = n.target.forEachFeatureAtPixel(n.pixel, (a) => {
          const l = a.getGeometry();
          return Th(l) || Io(l) ? a : !1;
        });
        return o ? Io(o.getGeometry()) : !1;
      },
      condition: function(n) {
        const r = n.target, o = r.forEachFeatureAtPixel(n.pixel, (l) => {
          const h = l.getGeometry();
          return Th(h) || Io(h) ? l : !1;
        });
        return r.getSelectedFeatures().getArray().findIndex((l) => l === o) > -1;
      }
    });
    v(this, "_map_instance");
    v(this, "_modify_features");
    this._map_instance = t, this._modify_features = i, this.setActive(!1), this.on("change:active", (n) => {
      const r = this._map_instance.getSelectedFeatures().getArray();
      n.target.getActive() ? (r.forEach((o) => oa.setModifyStyle(o, !0)), this._modify_features.extend(r).extend(r)) : (this._modify_features.clear(), r.forEach((o) => oa.setModifyStyle(o, !1)));
    });
  }
}
var Cr = class extends Dt {
  constructor(e) {
    e = e || {}, super({
      handleDownEvent: function(i) {
        return t.handleDownEvent_(i);
      },
      handleDragEvent: function(i) {
        return this.handleDragEvent_(i);
      },
      handleMoveEvent: function(i) {
        return this.handleMoveEvent_(i);
      },
      handleUpEvent: function(i) {
        return this.handleUpEvent_(i);
      }
    });
    var t = this;
    this.selection_ = new ce(), this.handles_ = new ce(), this.overlayLayer_ = new Be({
      source: new we({
        features: this.handles_,
        useSpatialIndex: !1,
        wrapX: !1
        // For vector editing across the -180° and 180° meridians to work properly, this should be set to false
      }),
      name: "Transform overlay",
      displayInLayerSwitcher: !1,
      // Return the style according to the handle type
      style: function(i) {
        return t.style[(i.get("handle") || "default") + (i.get("constraint") || "") + (i.get("option") || "")];
      }
    }), this.features_ = e.features, typeof e.filter == "function" && (this._filter = e.filter), this.layers_ = e.layers ? e.layers instanceof Array ? e.layers : [e.layers] : null, this._handleEvent = e.condition || function() {
      return !0;
    }, this.addFn_ = e.addCondition || function() {
      return !1;
    }, this.setPointRadius(e.pointRadius), this.set("translateFeature", e.translateFeature !== !1), this.set("translate", e.translate !== !1), this.set("translateBBox", e.translateBBox === !0), this.set("stretch", e.stretch !== !1), this.set("scale", e.scale !== !1), this.set("rotate", e.rotate !== !1), this.set("keepAspectRatio", e.keepAspectRatio || function(i) {
      return i.originalEvent.shiftKey;
    }), this.set("modifyCenter", e.modifyCenter || function(i) {
      return i.originalEvent.metaKey || i.originalEvent.ctrlKey;
    }), this.set("noFlip", e.noFlip || !1), this.set("selection", e.selection !== !1), this.set("hitTolerance", e.hitTolerance || 0), this.set("enableRotatedTransform", e.enableRotatedTransform || !1), this.set("keepRectangle", e.keepRectangle || !1), this.set("buffer", e.buffer || 0), this.on("propertychange", function() {
      this.drawSketch_();
    }), this.setDefaultStyle();
  }
  /**
   * Remove the interaction from its current map, if any,  and attach it to a new
   * map, if any. Pass `null` to just remove the interaction from the current map.
   * @param {ol.Map} map Map.
   * @api stable
   */
  setMap(e) {
    var t = this.getMap();
    if (t) {
      var i = t.getTargetElement();
      t.removeLayer(this.overlayLayer_), this.previousCursor_ && i && (i.style.cursor = this.previousCursor_), this.previousCursor_ = void 0;
    }
    super.setMap(e), this.overlayLayer_.setMap(e), e === null && this.select(null), e !== null && (this.isTouch = /touch/.test(e.getViewport().className), this.setDefaultStyle());
  }
  /**
   * Activate/deactivate interaction
   * @param {bool}
   * @api stable
   */
  setActive(e) {
    this.select(null), this.overlayLayer_ && this.overlayLayer_.setVisible(e), super.setActive(e);
  }
  /** Set default sketch style
   * @param {Object|undefined} options
   *  @param {ol_style_Stroke} stroke stroke style for selection rectangle
   *  @param {ol_style_Fill} fill fill style for selection rectangle
   *  @param {ol_style_Stroke} pointStroke stroke style for handles
   *  @param {ol_style_Fill} pointFill fill style for handles
   */
  setDefaultStyle(e) {
    e = e || {};
    var t = e.pointStroke || new K({ color: [255, 0, 0, 1], width: 1 }), i = e.stroke || new K({ color: [255, 0, 0, 1], width: 1, lineDash: [4, 4] }), n = e.fill || new N({ color: [255, 0, 0, 0.01] }), r = e.pointFill || new N({ color: [255, 255, 255, 0.8] }), o = new Fn({
      fill: r,
      stroke: t,
      radius: this.isTouch ? 12 : 6,
      displacement: this.isTouch ? [24, -24] : [12, -12],
      points: 15
    });
    o.setDisplacement || (o.getAnchor()[0] = this.isTouch ? -10 : -5);
    var a = new Fn({
      fill: r,
      stroke: t,
      radius: this.isTouch ? 16 : 8,
      points: 4,
      angle: Math.PI / 4
    }), l = new Fn({
      fill: r,
      stroke: t,
      radius: this.isTouch ? 12 : 6,
      points: 4,
      angle: Math.PI / 4
    });
    function h(c, u, d) {
      return [new se({ image: c, stroke: u, fill: d })];
    }
    this.style = {
      default: h(a, i, n),
      translate: h(a, t, r),
      rotate: h(o, t, r),
      rotate0: h(a, t, r),
      scale: h(a, t, r),
      scale1: h(a, t, r),
      scale2: h(a, t, r),
      scale3: h(a, t, r),
      scalev: h(l, t, r),
      scaleh1: h(l, t, r),
      scalev2: h(l, t, r),
      scaleh3: h(l, t, r)
    }, this.drawSketch_();
  }
  /**
   * Set sketch style.
   * @param {style} style Style name: 'default','translate','rotate','rotate0','scale','scale1','scale2','scale3','scalev','scaleh1','scalev2','scaleh3'
   * @param {ol.style.Style|Array<ol.style.Style>} olstyle
   * @api stable
   */
  setStyle(e, t) {
    if (t) {
      t instanceof Array ? this.style[e] = t : this.style[e] = [t];
      for (var i = 0; i < this.style[e].length; i++) {
        var n = this.style[e][i].getImage();
        n && (e == "rotate" && (n.getAnchor()[0] = -5), this.isTouch && n.setScale(1.8));
        var r = this.style[e][i].getText();
        r && (e == "rotate" && r.setOffsetX(this.isTouch ? 14 : 7), this.isTouch && r.setScale(1.8));
      }
      this.drawSketch_();
    }
  }
  /** Get Feature at pixel
   * @param {ol.Pixel}
   * @return {ol.feature}
   * @private
   */
  getFeatureAtPixel_(e) {
    var t = this;
    return this.getMap().forEachFeatureAtPixel(
      e,
      function(i, n) {
        var r = !1;
        if (!n) {
          if (i === t.bbox_)
            return t.get("translateBBox") ? { feature: i, handle: "translate", constraint: "", option: "" } : !1;
          if (t.handles_.forEach(function(a) {
            a === i && (r = !0);
          }), r)
            return { feature: i, handle: i.get("handle"), constraint: i.get("constraint"), option: i.get("option") };
        }
        if (!t.get("selection"))
          return t.selection_.getArray().some(function(a) {
            return i === a;
          }) ? { feature: i } : null;
        if (t._filter)
          return t._filter(i, n) ? { feature: i } : null;
        if (t.layers_) {
          for (var o = 0; o < t.layers_.length; o++)
            if (t.layers_[o] === n)
              return { feature: i };
          return null;
        } else
          return t.features_ ? (t.features_.forEach(function(a) {
            a === i && (r = !0);
          }), r ? { feature: i } : null) : { feature: i };
      },
      { hitTolerance: this.get("hitTolerance") }
    ) || {};
  }
  /** Rotate feature from map view rotation
   * @param {ol.Feature} f the feature
   * @param {boolean} clone clone resulting geom
   * @param {ol.geom.Geometry} rotated geometry
   */
  getGeometryRotateToZero_(e, t) {
    var i = e.getGeometry(), n = this.getMap().getView().getRotation();
    if (n === 0 || !this.get("enableRotatedTransform"))
      return t ? i.clone() : i;
    var r = i.clone();
    return r.rotate(n * -1, this.getMap().getView().getCenter()), r;
  }
  /** Test if rectangle
   * @param {ol.Geometry} geom
   * @returns {boolean}
   * @private
   */
  _isRectangle(e) {
    if (this.get("keepRectangle") && e.getType() === "Polygon") {
      var t = e.getCoordinates()[0];
      return t.length === 5;
    }
    return !1;
  }
  /** Draw transform sketch
  * @param {boolean} draw only the center
  */
  drawSketch_(e) {
    var t, i, n, r = this.selection_.item(0) && this._isRectangle(this.selection_.item(0).getGeometry());
    if (this.overlayLayer_.getSource().clear(), !!this.selection_.getLength()) {
      var o = this.getMap().getView().getRotation(), a = this.getGeometryRotateToZero_(this.selection_.item(0)).getExtent(), l;
      r && (l = this.getGeometryRotateToZero_(this.selection_.item(0)).getCoordinates()[0].slice(0, 4), l.unshift(l[3])), a = Si(a, this.get("buffer")), this.selection_.forEach(function(_) {
        var m = this.getGeometryRotateToZero_(_).getExtent();
        In(a, m);
      }.bind(this));
      var h = this.selection_.getLength() === 1 ? this._pointRadius(this.selection_.item(0)) : 0;
      if (h && !(h instanceof Array) && (h = [h, h]), e === !0)
        this.ispt_ || (this.overlayLayer_.getSource().addFeature(new $({ geometry: new Ee(this.center_), handle: "rotate0" })), n = ci(a), this.get("enableRotatedTransform") && o !== 0 && n.rotate(o, this.getMap().getView().getCenter()), i = this.bbox_ = new $(n), this.overlayLayer_.getSource().addFeature(i));
      else {
        if (this.ispt_) {
          var c = this.getMap().getPixelFromCoordinate([a[0], a[1]]);
          if (c) {
            var u = h && h[0] || 10, d = h && h[1] || 10;
            a = ze([
              this.getMap().getCoordinateFromPixel([c[0] - u, c[1] - d]),
              this.getMap().getCoordinateFromPixel([c[0] + u, c[1] + d])
            ]);
          }
        }
        n = r ? new We([l]) : ci(a), this.get("enableRotatedTransform") && o !== 0 && n.rotate(o, this.getMap().getView().getCenter()), i = this.bbox_ = new $(n);
        var f = [], g = n.getCoordinates()[0];
        if (!this.ispt_ || h) {
          if (f.push(i), !this.iscircle_ && !this.ispt_ && this.get("stretch") && this.get("scale"))
            for (t = 0; t < g.length - 1; t++)
              i = new $({ geometry: new Ee([(g[t][0] + g[t + 1][0]) / 2, (g[t][1] + g[t + 1][1]) / 2]), handle: "scale", constraint: t % 2 ? "h" : "v", option: t }), f.push(i);
          if (this.get("scale"))
            for (t = 0; t < g.length - 1; t++)
              i = new $({ geometry: new Ee(g[t]), handle: "scale", option: t }), f.push(i);
          this.get("translate") && !this.get("translateFeature") && (i = new $({ geometry: new Ee([(g[0][0] + g[2][0]) / 2, (g[0][1] + g[2][1]) / 2]), handle: "translate" }), f.push(i));
        }
        !this.iscircle_ && this.get("rotate") && (i = new $({ geometry: new Ee(g[3]), handle: "rotate" }), f.push(i)), this.overlayLayer_.getSource().addFeatures(f);
      }
    }
  }
  /** Select a feature to transform
  * @param {ol.Feature} feature the feature to transform
  * @param {boolean} add true to add the feature to the selection, default false
  */
  select(e, t) {
    if (!e) {
      this.selection_ && (this.selection_.clear(), this.drawSketch_());
      return;
    }
    if (!(!e.getGeometry || !e.getGeometry())) {
      if (t)
        this.selection_.push(e);
      else {
        var i = this.selection_.getArray().indexOf(e);
        this.selection_.removeAt(i);
      }
      this.ispt_ = this.selection_.getLength() === 1 ? this.selection_.item(0).getGeometry().getType() == "Point" : !1, this.iscircle_ = this.selection_.getLength() === 1 ? this.selection_.item(0).getGeometry().getType() == "Circle" : !1, this.drawSketch_(), this.watchFeatures_(), this.dispatchEvent({ type: "select", feature: e, features: this.selection_ });
    }
  }
  /** Update the selection collection.
  * @param {ol.Collection<ol.Feature>} features the features to transform
  */
  setSelection(e) {
    this.selection_.clear(), e.forEach(function(t) {
      this.selection_.push(t);
    }.bind(this)), this.ispt_ = this.selection_.getLength() === 1 ? this.selection_.item(0).getGeometry().getType() == "Point" : !1, this.iscircle_ = this.selection_.getLength() === 1 ? this.selection_.item(0).getGeometry().getType() == "Circle" : !1, this.drawSketch_(), this.watchFeatures_(), this.dispatchEvent({ type: "select", features: this.selection_ });
  }
  /** Watch selected features
   * @private
   */
  watchFeatures_() {
    this._featureListeners && this._featureListeners.forEach(function(e) {
      aa(e);
    }), this._featureListeners = [], this.selection_.forEach(function(e) {
      this._featureListeners.push(
        e.on("change", function() {
          this.isUpdating_ || this.drawSketch_();
        }.bind(this))
      );
    }.bind(this));
  }
  /**
   * @param {ol.MapBrowserEvent} evt Map browser event.
   * @return {boolean} `true` to start the drag sequence.
   * @private
   */
  handleDownEvent_(e) {
    if (this._handleEvent(e, this.selection_)) {
      var t = this.getFeatureAtPixel_(e.pixel), i = t.feature;
      if (this.selection_.getLength() && this.selection_.getArray().indexOf(i) >= 0 && (this.ispt_ && this.get("translate") || this.get("translateFeature")) && (t.handle = "translate"), t.handle) {
        this.mode_ = t.handle, this.opt_ = t.option, this.constraint_ = t.constraint;
        var n = this.getMap().getView().getRotation();
        this.coordinate_ = i.get("handle") ? i.getGeometry().getCoordinates() : e.coordinate, this.pixel_ = this.getMap().getCoordinateFromPixel(this.coordinate_), this.geoms_ = [], this.rotatedGeoms_ = [];
        for (var r = Me(), o = Me(), a = 0, l; l = this.selection_.item(a); a++)
          if (this.geoms_.push(l.getGeometry().clone()), r = In(r, l.getGeometry().getExtent()), this.get("enableRotatedTransform") && n !== 0) {
            var h = this.getGeometryRotateToZero_(l, !0);
            this.rotatedGeoms_.push(h), o = In(o, h.getExtent());
          }
        if (this.extent_ = ci(r).getCoordinates()[0], this.get("enableRotatedTransform") && n !== 0 && (this.rotatedExtent_ = ci(o).getCoordinates()[0]), this.mode_ === "rotate") {
          this.center_ = this.getCenter() || Ne(r);
          var c = e.map.getTargetElement();
          c.style.cursor = this.Cursors.rotate0, this.previousCursor_ = c.style.cursor;
        } else
          this.center_ = Ne(r);
        return this.angle_ = Math.atan2(this.center_[1] - e.coordinate[1], this.center_[0] - e.coordinate[0]), this.dispatchEvent({
          type: this.mode_ + "start",
          feature: this.selection_.item(0),
          features: this.selection_,
          pixel: e.pixel,
          coordinate: e.coordinate
        }), !0;
      } else if (this.get("selection")) {
        if (i) {
          this.addFn_(e) || this.selection_.clear();
          var u = this.selection_.getArray().indexOf(i);
          u < 0 ? this.selection_.push(i) : this.selection_.removeAt(u);
        } else
          this.selection_.clear();
        return this.ispt_ = this.selection_.getLength() === 1 ? this.selection_.item(0).getGeometry().getType() == "Point" : !1, this.iscircle_ = this.selection_.getLength() === 1 ? this.selection_.item(0).getGeometry().getType() == "Circle" : !1, this.drawSketch_(), this.watchFeatures_(), this.dispatchEvent({ type: "select", feature: i, features: this.selection_, pixel: e.pixel, coordinate: e.coordinate }), !1;
      }
    }
  }
  /**
   * Get the rotation center
   * @return {ol.coordinate|undefined}
   */
  getCenter() {
    return this.get("center");
  }
  /**
   * Set the rotation center
   * @param {ol.coordinate|undefined} c the center point, default center on the objet
   */
  setCenter(e) {
    return this.set("center", e);
  }
  /**
   * @param {ol.MapBrowserEvent} evt Map browser event.
   * @private
   */
  handleDragEvent_(e) {
    if (this._handleEvent(e, this.features_)) {
      var t = this.getMap().getView().getRotation(), i, n, r, o, a = [this.coordinate_[0], this.coordinate_[1]], l = [e.coordinate[0], e.coordinate[1]];
      switch (this.isUpdating_ = !0, this.mode_) {
        case "rotate": {
          var h = Math.atan2(this.center_[1] - l[1], this.center_[0] - l[0]);
          if (!this.ispt)
            for (i = 0, r; r = this.selection_.item(i); i++)
              o = this.geoms_[i].clone(), o.rotate(h - this.angle_, this.center_), o.getType() == "Circle" && o.setCenterAndRadius(o.getCenter(), o.getRadius()), r.setGeometry(o);
          this.drawSketch_(!0), this.dispatchEvent({
            type: "rotating",
            feature: this.selection_.item(0),
            features: this.selection_,
            angle: h - this.angle_,
            pixel: e.pixel,
            coordinate: e.coordinate
          });
          break;
        }
        case "translate": {
          var c = l[0] - a[0], u = l[1] - a[1];
          for (i = 0, r; r = this.selection_.item(i); i++)
            r.getGeometry().translate(c, u);
          this.handles_.forEach(function(I) {
            I.getGeometry().translate(c, u);
          }), this.coordinate_ = e.coordinate, this.dispatchEvent({
            type: "translating",
            feature: this.selection_.item(0),
            features: this.selection_,
            delta: [c, u],
            pixel: e.pixel,
            coordinate: e.coordinate
          });
          break;
        }
        case "scale": {
          var d = this.center_;
          if (this.get("modifyCenter")(e)) {
            var f = this.extent_;
            this.get("enableRotatedTransform") && t !== 0 && (f = this.rotatedExtent_), d = f[(Number(this.opt_) + 2) % 4];
          }
          var g = this.geoms_.length == 1 && this._isRectangle(this.geoms_[0]), _ = this.constraint_, m = this.opt_, p = this.coordinate_, x = e.coordinate;
          if (this.get("enableRotatedTransform") && t !== 0) {
            var y = new Ee(this.coordinate_);
            y.rotate(t * -1, d), p = y.getCoordinates();
            var E = new Ee(e.coordinate);
            E.rotate(t * -1, d), x = E.getCoordinates();
          }
          var C = (x[0] - d[0]) / (p[0] - d[0]), T = (x[1] - d[1]) / (p[1] - d[1]), w = [x[0] - p[0], x[1] - p[1]];
          if (this.get("enableRotatedTransform") && t !== 0) {
            var L = new Ee(d);
            L.rotate(t * -1, this.getMap().getView().getCenter()), d = L.getCoordinates();
          }
          for (this.get("noFlip") && (C < 0 && (C = -C), T < 0 && (T = -T)), this.constraint_ ? this.constraint_ == "h" ? C = 1 : T = 1 : this.get("keepAspectRatio")(e) && (C = T = Math.min(C, T)), i = 0, r; r = this.selection_.item(i); i++)
            o = t === 0 || !this.get("enableRotatedTransform") ? this.geoms_[i].clone() : this.rotatedGeoms_[i].clone(), o.applyTransform(function(I, S, Y) {
              if (Y < 2)
                return S;
              if (g) {
                var V = [[6], [0, 8], [2], [4]], P = [I[0], I[1]], q = [I[2], I[3]], F = [I[4], I[5]], b = [I[6], I[7]], A = [I[8], I[9]];
                if (_) {
                  var j = m % 2 === 0 ? this._countVector(P, q) : this._countVector(b, P), Q = this._projectVectorOnVector(w, j), ee = m + 1 < V.length ? m + 1 : 0, me = [...V[m], ...V[ee]];
                  for (n = 0; n < I.length; n += Y)
                    S[n] = me.includes(n) ? I[n] + Q[0] : I[n], S[n + 1] = me.includes(n) ? I[n + 1] + Q[1] : I[n + 1];
                } else {
                  var R, ue;
                  switch (m) {
                    case 0:
                      w = this._countVector(b, x), R = this._projectVectorOnVector(w, this._countVector(F, b)), ue = this._projectVectorOnVector(w, this._countVector(P, b)), [S[0], S[1]] = this._movePoint(P, R), [S[4], S[5]] = this._movePoint(F, ue), [S[6], S[7]] = this._movePoint(b, w), [S[8], S[9]] = this._movePoint(A, R);
                      break;
                    case 1:
                      w = this._countVector(P, x), R = this._projectVectorOnVector(w, this._countVector(b, P)), ue = this._projectVectorOnVector(w, this._countVector(q, P)), [S[0], S[1]] = this._movePoint(P, w), [S[2], S[3]] = this._movePoint(q, R), [S[6], S[7]] = this._movePoint(b, ue), [S[8], S[9]] = this._movePoint(A, w);
                      break;
                    case 2:
                      w = this._countVector(q, x), R = this._projectVectorOnVector(w, this._countVector(P, q)), ue = this._projectVectorOnVector(w, this._countVector(F, q)), [S[0], S[1]] = this._movePoint(P, ue), [S[2], S[3]] = this._movePoint(q, w), [S[4], S[5]] = this._movePoint(F, R), [S[8], S[9]] = this._movePoint(A, ue);
                      break;
                    case 3:
                      w = this._countVector(F, x), R = this._projectVectorOnVector(w, this._countVector(q, F)), ue = this._projectVectorOnVector(w, this._countVector(b, F)), [S[2], S[3]] = this._movePoint(q, ue), [S[4], S[5]] = this._movePoint(F, w), [S[6], S[7]] = this._movePoint(b, R);
                      break;
                  }
                }
              } else
                for (n = 0; n < I.length; n += Y)
                  C != 1 && (S[n] = d[0] + (I[n] - d[0]) * C), T != 1 && (S[n + 1] = d[1] + (I[n + 1] - d[1]) * T);
              return o.getType() == "Circle" && o.setCenterAndRadius(o.getCenter(), o.getRadius()), S;
            }.bind(this)), this.get("enableRotatedTransform") && t !== 0 && o.rotate(t, this.getMap().getView().getCenter()), r.setGeometry(o);
          this.drawSketch_(), this.dispatchEvent({
            type: "scaling",
            feature: this.selection_.item(0),
            features: this.selection_,
            scale: [C, T],
            pixel: e.pixel,
            coordinate: e.coordinate
          });
          break;
        }
      }
      this.isUpdating_ = !1;
    }
  }
  /**
   * @param {ol.MapBrowserEvent} evt Event.
   * @private
   */
  handleMoveEvent_(e) {
    if (this._handleEvent(e, this.features_) && !this.mode_) {
      var t = this.getFeatureAtPixel_(e.pixel), i = e.map.getTargetElement();
      if (t.feature) {
        var n = t.handle ? this.Cursors[(t.handle || "default") + (t.constraint || "") + (t.option || "")] : this.Cursors.select;
        this.previousCursor_ === void 0 && (this.previousCursor_ = i.style.cursor), i.style.cursor = n;
      } else
        this.previousCursor_ !== void 0 && (i.style.cursor = this.previousCursor_), this.previousCursor_ = void 0;
    }
  }
  /**
   * @param {ol.MapBrowserEvent} evt Map browser event.
   * @return {boolean} `false` to stop the drag sequence.
   */
  handleUpEvent_(e) {
    if (this.mode_ === "rotate") {
      var t = e.map.getTargetElement();
      t.style.cursor = this.Cursors.default, this.previousCursor_ = void 0;
    }
    return this.dispatchEvent({
      type: this.mode_ + "end",
      feature: this.selection_.item(0),
      features: this.selection_,
      oldgeom: this.geoms_[0],
      oldgeoms: this.geoms_
    }), this.drawSketch_(), this.mode_ = null, !1;
  }
  /** Set the point radius to calculate handles on points
   *  @param {number|Array<number>|function} [pointRadius=0] radius for points or a function that takes a feature and returns the radius (or [radiusX, radiusY]). If not null show handles to transform the points
   */
  setPointRadius(e) {
    typeof e == "function" ? this._pointRadius = e : this._pointRadius = function() {
      return e;
    };
  }
  /** Get the features that are selected for transform
   * @return ol.Collection
   */
  getFeatures() {
    return this.selection_;
  }
  /**
   * @private
   */
  _projectVectorOnVector(e, t) {
    var i = (e[0] * t[0] + e[1] * t[1]) / (t[0] * t[0] + t[1] * t[1]);
    return [t[0] * i, t[1] * i];
  }
  /**
   * @private
   */
  _countVector(e, t) {
    return [t[0] - e[0], t[1] - e[1]];
  }
  /**
   * @private
   */
  _movePoint(e, t) {
    return [e[0] + t[0], e[1] + t[1]];
  }
};
Cr.prototype.Cursors = {
  default: "auto",
  select: "pointer",
  translate: "move",
  rotate: "move",
  rotate0: "move",
  scale: "nesw-resize",
  scale1: "nwse-resize",
  scale2: "nesw-resize",
  scale3: "nwse-resize",
  scalev: "ew-resize",
  scaleh1: "ns-resize",
  scalev2: "ew-resize",
  scaleh3: "ns-resize"
};
const gx = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAD0AAAA9CAYAAAAeYmHpAAAACXBIWXMAACE4AAAhOAFFljFgAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAf4SURBVHgB7VpdaBxFHP9ptWpR3FIf0tKSrQ9RUPFCVWxfuqEgFixNKJSKSOJjBGljX4VeUfx46BeCtiDk8uLXQ5NgQVqsubyYIoVesQoWSze02BaMXoy012o553dzezOzO3u39xVpzA/mbmd2d3Z/8/+Y/39mgUUsYhGLuMNxF/4buOUSICdKHgsUrigTohQtZRTmQCwIuKJchJ1wUHjewQLCMAJyy5wiVqeK6PJkMYnvwgKCUuvB0SKOFFV5Ka2THkObcTfmD27laE3KPNO1Ua89jDaj3aRpn3sgpewmvMcrXz+ANjm2e9AeeJBkPTQGD+rejCh7RfHRIixBa0HJvifKYdiktFqo9TM7gCdeBO69X7UzWiiKn78LwJ9Xw3fRFgLnNokWoJXBiQfpoV2jtUs0b+gHnu6F8Nq1e5nxgfNZ4LsR+W9CnEQPmpR6q0jvFOWg0UKyW/bI/0ZB0l8MAZdzeisjN0p+BA2iFaRpu+lKjdIcHG2ObBhTGeBLQf66EakOoEHizZI2CdNmXxeEV7i17yQBFg5SUrXf1yP/FQbQAPFmSHuQU4sECe+eiCfwc1ao66RUWaqrLjXew/tTwu5TW+MHjYQ/6tPVnZ3QxnOoA42SdqHPvdUIk+yxvTanFI/1A9If2MhHJc6DbtSRpTU6ZR1AMI/yxXZ+LeKojuhVtMNPB8MqWYLjOOjokPcUCgXzJCV58hBKMnnMM89xYKkRUyNyipPT5E1RskiIRiTtQmZDEgPDUjI6qLof90Wk6zwnXnZ9f4lIfonSCmfOR/5cFs5P48h/Hwq9NwlHvf1A9C1OHpSDKkEpU9o+EqAR0sx7e0tHJEvSYbzdbU4zwpO7bwzDX+qiFtxbPvx0yGHFPYdqrgaWqpEoQ6tXvV3IaEuCnjpsx18J+z39eaXqbNuDwqsZQ7LVwOuczbvQsUwcnysHYBzAZcuBR583L37ElWou8bgoR0Qp1HpGvaTTosgnc/Q3DJhnL4mX++RlVRfOqLA5jXpRuC0Iux6c27Mo/HJKNl4U/8/uMAeZ/oQzgtQKxrXXRDlVq/96s6ytlaPurdGzmdcqh+4LAxB5MmzwVgk9fFKM4Dr57z4IO4Qtu+s8eUw/ofVfQarX/n5VUMumOawMMVPlY6/UytE+8Id5Jaem/T2q/u7FyJRDcsOeJB1G5rxIpU4LT/RX6ARtdp/WL5+rS5uDMbRcvyNb/qfe0ytGprJqknZFOQOp0hxOr3JmdSp69ZQWGFH1LYQnttgJEwNd8nxE6gxn9ZC2NJVpCAIbBQ8q+TkDS7ZXjXR84m+Lqy8pb+14/dHOSOghVAXPD/dE243+bEHOGosQyl1CkjcQt4iQgk54MOSlw5KmioWmKNxSVW9lbcL6tZ3i2uk5mP0FuGyJOBm9bdAGhgJQczhv5stX1DyOtGM80HQWUdxQZuOsdJG/ZZ7udVEX+lyRp/6gNeimoicq+nn9Gr4zg5eZ6aCF626Vl2zNGlk4eQjBuQ91wVlq1jmInZ2dquFG4jDbitaQDnvTEPI3URfCmkJMT0+rSpLUtQri1Fu9OW2I05EORkL6gx9QpPNX/JKk9Bcf88W89xQSI/urWS/F5kHFlskxOPnNV3UO/My0fsWsXokjTW/hg86MHewPuVQGHXQe+ous6Kw8iMmD7nyyV0Rnc8mcGQcoNxNqvHRWHdumSy4pnR1DDLIIzdXV1FukSTFZi82Dpvoqh+6F8WhnJ2qrOQdmaMpygstFledYnKoldQ26FCUSxlUjTWYUMaOOLPR81TZXplQEmM9m4Pxj2jal131UErOB2tBzLHqeWZeRbqZCkSYJm0LIlgvXyq3pZq3Ffh9yHSoA82ip8iSuz59B5CTa8/k83PEh5LeZcQEJrf1MzsWMzIL5mITDdlyBHm9bIr2QAFixhDcm6s2y1iLIsm7MyqxHh5bq5S9w9C0rH5DxNYmO+8rebXCO78XVbzOqwZbKMghR6k3p5lAD9U5ZSs9yY1FboqS50hHgWFrm1w2AhPNH06rBtmbGyCsq6ZqoV9I+ZFjnlmrXZ6OOZa1QhB+Pq+0Z8VLO3DQKq1KJlnrdm75YpuhDfjKjGvmMVw5HL2burgaeN4wgARpZLvKgL/1yFTScgNDmmQ6GvbywSWdjeY1Mm8ed23k413Il0/BPZMx7SLh/ODpg9Ohmfk3T85EAjS4Bq3UyqtxbZ+xSpL0xBrYgiNFLgcwV33oNNolUfrvl/ugycOL1MaKZdW/mqpIpJb17wn4lbd90NrVRbR+MWvROd1Pr3o2SJijp0UotbsUyQLATSedjC24YaZEkl6Hi9sHsZpNYrQM0Q5pIQ+5nSdSzl6VLPun15pYOwaT5IOpEs5vyWciB80o1euzcuFzJqEUk2LhLsnlHE/lwc9hEOBe+jwbQii8RstCJM9dlgMLkY02yaSoWzO5GhIc+/kGwhROAEm6IMNDaLxFo49x/cY1W2np5KycRaLe0e/umnw+ZQGTRBFpJmnAh7Ty6MhisWpaitp2mBlBtvzkk7TW8jatwqNx3Yi8932DSG/cNaFGsiZsfz705UUT8p5Psx0ML0a7vyIK0lNMJQ0Mf9YH301EtL/eTRQvRru/IAvhQqalMS2sjiwTpYTOYz88klS2Go7Pffcwn2i1pHZOQti4TBX0eNwOORJnSnQJXFO761fre28UCg4v4D93j985ajFbP00kRbP0G8NHCD14XsYj/Mf4FhS7Nq2O+sK4AAAAASUVORK5CYII=", _x = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAQKADAAQAAAABAAAAQAAAAABGUUKwAAAKKklEQVR4AeUbC1BU1/Xcx4KCfFXwG+MnggH/CEhsUEyDn6aampQmdMYoJswkFWtmGp1pOrLSmbbGONFAkwYLmk6GWjMxiW0mZtRKSUkCfsAQQdH4ARURlL8osvt6ztOF99vd99mNdLgzu3vfveece85555577rl3GXi5rM78Qzjj7ybxPB8DDKIYQCTPw3CsB+HQ9KHSDjy0MwZNPEAN1s8wxk7xzLd4V85vG++BeOcb+fF8eXFddqydt6ehoE+iMFMBeIPjMB4V9R0q5iDHuMK/vr3puKe5NciYko30DVuCoOt2BvB8Or7taCWE+Ra0iipgrAD8B+cVvLGx3TxFQP2aLOvXW0PbemA9vul1PPBhJslpQmfAmpHzt4MtsH37dmuLJiQnQIYVgG+ZpWdmr2LAb8F6uBP6Xm1Gi2jEObKxIGfTbqyj+9BfDCkg49fWcT02KETB5+kf0vMYKHyJxQfS8nZYa/VS162ANWuz56GD24eOLULvYN6FZ9fRUa7Iz91UomccTg/wmkxruh3s/+5/wpMUfATxRjzqkUmTBezdu9fni+KqrXaef1UP8QcFyzH21qKk6NdSU1Nt7nhwqwAS/kBx1T6c78vcEetP/egX9i9Oil7hTgk+7pgOHhGzDYVf5Q6uH/ZHna9tCiovK/rCFW8uFSDMeZ7/oysC/bkP18XE2LnJdaiEcmd8Op0Cgrcnh8fzfs6QjbYP8vOD555ZBAlzpkJDww3Ie38f1Dc0GSXnGo+xbg64hc5WB1ULoHXeZucPo2cNdk1df+/IEcPhtXUrYVr0I2CxWCA0JEj4HD1xSj8xbRg+aAlPxT+2YO/x0qJWOYpiGcT5zijI8cZSN2dWNGza8BKMHikNHMOHh8r58vAzH3E/cFNYvMICam9wq9HsMz3JAcdxkPqzFHj+mcXCW5fTbm3rgKL/enyjJx9m3KefF1+qKCuqEHdILIA2NhTbiwHM1oODAmHDuhdg0cJEs6RM45NsJKOYkEQBtKvDKSC1TzG0zvqkCQ9B1sYMiHzkYZ2Y3gEn2YSdq4h87xQQ9vPdPXuwz1/Ub7iaGDcd1mY8B0MC3JOz23mov9YELa3tYLPZDY+pBRG30jNmJS95p7zkUDfBW3qRMJnhqf28Bbdmq9J+ChafXv32DqNWCQsNhldf+SX09PRAzfe1cKioFCoqz6iBmm4jGRklbgC2EbE+BWAmxzT1+wQwFYbC2MDX11cXSVoWo6MmCp/6a43w4aeHvKOIe7IKChBekZDDs9tf18WtC2Cca3CzuRVmTosCWgGMlKDAIRgoTYPw4WFQXXNRsA4jdJzghM9JfOJfJ0qP1AvcUQLTCaDh5m+OVcK2P38AHR233NKw2Wy48qLZqJTH4mcIscPQsBCVXuNNDpkFC5gZv+BNJDXCODl1zKYbLVCGEd6UyeMhJDhQHQhbL19tgOw38gQnOGZUBOY8B0lgA4cEQOzMR+FkZQ103uqS9Bl/YIEYE7zrQ3l74G1bkZAiSjJOvA+zq+s2fFV6EiLCh8KY0epJJAqEDhz+Cr6/cBmOfHkUVwKbsHTilraXUID/YCF8LvmmAnqw33xhEbPmprzjMzs+aQmGvb8wT9A5BZvdDscqqqD77l14NHICZrb7BCMscSRoR9gz5y5B9ZkL6EMigTZOjkKWMGxYKByvqHY0mflFLvhSDudejBkqenA/P1gCO/5SCLdkZkwKkJez52vhzZy/QUen1IfMRcdIztUThWTn0PA9Q00jR5VV5yB76064cOmKgNHc0gaffFakil13pQF2vv+xom/50gWKNkMNKLsFjTFS3f8aIqkJ6XrjTfg9KsEf5zX5CFelsuosFJcch6R5sb1gDz80CqbHTIZvT53tbTNSIdlxCuBB5QMq7oR3sLX/QLHC8dHW2mwh2WkKBJkl5G18CqpoCRSXadGTxY/G6ig7BUKGFUDeXOyljXGhDYumgrhQXEFLq8kS1LcX0EkpbnYMbniWCUELMZeTt0eI/3WS0Qx+qa5eARuG6TTyJ2YKWYChY+a0Zxf3RmxkjrEzzc9JV4KoLZXBLqJLV7REfe0c3cwQNWiu+okCFEIaGTFMM64RQHnwJNAwu3yh7HiKBIby0bR+i8vQMI8nkMXkQY3+TRkPEgQNDyQ7h0qUulcNiATS3CxVgDzTq5GMZjA1+vKXoJnYfUCSnaaAodRL7ZVrkvEmjh8r5PcljR58oN2guLR3dIJZBZDsOAWYoRMJ+UEGzVHau3uj0JIXPWWShDRtiJzlECSALh5Ido6uouFOWLc7uVh7FZpuNEvIL035EQQFBkjaPPHw7PIfK/KLx8qrTJJmeATkW8wJ9/DwKpoRaof+UyZBoz07HX54stD2WW5Zl3GTVF1zwdwwKDPJLqTE0HoPGqF2GLO38kPNuZgOX7ZkvhFyChxyfL96MVWRPyj86IAHzP+ezIIC6BKiYnQNDZTo2IPMyMvTP0kG+qiu3XJgJ8+TJoyF32SuhADZuQKZ/mmzbx/HdMgs5AQpOzo7ITkV23WfClEoSs5oCpqquERhHnASrgyU59e66yN8HzxLSMFjtJdeWAE0pcTlSv11yHnv76ZDbnwxVfk5Wb8TxnMMMCsh2R8lSXE86/mlFNawoSEwbuwoCRptVhYmxUEIxuy0ZLW1d0r6xQ+U7kqMnw4vr/k5xOM+Q55OJ/wtO3ZDu4Yss5iuWp1x3Ba8NPE19fVthvD6Kevset3o6dDuwn/CnTvd8MT8BMmYdDq08PE44UPb2hpUVjMegZEyBg/yE7LFY0ePgInjxyiEdhCiN5+78x/m130kiEdjzXTV1kFbkp1MX2u1ojlnOTqN/NKZ4Mrnn/LYNrnsxHew64P9cKe72wg7Chw0/80FuVaro6PPArCF7t629bBXUAm6fYGD4NdHv4Vz5+tg2dL5QMqQm7IDzt0vnRV88tkROHHytDtQzf0ofCPJKEaQWAB1rF67GS9I2AvEQEbro/A6DDm0GVMjNYXJdDh6+uxFoNw/HaiYjfQUfDMufVdu1i5xu0IBOChbk7n5S/ydJwY0Wx8/brRwQkRHXBTaBgcPgdu3u6EV/UELpsVrL9fDqerzHjN1Ob/49kvQ8z+Ov7y4TzIFqIMA8JJU2t0edtST94QodKbPgynsOl2mlgtPvAiBkJwpunVNF49RG57xPPIBfshnuiaHsji7SS4EQmr8lJcdqYtNWHAVY5zlav3/L20cxzLyc7P2O+PXqQIIgW5YxiYkh+CkefA3nJxJ4KKdLk3n51r/5AJEfQqIEejWNc4dpxoUw/anOvFMvLvjSdUHiJHotjXduiZtitv7c5141XJTnGRQLIOuBLt3eRrexQW678zaFcIP3Sc4PHg5P8eqOY7RpQCSZ0D/ZYYUQLeufS0Qh3NM139zCNdbhXghnpzdCHc1rm4LcBCjiHHA/m3OoQT6HbB/nBQrgeoD9q+zckXQ84D887SaIqitv/99/n94WNdui+gDcwAAAABJRU5ErkJggg==";
class mx extends Au {
  constructor(t) {
    const i = t._features || new ce();
    super({
      features: i,
      condition: (n) => n.originalEvent.buttons === 1
    });
    v(this, "_translate_features");
    this._translate_features = i, this.setActive(!1), this.on("change:active", (n) => {
      var o;
      const r = t._features || ((o = t.map_instance) == null ? void 0 : o.getSelectedFeatures().getArray());
      n.target.getActive() && (r.forEach((a) => {
        a.getStyle().getStroke().setColor("#09F"), a.getStyle().getStroke().setWidth(2), a.getStyle().getText().setFill(new N({ color: "#15F9F8" }));
      }), this._translate_features.extend(r).extend(r));
    });
  }
}
function px(s) {
  const e = s.getExtent();
  return Ne(e);
}
const yx = () => {
  const s = new we({
    features: [],
    wrapX: !1,
    useSpatialIndex: !1
  });
  return new Be({
    updateWhileInteracting: !0,
    source: s,
    zIndex: 99
  });
};
class ll extends Cr {
  constructor(t, i) {
    const { transform_name: n = [] } = i;
    super({
      translateFeature: n.includes("translate"),
      translate: n.includes("translate"),
      translateBBox: n.includes("translate"),
      rotate: n.includes("rotate"),
      enableRotatedTransform: !1,
      selection: !1,
      scale: n.includes("scale"),
      keepRectangle: !1,
      stretch: !0
    });
    v(this, "map_instance");
    // 覆盖父类的 setActive
    v(this, "setActive", (t) => {
      this.map_instance.getSelectedFeatures().forEach((i) => {
        var n, r, o, a;
        t && ((r = (n = i == null ? void 0 : i.getStyle()) == null ? void 0 : n.getStroke()) == null || r.setColor("#09F"), (a = (o = i == null ? void 0 : i.getStyle()) == null ? void 0 : o.getStroke()) == null || a.setWidth(2), i.changed()), this.select(i, t);
      }), this._setDefaultStyle(), Object.getPrototypeOf(this).setActive(t);
    });
    this.map_instance = t, this.setActive(!1);
  }
  _setDefaultStyle() {
    this.setDefaultStyle({
      stroke: new K({ color: [0, 153, 255], width: 2, lineDash: [4, 4] }),
      fill: new N({ color: [255, 255, 255, 0] }),
      pointStroke: new K({ color: [0, 153, 255] }),
      pointFill: new N({ color: [255, 255, 255, 1] })
    });
  }
}
class xx extends ll {
  constructor(e) {
    super(e, {
      transform_name: ["scale"]
    });
  }
}
class Ex extends ll {
  constructor(e) {
    super(e, {
      transform_name: ["translate"]
    });
  }
  watchActive() {
    this.setDefaultStyle({
      stroke: new K({ color: [255, 255, 255, 0], width: 2 }),
      fill: new N({ color: [255, 255, 255, 0] })
    });
  }
}
class vx extends ll {
  constructor(t) {
    super(t, {
      transform_name: ["rotate"]
    });
    v(this, "_translate_instance");
    v(this, "_collection_translate", new ce());
    v(this, "_layer", yx());
    this._translate_instance = new mx({ _features: this._collection_translate }), this.map_instance.addInteraction(this._translate_instance), this.map_instance.addLayer(this._layer);
  }
  _handleTranslateEnd(t) {
    this.setCenter(t.coordinate);
  }
  _setHandStyle() {
    Cr.prototype.Cursors.rotate = "move", Cr.prototype.Cursors.rotate0 = "move";
    const t = new tt({
      src: _x,
      width: 20,
      anchor: [-0.3, 0.5],
      // ol-ext 内部会调用 getAnchor()，如果不设置 size，getAnchor() 返回 null
      // size 设为图片实际 width+5, height+5
      size: [70, 70]
    }), i = new se({
      image: t
    });
    this.setStyle("rotate", i), this.setStyle(
      "rotate0",
      new se({
        text: new De({ text: "" })
      })
    );
  }
  watchActive(t) {
    t ? this._translate_instance.on("translateend", this._handleTranslateEnd.bind(this)) : this._translate_instance.un("translateend", this._handleTranslateEnd.bind(this)), this._translate_instance.setActive(t), this._setRotateCenterPoint(t);
  }
  _setRotateCenterPoint(t) {
    if (t) {
      this._setHandStyle();
      const i = px(this.bbox_.getGeometry()), n = new $({ geometry: new Ee(i) });
      n.setStyle(
        new se({
          image: new tt({
            src: gx,
            width: 20
          })
        })
      ), this._layer.getSource().addFeature(n), this._collection_translate.push(n), this.setCenter(i);
    } else
      this._layer.getSource().clear(), this._collection_translate.clear();
  }
}
var tn = Object.freeze({
  Linear: Object.freeze({
    None: function(s) {
      return s;
    },
    In: function(s) {
      return s;
    },
    Out: function(s) {
      return s;
    },
    InOut: function(s) {
      return s;
    }
  }),
  Quadratic: Object.freeze({
    In: function(s) {
      return s * s;
    },
    Out: function(s) {
      return s * (2 - s);
    },
    InOut: function(s) {
      return (s *= 2) < 1 ? 0.5 * s * s : -0.5 * (--s * (s - 2) - 1);
    }
  }),
  Cubic: Object.freeze({
    In: function(s) {
      return s * s * s;
    },
    Out: function(s) {
      return --s * s * s + 1;
    },
    InOut: function(s) {
      return (s *= 2) < 1 ? 0.5 * s * s * s : 0.5 * ((s -= 2) * s * s + 2);
    }
  }),
  Quartic: Object.freeze({
    In: function(s) {
      return s * s * s * s;
    },
    Out: function(s) {
      return 1 - --s * s * s * s;
    },
    InOut: function(s) {
      return (s *= 2) < 1 ? 0.5 * s * s * s * s : -0.5 * ((s -= 2) * s * s * s - 2);
    }
  }),
  Quintic: Object.freeze({
    In: function(s) {
      return s * s * s * s * s;
    },
    Out: function(s) {
      return --s * s * s * s * s + 1;
    },
    InOut: function(s) {
      return (s *= 2) < 1 ? 0.5 * s * s * s * s * s : 0.5 * ((s -= 2) * s * s * s * s + 2);
    }
  }),
  Sinusoidal: Object.freeze({
    In: function(s) {
      return 1 - Math.sin((1 - s) * Math.PI / 2);
    },
    Out: function(s) {
      return Math.sin(s * Math.PI / 2);
    },
    InOut: function(s) {
      return 0.5 * (1 - Math.sin(Math.PI * (0.5 - s)));
    }
  }),
  Exponential: Object.freeze({
    In: function(s) {
      return s === 0 ? 0 : Math.pow(1024, s - 1);
    },
    Out: function(s) {
      return s === 1 ? 1 : 1 - Math.pow(2, -10 * s);
    },
    InOut: function(s) {
      return s === 0 ? 0 : s === 1 ? 1 : (s *= 2) < 1 ? 0.5 * Math.pow(1024, s - 1) : 0.5 * (-Math.pow(2, -10 * (s - 1)) + 2);
    }
  }),
  Circular: Object.freeze({
    In: function(s) {
      return 1 - Math.sqrt(1 - s * s);
    },
    Out: function(s) {
      return Math.sqrt(1 - --s * s);
    },
    InOut: function(s) {
      return (s *= 2) < 1 ? -0.5 * (Math.sqrt(1 - s * s) - 1) : 0.5 * (Math.sqrt(1 - (s -= 2) * s) + 1);
    }
  }),
  Elastic: Object.freeze({
    In: function(s) {
      return s === 0 ? 0 : s === 1 ? 1 : -Math.pow(2, 10 * (s - 1)) * Math.sin((s - 1.1) * 5 * Math.PI);
    },
    Out: function(s) {
      return s === 0 ? 0 : s === 1 ? 1 : Math.pow(2, -10 * s) * Math.sin((s - 0.1) * 5 * Math.PI) + 1;
    },
    InOut: function(s) {
      return s === 0 ? 0 : s === 1 ? 1 : (s *= 2, s < 1 ? -0.5 * Math.pow(2, 10 * (s - 1)) * Math.sin((s - 1.1) * 5 * Math.PI) : 0.5 * Math.pow(2, -10 * (s - 1)) * Math.sin((s - 1.1) * 5 * Math.PI) + 1);
    }
  }),
  Back: Object.freeze({
    In: function(s) {
      var e = 1.70158;
      return s === 1 ? 1 : s * s * ((e + 1) * s - e);
    },
    Out: function(s) {
      var e = 1.70158;
      return s === 0 ? 0 : --s * s * ((e + 1) * s + e) + 1;
    },
    InOut: function(s) {
      var e = 2.5949095;
      return (s *= 2) < 1 ? 0.5 * (s * s * ((e + 1) * s - e)) : 0.5 * ((s -= 2) * s * ((e + 1) * s + e) + 2);
    }
  }),
  Bounce: Object.freeze({
    In: function(s) {
      return 1 - tn.Bounce.Out(1 - s);
    },
    Out: function(s) {
      return s < 1 / 2.75 ? 7.5625 * s * s : s < 2 / 2.75 ? 7.5625 * (s -= 1.5 / 2.75) * s + 0.75 : s < 2.5 / 2.75 ? 7.5625 * (s -= 2.25 / 2.75) * s + 0.9375 : 7.5625 * (s -= 2.625 / 2.75) * s + 0.984375;
    },
    InOut: function(s) {
      return s < 0.5 ? tn.Bounce.In(s * 2) * 0.5 : tn.Bounce.Out(s * 2 - 1) * 0.5 + 0.5;
    }
  }),
  generatePow: function(s) {
    return s === void 0 && (s = 4), s = s < Number.EPSILON ? Number.EPSILON : s, s = s > 1e4 ? 1e4 : s, {
      In: function(e) {
        return Math.pow(e, s);
      },
      Out: function(e) {
        return 1 - Math.pow(1 - e, s);
      },
      InOut: function(e) {
        return e < 0.5 ? Math.pow(e * 2, s) / 2 : (1 - Math.pow(2 - e * 2, s)) / 2 + 0.5;
      }
    };
  }
}), Sn = function() {
  return performance.now();
}, Cx = (
  /** @class */
  function() {
    function s() {
      this._tweens = {}, this._tweensAddedDuringUpdate = {};
    }
    return s.prototype.getAll = function() {
      var e = this;
      return Object.keys(this._tweens).map(function(t) {
        return e._tweens[t];
      });
    }, s.prototype.removeAll = function() {
      this._tweens = {};
    }, s.prototype.add = function(e) {
      this._tweens[e.getId()] = e, this._tweensAddedDuringUpdate[e.getId()] = e;
    }, s.prototype.remove = function(e) {
      delete this._tweens[e.getId()], delete this._tweensAddedDuringUpdate[e.getId()];
    }, s.prototype.update = function(e, t) {
      e === void 0 && (e = Sn()), t === void 0 && (t = !1);
      var i = Object.keys(this._tweens);
      if (i.length === 0)
        return !1;
      for (; i.length > 0; ) {
        this._tweensAddedDuringUpdate = {};
        for (var n = 0; n < i.length; n++) {
          var r = this._tweens[i[n]], o = !t;
          r && r.update(e, o) === !1 && !t && delete this._tweens[i[n]];
        }
        i = Object.keys(this._tweensAddedDuringUpdate);
      }
      return !0;
    }, s;
  }()
), Hi = {
  Linear: function(s, e) {
    var t = s.length - 1, i = t * e, n = Math.floor(i), r = Hi.Utils.Linear;
    return e < 0 ? r(s[0], s[1], i) : e > 1 ? r(s[t], s[t - 1], t - i) : r(s[n], s[n + 1 > t ? t : n + 1], i - n);
  },
  Bezier: function(s, e) {
    for (var t = 0, i = s.length - 1, n = Math.pow, r = Hi.Utils.Bernstein, o = 0; o <= i; o++)
      t += n(1 - e, i - o) * n(e, o) * s[o] * r(i, o);
    return t;
  },
  CatmullRom: function(s, e) {
    var t = s.length - 1, i = t * e, n = Math.floor(i), r = Hi.Utils.CatmullRom;
    return s[0] === s[t] ? (e < 0 && (n = Math.floor(i = t * (1 + e))), r(s[(n - 1 + t) % t], s[n], s[(n + 1) % t], s[(n + 2) % t], i - n)) : e < 0 ? s[0] - (r(s[0], s[0], s[1], s[1], -i) - s[0]) : e > 1 ? s[t] - (r(s[t], s[t], s[t - 1], s[t - 1], i - t) - s[t]) : r(s[n ? n - 1 : 0], s[n], s[t < n + 1 ? t : n + 1], s[t < n + 2 ? t : n + 2], i - n);
  },
  Utils: {
    Linear: function(s, e, t) {
      return (e - s) * t + s;
    },
    Bernstein: function(s, e) {
      var t = Hi.Utils.Factorial;
      return t(s) / t(e) / t(s - e);
    },
    Factorial: function() {
      var s = [1];
      return function(e) {
        var t = 1;
        if (s[e])
          return s[e];
        for (var i = e; i > 1; i--)
          t *= i;
        return s[e] = t, t;
      };
    }(),
    CatmullRom: function(s, e, t, i, n) {
      var r = (t - s) * 0.5, o = (i - e) * 0.5, a = n * n, l = n * a;
      return (2 * e - 2 * t + r + o) * l + (-3 * e + 3 * t - 2 * r - o) * a + r * n + e;
    }
  }
}, wx = (
  /** @class */
  function() {
    function s() {
    }
    return s.nextId = function() {
      return s._nextId++;
    }, s._nextId = 0, s;
  }()
), ra = new Cx(), Tx = (
  /** @class */
  function() {
    function s(e, t) {
      t === void 0 && (t = ra), this._object = e, this._group = t, this._isPaused = !1, this._pauseStart = 0, this._valuesStart = {}, this._valuesEnd = {}, this._valuesStartRepeat = {}, this._duration = 1e3, this._isDynamic = !1, this._initialRepeat = 0, this._repeat = 0, this._yoyo = !1, this._isPlaying = !1, this._reversed = !1, this._delayTime = 0, this._startTime = 0, this._easingFunction = tn.Linear.None, this._interpolationFunction = Hi.Linear, this._chainedTweens = [], this._onStartCallbackFired = !1, this._onEveryStartCallbackFired = !1, this._id = wx.nextId(), this._isChainStopped = !1, this._propertiesAreSetUp = !1, this._goToEnd = !1;
    }
    return s.prototype.getId = function() {
      return this._id;
    }, s.prototype.isPlaying = function() {
      return this._isPlaying;
    }, s.prototype.isPaused = function() {
      return this._isPaused;
    }, s.prototype.getDuration = function() {
      return this._duration;
    }, s.prototype.to = function(e, t) {
      if (t === void 0 && (t = 1e3), this._isPlaying)
        throw new Error("Can not call Tween.to() while Tween is already started or paused. Stop the Tween first.");
      return this._valuesEnd = e, this._propertiesAreSetUp = !1, this._duration = t < 0 ? 0 : t, this;
    }, s.prototype.duration = function(e) {
      return e === void 0 && (e = 1e3), this._duration = e < 0 ? 0 : e, this;
    }, s.prototype.dynamic = function(e) {
      return e === void 0 && (e = !1), this._isDynamic = e, this;
    }, s.prototype.start = function(e, t) {
      if (e === void 0 && (e = Sn()), t === void 0 && (t = !1), this._isPlaying)
        return this;
      if (this._group && this._group.add(this), this._repeat = this._initialRepeat, this._reversed) {
        this._reversed = !1;
        for (var i in this._valuesStartRepeat)
          this._swapEndStartRepeatValues(i), this._valuesStart[i] = this._valuesStartRepeat[i];
      }
      if (this._isPlaying = !0, this._isPaused = !1, this._onStartCallbackFired = !1, this._onEveryStartCallbackFired = !1, this._isChainStopped = !1, this._startTime = e, this._startTime += this._delayTime, !this._propertiesAreSetUp || t) {
        if (this._propertiesAreSetUp = !0, !this._isDynamic) {
          var n = {};
          for (var r in this._valuesEnd)
            n[r] = this._valuesEnd[r];
          this._valuesEnd = n;
        }
        this._setupProperties(this._object, this._valuesStart, this._valuesEnd, this._valuesStartRepeat, t);
      }
      return this;
    }, s.prototype.startFromCurrentValues = function(e) {
      return this.start(e, !0);
    }, s.prototype._setupProperties = function(e, t, i, n, r) {
      for (var o in i) {
        var a = e[o], l = Array.isArray(a), h = l ? "array" : typeof a, c = !l && Array.isArray(i[o]);
        if (!(h === "undefined" || h === "function")) {
          if (c) {
            var u = i[o];
            if (u.length === 0)
              continue;
            for (var d = [a], f = 0, g = u.length; f < g; f += 1) {
              var _ = this._handleRelativeValue(a, u[f]);
              if (isNaN(_)) {
                c = !1, console.warn("Found invalid interpolation list. Skipping.");
                break;
              }
              d.push(_);
            }
            c && (i[o] = d);
          }
          if ((h === "object" || l) && a && !c) {
            t[o] = l ? [] : {};
            var m = a;
            for (var p in m)
              t[o][p] = m[p];
            n[o] = l ? [] : {};
            var u = i[o];
            if (!this._isDynamic) {
              var x = {};
              for (var p in u)
                x[p] = u[p];
              i[o] = u = x;
            }
            this._setupProperties(m, t[o], u, n[o], r);
          } else
            (typeof t[o] > "u" || r) && (t[o] = a), l || (t[o] *= 1), c ? n[o] = i[o].slice().reverse() : n[o] = t[o] || 0;
        }
      }
    }, s.prototype.stop = function() {
      return this._isChainStopped || (this._isChainStopped = !0, this.stopChainedTweens()), this._isPlaying ? (this._group && this._group.remove(this), this._isPlaying = !1, this._isPaused = !1, this._onStopCallback && this._onStopCallback(this._object), this) : this;
    }, s.prototype.end = function() {
      return this._goToEnd = !0, this.update(1 / 0), this;
    }, s.prototype.pause = function(e) {
      return e === void 0 && (e = Sn()), this._isPaused || !this._isPlaying ? this : (this._isPaused = !0, this._pauseStart = e, this._group && this._group.remove(this), this);
    }, s.prototype.resume = function(e) {
      return e === void 0 && (e = Sn()), !this._isPaused || !this._isPlaying ? this : (this._isPaused = !1, this._startTime += e - this._pauseStart, this._pauseStart = 0, this._group && this._group.add(this), this);
    }, s.prototype.stopChainedTweens = function() {
      for (var e = 0, t = this._chainedTweens.length; e < t; e++)
        this._chainedTweens[e].stop();
      return this;
    }, s.prototype.group = function(e) {
      return e === void 0 && (e = ra), this._group = e, this;
    }, s.prototype.delay = function(e) {
      return e === void 0 && (e = 0), this._delayTime = e, this;
    }, s.prototype.repeat = function(e) {
      return e === void 0 && (e = 0), this._initialRepeat = e, this._repeat = e, this;
    }, s.prototype.repeatDelay = function(e) {
      return this._repeatDelayTime = e, this;
    }, s.prototype.yoyo = function(e) {
      return e === void 0 && (e = !1), this._yoyo = e, this;
    }, s.prototype.easing = function(e) {
      return e === void 0 && (e = tn.Linear.None), this._easingFunction = e, this;
    }, s.prototype.interpolation = function(e) {
      return e === void 0 && (e = Hi.Linear), this._interpolationFunction = e, this;
    }, s.prototype.chain = function() {
      for (var e = [], t = 0; t < arguments.length; t++)
        e[t] = arguments[t];
      return this._chainedTweens = e, this;
    }, s.prototype.onStart = function(e) {
      return this._onStartCallback = e, this;
    }, s.prototype.onEveryStart = function(e) {
      return this._onEveryStartCallback = e, this;
    }, s.prototype.onUpdate = function(e) {
      return this._onUpdateCallback = e, this;
    }, s.prototype.onRepeat = function(e) {
      return this._onRepeatCallback = e, this;
    }, s.prototype.onComplete = function(e) {
      return this._onCompleteCallback = e, this;
    }, s.prototype.onStop = function(e) {
      return this._onStopCallback = e, this;
    }, s.prototype.update = function(e, t) {
      var i;
      if (e === void 0 && (e = Sn()), t === void 0 && (t = !0), this._isPaused)
        return !0;
      var n = this._startTime + this._duration;
      if (!this._goToEnd && !this._isPlaying) {
        if (e > n)
          return !1;
        t && this.start(e, !0);
      }
      if (this._goToEnd = !1, e < this._startTime)
        return !0;
      this._onStartCallbackFired === !1 && (this._onStartCallback && this._onStartCallback(this._object), this._onStartCallbackFired = !0), this._onEveryStartCallbackFired === !1 && (this._onEveryStartCallback && this._onEveryStartCallback(this._object), this._onEveryStartCallbackFired = !0);
      var r = e - this._startTime, o = this._duration + ((i = this._repeatDelayTime) !== null && i !== void 0 ? i : this._delayTime), a = this._duration + this._repeat * o, l = this._calculateElapsedPortion(r, o, a), h = this._easingFunction(l), c = this._calculateCompletionStatus(r, o);
      if (c === "repeat" && this._processRepetition(r, o), this._updateProperties(this._object, this._valuesStart, this._valuesEnd, h), c === "about-to-repeat" && this._processRepetition(r, o), this._onUpdateCallback && this._onUpdateCallback(this._object, l), c === "repeat" || c === "about-to-repeat")
        this._onRepeatCallback && this._onRepeatCallback(this._object), this._onEveryStartCallbackFired = !1;
      else if (c === "completed") {
        this._isPlaying = !1, this._onCompleteCallback && this._onCompleteCallback(this._object);
        for (var u = 0, d = this._chainedTweens.length; u < d; u++)
          this._chainedTweens[u].start(this._startTime + this._duration, !1);
      }
      return c !== "completed";
    }, s.prototype._calculateElapsedPortion = function(e, t, i) {
      if (this._duration === 0 || e > i)
        return 1;
      var n = e % t, r = Math.min(n / this._duration, 1);
      return r === 0 && e !== 0 && e % this._duration === 0 ? 1 : r;
    }, s.prototype._calculateCompletionStatus = function(e, t) {
      return this._duration !== 0 && e < this._duration ? "playing" : this._repeat <= 0 ? "completed" : e === this._duration ? "about-to-repeat" : "repeat";
    }, s.prototype._processRepetition = function(e, t) {
      var i = Math.min(Math.trunc((e - this._duration) / t) + 1, this._repeat);
      isFinite(this._repeat) && (this._repeat -= i);
      for (var n in this._valuesStartRepeat) {
        var r = this._valuesEnd[n];
        !this._yoyo && typeof r == "string" && (this._valuesStartRepeat[n] = this._valuesStartRepeat[n] + parseFloat(r)), this._yoyo && this._swapEndStartRepeatValues(n), this._valuesStart[n] = this._valuesStartRepeat[n];
      }
      this._yoyo && (this._reversed = !this._reversed), this._startTime += t * i;
    }, s.prototype._updateProperties = function(e, t, i, n) {
      for (var r in i)
        if (t[r] !== void 0) {
          var o = t[r] || 0, a = i[r], l = Array.isArray(e[r]), h = Array.isArray(a), c = !l && h;
          c ? e[r] = this._interpolationFunction(a, n) : typeof a == "object" && a ? this._updateProperties(e[r], o, a, n) : (a = this._handleRelativeValue(o, a), typeof a == "number" && (e[r] = o + (a - o) * n));
        }
    }, s.prototype._handleRelativeValue = function(e, t) {
      return typeof t != "string" ? t : t.charAt(0) === "+" || t.charAt(0) === "-" ? e + parseFloat(t) : parseFloat(t);
    }, s.prototype._swapEndStartRepeatValues = function(e) {
      var t = this._valuesStartRepeat[e], i = this._valuesEnd[e];
      typeof i == "string" ? this._valuesStartRepeat[e] = this._valuesStartRepeat[e] + parseFloat(i) : this._valuesStartRepeat[e] = this._valuesEnd[e], this._valuesEnd[e] = t;
    }, s;
  }()
), yt = ra, Sx = yt.getAll.bind(yt), Lo = yt.removeAll.bind(yt);
yt.add.bind(yt);
var Rx = yt.remove.bind(yt), Ix = yt.update.bind(yt);
let Sh = 1, Rh, Rt;
var Lx = /* @__PURE__ */ ((s) => (s.BAIDU = "baidu", s.KML = "kml", s.EARTH = "earth", s.IMAGE = "image", s.GEOJSON = "geojson", s))(Lx || {});
class Ax extends wc {
  constructor(t) {
    var n, r, o, a;
    let i;
    t.type === "geojson" && (i = new er({
      code: "custom",
      extent: [0, 0, 4007501668e-2, 400979322e-1],
      units: "m"
    }));
    super({
      target: document.getElementById(t.dom) || void 0,
      view: new Pe({
        center: t.center || [0, 0],
        zoom: t.zoom || 20,
        maxZoom: t.max_zoom,
        minZoom: t.min_zoom,
        extent: t.extent,
        enableRotation: t.enable_rotation,
        zoomFactor: t.zoom_factor,
        resolution: t.resolution,
        rotation: t.rotation,
        constrainOnlyCenter: !1,
        showFullExtent: !0,
        projection: i
      }),
      interactions: Ec({
        dragPan: !1,
        mouseWheelZoom: !1
      }).extend([
        new pc({ kinetic: void 0 }),
        new xc({ duration: 0 })
      ])
    });
    v(this, "layer_map");
    v(this, "layer_little_map");
    v(this, "label_layer");
    v(this, "floor_layer_maps", []);
    v(this, "xhr");
    v(this, "vector_person_source");
    v(this, "vector_person_source_little");
    v(this, "vector_person_layer");
    v(this, "vector_person_layer_little");
    v(this, "vector_track_source");
    v(this, "vector_track_layer");
    v(this, "vector_station_source");
    v(this, "vector_station_layer");
    v(this, "vector_area_source");
    v(this, "vector_area_layer");
    v(this, "vector_draw_source");
    v(this, "vector_draw_layer");
    v(this, "heat_map_source");
    v(this, "heat_map_layer");
    v(this, "vector_measure_source");
    v(this, "vector_measure_layer");
    v(this, "animation_enable", !1);
    v(this, "cache_animation_enable", !1);
    v(this, "animation_cache_time", 1);
    v(this, "animation_speed_point", 1);
    v(this, "animation_delay_time_point", 2);
    v(this, "animation_delay_time", 5);
    v(this, "map_stroke_color");
    v(this, "now_zoom");
    v(this, "all_person", []);
    v(this, "all_little_person", []);
    v(this, "all_track", {});
    v(this, "all_track_card_time", {});
    v(this, "all_track_card", []);
    v(this, "all_track_point_count", {});
    v(this, "all_track_color", {});
    v(this, "all_track_dash_distance", {});
    v(this, "all_track_max_point_num", {});
    v(this, "all_station", {});
    v(this, "all_area", {});
    v(this, "measure_control");
    v(this, "overviewMapControl");
    v(this, "measure_notify_element");
    v(this, "display_cluster_card", 0);
    v(this, "now_map_type");
    v(this, "show_heat_point", !1);
    v(this, "_modify_instance");
    v(this, "_translate_instance");
    v(this, "_scale_instance");
    v(this, "_rotate_instance");
    v(this, "_history_card_times", 1);
    v(this, "_building_extent");
    // _animation = ()=>{
    // 	const currentTime = performance.now();
    // 	const delta = currentTime - lastTime;
    // 	if (delta > 1000) {
    // 		console.log("fps：",fps);
    // 		fps = 0;
    // 		lastTime = currentTime;
    // 	}
    // 	fps++;
    // 	requestAnimationFrame(this._animation)
    // }
    v(this, "_initVars", () => {
      this.all_person = [], this.all_little_person = [], this.all_track = {}, this.all_track_card = [], this.all_track_point_count = {}, this.all_track_max_point_num = {}, this.all_track_color = {}, this.all_track_dash_distance = {}, this.all_station = {}, this.all_area = {}, this.display_cluster_card = 0;
    });
    // 鼠标右键旋转地图
    v(this, "_mouseRightRotation", () => {
      let t;
      this.on("contextmenu", (i) => {
        i.preventDefault();
      }), this.on("pointerdrag", (i) => {
        if (i.originalEvent.buttons === 1)
          return;
        const n = this.getSize(), r = this.getEventPixel(i.originalEvent), o = Math.atan2(n[1] / 2 - r[1], r[0] - n[0] / 2);
        if (t !== void 0) {
          const a = o - t;
          this.getView().adjustRotationInternal(-a);
        }
        t = o;
      }), this.on("pointerdown", () => {
        t = void 0;
      });
    });
    /**
     *
     * 判断地图类型初始化
     * @param {map_options} map_options
     * @memberof Map
     */
    v(this, "_getMapLayer", (t) => {
      const { floors_params: i, type: n, url: r } = t;
      let o = "";
      if (n === "kml")
        this.layer_map = this._getKmlLayer(r), this.layer_little_map = new ai({
          source: this.layer_map.getSource(),
          style: (a) => this._vectorLayerStyle(a, this.map_stroke_color, !0)
        }), o = "change";
      else if (n === "image")
        (typeof t.extend != "object" || t.extend.length !== 4) && (console.error("错误的extend"), t.extend = []), this.layer_map = this._getImageLayer(r, t.extend), this.layer_little_map = new Ns({
          source: this.layer_map.getSource()
        }), o = "imageloadend";
      else if (n === "baidu")
        this.layer_map = this._getBDLayer("baidu"), this.layer_little_map = new fo({
          source: this.layer_map.getSource()
        }), o = "tileloadend";
      else if (n === "earth")
        this.layer_map = this._getBDLayer("earth"), this.label_layer = this._getBDLayer("earth_label"), this.layer_little_map = new fo({
          source: this.layer_map.getSource()
        }), o = "tileloadend";
      else if (n === "geojson")
        this.layer_map = this._getGeoJsonLayer(r), this.layer_little_map = new ai({
          source: this.layer_map.getSource(),
          style: (a) => this._vectorLayerStyle(a, this.map_stroke_color, !0)
        }), o = "change";
      else {
        console.error("错误的type类型");
        return;
      }
      i && i.length && this._setFloorMapLayers(i), this.layer_map.getSource().once(o, () => {
        var h;
        if (this.dispatchEvent("loaded"), ![
          "geojson",
          "kml"
          /* KML */
        ].includes(n))
          return;
        const a = this.getView().calculateExtent(), l = (h = this.layer_map.getSource()) == null ? void 0 : h.getFeaturesInExtent(a);
        if (l && !l.length) {
          const c = setTimeout(() => {
            t.url === Rt && this.dispatchEvent("parsefinish"), clearTimeout(c);
          }, 1e3);
        }
      }), this.layer_map.once("postrender", () => {
        if (t.url === Rt)
          if (n === "image" && t.center && t.extend) {
            this.getView().setCenter(t.center);
            const a = this.getView().calculateExtent();
            if (Ce(t.extend, a))
              this.dispatchEvent("parsefinish");
            else {
              const l = setTimeout(() => {
                t.url === Rt && this.dispatchEvent("parsefinish"), clearTimeout(l);
              }, 500);
            }
          } else
            this.dispatchEvent("parsefinish");
      });
    });
    /**
     *
     *
     * @param {*} feature
     * @param {string} color
     * @return {*}
     * @memberof Map
     */
    v(this, "_vectorLayerStyle", (t, i, n) => {
      let r = t.get("name"), o = new se({
        stroke: new K({
          color: i,
          width: 1
        })
      });
      if (t.getGeometry().getType() === "Point") {
        let a = new De({
          textAlign: "center",
          textBaseline: "top",
          font: "14px serif",
          text: n ? "" : r,
          scale: Sh,
          fill: new N({
            color: i
          })
        });
        return o.setText(a), o;
      } else
        return o;
    });
    /**
     *
     * 生成geojson图层
     * @param {string} url
     * @memberof Map
     */
    v(this, "_getGeoJsonLayer", (t) => new ai({
      source: new we({
        loader: () => {
          let i = new XMLHttpRequest();
          this.xhr = i, i.open("GET", t);
          let n = 0, r = 0;
          i.onprogress = (o) => {
            if (t !== Rt) {
              i.abort();
              return;
            }
            if (o.lengthComputable) {
              let a = o.loaded / o.total;
              a = a < 1 ? a : 0.99;
              const l = {
                type: "progress",
                progress: {
                  percent_complete: a,
                  speed: (o.loaded - n) / ((o.timeStamp - r) / 1e3),
                  loaded: o.loaded,
                  total: o.total
                }
              };
              n = o.loaded, r = o.timeStamp, this.dispatchEvent(l);
            }
          }, i.onload = () => {
            if (i.status == 200) {
              let o = this.layer_map.getSource().getFormat().readFeatures(i.responseText, { featureProjection: this.getView().getProjection() });
              this.layer_map.getSource().addFeatures(o);
              const a = {
                type: "progress",
                progress: { percent_complete: 1 },
                data: i.responseText
              };
              this.dispatchEvent(a);
            }
          }, i.onerror = () => {
            this.dispatchEvent("loadingfailed");
          }, i.ontimeout = () => {
            this.dispatchEvent("loadingfailed");
          }, i.send();
        },
        format: new rh(),
        wrapX: !1
      }),
      style: (i) => this._vectorLayerStyle(i, this.map_stroke_color)
    }));
    /**
     *
     * 生成kml图层
     * @param {string} url
     * @memberof Map
     */
    v(this, "_getKmlLayer", (t) => new ai({
      source: new we({
        loader: () => {
          let i = new XMLHttpRequest();
          this.xhr = i, i.open("GET", t);
          let n = 0, r = 0;
          i.onprogress = (o) => {
            if (t !== Rt) {
              i.abort();
              return;
            }
            if (o.lengthComputable) {
              let a = o.loaded / o.total;
              a = a < 1 ? a : 0.99;
              const l = {
                type: "progress",
                progress: {
                  percent_complete: a,
                  speed: (o.loaded - n) / ((o.timeStamp - r) / 1e3),
                  loaded: o.loaded,
                  total: o.total
                }
              };
              n = o.loaded, r = o.timeStamp, this.dispatchEvent(l);
            }
          }, i.onload = () => {
            if (i.status == 200) {
              let o = this.layer_map.getSource().getFormat().readFeatures(i.responseText, { featureProjection: this.getView().getProjection() });
              this.layer_map.getSource().addFeatures(o);
              const a = {
                type: "progress",
                progress: { percent_complete: 1 },
                data: i.responseText
              };
              this.dispatchEvent(a);
            }
          }, i.onerror = () => {
            this.dispatchEvent("loadingfailed");
          }, i.ontimeout = () => {
            this.dispatchEvent("loadingfailed");
          }, i.send();
        },
        format: new sh({
          extractStyles: !1
        }),
        wrapX: !1
      }),
      style: (i) => this._vectorLayerStyle(i, this.map_stroke_color)
    }));
    /**
     *
     * 生成images图层
     * @param {string} url
     * @param {number[]} extend
     * @memberof Map
     */
    v(this, "_getImageLayer", (t, i) => {
      const n = this.getView().calculateExtent();
      return Ce(i, n) || this.getView().setCenter(Ne(i)), new Ns({
        source: new lh({
          url: t,
          crossOrigin: "",
          imageExtent: i,
          imageLoadFunction: (r) => {
            let o = r.getImage(), a = new XMLHttpRequest();
            this.xhr = a, a.open("GET", t), a.responseType = "blob";
            let l = 0, h = 0;
            a.onprogress = (c) => {
              if (t !== Rt) {
                a.abort();
                return;
              }
              if (c.lengthComputable) {
                let u = c.loaded / c.total;
                u = u < 1 ? u : 0.99;
                const d = {
                  type: "progress",
                  progress: {
                    percent_complete: u,
                    speed: (c.loaded - l) / ((c.timeStamp - h) / 1e3),
                    loaded: c.loaded,
                    total: c.total
                  }
                };
                l = c.loaded, h = c.timeStamp, this.dispatchEvent(d);
              }
            }, a.onload = () => {
              if (a.status == 200) {
                let c = a.response;
                o.onload = () => {
                  window.URL.revokeObjectURL(o.src);
                }, o.src = window.URL.createObjectURL(c);
                const u = { type: "progress", progress: { percent_complete: 1 }, data: c };
                this.dispatchEvent(u);
              }
            }, a.onerror = () => {
              this.dispatchEvent("loadingfailed");
            }, a.ontimeout = () => {
              this.dispatchEvent("loadingfailed");
            }, a.send();
          }
        })
      });
    });
    /**
     *
     * 生成百度地图图层
     * @param {string} baidu_type
     * @memberof Map
     */
    v(this, "_getBDLayer", (t) => {
      let i = [];
      for (let o = 0; o <= 18; o++)
        i[o] = Math.pow(2, 18 - o);
      let n = new hu({
        origin: [0, 0],
        resolutions: i
      }), r = new Gy({
        tileGrid: n,
        tileUrlFunction: (o) => {
          let a = o[0], l = o[1], h = -o[2] - 1;
          return l < 0 && (l = "M" + -l), h < 0 && (h = "M" + -h), t === "earth" ? "http://shangetu" + Math.floor(Math.random() * 5) + ".map.bdimg.com/it/u=x=" + l + ";y=" + h + ";z=" + a + ";v=009;type=sate&fm=46&udt=20181205" : t === "baidu" ? "http://online" + Math.floor(Math.random() * 6) + ".map.bdimg.com/onlinelabel/?qt=vtile&x=" + l + "&y=" + h + "&z=" + a + "&styles=pl&udt=20181205" : "http://online" + Math.floor(Math.random() * 6) + ".map.bdimg.com/onlinelabel/?qt=vtile&x=" + l + "&y=" + h + "&z=" + a + "&styles=sl&udt=20181205";
        }
      });
      return r.on("tileloaderror", () => {
        const o = { type: "error", layer: "baidu" };
        this.dispatchEvent(o);
      }), new fo({
        source: r
      });
    });
    v(this, "_getFloorLayer", (t, i, n, r) => {
      if (i === "kml")
        return new ai({
          source: new we({
            loader: () => {
              let o = new XMLHttpRequest();
              this.xhr = o, o.open("GET", n), o.onload = () => {
                var a;
                if (o.status == 200) {
                  let l = (a = this.floor_layer_maps[t]) == null ? void 0 : a.getSource().getFormat().readFeatures(o.responseText, { featureProjection: this.getView().getProjection() });
                  this.floor_layer_maps[t].getSource().addFeatures(l);
                }
              }, o.send();
            },
            format: new sh({
              extractStyles: !1
            }),
            wrapX: !1
          }),
          style: (o) => this._vectorLayerStyle(o, this.map_stroke_color)
        });
      if (i === "image") {
        if (typeof r != "object" || r.length !== 4) {
          console.error("错误的extend");
          return;
        }
        return new Ns({
          source: new lh({
            url: n,
            crossOrigin: "",
            imageExtent: r,
            imageLoadFunction: (o) => {
              let a = o.getImage(), l = new XMLHttpRequest();
              this.xhr = l, l.open("GET", n), l.responseType = "blob", l.onload = () => {
                if (l.status == 200) {
                  let h = l.response;
                  a.onload = () => {
                    window.URL.revokeObjectURL(a.src);
                  }, a.src = window.URL.createObjectURL(h);
                }
              }, l.send();
            }
          })
        });
      } else if (i === "geojson")
        return new ai({
          source: new we({
            loader: () => {
              let o = new XMLHttpRequest();
              this.xhr = o, o.open("GET", n), o.onload = () => {
                var a, l;
                if (o.status == 200) {
                  let h = (a = this.floor_layer_maps[t]) == null ? void 0 : a.getSource().getFormat().readFeatures(o.responseText, { featureProjection: this.getView().getProjection() });
                  (l = this.floor_layer_maps[t]) == null || l.getSource().addFeatures(h);
                }
              }, o.send();
            },
            format: new rh(),
            wrapX: !1
          }),
          style: (o) => this._vectorLayerStyle(o, this.map_stroke_color)
        });
    });
    v(this, "_setFloorMapLayers", (t) => {
      const i = t.map((n, r) => this._getMapLayersPromise(n, r));
      Promise.all(i).then((n) => {
        n.forEach((r, o) => {
          var l, h;
          this.floor_layer_maps.push(r);
          const a = t[o].type === "image" ? new Ns({ source: r.getSource() }) : new ai({ source: r.getSource(), style: (c) => this._vectorLayerStyle(c, this.map_stroke_color, !0) });
          (h = (l = this.overviewMapControl) == null ? void 0 : l.getOverviewMap()) == null || h.getLayers().insertAt(o + 1, a), this.getLayers().insertAt(o + 1, r);
        });
      });
    });
    v(this, "_getMapLayersPromise", (t, i) => {
      const { type: n, url: r, extend: o } = t;
      return new Promise((a) => {
        a(this._getFloorLayer(i, n, r, o));
      });
    });
    /**
     *
     * 生成人员图标图层
     * @memberof Map
     */
    v(this, "_getPersonLayer", () => {
      this.vector_person_source = new we({
        features: [],
        wrapX: !1
      }), this.vector_person_source_little = new we({
        features: [],
        wrapX: !1
      }), this.vector_person_layer = new Be({
        updateWhileInteracting: !0,
        source: this.vector_person_source
      }), this.vector_person_layer_little = new Be({
        updateWhileInteracting: !0,
        source: this.vector_person_source_little
      });
    });
    /**
     *
     * 生成轨迹图层
     * @memberof Map
     */
    v(this, "_getTrackLayer", () => {
      this.vector_track_source = new we({
        features: [],
        wrapX: !1
      }), this.vector_track_layer = new Be({
        updateWhileInteracting: !0,
        source: this.vector_track_source
      });
    });
    /**
     *
     * 生成基站图标图层
     * @memberof Map
     */
    v(this, "_getBaseStationLayer", () => {
      this.vector_station_source = new we({
        features: [],
        wrapX: !1
      }), this.vector_station_layer = new Be({
        updateWhileInteracting: !0,
        source: this.vector_station_source
      });
    });
    /**
     *
     * 生成区域显示图层
     * @memberof Map
     */
    v(this, "_getAreaLayer", () => {
      this.vector_area_source = new we({
        features: [],
        wrapX: !1
      }), this.vector_area_layer = new Be({
        updateWhileInteracting: !0,
        source: this.vector_area_source
      });
    });
    /**
     *
     *  生成绘制图层
     * @memberof Map
     */
    v(this, "_getDrawLayer", () => {
      this.vector_draw_source = new we({
        features: [],
        wrapX: !1,
        useSpatialIndex: !1
      }), this.vector_draw_layer = new Be({
        updateWhileInteracting: !0,
        source: this.vector_draw_source
      });
    });
    /**
     *
     *  生成热力图图层
     * @memberof Map
     */
    v(this, "_getHeatMapLayer", () => {
      this.heat_map_source = new we({
        features: [],
        wrapX: !1
      }), this.heat_map_layer = new G0({
        source: this.heat_map_source,
        blur: 7,
        radius: 4
      });
    });
    /**
     *
     * 生成测量图层
     * @memberof Map
     */
    v(this, "_getMeasureLayer", () => {
      this.vector_measure_source = new we({
        features: [],
        wrapX: !1
      }), this.vector_measure_layer = new Be({
        source: this.vector_measure_source,
        style: new se({
          fill: new N({
            color: "rgba(255, 255, 255, 0.2)"
          }),
          stroke: new K({
            color: "#ffcc33",
            width: 2
          }),
          image: new qi({
            radius: 7,
            fill: new N({
              color: "#ffcc33"
            })
          })
        })
      });
    });
    /**
     *
     * 获得点元素的样式，包括人员，基站，等
     * @param {string} icon
     * @param {string} text
     * @param {point_feature_style} options
     * @memberof Map
     */
    v(this, "_getPointFeatureStyle", (t, i, n) => {
      let r = new se({
        image: new tt({
          anchor: [0.5, 0.92],
          src: t,
          scale: n.icon_scale
        }),
        text: new De({
          textAlign: "center",
          textBaseline: "top",
          font: "14px Source Han Sans CN",
          scale: n.text_scale,
          offsetY: n.offset_y,
          text: i,
          fill: new N({ color: "#15F9F8" }),
          backgroundFill: new N({ color: "rgba(15, 33, 51, 0.85)" }),
          padding: [4, 5, 2, 6]
        })
      });
      return n.text_color && r.getText().setFill(new N({ color: n.text_color })), n.text_background_color && r.getText().setBackgroundFill(new N({ color: n.text_background_color })), (n.text_background_border_color || n.text_background_border_width) && r.getText().setBackgroundStroke(new K({ color: n.text_background_border_color, width: n.text_background_border_width })), r;
    });
    /**
     * 处理轨迹追踪
     * 内部函数
     * @param {number} card_id
     * @param {number} card_x
     * @param {number} card_y
     * @param {boolean} is_dash
     * @param {boolean} is_end_point
     * @memberof Map
     */
    v(this, "_handleTrackCard", (t, i, n, r, o, a) => {
      if (this.all_person[t].track_overtime && o && this.all_track_card_time[t] && o - this.all_track_card_time[t] > this.all_person[t].track_overtime * 1e3) {
        this.all_track[t] = void 0, a && (this.all_track_card_time[t] = o, this._addNewTrackLine(t, i, n, r));
        return;
      }
      if (a && this.all_track_point_count[t] && (this.all_track_point_count[t].count && this.all_track_point_count[t].count++, this.all_track_point_count[t].coords ? this.all_track_point_count[t].coords.push([i, n]) : this.all_track_point_count[t].coords = [[i, n]]), this.all_track_card_time[t] = o, this.all_track[t] && this.all_track[t].length > 0) {
        let l = this.all_track[t].length - 1;
        if (this.all_track[t][l].is_dash === r)
          this._updateTrackLine(t, i, n);
        else {
          let h = this.all_person[t].getGeometry().getCoordinates();
          this._addNewTrackLine(t, h[0], h[1], r), this._updateTrackLine(t, i, n);
        }
      } else
        this._addNewTrackLine(t, i, n, r);
    });
    /**
     * 添加一条新的轨迹
     * 内部函数
     * @param {number} card_id
     * @param {number} card_x
     * @param {number} card_y
     * @param {boolean} is_dash
     * @memberof Map
     */
    v(this, "_addNewTrackLine", (t, i, n, r) => {
      let o;
      r && (o = [1, 5]);
      let a = new se({
        stroke: new K({
          color: "#000",
          lineDash: o,
          width: 4
        })
      }), l = new se({
        stroke: new K({
          color: this.all_track_color[t],
          lineDash: o,
          width: 3
        })
      }), h = new $({
        geometry: new qe([[i, n]])
      });
      h.setStyle([a, l]), h.is_dash = r, this.vector_track_source.addFeature(h), this.all_track_point_count[t] = { count: 1 }, this.all_track[t] === void 0 ? this.all_track[t] = [h] : this.all_track[t].push(h);
    });
    /**
     * 更新一条轨迹
     * 内部函数
     * @param {number} card_id
     * @param {number} card_x
     * @param {number} card_y
     * @memberof Map
     */
    v(this, "_updateTrackLine", (t, i, n) => {
      var o;
      let r = this.all_track[t].length - 1;
      if (this.all_track[t][r].getGeometry().appendCoordinate([i, n]), this.all_track_point_count[t].count > this.all_track_max_point_num[t]) {
        if (this.animation_enable) {
          let a = this.all_track[t][0].getGeometry().getCoordinates();
          const l = (o = this.all_track_point_count[t].coords) == null ? void 0 : o.shift(), h = a.findIndex((c) => l[0] === c[0] && l[1] === c[1]);
          a.splice(0, h), this.all_track[t][0].getGeometry().setCoordinates(a);
        } else {
          let a = this.all_track[t][0].getGeometry().getCoordinates();
          if (a.length > 1)
            a.shift(0, 1), this.all_track[t][0].getGeometry().setCoordinates(a);
          else {
            this.vector_track_source.removeFeature(this.all_track[t][0]), this.all_track[t].shift();
            let l = this.all_track[t][0].getGeometry().getCoordinates();
            l.shift(0, 1), this.all_track[t][0].getGeometry().setCoordinates(l);
          }
        }
        this.all_track_point_count[t].count--;
      }
    });
    /**
     * 获得两点之间的距离
     * 内部函数
     * @param {number[]} point_one
     * @param {number[]} point_two
     * @memberof Map
     */
    v(this, "_getTwoPointsDistance", (t, i) => Math.sqrt((t[0] - i[0]) * (t[0] - i[0]) + (t[1] - i[1]) * (t[1] - i[1])));
    /**
     * 处理定位图标动画
     * 内部函数
     * @memberof Map
     */
    v(this, "_handlePersonAnimation", () => {
      const t = { type: "updateBuildingLabelPosition", position: this.getBuildingLabelsPosition() };
      this.dispatchEvent(t), Ix();
    });
    /**
     * 创建测量信息框
     * 内部函数
     * @param {*} dom 元素ID
     * @memberof Map
     */
    v(this, "_createMeasureTooltip", (t) => {
      t && t.parentNode.removeChild(t), t = document.createElement("div"), t.className = "hg_tooltip hg_tooltip_measure";
      let i = new ta({
        element: t,
        offset: [0, -15],
        positioning: "bottom-center"
      });
      return this.addOverlay(i), { dom: t, measureOverlay: i };
    });
    /**
     * 处理窗口切换事件
     * 内部函数
     * @memberof Map
     */
    v(this, "_handleVisibilityChange", () => {
      document.visibilityState === "hidden" ? this._handleAppPause() : this._handleAppResume();
    });
    /**
     * 处理窗口暂停事件
     * 内部函数
     * @memberof Map
     */
    v(this, "_handleAppPause", () => {
      Lo();
      for (let t in this.all_person) {
        let i = this.all_person[t];
        if (!i)
          continue;
        let n = i.points;
        n && this._handleTrackTimeDelay(Number(t), n);
      }
    });
    /**
     * 处理窗口继续事件
     * 内部函数
     * @memberof Map
     */
    v(this, "_handleAppResume", () => {
      for (let t in this.all_person) {
        let i = this.all_person[t];
        i && (i.is_animate = !1);
      }
    });
    /**
     * 处理moveEnd事件，用来判断是否进行了缩放
     * 内部函数
     * @memberof Map
     */
    v(this, "_handleMoveEnd", () => {
      this.getView().getZoom() !== this.now_zoom && (this.now_zoom = this.getView().getZoom(), this.getView().dispatchEvent("change:zoom"));
    });
    /**
     * 创建小地图的point feature
     * 内部函数
     * @memberof Map
     */
    v(this, "_createOverviewPoint", (t, i) => {
      let n, r;
      i.icon && (n = new tt({
        anchor: i.anchor ? i.anchor : [0.5, 1],
        src: i.icon,
        scale: i.icon_scale,
        rotation: i.rotation
      })), i.text && (r = new De({
        textAlign: "center",
        textBaseline: "top",
        font: "14px serif",
        scale: i.text_scale,
        text: i.text
      }), i.text_color && r.setFill(new N({ color: i.text_color })), i.text_background_color && (r.setBackgroundFill(new N({ color: i.text_background_color })), r.setPadding([0, 5, 0, 5])), i.text_background_border_color && (r.setBackgroundStroke(new K({ color: i.text_background_border_color })), r.setPadding([0, 5, 0, 5])));
      let o = new se({
        image: n,
        text: r
      }), a = new $({
        geometry: t
      });
      return a.setStyle(o), a;
    });
    // 聚类的样式函数
    v(this, "_clusterStyleFunc", (t) => {
      const i = this.vector_person_layer.getSource().getFeatures();
      let n = t.get("features");
      if (n.length === 1) {
        for (let h in n[0])
          n[h] === void 0 && (n[h] = n[0][h]);
        return n[0].getStyle();
      }
      const o = [];
      i.forEach((h) => {
        const c = h.get("features");
        if (c && c.length > 1) {
          const u = c[0].getGeometry().getCoordinates(), d = this.getPixelFromCoordinate(u), f = c.map((g) => g.id);
          o.push({
            card_list: f,
            cluster_center: {
              x: d[0],
              y: d[1]
            }
          });
        }
      });
      const a = { type: "updateclustercardlabel", cluster_list: o };
      this.dispatchEvent(a);
      const l = n.find((h) => h.id === this.display_cluster_card);
      return l ? l.getStyle() : void 0;
    });
    /**
     * 改变地图
     *
     * @param {map_options} options
     * @memberof Map
     */
    v(this, "changeMap", (t) => {
      this.removeLayer(this.layer_map), this.floor_layer_maps.forEach((n) => {
        var r, o;
        this.removeLayer(n), (o = (r = this.overviewMapControl) == null ? void 0 : r.getOverviewMap()) == null || o.removeLayer(n);
      }), this.floor_layer_maps = [], this.xhr && this.xhr.status !== 200 && this.xhr.abort(), this.overviewMapControl && (this.overviewMapControl.getOverviewMap().removeLayer(this.layer_little_map), this.overviewMapControl.getOverviewMap().removeLayer(this.vector_person_layer_little)), this.now_map_type = t.type, Rt = t.url, this._getMapLayer(t), this.getLayers().insertAt(0, this.layer_map);
      let i;
      if (t.type === "geojson" && (i = new er({
        code: "custom",
        extent: [0, 0, 4007501668e-2, 400979322e-1],
        units: "m"
      })), t.center && t.zoom) {
        const n = {
          center: t.center || [0, 0],
          zoom: t.zoom || 20,
          maxZoom: t.max_zoom,
          minZoom: t.min_zoom,
          extent: t.extent,
          enableRotation: t.enable_rotation,
          zoomFactor: t.zoom_factor,
          resolution: t.resolution,
          rotation: t.rotation,
          constrainOnlyCenter: !0,
          projection: i
        };
        if (this.setView(
          new Pe(n)
        ), this.overviewMapControl) {
          const r = this.getResolutionForZoom(t.little_map_zoom || 0);
          this.overviewMapControl.setMap(this), this.overviewMapControl.getOverviewMap().addLayer(this.layer_little_map), this.overviewMapControl.getOverviewMap().addLayer(this.vector_person_layer_little), this.overviewMapControl.getOverviewMap().setView(new Pe({
            center: t.center || [0, 0],
            resolution: r,
            resolutions: [r],
            constrainOnlyCenter: !0,
            showFullExtent: !0,
            projection: i
          }));
        }
      } else if (t.type === "geojson") {
        const n = this.getView(), r = {
          center: n.getCenter(),
          zoom: n.getZoom(),
          maxZoom: n.getMaxZoom(),
          minZoom: n.getMinZoom(),
          extent: t.extent,
          enableRotation: t.enable_rotation,
          zoomFactor: t.zoom_factor,
          resolution: t.resolution,
          rotation: t.rotation,
          constrainOnlyCenter: !0,
          projection: i
        };
        if (this.setView(
          new Pe(r)
        ), this.overviewMapControl) {
          const o = this.getResolutionForZoom(t.little_map_zoom || 0);
          this.overviewMapControl.setMap(this), this.overviewMapControl.getOverviewMap().addLayer(this.layer_little_map), this.overviewMapControl.getOverviewMap().addLayer(this.vector_person_layer_little), this.overviewMapControl.getOverviewMap().setView(new Pe({
            center: t.center || [0, 0],
            resolution: o,
            resolutions: [o],
            constrainOnlyCenter: !0,
            showFullExtent: !0,
            projection: i
          }));
        }
      }
      return this.animation_enable = t.animation_enable === void 0 ? !1 : t.animation_enable, this.cache_animation_enable = t.animation_enable === void 0 ? !1 : t.animation_enable, this.animation_cache_time = t.animation_cache_time === void 0 ? 1 : t.animation_cache_time, this.animation_speed_point = t.animation_speed_point || this.animation_speed_point, this._building_extent = t.building_extent, !0;
    });
    v(this, "getBuildingLabelsPosition", () => {
      if (this._building_extent) {
        const t = {};
        for (const i in this._building_extent) {
          const [n, r] = this.getPixelFromCoordinate(Ne(this._building_extent[i]));
          t[i] = { x: n, y: r };
        }
        return t;
      }
      return null;
    });
    /**
     * 小地图的折叠与展开，true表示折叠，false表示展开
     *
     * @param collapsed
     * @memberof Map
     */
    v(this, "littleMapCollapsed", (t) => {
      var i;
      (i = this.overviewMapControl) == null || i.setCollapsed(t);
    });
    /**
     *
     * 重置地图
     * @memberof Map
     */
    v(this, "reset", () => (Rt = "", this._initVars(), this.removeControlMeasure(), Lo(), this.vector_person_source.clear(), this.vector_person_source_little.clear(), this.vector_area_source.clear(), this.vector_track_source.clear(), this.vector_station_source.clear(), this.vector_draw_source.clear(), this.vector_measure_source.clear(), this.heat_map_source.clear(), this.vector_person_layer.setVisible(!0), this.vector_station_layer.setVisible(!0), this.vector_person_layer_little.setVisible(!0), this.vector_area_layer.setVisible(!0), this.vector_track_layer.setVisible(!0), !0));
    /**
     * 新增定位卡信息
     *
     * @param {number} card_id 定位卡卡号
     * @param {string} icon 定位卡图标
     * @param {number} card_x 定位卡坐标X
     * @param {number} card_y 定位卡坐标Y
     * @param {string} text 定位卡显示文字
     * @param {{}} options 定位卡可选参数
     * @memberof Map
     */
    v(this, "addCardInfo", (t, i, n, r, o, a, l) => {
      l = l || {}, t = typeof t == "string" ? parseInt(t) : t, o = o !== void 0 ? o : t.toString();
      let h = !1;
      if (l.close_animation && (h = !0, delete l.close_animation), this.all_person[t])
        return this.setCardCoordinate(t, n, r, a), console.error("该卡已经加入显示，如需更改，请调用相关更新接口"), !1;
      let c = new Js([n, r], { icon: i, text: o, ...l }), u = this._createOverviewPoint(c.getGeometry(), { icon: i, icon_scale: 0.2 });
      if (this.animation_enable && !h) {
        let d = [[n, r, a]];
        c.points = d, c.speed_points = [[n, r, a]];
      }
      return c.last_point = [n, r], c.close_animation = h, this.all_person[t] = c, this.all_little_person[t] = u, this.vector_person_source.addFeature(c), this.vector_person_source_little.addFeature(u), this.updateHeatMapPoint(), this.all_track_card_time[t] = a, this.all_track_card.includes(t) && this._handleTrackCard(t, n, r, !1, a, !0), c;
    });
    v(this, "_setPersonAnimate", (t) => {
      const i = this.all_person[t];
      if (!i || !i.points)
        return;
      let n = i.points;
      if (!(n[n.length - 1][2] - n[0][2] <= this.animation_cache_time * 1e3 && !i.animate_start) && n.length >= 2 && !i.is_animate) {
        let r;
        if (this.animation_speed_point && this.animation_speed_point > 1 && i.speed_points) {
          const d = i.speed_points, f = d.reduce((_, m, p, x) => p === x.length - 1 ? _ : _ + this._getTwoPointsDistance(m, x[p + 1]), 0), g = d.reduce((_, m, p, x) => {
            if (p === x.length - 1)
              return _;
            let y = x[p + 1][2] - m[2];
            return (this._getTwoPointsDistance(m, x[p + 1]) < 0.1 || y > this.animation_delay_time_point * 1e3) && (y = 0), _ + y;
          }, 0);
          r = f / g;
        }
        i.is_animate = !0, i.animate_start = !0;
        const [o, a, l] = n.shift();
        let h = { x: n[0][0], y: n[0][1] }, c = r ? this._getTwoPointsDistance([o, a], n[0]) / r : n[0][2] - l;
        if (n[0][2] - l > this.animation_delay_time_point * 1e3 && (c = 500), n[n.length - 1][2] - l > this.animation_delay_time * 1e3) {
          this._handleTrackTimeDelay(t, n), i && (i.is_animate = !1);
          return;
        }
        const u = new Tx({ x: o, y: a }).to(h, c / this._history_card_times).easing(tn.Linear.None).dynamic(!0).onUpdate((d) => {
          var f;
          if ((f = i == null ? void 0 : i.getGeometry()) == null || f.setCoordinates([d.x, d.y]), this.setFollowCardFeature(t, d.x, d.y), this.all_track_card.includes(t)) {
            const g = d.x === h.x && d.y === h.y && this._getTwoPointsDistance([o, a], [h.x, h.y]) > 0.1;
            this._handleTrackCard(t, d.x, d.y, !1, n[0][2], g);
          }
        }).start().onComplete(() => {
          i && (i.is_animate = !1), this._setPersonAnimate(t);
        });
        u.animate_card = t;
      }
    });
    v(this, "_handleTrackTimeDelay", (t, i) => {
      const n = this.all_person[t];
      if (this.all_track_card.includes(t))
        for (let o = 0; o < i.length; o++)
          this._handleTrackCard(t, i[o][0], i[o][1], i[o][3], i[o][2], !0);
      const r = i[i.length - 1];
      this.all_person[t].points = [r], n.getGeometry().setCoordinates([r[0], r[1]]), this.setFollowCardFeature(t, r[0], r[1]);
    });
    // 设置历史回放倍数
    v(this, "setAnimationSpeed", (t) => {
      this._history_card_times = t || 1;
    });
    // 设置历史回放暂停
    v(this, "setAnimationPause", () => {
      this._handleAppPause();
    });
    /**
     * 设置定位卡坐标
     *
     * @param {number} card_id
     * @param {number} card_x
     * @param {number} card_y
     * @memberof Map
     */
    v(this, "setCardCoordinate", (t, i, n, r) => {
      t = typeof t == "string" ? parseInt(t) : t;
      let o = [i, n, r, !1];
      if (this.all_track_card.includes(t) && (!this.animation_enable || this.all_person[t] && this.all_person[t].close_animation ? this._handleTrackCard(t, i, n, !1, r, !0) : o[3] = !1), this.all_person[t]) {
        if (this.animation_enable && !this.all_person[t].close_animation) {
          if (this.all_person[t].points ? this.all_person[t].points.push(o) : this.all_person[t].points = [o], this.animation_speed_point && this.animation_speed_point > 1) {
            this.all_person[t].speed_points || (this.all_person[t].speed_points = []);
            let a = this.all_person[t].speed_points;
            a.length >= this.animation_speed_point && a.shift(), a.push(o);
          }
          this.vector_person_layer.changed(), this.vector_person_layer_little.changed(), this._setPersonAnimate(t);
        } else
          this.all_person[t].getGeometry().setCoordinates([i, n]), this.setFollowCardFeature(t, i, n);
        return this.all_person[t].last_point = [i, n], !0;
      } else
        return console.error("没有该卡的信息，需要先添加定位卡"), !1;
    });
    // 设置跟随卡号移动的危险源等feature
    v(this, "setFollowCardFeature", (t, i, n) => {
      var r, o;
      (o = (r = this.vector_draw_source) == null ? void 0 : r.getFeatures()) == null || o.forEach((a) => {
        var l;
        Number(a.follow_card) === t && ((l = a.getGeometry()) == null || l.setCenter([i, n]));
      });
    });
    /**
     *
     * 设置定位卡图标
     * @param {number} card_id
     * @param {string} icon
     * @param {point_feature_style} options
     * @memberof Map
     */
    v(this, "setCardIcon", (t, i, n) => {
      var r, o, a, l, h, c, u, d, f, g;
      if (t = typeof t == "string" ? parseInt(t) : t, this.all_person[t]) {
        let _ = (r = this.all_person[t].getStyle()) == null ? void 0 : r.getImage(), m = (o = this.all_little_person[t].getStyle()) == null ? void 0 : o.getImage();
        return n = n || {}, i && (_ = new tt({
          anchor: [0.5, 0.92],
          src: i
        }), m = new tt({
          anchor: [0.5, 0.92],
          src: i,
          scale: 0.2
        })), n.icon_scale && _.setScale(n.icon_scale), (a = this.all_person[t].getStyle()) == null || a.setImage(_), (h = (l = this.all_little_person[t]) == null ? void 0 : l.getStyle()) == null || h.setImage(m), n.text_scale && this.all_person[t].getStyle().getText().setScale(n.text_scale), n.offset_y && ((u = (c = this.all_person[t].getStyle()) == null ? void 0 : c.getText()) == null || u.setOffsetY(n.offset_y)), n.z_index ? (d = this.all_person[t].getStyle()) == null || d.setZIndex(n.z_index) : (f = this.all_person[t].getStyle()) == null || f.setZIndex(), this.all_person[t].changed(), this.all_little_person[t].changed(), this.all_person[t].images_flash_timer && (this.all_person[t].old_images_style = (g = this.all_person[t].getStyle()) == null ? void 0 : g.getImage()), !0;
      } else
        return console.error("没有该卡的信息，需要先添加定位卡"), !1;
    });
    /**
     *
     * 设置定位卡文字
     * @param {number} card_id
     * @param {string} text
     * @param {point_feature_style} options
     * @memberof Map
     */
    v(this, "setCardText", (t, i, n) => {
      if (t = typeof t == "string" ? parseInt(t) : t, this.all_person[t]) {
        const r = this.all_person[t].getStyle();
        let o = r.getText() || new De({
          textAlign: "center",
          textBaseline: "top",
          font: "14px Source Han Sans CN",
          text: i,
          scale: n == null ? void 0 : n.text_scale,
          offsetY: n == null ? void 0 : n.offset_y,
          fill: new N({ color: "#15F9F8" }),
          backgroundFill: new N({ color: "rgba(15, 33, 51, 0.85)" }),
          padding: [4, 5, 2, 6]
        });
        return n = n || {}, i !== void 0 && o.setText(i), n.text_color && o.setFill(new N({ color: n.text_color })), n.text_background_color && o.setBackgroundFill(new N({ color: n.text_background_color })), (n.text_background_border_color || n.text_background_border_width) && o.setBackgroundStroke(new K({ width: n.text_background_border_width, color: n.text_background_border_color })), r.setText(o), this.all_person[t].changed(), !0;
      } else
        return console.error("没有该卡的信息，需要先添加定位卡"), !1;
    });
    /**
     *
     * 设置全部定位卡图标大小和文字大小
     * @param {point_feature_style} scale
     * @memberof Map
     */
    v(this, "setAllCardScale", (t) => {
      var i, n, r;
      for (let o in this.all_person)
        this.all_person[o] && (t.icon_scale && ((i = this.all_person[o].getStyle().getImage()) == null || i.setScale(t.icon_scale)), t.text_scale && ((n = this.all_person[o].getStyle().getText()) == null || n.setScale(t.text_scale)), t.offset_y && ((r = this.all_person[o].getStyle().getText()) == null || r.setOffsetY(t.offset_y)), this.all_person[o].changed());
      return !0;
    });
    /**
     *
     * 删除一张定位卡
     * @param {number} card_id
     * @memberof Map
     */
    v(this, "removeOneCard", (t) => {
      if (t = typeof t == "string" ? parseInt(t) : t, this.all_person[t]) {
        const i = Sx().find((n) => n.animate_card === t);
        return i && Rx(i), this.vector_person_source.removeFeature(this.all_person[t]), this.vector_person_source_little.removeFeature(this.all_little_person[t]), this.all_little_person[t] = void 0, this.all_person[t] = void 0, this.updateHeatMapPoint(), this.all_track_card_time[t] && delete this.all_track_card_time[t], !0;
      } else
        return console.error("没有该卡的信息，需要先添加定位卡"), !1;
    });
    /**
     *
     * 删除所有定位卡
     * @memberof Map
     */
    v(this, "removeAllCard", () => (Lo(), this.all_person = [], this.all_little_person = [], this.all_track_card_time = {}, this.vector_person_source.clear(), this.vector_person_source_little.clear(), this.heat_map_source.clear(), !0));
    /**
     *
     * 隐藏全部定位卡
     * @memberof Map
     */
    v(this, "hideAllCard", () => (this.vector_person_layer.setVisible(!1), this.vector_person_layer_little.setVisible(!1), !0));
    /**
     *
     * 显示所有定位卡
     * @memberof Map
     */
    v(this, "showAllCard", () => (this.vector_person_layer.setVisible(!0), this.vector_person_layer_little.setVisible(!0), !0));
    // 地图中心点聚焦到标签卡上
    v(this, "setCardFocus", (t) => {
      if (t && this.all_person[t]) {
        const i = this.getMaxZoom(), n = this.all_person[t].getGeometry().getCoordinates();
        return this.getView().animate({ center: n, zoom: i }), !0;
      } else
        return console.error("没有该卡的信息，需要先添加定位卡"), !1;
    });
    /**
     *
     * 添加轨迹追踪
     * @param {number} card_id 卡号
     * @param {number} points_num 轨迹的点数
     * @param {string} color 轨迹的颜色
     * @param {number} distance 轨迹绘制为虚线的距离
     * @memberof Map
     */
    v(this, "addTrack", (t, i, n, r, o) => (t = typeof t == "string" ? parseInt(t) : t, this.all_track_card.includes(t) ? (console.error("已经添加了该轨迹，不能重复添加"), !1) : (this.all_track_dash_distance[t] = r || 0, this.all_track_color[t] = n || "rgb(" + Math.floor(Math.random() * 256) + "," + Math.floor(Math.random() * 256) + "," + Math.floor(Math.random() * 256) + ")", this.all_track_card.push(t), this.all_track_max_point_num[t] = i || 500, this.all_person[t] && o && (this.all_person[t].track_overtime = o), !0)));
    /**
     *
     * 删除指定定位卡的轨迹追踪
     * @param {number} card_id
     * @memberof Map
     */
    v(this, "removeOneTrack", (t) => {
      if (t = typeof t == "string" ? parseInt(t) : t, this.all_track[t]) {
        for (let i in this.all_track[t])
          this.vector_track_source.removeFeature(this.all_track[t][i]);
        delete this.all_track[t], delete this.all_track_point_count[t], this.all_track_card_time[t] && delete this.all_track_card_time[t];
      }
      return this.all_track_card.indexOf(t) === -1 ? (console.error("该卡没处于轨迹追踪状态"), !1) : (this.all_track_card.splice(this.all_track_card.indexOf(t), 1), this.all_track_max_point_num[t] = 500, this.all_track_color[t] = void 0, !0);
    });
    /**
     *
     * 删除所有定位卡的轨迹追踪
     * @memberof Map
     */
    v(this, "removeAllTrack", () => (this.all_track = {}, this.all_track_card = [], this.all_track_max_point_num = {}, this.all_track_color = {}, this.all_track_point_count = {}, this.all_track_dash_distance = {}, this.all_track_card_time = {}, this.vector_track_source.clear(), !0));
    /**
     *
     * 清除指定定位卡的轨迹
     * @param {number} card_id
     * @memberof Map
     */
    v(this, "clearOneTrack", (t) => {
      if (t = typeof t == "string" ? parseInt(t) : t, this.all_track[t]) {
        for (let i in this.all_track[t])
          this.vector_track_source.removeFeature(this.all_track[t][i]);
        return delete this.all_track[t], delete this.all_track_point_count[t], this.all_track_card_time[t] && delete this.all_track_card_time[t], !0;
      } else
        return console.error("没有该卡的轨迹"), !1;
    });
    /**
     *
     * 清除所有定位卡额轨迹
     * @memberof Map
     */
    v(this, "clearAllTrack", () => (this.all_track = {}, this.all_track_point_count = {}, this.all_track_card_time = {}, this.vector_track_source.clear(), !0));
    /**
     *
     * 隐藏所有定位卡的轨迹
     * @memberof Map
     */
    v(this, "hideAllTrack", () => (this.vector_track_layer.setVisible(!1), !0));
    /**
     *
     * 显示所有定位卡的轨迹
     * @memberof Map
     */
    v(this, "showAllTrack", () => (this.vector_track_layer.setVisible(!0), !0));
    /**
     *
     * 查询定位卡是否处于轨迹追踪状态
     * @param {number} card_id
     * @memberof Map
     */
    v(this, "getTrackStatus", (t) => {
      if (t !== void 0)
        return typeof t != "number" ? (console.error("错误的卡号"), !1) : this.all_track_card.indexOf(t) !== -1;
      {
        let i = [];
        for (let n in this.all_track_card)
          i.push(this.all_track_card[n]);
        return i;
      }
    });
    /**
     *
     * 获得所有的聚类元素
     * @memberof Map
     */
    v(this, "getClusterFeatures", () => this.vector_person_layer.cluster === void 0 ? (console.error("请先开启聚类"), !1) : this.vector_person_layer.getSource().getFeatures());
    /**
     *
     * 设置聚类的距离
     * @param {number} distance
     * @memberof Map
     */
    v(this, "setClusterDistance", (t) => this.vector_person_layer.cluster === void 0 ? (console.error("请先开启聚类"), !1) : (this.vector_person_layer.getSource().setDistance(t), !0));
    /**
     *
     * 开启聚类
     * @param {number} cluster_distance
     * @memberof Map
     */
    v(this, "enableCluster", (t) => {
      t = t || 10;
      const i = this;
      if (this.vector_person_layer.cluster === void 0) {
        let n = new Be({
          updateWhileInteracting: !0,
          updateWhileAnimating: !0,
          source: new Zy({
            distance: t,
            source: this.vector_person_source,
            createCluster: function(r, o) {
              return (o == null ? void 0 : o.length) === 1 ? o[0] : new $({
                geometry: r,
                features: o
              });
            },
            wrapX: !1
          }),
          style: function(r) {
            return i._clusterStyleFunc(r);
          }
        });
        return this.removeLayer(this.vector_person_layer), this.getLayers().push(n), this.vector_person_layer = n, this.vector_person_layer.cluster = !0, this.animation_enable = !1, !0;
      } else
        return console.error("聚类已经开启，请不要重复开启"), !1;
    });
    v(this, "displayClusterCard", (t) => {
      this.display_cluster_card = t;
    });
    /**
     *
     * 关闭聚类
     * @memberof Map
     */
    v(this, "disableCluster", () => {
      if (this.vector_person_layer.cluster === void 0)
        return console.error("聚类已经关闭，请不要重复关闭"), !1;
      {
        let t = this.vector_person_source.getFeatures();
        this.vector_person_source.clear(), this.vector_person_layer.getSource().clear(), this.vector_person_source = new we({
          features: t,
          wrapX: !1
        });
        let i = new Be({
          updateWhileInteracting: !0,
          source: this.vector_person_source
        });
        return this.removeLayer(this.vector_person_layer), this.getLayers().push(i), this.vector_person_layer = i, this.vector_person_layer.cluster = void 0, this.animation_enable = this.cache_animation_enable, !0;
      }
    });
    /**
     *
     * 获得聚类是否开启
     * @memberof Map
     */
    v(this, "getClusterEnable", () => this.vector_person_layer.cluster !== void 0);
    /**
     * 设置地图的文字大小
     *
     * @param {number} scale
     * @memberof Map
     */
    v(this, "setMapTextScale", (t) => {
      Sh = t, this.layer_map.changed();
    });
    /**
     *
     * 新增信息弹出框
     * @param {string} dom
     * @param {*} options
     * @memberof Map
     */
    v(this, "addPopup", (t, i) => {
      let n = document.getElementById(t) || void 0;
      i = i || {};
      let r = new ta({
        element: n,
        stopEvent: i.stop_event,
        className: "hg-info-box-container"
      });
      return this.addOverlay(r), r;
    });
    /**
     *
     * 删除所有信息弹出框
     */
    v(this, "removeAllPopup", () => {
      const t = this.getOverlays().getArray();
      for (let i = t.length - 1; i >= 0; i--)
        t[i].getOptions().className === "hg-info-box-container" && this.removeOverlay(t[i]);
    });
    /**
     *
     * 新增基站图标
     * @param {number} station_id
     * @param {string} icon
     * @param {number} station_x
     * @param {number} station_y
     * @param {string} text
     * @param {point_feature_style} options
     * @memberof Map
     */
    v(this, "addBaseStation", (t, i, n, r, o, a) => {
      o = o !== void 0 ? o : t.toString();
      let l = this._getPointFeatureStyle(i, o, a), h = [n, r], c = new Js(h);
      return c.setStyle(l), this.all_station[t] = c, this.vector_station_source.addFeature(c), c;
    });
    /**
     *
     * 设置全部定位基站图标大小和文字大小
     * @param {point_feature_style} scale
     * @memberof Map
     */
    v(this, "setAllBaseStationScale", (t) => {
      var i, n, r;
      for (let o in this.all_station)
        t.icon_scale && ((i = this.all_station[o].getStyle().getImage()) == null || i.setScale(t.icon_scale)), t.text_scale && ((n = this.all_station[o].getStyle().getText()) == null || n.setScale(t.text_scale)), t.offset_y && ((r = this.all_station[o].getStyle().getText()) == null || r.setOffsetY(t.offset_y)), this.all_station[o].changed();
      return !0;
    });
    /**
     *
     * 删除一个基站图标
     * @param {number} station_id
     * @memberof Map
     */
    v(this, "removeOneBaseStation", (t) => this.all_station[t] ? (this.vector_station_source.removeFeature(this.all_station[t]), !0) : (console.error("没有该基站的信息，需要先添加基站"), !1));
    /**
     *
     * 删除所有基站图标
     * @memberof Map
     */
    v(this, "removeAllBaseStation", () => (this.all_station = {}, this.vector_station_source.clear(), !0));
    /**
     *
     * 隐藏所有基站图标
     * @memberof Map
     */
    v(this, "hideAllBaseStation", () => (this.vector_station_layer.setVisible(!1), !0));
    /**
     *
     * 显示所有基站图标
     * @memberof Map
     */
    v(this, "showAllBaseStation", () => (this.vector_station_layer.setVisible(!0), !0));
    /**
     *
     * 新增区域
     * @param {[]} point_array
     * @param {number} id
     * @param {string} text
     * @param {string} color
     * @param {polygon_feature_style} options
     * @memberof Map
     */
    v(this, "addZone", (t, i, n, r, o) => {
      r = r || "rgba(52, 64, 255, 0.5)";
      let a = new se({
        fill: new N({
          color: r
        }),
        stroke: new K({
          color: "#5B7397",
          width: 1
        }),
        text: new De({
          textAlign: "center",
          font: "500 16px Noto Sans CJK SC Regular",
          text: n,
          fill: new N({ color: "#fff" }),
          stroke: new K({
            color: "#000",
            width: 2
          })
        })
      });
      o && o.font && a.getText().setFont(o.font), o && o.text_color && a.getText().setFill(new N({ color: o.text_color })), o && o.text_scale && a.getText().setScale(o.text_scale), o && o.text_background_color && (a.getText().setBackgroundFill(new N({ color: o.text_background_color })), a.getText().setPadding([6, 8, 4, 10])), o && o.text_background_border_color && (a.getText().setBackgroundStroke(new K({ color: o.text_background_border_color })), a.getText().setPadding([6, 8, 4, 10])), o && o.text_align && a.getText().setTextAlign(o.text_align), o && o.overflow && a.getText().setOverflow(o.overflow), a.setZIndex(o == null ? void 0 : o.z_index);
      let l = new pu(t);
      return l.origin_z_index = o == null ? void 0 : o.z_index, l.setStyle(a), this.all_area[i] = l, this.vector_area_source.addFeature(l), l;
    });
    v(this, "setZoneHover", (t) => {
      if (t && this.all_area[t] && !this.all_area[t].zone_checked) {
        const i = this.all_area[t].getStyle();
        i.getStroke().setColor("#00FFFE"), i.getStroke().setWidth(2), this.all_area[t].changed();
      }
    });
    v(this, "setZoneChecked", (t) => {
      if (t && this.all_area[t]) {
        this.all_area[t].zone_checked = !0;
        const i = this.all_area[t].getStyle();
        i.getStroke().setColor("#00FFFE"), i.getStroke().setWidth(2), i.getText().setFill(new N({ color: "#15F9F8" })), i.setZIndex(100), this.all_area[t].changed();
      }
      return this.all_area[t];
    });
    v(this, "cancelZoneHandleStatus", (t) => {
      for (let i in this.all_area)
        if (t && !this.all_area[i].zone_checked || !t) {
          let n = this.all_area[i].getStyle();
          n.getStroke().setColor("#5B7397"), n.getStroke().setWidth(1), n.getText().setFill(new N({ color: "#fff" })), n.setZIndex(this.all_area[i].origin_z_index), this.all_area[i].zone_checked = !1, this.all_area[i].changed();
        }
    });
    v(this, "clearZoneHandleActive", () => {
      var t, i;
      for (let n in this.all_area)
        if (this.all_area[n].zone_checked) {
          let r = this.all_area[n].getStyle();
          r.length && (r = r[0]);
          let o = new se({
            fill: r.getFill(),
            stroke: new K({
              color: "#00FFFE",
              width: 2
            }),
            text: r.getText()
          });
          o.getText().setFill(new N({ color: "#15F9F8" })), this.all_area[n].setStyle(o), this.all_area[n].changed();
        }
      (i = (t = this.vector_draw_source) == null ? void 0 : t.getFeatures()) == null || i.forEach((n) => {
        var r, o;
        if (n.feature_checked) {
          const a = n.getStyle();
          (r = a == null ? void 0 : a.getStroke()) == null || r.setColor("#5B7397"), (o = a == null ? void 0 : a.getStroke()) == null || o.setWidth(1), n.changed();
        }
      });
    });
    /**
     *
     * 获得是否已经添加该区域
     * @param {number} id
     * @memberof Map
     */
    v(this, "getZoneStatus", (t) => {
      if (t !== void 0)
        return isNaN(t) ? (console.error("错误的区域ID"), !1) : !!this.all_area[t];
      {
        let i = [];
        for (let n in this.all_area)
          i.push(parseInt(n));
        return i;
      }
    });
    /**
     *
     * 设置区域颜色
     * @param {number} id
     * @param {string} color
     * @memberof Map
     */
    v(this, "setZoneColor", (t, i) => this.all_area[t] ? (this.all_area[t].getStyle().getFill().setColor(i), this.all_area[t].changed(), !0) : (console.error("没有该区域的信息，需要先添加区域"), !1));
    /**
     *
     * 设置区域文字
     * @param {number} id
     * @param {string} text
     * @param {polygon_feature_style} options
     * @memberof Map
     */
    v(this, "setZoneText", (t, i, n) => {
      if (this.all_area[t]) {
        const r = this.all_area[t].getStyle();
        return i && r.getText().setText(i), n.font && r.getText().setFont(n.font), n.text_color && r.getText().setFill(new N({ color: n.text_color })), n.text_scale && r.getText().setScale(n.text_scale), n.text_background_color && (r.getText().setBackgroundFill(new N({ color: n.text_background_color })), r.getText().setPadding([0, 5, 0, 5])), n.text_background_border_color && (r.getText().setBackgroundStroke(new K({ color: n.text_background_border_color })), r.getText().setPadding([0, 5, 0, 5])), n.text_align && r.getText().setTextAlign(n.text_align), n.overflow && r.getText().setOverflow(n.overflow), this.all_area[t].changed(), !0;
      } else
        return console.error("没有该区域的信息，需要先添加区域"), !1;
    });
    /**
     *
     * 设置全部区域文字参数
     * @param {polygon_feature_style} options
     * @memberof Map
     */
    v(this, "setAllZoneTextPara", (t) => {
      for (let i in this.all_area) {
        const n = this.all_area[i].getStyle();
        t.font && n.getText().setFont(t.font), t.text_color && n.getText().setFill(new N({ color: t.text_color })), t.text_scale && n.getText().setScale(t.text_scale), t.text_background_color && (n.getText().setBackgroundFill(new N({ color: t.text_background_color })), n.getText().setPadding([0, 5, 0, 5])), t.text_background_border_color && (n.getText().setBackgroundStroke(new K({ color: t.text_background_border_color })), n.getText().setPadding([0, 5, 0, 5])), t.text_align && n.getText().setTextAlign(t.text_align), t.overflow && n.getText().setOverflow(t.overflow), this.all_area[i].changed();
      }
      return !0;
    });
    /**
     *
     * 删除一个区域
     * @param {number} id
     * @memberof Map
     */
    v(this, "removeOneZone", (t) => this.all_area[t] ? (this.vector_area_source.removeFeature(this.all_area[t]), delete this.all_area[t], !0) : (console.error("没有该区域的信息，需要先添加区域"), !1));
    /**
     *
     * 删除所有区域
     * @memberof Map
     */
    v(this, "removeAllZone", () => (this.all_area = [], this.vector_area_source.clear(), !0));
    /**
     *
     * 隐藏所有区域
     * @memberof Map
     */
    v(this, "hideAllZone", () => (this.vector_area_layer.setVisible(!1), !0));
    /**
     *
     * 显示所有区域
     * @memberof Map
     */
    v(this, "showAllZone", () => (this.vector_area_layer.setVisible(!0), !0));
    /**
     *
     * 添加一个自定义元素
     * @param {Feature<any>} feature
     * @memberof Map
     */
    v(this, "addFeature", (t) => (this.vector_draw_source.addFeature(t), !0));
    /**
     *
     * 删除一个自定义元素
     * @param {Feature<any>} feature
     * @memberof Map
     */
    v(this, "removeFeature", (t) => (this.vector_draw_source.removeFeature(t), !0));
    /**
     *
     * 删除所有自定义元素
     * @memberof Map
     */
    v(this, "removeAllFeature", () => (this.vector_draw_source.clear(), !0));
    v(this, "setAllFeatureScale", (t, i) => {
      var n;
      return (n = this.vector_draw_source.getFeatures()) == null || n.forEach((r) => {
        var o, a, l;
        r.type === t && (i.icon_scale && ((o = r.getStyle().getImage()) == null || o.setScale(i.icon_scale)), i.text_scale && ((a = r.getStyle().getText()) == null || a.setScale(i.text_scale)), i.offset_y && ((l = r.getStyle().getText()) == null || l.setOffsetY(i.offset_y)), r.changed());
      }), !0;
    });
    /**
     *
     * 所有自定义元素的显示隐藏
     * @memberof Map
     */
    v(this, "setAllFeatureVisible", (t) => {
      this.vector_draw_layer.setVisible(t);
    });
    /**
     *
     * 添加一个热力图点
     * @param {number} x
     * @param {number} y
     * @memberof Map
     */
    v(this, "addHeatMapPoint", (t, i) => {
      let n = new Js([t, i]);
      return n.set("weight", 0.5), this.heat_map_source.addFeature(n), n;
    });
    v(this, "showHeatMapPoint", () => {
      this.show_heat_point = !0, this.updateHeatMapPoint();
    });
    v(this, "updateHeatMapPoint", () => {
      var t;
      if (this.heat_map_source.clear(), this.show_heat_point) {
        const i = (t = this.vector_person_source.getFeatures()) == null ? void 0 : t.map((n) => {
          const r = new $({
            geometry: n.getGeometry()
          });
          return r.set("weight", 0.5), r.changed(), r;
        });
        this.heat_map_source.addFeatures(i);
      }
    });
    v(this, "hideHeatMapPoint", () => {
      this.show_heat_point = !1, this.heat_map_source.clear();
    });
    /**
     *
     * 获得当前缩放比
     * @memberof Map
     */
    v(this, "getZoom", () => this.getView().getZoom());
    /**
     *
     * 获得最大缩放比
     * @memberof Map
     */
    v(this, "getMaxZoom", () => this.getView().getMaxZoom());
    /**
     *
     * 获得当前缩放比
     * @memberof Map
     */
    v(this, "getMinZoom", () => this.getView().getMinZoom());
    /**
     *
     * 获得当前分辨率
     * @memberof Map
     */
    v(this, "getResolution", () => this.getView().getResolution());
    /**
     *
     * 根据缩放比获得当前分辨率
     * @memberof Map
     */
    v(this, "getResolutionForZoom", (t) => this.getView().getResolutionForZoom(t));
    /**
     *
     * 根据分辨率获得当前缩放比
     * @memberof Map
     */
    v(this, "getZoomForResolution", (t) => this.getView().getZoomForResolution(t));
    /**
     *
     * 设置当前缩放比
     * @param {number} zoom
     * @memberof Map
     */
    v(this, "setZoom", (t) => (this.getView().setZoom(+t), !0));
    /**
     *
     * 设置最大缩放比
     * @param {number} zoom
     * @memberof Map
     */
    v(this, "setMaxZoom", (t) => (this.getView().setMaxZoom(+t), !0));
    /**
     *
     * 设置最小缩放比
     * @param {number} zoom
     * @memberof Map
     */
    v(this, "setMinZoom", (t) => (this.getView().setMinZoom(+t), !0));
    /**
     *
     * 获得当前中心点
     * @memberof Map
     */
    v(this, "getCenter", () => this.getView().getCenter());
    /**
     *
     * 设置当前中心点
     * @param {number} x
     * @param {number} y
     * @memberof Map
     */
    v(this, "setCenter", (t, i) => (this.getView().setCenter([t, i]), !0));
    v(this, "updateMeasureNotifyLabel", (t) => {
      this.measure_notify_element && (this.measure_notify_element.style.top = `${t.offsetY - 25}px`, this.measure_notify_element.style.left = `${t.offsetX + 10}px`);
    });
    /**
     *
     * 添加绘制工具
     * @param {any} type 工具类型
     * @param {*} options 可选配置参数
     * @memberof Map
     */
    v(this, "addControlMeasure", (t, i) => {
      var g, _;
      if (this.measure_control)
        return console.error("已存在测量工具，请先移除已有的测量工具"), !1;
      t = t == "area" ? "Polygon" : "LineString";
      let n, r, o, a, l, h = new _n({
        source: this.vector_measure_source,
        type: t,
        style: new se({
          fill: new N({
            color: "rgba(255, 255, 255, 0.2)"
          }),
          stroke: new K({
            color: "rgba(0, 0, 0, 0.5)",
            lineDash: [10, 10],
            width: 2
          }),
          image: new qi({
            radius: 5,
            stroke: new K({
              color: "rgba(0, 0, 0, 0.7)"
            }),
            fill: new N({
              color: "rgba(255, 255, 255, 0.2)"
            })
          })
        })
      });
      this.measure_control = h, this.addInteraction(h);
      let c = this._createMeasureTooltip();
      r = c.dom, o = c.measureOverlay;
      let u = this._createMeasureTooltip();
      a = u.dom, l = u.measureOverlay;
      let d = [], f;
      return this.measure_notify_element || (this.measure_notify_element = this.createMeasureNotifyLabel(), (_ = (g = this.getTargetElement()) == null ? void 0 : g.querySelector(".ol-overlaycontainer-stopevent")) == null || _.appendChild(this.measure_notify_element)), this.getTargetElement().addEventListener("mousemove", this.updateMeasureNotifyLabel), h.on("drawstart", (m) => {
        n = m.feature;
        let p = m.coordinate;
        a.innerHTML = Rh.measure_start_point, l.setPosition(n.getGeometry().getFirstCoordinate()), f = n.getGeometry().on("change", (x) => {
          let y = x.target, E;
          if (y instanceof We)
            E = Fx(y), p = y.getInteriorPoint().getCoordinates();
          else if (y instanceof qe && (E = bx(y, this.now_map_type), p = y.getLastCoordinate(), y.old_getCoordinates_length == null && (y.old_getCoordinates_length = 2), y.old_getCoordinates_length < y.getCoordinates().length)) {
            y.old_getCoordinates_length = y.getCoordinates().length, r.className = "hg_tooltip hg_tooltip_static_drawing", o.setOffset([0, -7]), l.setOffset([0, -7]), d.push(r), r = null;
            let C = this._createMeasureTooltip();
            r = C.dom, o = C.measureOverlay;
          }
          r.innerHTML = E, o.setPosition(p);
        }), this.measure_notify_element && (this.measure_notify_element.innerHTML = "点击继续，双击结束测量");
      }), h.on("drawend", (m) => {
        if (m.feature.getGeometry() instanceof We) {
          r.className = "hg_tooltip hg_tooltip_static", o.setOffset([0, -7]), l.setOffset([0, -7]), r = null;
          let x = this._createMeasureTooltip();
          r = x.dom, o = x.measureOverlay;
        }
        for (let x in d)
          d[x].className = "hg_tooltip hg_tooltip_static";
        a.className = "hg_tooltip hg_tooltip_static", n = null, a = null;
        let p = this._createMeasureTooltip();
        a = p.dom, l = p.measureOverlay, aa(f), this.measure_notify_element && (this.measure_notify_element.innerHTML = "点击开始绘制"), i != null && i.drawend && (i == null || i.drawend(m));
      }), !0;
    });
    /**
     *
     * 删除绘制工具
     * @memberof Map
     */
    v(this, "removeControlMeasure", () => {
      let t = document.getElementsByClassName("hg_tooltip_measure");
      for (; t.length > 0; )
        t[0].parentNode.removeChild(t[0]);
      let i = document.getElementsByClassName("hg_tooltip_static_drawing");
      for (; i.length > 0; )
        i[0].parentNode.removeChild(i[0]);
      return this.measure_control && (this.removeInteraction(this.measure_control), this.measure_control = void 0), this.getTargetElement().removeEventListener("mousemove", this.updateMeasureNotifyLabel), this.measure_notify_element && this.measure_notify_element.remove(), this.measure_notify_element = void 0, !0;
    });
    /**
     *
     * 清除已有绘制元素
     * @memberof Map
     */
    v(this, "clearMeasureFeature", () => {
      this.vector_measure_source.clear();
      let t = document.getElementsByClassName("hg_tooltip_static");
      for (; t.length > 0; )
        t[0].parentNode.removeChild(t[0]);
      return !0;
    });
    v(this, "setMapTarget", (t) => {
      const i = document.getElementById(t);
      this.setTarget(i);
    });
    v(this, "getMapTarget", () => this.getTarget());
    v(this, "getGeometryCenter", (t) => {
      const i = t.getExtent();
      return Ne(i);
    });
    /**
     *
     * 销毁地图实例
     * @memberof Map
     */
    v(this, "destroy", () => {
      var o, a;
      this.reset(), (o = this.layer_map.getSource()) == null || o.clear(), (a = this.layer_map.getRenderer()) == null || a.dispose(), this.layer_map.setSource(null), this.vector_person_layer.setSource(void 0), this.removeLayer(this.layer_map), this.un("postcompose", this._handlePersonAnimation), document.removeEventListener("visibilitychange", this._handleVisibilityChange), document.removeEventListener("pause", this._handleAppPause), document.removeEventListener("resume", this._handleAppResume), this.un("moveend", this._handleMoveEnd);
      const t = this.getControls().getArray(), i = this.getInteractions().getArray(), n = this.getLayers().getArray(), r = this.getOverlays().getArray();
      for (let l = t.length - 1; l >= 0; l--)
        this.removeControl(t[l]);
      for (let l = i.length - 1; l >= 0; l--)
        this.removeInteraction(i[l]);
      for (let l = n.length - 1; l >= 0; l--) {
        const h = n[l].getSource();
        h && h.clear && h.clear(), this.removeLayer(n[l]);
      }
      for (let l = r.length - 1; l >= 0; l--)
        this.removeOverlay(r[l]);
      return this.setTarget(), !0;
    });
    if (this._initVars(), Rt = t.url, this.now_map_type = t.type, Rh = U0(t.lang), (r = (n = this.getTargetElement()) == null ? void 0 : n.querySelector(".ol-zoom-in")) == null || r.removeAttribute("title"), (a = (o = this.getTargetElement()) == null ? void 0 : o.querySelector(".ol-zoom-out")) == null || a.removeAttribute("title"), this._modify_instance = new fx(this), this._translate_instance = new Ex(this), this._scale_instance = new xx(this), this._rotate_instance = new vx(this), !document.getElementById(t.dom)) {
      console.error("缺少必传参数dom");
      return;
    }
    if (!t.type) {
      console.error("缺少必传参数type");
      return;
    }
    if (t.type !== "baidu" && !t.url) {
      console.error("缺少必传参数url");
      return;
    }
    if (t.type === "image" && !t.extend) {
      console.error("缺少必传参数extend");
      return;
    }
    if (this._getMapLayer(t), this._getPersonLayer(), this._getTrackLayer(), this._getBaseStationLayer(), this._getAreaLayer(), this._getDrawLayer(), this._getHeatMapLayer(), this._getMeasureLayer(), this.getLayers().insertAt(0, this.layer_map), t.type === "earth" && this.addLayer(this.label_layer), this.addLayer(this.vector_area_layer), this.addLayer(this.vector_track_layer), this.addLayer(this.vector_station_layer), this.addLayer(this.vector_draw_layer), this.addLayer(this.vector_measure_layer), this.addLayer(this.heat_map_layer), this.addLayer(this.vector_person_layer), this.now_zoom = this.getView().getZoom(), this.animation_enable = !!t.animation_enable, this.cache_animation_enable = !!t.animation_enable, this.map_stroke_color = t.map_stroke_color || "rgba(52, 0, 0, 0.5)", this.animation_cache_time = t.animation_cache_time || 1, this.animation_speed_point = t.animation_speed_point || this.animation_speed_point, this.animation_delay_time_point = t.animation_delay_time_point || this.animation_delay_time_point, this.animation_delay_time = t.animation_delay_time || this.animation_delay_time, this._building_extent = t.building_extent, this._mouseRightRotation(), this.on("postrender", this._handlePersonAnimation), t.show_little_map) {
      const l = this.getResolutionForZoom(t.little_map_zoom || 0);
      this.overviewMapControl = new hx({
        className: "ol-overviewmap ol-custom-overviewmap",
        layers: [this.layer_little_map, this.vector_person_layer_little],
        collapsed: !1,
        view: new Pe({
          resolutions: [l],
          showFullExtent: !0
        })
      }), this.addControl(this.overviewMapControl);
    }
    document.addEventListener("visibilitychange", this._handleVisibilityChange), document.addEventListener("pause", this._handleAppPause), document.addEventListener("resume", this._handleAppResume), this.on("moveend", this._handleMoveEnd);
  }
  getSelectedFeatures() {
    var i, n;
    const t = [];
    for (let r in this.all_area)
      this.all_area[r].zone_checked && t.push(this.all_area[r]);
    return (n = (i = this.vector_draw_source) == null ? void 0 : i.getFeatures()) == null || n.forEach((r) => {
      r.feature_checked && t.push(r);
    }), new ce(t);
  }
  setModifyInteractionActive(t) {
    var i;
    this.removeInteraction(this._modify_instance), t && this.addInteraction(this._modify_instance), (i = this._modify_instance) == null || i.setActive(t);
  }
  setTranslateInteractionActive(t) {
    var i, n;
    this.removeInteraction(this._translate_instance), t && this.addInteraction(this._translate_instance), (i = this._translate_instance) == null || i.setActive(t), (n = this._translate_instance) == null || n.watchActive();
  }
  setScaleInteractionActive(t) {
    var i;
    this.removeInteraction(this._scale_instance), t && this.addInteraction(this._scale_instance), (i = this._scale_instance) == null || i.setActive(t);
  }
  setRotateInteractionActive(t) {
    var i, n;
    this.removeInteraction(this._rotate_instance), t && (this.addInteraction(this._rotate_instance), this._rotate_instance.on("rotating", () => {
      this._rotate_instance._setHandStyle();
    })), (i = this._rotate_instance) == null || i.setActive(t), (n = this._rotate_instance) == null || n.watchActive(t);
  }
  static setModifyStyle(t, i) {
    if (i) {
      const n = t.getStyle();
      n.setStroke(new K({ color: "#09F", width: 2 })), t.setStyle([
        n,
        new se({
          image: new qi({
            radius: 4,
            fill: new N({ color: [243, 246, 251] }),
            stroke: new K({ color: [162, 178, 194] })
          }),
          geometry(r) {
            const a = r.getGeometry().getCoordinates();
            return new gs(a[0]);
          }
        })
      ]);
    }
  }
  createMeasureNotifyLabel() {
    const t = document.createElement("p");
    return t.innerHTML = "点击开始绘制", t.classList.add("measure-tool-notify"), t;
  }
}
function Fx(s) {
  let e = Wh(s);
  return Math.round(e * 100) / 100 + " m<sup>2</sup>";
}
function bx(s, e) {
  let t = e === "baidu" ? Xh(s) : s.getLength();
  return Math.round(t * 100) / 100 + " m";
}
const oa = Ax;
class Px extends rx {
  constructor() {
    super({ className: "hg-full-screen" });
  }
}
class Mx extends ax {
  constructor(e) {
    super({
      className: "hg_mouse_position",
      coordinateFormat: function(t) {
        let i = t ? t[0].toFixed(2) : "", n = t ? t[1].toFixed(2) : "";
        return e ? `${i},${n}` : "X：" + i + "，Y：" + n;
      }
    });
  }
}
class Ox extends dx {
  constructor(e) {
    super({
      className: "hg_scale_line",
      minWidth: e
    });
  }
}
class Dx extends _n {
  constructor(e) {
    const t = e ? e.max_point : void 0;
    super({
      maxPoints: t,
      type: "LineString"
    });
  }
}
class kx extends _n {
  constructor() {
    super({
      geometryFunction: V0(),
      type: "Circle"
    });
  }
}
class Nx extends _n {
  constructor() {
    super({
      type: "Circle"
    });
  }
}
class Gx extends _n {
  constructor(e) {
    e = e || 10, super({
      geometryFunction: Y0(e),
      type: "Circle"
    });
  }
}
class Ux extends _n {
  constructor() {
    super({
      type: "Polygon"
    });
  }
}
class zx extends ex {
  constructor() {
    super({
      style: null
    });
  }
}
class Bx extends Iu {
  constructor(e) {
    super({
      features: e
    });
  }
}
class Xx extends Au {
  constructor(e, t) {
    if (e === void 0)
      throw new Error("使用HG2DMap.draw.translate必须指定要修改的元素");
    super({
      features: e,
      layers: t
    });
  }
}
class Wx extends yc {
  constructor() {
    super({
      condition: uc
    });
  }
}
function Yx(s) {
  for (let e = 0; e + 1 < s.length; e++) {
    let t = e + 2;
    for (t; t < s.length; t++)
      if (t + 1 == s.length) {
        if (Ih(s[e], s[e + 1], s[t], s[0]))
          return !0;
      } else if (Ih(s[e], s[e + 1], s[t], s[t + 1]))
        return !0;
  }
  return !1;
}
function Ih(s, e, t, i) {
  let n = 0, r = 0, o = 0, a = 0;
  return n = (e[0] - s[0]) * (i[1] - s[1]) - (e[1] - s[1]) * (i[0] - s[0]), r = (e[0] - s[0]) * (t[1] - s[1]) - (e[1] - s[1]) * (t[0] - s[0]), !(n * r >= 0 || (o = (i[0] - t[0]) * (e[1] - t[1]) - (i[1] - t[1]) * (e[0] - t[0]), a = (i[0] - t[0]) * (s[1] - t[1]) - (i[1] - t[1]) * (s[0] - t[0]), o * a >= 0));
}
const sE = {
  point: Js,
  line: jy,
  polygon: pu,
  circle: Hy
}, rE = {
  full_screen: Px,
  mouse_position: Mx,
  scale_line: Ox
}, oE = {
  line: Dx,
  rectangle: kx,
  circle: Nx,
  regular_polygon: Gx,
  polygon: Ux,
  select: zx,
  modify: Bx,
  translate: Xx,
  drag_rotate: Wx,
  isSelfIntersection: Yx
};
oa.version = "1.2.4";
export {
  rE as control,
  oE as draw,
  sE as feature,
  oa as map,
  Lx as map_type,
  Pe as view
};
//# sourceMappingURL=HG2DMap.mjs.map
