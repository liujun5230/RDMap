var Bf = Object.defineProperty;
var Uf = (o, e, t) => e in o ? Bf(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t;
var k = (o, e, t) => Uf(o, typeof e != "symbol" ? e + "" : e, t);
var Rn = function() {
  var o = 0, e = document.createElement("div");
  e.style.cssText = "position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000", e.addEventListener("click", function(h) {
    h.preventDefault(), i(++o % e.children.length);
  }, !1);
  function t(h) {
    return e.appendChild(h.dom), h;
  }
  function i(h) {
    for (var u = 0; u < e.children.length; u++)
      e.children[u].style.display = u === h ? "block" : "none";
    o = h;
  }
  var n = (performance || Date).now(), s = n, r = 0, a = t(new Rn.Panel("FPS", "#0ff", "#002")), l = t(new Rn.Panel("MS", "#0f0", "#020"));
  if (self.performance && self.performance.memory)
    var c = t(new Rn.Panel("MB", "#f08", "#201"));
  return i(0), {
    REVISION: 16,
    dom: e,
    addPanel: t,
    showPanel: i,
    begin: function() {
      n = (performance || Date).now();
    },
    end: function() {
      r++;
      var h = (performance || Date).now();
      if (l.update(h - n, 200), h >= s + 1e3 && (a.update(r * 1e3 / (h - s), 100), s = h, r = 0, c)) {
        var u = performance.memory;
        c.update(u.usedJSHeapSize / 1048576, u.jsHeapSizeLimit / 1048576);
      }
      return h;
    },
    update: function() {
      n = this.end();
    },
    // Backwards Compatibility
    domElement: e,
    setMode: i
  };
};
Rn.Panel = function(o, e, t) {
  var i = 1 / 0, n = 0, s = Math.round, r = s(window.devicePixelRatio || 1), a = 80 * r, l = 48 * r, c = 3 * r, h = 2 * r, u = 3 * r, d = 15 * r, f = 74 * r, m = 30 * r, _ = document.createElement("canvas");
  _.width = a, _.height = l, _.style.cssText = "width:80px;height:48px";
  var p = _.getContext("2d");
  return p.font = "bold " + 9 * r + "px Helvetica,Arial,sans-serif", p.textBaseline = "top", p.fillStyle = t, p.fillRect(0, 0, a, l), p.fillStyle = e, p.fillText(o, c, h), p.fillRect(u, d, f, m), p.fillStyle = t, p.globalAlpha = 0.9, p.fillRect(u, d, f, m), {
    dom: _,
    update: function(g, x) {
      i = Math.min(i, g), n = Math.max(n, g), p.fillStyle = t, p.globalAlpha = 1, p.fillRect(0, 0, a, d), p.fillStyle = e, p.fillText(s(g) + " " + o + " (" + s(i) + "-" + s(n) + ")", c, h), p.drawImage(_, u + r, d, f - r, m, u, d, f - r, m), p.fillRect(u + f - r, d, r, m), p.fillStyle = t, p.globalAlpha = 0.9, p.fillRect(u + f - r, d, r, s((1 - g / x) * m));
    }
  };
};
class Vf {
  constructor() {
    k(this, "stats");
    // 平均帧生成时间面板
    k(this, "avgPanel");
    // 平均帧率面板
    k(this, "avgFpsPanel");
    k(this, "totalFrameTime", 0);
    k(this, "lastFrameTime", null);
    k(this, "frameCount", 0);
    k(this, "maxFrameCount", 360);
    // 保持最近1000帧的平均值
    k(this, "active", !1);
    this.stats = new Rn(), this.avgPanel = new Rn.Panel("A-MS", "#ff8", "#221"), this.avgFpsPanel = new Rn.Panel("A-FPS", "#8ff", "#221"), this.stats.addPanel(this.avgPanel), this.stats.addPanel(this.avgFpsPanel), this.stats.showPanel(0);
  }
  showPanel(e) {
    this.stats.dom.children[e].style.display = "block";
  }
  getActivePanelId() {
    return Array.from(this.stats.dom.children).findIndex((e) => e.style.display === "block");
  }
  update() {
    this.stats.update(), (this.active || this.getActivePanelId() === 3 || this.getActivePanelId() === 4) && (this.active = !0, this.updateAvgPanel());
  }
  updateAvgPanel() {
    const e = (performance || Date).now();
    if (this.lastFrameTime !== null) {
      const t = e - this.lastFrameTime;
      this.totalFrameTime += t, this.frameCount++, this.frameCount > this.maxFrameCount && (this.totalFrameTime = this.totalFrameTime * (this.maxFrameCount - 1) / this.maxFrameCount, this.frameCount = this.maxFrameCount);
      const i = this.totalFrameTime / this.frameCount;
      this.avgPanel.update(i, 50);
      const n = 1e3 / i;
      this.avgFpsPanel.update(n, 120);
    }
    this.lastFrameTime = e;
  }
  get dom() {
    return this.stats.dom;
  }
}
class sd {
  constructor() {
    k(this, "listeners");
    this.listeners = /* @__PURE__ */ new Map();
  }
  addEventListener(e, t) {
    const i = this.listeners.get(e);
    i === void 0 ? this.listeners.set(e, [t]) : i.push(t);
  }
  removeEventListener(e, t) {
    const i = this.listeners.get(e);
    if (i !== void 0) {
      const n = i.findIndex((s) => s === t);
      n !== -1 && i.splice(n, 1);
    }
  }
  dispatchEvent(e, t) {
    const i = this.listeners.get(e);
    i !== void 0 && i.forEach((n) => n(t));
  }
}
var Ae = /* @__PURE__ */ ((o) => (o.LOADMODELFINISH = "loadmodelfinish", o.LOADMODEL = "loadmodel", o.LOADOVERVIEWMAP = "loadoverviewmap", o.COMPLETE = "complete", o.SCENELOAD = "sceneload", o.SCENEPARSEFINISH = "sceneparsefinish", o.INIT = "init", o.START = "start", o.STOP = "stop", o.KEYDOWN = "keydown", o.KEYUP = "keyup", o.MOUSEDOWN = "mousedown", o.MOUSEUP = "mouseup", o.MOUSEMOVE = "mousemove", o.HOVER = "hover", o.TOUCHSTART = "touchstart", o.TOUCHEND = "touchend", o.TOUCHMOVE = "touchmove", o.UPDATE = "update", o.DBCLICK = "dblclick", o.CLICK = "click", o.MEASUREPOSITION = "measure_position", o.WINDOWCLICK = "windowclick", o.SELECTEDCARD = "selectedcard", o.UNSELECTEDCARD = "unselectedcard", o.CLICKCARD = "clickcard", o.CLICKPOSITION = "clickposition", o.CLICKMODEL = "clickmodel", o.CLICKZONE = "clickzone", o.SELECTEDMODEL = "selectedmodel", o.STOPPATROL = "stoppatrol", o.UPDATECLUSTERCARDLABEL = "updateclustercardlabel", o.UPDATEBASESTATIONLABEL = "updatebasestationlabel", o.UPDATESELECTEDMODELPOSITION = "updateselectedmodelposition", o.POSTRENDER = "postrender", o.DRAW_AREA_FINISH = "drawareafinish", o.SCENERENDERBUILDINGLABELPOSITION = "scenerenderbuildinglabelposition", o.MODELLOADEDFINISH = "modelloadedfinish", o.FRAMERENDERFINISH = "framerenderfinish", o.MAPLOADFAILED = "maploadfailed", o.FOLDBUILDING = "foldbuilding", o.UNFOLDBUILDING = "unfoldbuilding", o.SELECTFLOOR = "selectfloor", o.CAMERAROTATION = "change:rotation", o.JSONFILELOADED = "jsonfileloaded", o.VIEWCHANGE = "viewchange", o.CLICKCYLINDER = "clickcylinder", o))(Ae || {});
/**
 * @license
 * Copyright 2010-2022 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const Ol = "148", an = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 }, on = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 }, Gf = 0, Rc = 1, Hf = 2, rd = 1, Wf = 2, rr = 3, dn = 0, oi = 1, ji = 2, zr = 3, Ti = 0, bs = 1, za = 2, Ic = 3, Dc = 4, Xf = 5, ps = 100, qf = 101, jf = 102, Oc = 103, Nc = 104, Yf = 200, Zf = 201, Jf = 202, Kf = 203, ad = 204, od = 205, $f = 206, Qf = 207, ep = 208, tp = 209, ip = 210, np = 0, sp = 1, rp = 2, pl = 3, ap = 4, op = 5, lp = 6, cp = 7, Ya = 0, hp = 1, up = 2, Wi = 0, dp = 1, fp = 2, pp = 3, mp = 4, _p = 5, Nl = 300, Nn = 301, kn = 302, mr = 303, Fa = 304, Cr = 306, Yi = 1e3, Vt = 1001, _r = 1002, yt = 1003, Ba = 1004, cr = 1005, Ut = 1006, kl = 1007, fn = 1008, zn = 1009, gp = 1010, vp = 1011, ld = 1012, yp = 1013, Ln = 1014, cn = 1015, gr = 1016, xp = 1017, wp = 1018, Ms = 1020, bp = 1021, Mp = 1022, ri = 1023, Sp = 1024, Tp = 1025, In = 1026, Es = 1027, Ap = 1028, Ep = 1029, Cp = 1030, Lp = 1031, Pp = 1033, lo = 33776, co = 33777, ho = 33778, uo = 33779, kc = 35840, zc = 35841, Fc = 35842, Bc = 35843, Rp = 36196, Uc = 37492, Vc = 37496, Gc = 37808, Hc = 37809, Wc = 37810, Xc = 37811, qc = 37812, jc = 37813, Yc = 37814, Zc = 37815, Jc = 37816, Kc = 37817, $c = 37818, Qc = 37819, eh = 37820, th = 37821, ih = 36492, Ip = 2200, Dp = 2201, Op = 2202, vr = 2300, Cs = 2301, fo = 2302, ms = 2400, _s = 2401, Ua = 2402, zl = 2500, Np = 2501, kp = 1, cd = 2, Fn = 3e3, He = 3001, zp = 3200, hd = 3201, Vn = 0, Fp = 1, Si = "srgb", yr = "srgb-linear", po = 7680, Bp = 519, ml = 35044, nh = "300 es", _l = 1035;
class gn {
  addEventListener(e, t) {
    this._listeners === void 0 && (this._listeners = {});
    const i = this._listeners;
    i[e] === void 0 && (i[e] = []), i[e].indexOf(t) === -1 && i[e].push(t);
  }
  hasEventListener(e, t) {
    if (this._listeners === void 0) return !1;
    const i = this._listeners;
    return i[e] !== void 0 && i[e].indexOf(t) !== -1;
  }
  removeEventListener(e, t) {
    if (this._listeners === void 0) return;
    const n = this._listeners[e];
    if (n !== void 0) {
      const s = n.indexOf(t);
      s !== -1 && n.splice(s, 1);
    }
  }
  dispatchEvent(e) {
    if (this._listeners === void 0) return;
    const i = this._listeners[e.type];
    if (i !== void 0) {
      e.target = this;
      const n = i.slice(0);
      for (let s = 0, r = n.length; s < r; s++)
        n[s].call(this, e);
      e.target = null;
    }
  }
}
const Dt = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let sh = 1234567;
const Ss = Math.PI / 180, xr = 180 / Math.PI;
function li() {
  const o = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, i = Math.random() * 4294967295 | 0;
  return (Dt[o & 255] + Dt[o >> 8 & 255] + Dt[o >> 16 & 255] + Dt[o >> 24 & 255] + "-" + Dt[e & 255] + Dt[e >> 8 & 255] + "-" + Dt[e >> 16 & 15 | 64] + Dt[e >> 24 & 255] + "-" + Dt[t & 63 | 128] + Dt[t >> 8 & 255] + "-" + Dt[t >> 16 & 255] + Dt[t >> 24 & 255] + Dt[i & 255] + Dt[i >> 8 & 255] + Dt[i >> 16 & 255] + Dt[i >> 24 & 255]).toLowerCase();
}
function _t(o, e, t) {
  return Math.max(e, Math.min(t, o));
}
function Fl(o, e) {
  return (o % e + e) % e;
}
function Up(o, e, t, i, n) {
  return i + (o - e) * (n - i) / (t - e);
}
function Vp(o, e, t) {
  return o !== e ? (t - o) / (e - o) : 0;
}
function hr(o, e, t) {
  return (1 - t) * o + t * e;
}
function Gp(o, e, t, i) {
  return hr(o, e, 1 - Math.exp(-t * i));
}
function Hp(o, e = 1) {
  return e - Math.abs(Fl(o, e * 2) - e);
}
function Wp(o, e, t) {
  return o <= e ? 0 : o >= t ? 1 : (o = (o - e) / (t - e), o * o * (3 - 2 * o));
}
function Xp(o, e, t) {
  return o <= e ? 0 : o >= t ? 1 : (o = (o - e) / (t - e), o * o * o * (o * (o * 6 - 15) + 10));
}
function qp(o, e) {
  return o + Math.floor(Math.random() * (e - o + 1));
}
function jp(o, e) {
  return o + Math.random() * (e - o);
}
function Yp(o) {
  return o * (0.5 - Math.random());
}
function Zp(o) {
  o !== void 0 && (sh = o);
  let e = sh += 1831565813;
  return e = Math.imul(e ^ e >>> 15, e | 1), e ^= e + Math.imul(e ^ e >>> 7, e | 61), ((e ^ e >>> 14) >>> 0) / 4294967296;
}
function Jp(o) {
  return o * Ss;
}
function Kp(o) {
  return o * xr;
}
function gl(o) {
  return (o & o - 1) === 0 && o !== 0;
}
function ud(o) {
  return Math.pow(2, Math.ceil(Math.log(o) / Math.LN2));
}
function Va(o) {
  return Math.pow(2, Math.floor(Math.log(o) / Math.LN2));
}
function $p(o, e, t, i, n) {
  const s = Math.cos, r = Math.sin, a = s(t / 2), l = r(t / 2), c = s((e + i) / 2), h = r((e + i) / 2), u = s((e - i) / 2), d = r((e - i) / 2), f = s((i - e) / 2), m = r((i - e) / 2);
  switch (n) {
    case "XYX":
      o.set(a * h, l * u, l * d, a * c);
      break;
    case "YZY":
      o.set(l * d, a * h, l * u, a * c);
      break;
    case "ZXZ":
      o.set(l * u, l * d, a * h, a * c);
      break;
    case "XZX":
      o.set(a * h, l * m, l * f, a * c);
      break;
    case "YXY":
      o.set(l * f, a * h, l * m, a * c);
      break;
    case "ZYZ":
      o.set(l * m, l * f, a * h, a * c);
      break;
    default:
      console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + n);
  }
}
function Hi(o, e) {
  switch (e.constructor) {
    case Float32Array:
      return o;
    case Uint16Array:
      return o / 65535;
    case Uint8Array:
      return o / 255;
    case Int16Array:
      return Math.max(o / 32767, -1);
    case Int8Array:
      return Math.max(o / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function ot(o, e) {
  switch (e.constructor) {
    case Float32Array:
      return o;
    case Uint16Array:
      return Math.round(o * 65535);
    case Uint8Array:
      return Math.round(o * 255);
    case Int16Array:
      return Math.round(o * 32767);
    case Int8Array:
      return Math.round(o * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
var Rt = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  DEG2RAD: Ss,
  RAD2DEG: xr,
  generateUUID: li,
  clamp: _t,
  euclideanModulo: Fl,
  mapLinear: Up,
  inverseLerp: Vp,
  lerp: hr,
  damp: Gp,
  pingpong: Hp,
  smoothstep: Wp,
  smootherstep: Xp,
  randInt: qp,
  randFloat: jp,
  randFloatSpread: Yp,
  seededRandom: Zp,
  degToRad: Jp,
  radToDeg: Kp,
  isPowerOfTwo: gl,
  ceilPowerOfTwo: ud,
  floorPowerOfTwo: Va,
  setQuaternionFromProperEuler: $p,
  normalize: ot,
  denormalize: Hi
});
class G {
  constructor(e = 0, t = 0) {
    G.prototype.isVector2 = !0, this.x = e, this.y = t;
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, t) {
    return this.x = e, this.y = t, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this;
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const t = this.x, i = this.y, n = e.elements;
    return this.x = n[0] * t + n[3] * i + n[6], this.y = n[1] * t + n[4] * i + n[7], this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this;
  }
  clampLength(e, t) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  }
  roundToZero() {
    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x, i = this.y - e.y;
    return t * t + i * i;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this;
  }
  lerpVectors(e, t, i) {
    return this.x = e.x + (t.x - e.x) * i, this.y = e.y + (t.y - e.y) * i, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this;
  }
  rotateAround(e, t) {
    const i = Math.cos(t), n = Math.sin(t), s = this.x - e.x, r = this.y - e.y;
    return this.x = s * i - r * n + e.x, this.y = s * n + r * i + e.y, this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class Gt {
  constructor() {
    Gt.prototype.isMatrix3 = !0, this.elements = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ];
  }
  set(e, t, i, n, s, r, a, l, c) {
    const h = this.elements;
    return h[0] = e, h[1] = n, h[2] = a, h[3] = t, h[4] = s, h[5] = l, h[6] = i, h[7] = r, h[8] = c, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ), this;
  }
  copy(e) {
    const t = this.elements, i = e.elements;
    return t[0] = i[0], t[1] = i[1], t[2] = i[2], t[3] = i[3], t[4] = i[4], t[5] = i[5], t[6] = i[6], t[7] = i[7], t[8] = i[8], this;
  }
  extractBasis(e, t, i) {
    return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), i.setFromMatrix3Column(this, 2), this;
  }
  setFromMatrix4(e) {
    const t = e.elements;
    return this.set(
      t[0],
      t[4],
      t[8],
      t[1],
      t[5],
      t[9],
      t[2],
      t[6],
      t[10]
    ), this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const i = e.elements, n = t.elements, s = this.elements, r = i[0], a = i[3], l = i[6], c = i[1], h = i[4], u = i[7], d = i[2], f = i[5], m = i[8], _ = n[0], p = n[3], g = n[6], x = n[1], y = n[4], v = n[7], M = n[2], S = n[5], A = n[8];
    return s[0] = r * _ + a * x + l * M, s[3] = r * p + a * y + l * S, s[6] = r * g + a * v + l * A, s[1] = c * _ + h * x + u * M, s[4] = c * p + h * y + u * S, s[7] = c * g + h * v + u * A, s[2] = d * _ + f * x + m * M, s[5] = d * p + f * y + m * S, s[8] = d * g + f * v + m * A, this;
  }
  multiplyScalar(e) {
    const t = this.elements;
    return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this;
  }
  determinant() {
    const e = this.elements, t = e[0], i = e[1], n = e[2], s = e[3], r = e[4], a = e[5], l = e[6], c = e[7], h = e[8];
    return t * r * h - t * a * c - i * s * h + i * a * l + n * s * c - n * r * l;
  }
  invert() {
    const e = this.elements, t = e[0], i = e[1], n = e[2], s = e[3], r = e[4], a = e[5], l = e[6], c = e[7], h = e[8], u = h * r - a * c, d = a * l - h * s, f = c * s - r * l, m = t * u + i * d + n * f;
    if (m === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const _ = 1 / m;
    return e[0] = u * _, e[1] = (n * c - h * i) * _, e[2] = (a * i - n * r) * _, e[3] = d * _, e[4] = (h * t - n * l) * _, e[5] = (n * s - a * t) * _, e[6] = f * _, e[7] = (i * l - c * t) * _, e[8] = (r * t - i * s) * _, this;
  }
  transpose() {
    let e;
    const t = this.elements;
    return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this;
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const t = this.elements;
    return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this;
  }
  setUvTransform(e, t, i, n, s, r, a) {
    const l = Math.cos(s), c = Math.sin(s);
    return this.set(
      i * l,
      i * c,
      -i * (l * r + c * a) + r + e,
      -n * c,
      n * l,
      -n * (-c * r + l * a) + a + t,
      0,
      0,
      1
    ), this;
  }
  //
  scale(e, t) {
    return this.premultiply(mo.makeScale(e, t)), this;
  }
  rotate(e) {
    return this.premultiply(mo.makeRotation(-e)), this;
  }
  translate(e, t) {
    return this.premultiply(mo.makeTranslation(e, t)), this;
  }
  // for 2D Transforms
  makeTranslation(e, t) {
    return this.set(
      1,
      0,
      e,
      0,
      1,
      t,
      0,
      0,
      1
    ), this;
  }
  makeRotation(e) {
    const t = Math.cos(e), i = Math.sin(e);
    return this.set(
      t,
      -i,
      0,
      i,
      t,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(e, t) {
    return this.set(
      e,
      0,
      0,
      0,
      t,
      0,
      0,
      0,
      1
    ), this;
  }
  //
  equals(e) {
    const t = this.elements, i = e.elements;
    for (let n = 0; n < 9; n++)
      if (t[n] !== i[n]) return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let i = 0; i < 9; i++)
      this.elements[i] = e[i + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const i = this.elements;
    return e[t] = i[0], e[t + 1] = i[1], e[t + 2] = i[2], e[t + 3] = i[3], e[t + 4] = i[4], e[t + 5] = i[5], e[t + 6] = i[6], e[t + 7] = i[7], e[t + 8] = i[8], e;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const mo = /* @__PURE__ */ new Gt();
function dd(o) {
  for (let e = o.length - 1; e >= 0; --e)
    if (o[e] >= 65535) return !0;
  return !1;
}
const Qp = {
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array
};
function gs(o, e) {
  return new Qp[o](e);
}
function wr(o) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", o);
}
function Dn(o) {
  return o < 0.04045 ? o * 0.0773993808 : Math.pow(o * 0.9478672986 + 0.0521327014, 2.4);
}
function Ra(o) {
  return o < 31308e-7 ? o * 12.92 : 1.055 * Math.pow(o, 0.41666) - 0.055;
}
const _o = {
  [Si]: { [yr]: Dn },
  [yr]: { [Si]: Ra }
}, kt = {
  legacyMode: !0,
  get workingColorSpace() {
    return yr;
  },
  set workingColorSpace(o) {
    console.warn("THREE.ColorManagement: .workingColorSpace is readonly.");
  },
  convert: function(o, e, t) {
    if (this.legacyMode || e === t || !e || !t)
      return o;
    if (_o[e] && _o[e][t] !== void 0) {
      const i = _o[e][t];
      return o.r = i(o.r), o.g = i(o.g), o.b = i(o.b), o;
    }
    throw new Error("Unsupported color space conversion.");
  },
  fromWorkingColorSpace: function(o, e) {
    return this.convert(o, this.workingColorSpace, e);
  },
  toWorkingColorSpace: function(o, e) {
    return this.convert(o, e, this.workingColorSpace);
  }
}, fd = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
}, vt = { r: 0, g: 0, b: 0 }, hi = { h: 0, s: 0, l: 0 }, Fr = { h: 0, s: 0, l: 0 };
function go(o, e, t) {
  return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? o + (e - o) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? o + (e - o) * 6 * (2 / 3 - t) : o;
}
function Br(o, e) {
  return e.r = o.r, e.g = o.g, e.b = o.b, e;
}
class de {
  constructor(e, t, i) {
    return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, t === void 0 && i === void 0 ? this.set(e) : this.setRGB(e, t, i);
  }
  set(e) {
    return e && e.isColor ? this.copy(e) : typeof e == "number" ? this.setHex(e) : typeof e == "string" && this.setStyle(e), this;
  }
  setScalar(e) {
    return this.r = e, this.g = e, this.b = e, this;
  }
  setHex(e, t = Si) {
    return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, kt.toWorkingColorSpace(this, t), this;
  }
  setRGB(e, t, i, n = kt.workingColorSpace) {
    return this.r = e, this.g = t, this.b = i, kt.toWorkingColorSpace(this, n), this;
  }
  setHSL(e, t, i, n = kt.workingColorSpace) {
    if (e = Fl(e, 1), t = _t(t, 0, 1), i = _t(i, 0, 1), t === 0)
      this.r = this.g = this.b = i;
    else {
      const s = i <= 0.5 ? i * (1 + t) : i + t - i * t, r = 2 * i - s;
      this.r = go(r, s, e + 1 / 3), this.g = go(r, s, e), this.b = go(r, s, e - 1 / 3);
    }
    return kt.toWorkingColorSpace(this, n), this;
  }
  setStyle(e, t = Si) {
    function i(s) {
      s !== void 0 && parseFloat(s) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.");
    }
    let n;
    if (n = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e)) {
      let s;
      const r = n[1], a = n[2];
      switch (r) {
        case "rgb":
        case "rgba":
          if (s = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
            return this.r = Math.min(255, parseInt(s[1], 10)) / 255, this.g = Math.min(255, parseInt(s[2], 10)) / 255, this.b = Math.min(255, parseInt(s[3], 10)) / 255, kt.toWorkingColorSpace(this, t), i(s[4]), this;
          if (s = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
            return this.r = Math.min(100, parseInt(s[1], 10)) / 100, this.g = Math.min(100, parseInt(s[2], 10)) / 100, this.b = Math.min(100, parseInt(s[3], 10)) / 100, kt.toWorkingColorSpace(this, t), i(s[4]), this;
          break;
        case "hsl":
        case "hsla":
          if (s = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) {
            const l = parseFloat(s[1]) / 360, c = parseFloat(s[2]) / 100, h = parseFloat(s[3]) / 100;
            return i(s[4]), this.setHSL(l, c, h, t);
          }
          break;
      }
    } else if (n = /^\#([A-Fa-f\d]+)$/.exec(e)) {
      const s = n[1], r = s.length;
      if (r === 3)
        return this.r = parseInt(s.charAt(0) + s.charAt(0), 16) / 255, this.g = parseInt(s.charAt(1) + s.charAt(1), 16) / 255, this.b = parseInt(s.charAt(2) + s.charAt(2), 16) / 255, kt.toWorkingColorSpace(this, t), this;
      if (r === 6)
        return this.r = parseInt(s.charAt(0) + s.charAt(1), 16) / 255, this.g = parseInt(s.charAt(2) + s.charAt(3), 16) / 255, this.b = parseInt(s.charAt(4) + s.charAt(5), 16) / 255, kt.toWorkingColorSpace(this, t), this;
    }
    return e && e.length > 0 ? this.setColorName(e, t) : this;
  }
  setColorName(e, t = Si) {
    const i = fd[e.toLowerCase()];
    return i !== void 0 ? this.setHex(i, t) : console.warn("THREE.Color: Unknown color " + e), this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(e) {
    return this.r = e.r, this.g = e.g, this.b = e.b, this;
  }
  copySRGBToLinear(e) {
    return this.r = Dn(e.r), this.g = Dn(e.g), this.b = Dn(e.b), this;
  }
  copyLinearToSRGB(e) {
    return this.r = Ra(e.r), this.g = Ra(e.g), this.b = Ra(e.b), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(e = Si) {
    return kt.fromWorkingColorSpace(Br(this, vt), e), _t(vt.r * 255, 0, 255) << 16 ^ _t(vt.g * 255, 0, 255) << 8 ^ _t(vt.b * 255, 0, 255) << 0;
  }
  getHexString(e = Si) {
    return ("000000" + this.getHex(e).toString(16)).slice(-6);
  }
  getHSL(e, t = kt.workingColorSpace) {
    kt.fromWorkingColorSpace(Br(this, vt), t);
    const i = vt.r, n = vt.g, s = vt.b, r = Math.max(i, n, s), a = Math.min(i, n, s);
    let l, c;
    const h = (a + r) / 2;
    if (a === r)
      l = 0, c = 0;
    else {
      const u = r - a;
      switch (c = h <= 0.5 ? u / (r + a) : u / (2 - r - a), r) {
        case i:
          l = (n - s) / u + (n < s ? 6 : 0);
          break;
        case n:
          l = (s - i) / u + 2;
          break;
        case s:
          l = (i - n) / u + 4;
          break;
      }
      l /= 6;
    }
    return e.h = l, e.s = c, e.l = h, e;
  }
  getRGB(e, t = kt.workingColorSpace) {
    return kt.fromWorkingColorSpace(Br(this, vt), t), e.r = vt.r, e.g = vt.g, e.b = vt.b, e;
  }
  getStyle(e = Si) {
    return kt.fromWorkingColorSpace(Br(this, vt), e), e !== Si ? `color(${e} ${vt.r} ${vt.g} ${vt.b})` : `rgb(${vt.r * 255 | 0},${vt.g * 255 | 0},${vt.b * 255 | 0})`;
  }
  offsetHSL(e, t, i) {
    return this.getHSL(hi), hi.h += e, hi.s += t, hi.l += i, this.setHSL(hi.h, hi.s, hi.l), this;
  }
  add(e) {
    return this.r += e.r, this.g += e.g, this.b += e.b, this;
  }
  addColors(e, t) {
    return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this;
  }
  addScalar(e) {
    return this.r += e, this.g += e, this.b += e, this;
  }
  sub(e) {
    return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this;
  }
  multiply(e) {
    return this.r *= e.r, this.g *= e.g, this.b *= e.b, this;
  }
  multiplyScalar(e) {
    return this.r *= e, this.g *= e, this.b *= e, this;
  }
  lerp(e, t) {
    return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this;
  }
  lerpColors(e, t, i) {
    return this.r = e.r + (t.r - e.r) * i, this.g = e.g + (t.g - e.g) * i, this.b = e.b + (t.b - e.b) * i, this;
  }
  lerpHSL(e, t) {
    this.getHSL(hi), e.getHSL(Fr);
    const i = hr(hi.h, Fr.h, t), n = hr(hi.s, Fr.s, t), s = hr(hi.l, Fr.l, t);
    return this.setHSL(i, n, s), this;
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  fromArray(e, t = 0) {
    return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e;
  }
  fromBufferAttribute(e, t) {
    return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), this;
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
}
de.NAMES = fd;
let Hn;
class pd {
  static getDataURL(e) {
    if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u")
      return e.src;
    let t;
    if (e instanceof HTMLCanvasElement)
      t = e;
    else {
      Hn === void 0 && (Hn = wr("canvas")), Hn.width = e.width, Hn.height = e.height;
      const i = Hn.getContext("2d");
      e instanceof ImageData ? i.putImageData(e, 0, 0) : i.drawImage(e, 0, 0, e.width, e.height), t = Hn;
    }
    return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e), t.toDataURL("image/jpeg", 0.6)) : t.toDataURL("image/png");
  }
  static sRGBToLinear(e) {
    if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
      const t = wr("canvas");
      t.width = e.width, t.height = e.height;
      const i = t.getContext("2d");
      i.drawImage(e, 0, 0, e.width, e.height);
      const n = i.getImageData(0, 0, e.width, e.height), s = n.data;
      for (let r = 0; r < s.length; r++)
        s[r] = Dn(s[r] / 255) * 255;
      return i.putImageData(n, 0, 0), t;
    } else if (e.data) {
      const t = e.data.slice(0);
      for (let i = 0; i < t.length; i++)
        t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[i] = Math.floor(Dn(t[i] / 255) * 255) : t[i] = Dn(t[i]);
      return {
        data: t,
        width: e.width,
        height: e.height
      };
    } else
      return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e;
  }
}
class vs {
  constructor(e = null) {
    this.isSource = !0, this.uuid = li(), this.data = e, this.version = 0;
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.images[this.uuid] !== void 0)
      return e.images[this.uuid];
    const i = {
      uuid: this.uuid,
      url: ""
    }, n = this.data;
    if (n !== null) {
      let s;
      if (Array.isArray(n)) {
        s = [];
        for (let r = 0, a = n.length; r < a; r++)
          n[r].isDataTexture ? s.push(vo(n[r].image)) : s.push(vo(n[r]));
      } else
        s = vo(n);
      i.url = s;
    }
    return t || (e.images[this.uuid] = i), i;
  }
}
function vo(o) {
  return typeof HTMLImageElement < "u" && o instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && o instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && o instanceof ImageBitmap ? pd.getDataURL(o) : o.data ? {
    data: Array.from(o.data),
    width: o.width,
    height: o.height,
    type: o.data.constructor.name
  } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let em = 0;
class dt extends gn {
  constructor(e = dt.DEFAULT_IMAGE, t = dt.DEFAULT_MAPPING, i = Vt, n = Vt, s = Ut, r = fn, a = ri, l = zn, c = dt.DEFAULT_ANISOTROPY, h = Fn) {
    super(), this.isTexture = !0, Object.defineProperty(this, "id", { value: em++ }), this.uuid = li(), this.name = "", this.source = new vs(e), this.mipmaps = [], this.mapping = t, this.wrapS = i, this.wrapT = n, this.magFilter = s, this.minFilter = r, this.anisotropy = c, this.format = a, this.internalFormat = null, this.type = l, this.offset = new G(0, 0), this.repeat = new G(1, 1), this.center = new G(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Gt(), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = h, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.needsPMREMUpdate = !1;
  }
  get image() {
    return this.source.data;
  }
  set image(e) {
    this.source.data = e;
  }
  updateMatrix() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.encoding = e.encoding, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this;
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.textures[this.uuid] !== void 0)
      return e.textures[this.uuid];
    const i = {
      metadata: {
        version: 4.5,
        type: "Texture",
        generator: "Texture.toJSON"
      },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(e).uuid,
      mapping: this.mapping,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      type: this.type,
      encoding: this.encoding,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    };
    return Object.keys(this.userData).length > 0 && (i.userData = this.userData), t || (e.textures[this.uuid] = i), i;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(e) {
    if (this.mapping !== Nl) return e;
    if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1)
      switch (this.wrapS) {
        case Yi:
          e.x = e.x - Math.floor(e.x);
          break;
        case Vt:
          e.x = e.x < 0 ? 0 : 1;
          break;
        case _r:
          Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
          break;
      }
    if (e.y < 0 || e.y > 1)
      switch (this.wrapT) {
        case Yi:
          e.y = e.y - Math.floor(e.y);
          break;
        case Vt:
          e.y = e.y < 0 ? 0 : 1;
          break;
        case _r:
          Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
          break;
      }
    return this.flipY && (e.y = 1 - e.y), e;
  }
  set needsUpdate(e) {
    e === !0 && (this.version++, this.source.needsUpdate = !0);
  }
}
dt.DEFAULT_IMAGE = null;
dt.DEFAULT_MAPPING = Nl;
dt.DEFAULT_ANISOTROPY = 1;
class We {
  constructor(e = 0, t = 0, i = 0, n = 1) {
    We.prototype.isVector4 = !0, this.x = e, this.y = t, this.z = i, this.w = n;
  }
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  set(e, t, i, n) {
    return this.x = e, this.y = t, this.z = i, this.w = n, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this.w = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setW(e) {
    return this.w = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      case 3:
        this.w = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w !== void 0 ? e.w : 1, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this.w += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this;
  }
  applyMatrix4(e) {
    const t = this.x, i = this.y, n = this.z, s = this.w, r = e.elements;
    return this.x = r[0] * t + r[4] * i + r[8] * n + r[12] * s, this.y = r[1] * t + r[5] * i + r[9] * n + r[13] * s, this.z = r[2] * t + r[6] * i + r[10] * n + r[14] * s, this.w = r[3] * t + r[7] * i + r[11] * n + r[15] * s, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    const t = Math.sqrt(1 - e.w * e.w);
    return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this;
  }
  setAxisAngleFromRotationMatrix(e) {
    let t, i, n, s;
    const l = e.elements, c = l[0], h = l[4], u = l[8], d = l[1], f = l[5], m = l[9], _ = l[2], p = l[6], g = l[10];
    if (Math.abs(h - d) < 0.01 && Math.abs(u - _) < 0.01 && Math.abs(m - p) < 0.01) {
      if (Math.abs(h + d) < 0.1 && Math.abs(u + _) < 0.1 && Math.abs(m + p) < 0.1 && Math.abs(c + f + g - 3) < 0.1)
        return this.set(1, 0, 0, 0), this;
      t = Math.PI;
      const y = (c + 1) / 2, v = (f + 1) / 2, M = (g + 1) / 2, S = (h + d) / 4, A = (u + _) / 4, w = (m + p) / 4;
      return y > v && y > M ? y < 0.01 ? (i = 0, n = 0.707106781, s = 0.707106781) : (i = Math.sqrt(y), n = S / i, s = A / i) : v > M ? v < 0.01 ? (i = 0.707106781, n = 0, s = 0.707106781) : (n = Math.sqrt(v), i = S / n, s = w / n) : M < 0.01 ? (i = 0.707106781, n = 0.707106781, s = 0) : (s = Math.sqrt(M), i = A / s, n = w / s), this.set(i, n, s, t), this;
    }
    let x = Math.sqrt((p - m) * (p - m) + (u - _) * (u - _) + (d - h) * (d - h));
    return Math.abs(x) < 1e-3 && (x = 1), this.x = (p - m) / x, this.y = (u - _) / x, this.z = (d - h) / x, this.w = Math.acos((c + f + g - 1) / 2), this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this.w = Math.max(e, Math.min(t, this.w)), this;
  }
  clampLength(e, t) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
  }
  roundToZero() {
    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this;
  }
  lerpVectors(e, t, i) {
    return this.x = e.x + (t.x - e.x) * i, this.y = e.y + (t.y - e.y) * i, this.z = e.z + (t.z - e.z) * i, this.w = e.w + (t.w - e.w) * i, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
class Ot extends gn {
  constructor(e = 1, t = 1, i = {}) {
    super(), this.isWebGLRenderTarget = !0, this.width = e, this.height = t, this.depth = 1, this.scissor = new We(0, 0, e, t), this.scissorTest = !1, this.viewport = new We(0, 0, e, t);
    const n = { width: e, height: t, depth: 1 };
    this.texture = new dt(n, i.mapping, i.wrapS, i.wrapT, i.magFilter, i.minFilter, i.format, i.type, i.anisotropy, i.encoding), this.texture.isRenderTargetTexture = !0, this.texture.flipY = !1, this.texture.generateMipmaps = i.generateMipmaps !== void 0 ? i.generateMipmaps : !1, this.texture.internalFormat = i.internalFormat !== void 0 ? i.internalFormat : null, this.texture.minFilter = i.minFilter !== void 0 ? i.minFilter : Ut, this.depthBuffer = i.depthBuffer !== void 0 ? i.depthBuffer : !0, this.stencilBuffer = i.stencilBuffer !== void 0 ? i.stencilBuffer : !1, this.depthTexture = i.depthTexture !== void 0 ? i.depthTexture : null, this.samples = i.samples !== void 0 ? i.samples : 0;
  }
  setSize(e, t, i = 1) {
    (this.width !== e || this.height !== t || this.depth !== i) && (this.width = e, this.height = t, this.depth = i, this.texture.image.width = e, this.texture.image.height = t, this.texture.image.depth = i, this.dispose()), this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.width = e.width, this.height = e.height, this.depth = e.depth, this.viewport.copy(e.viewport), this.texture = e.texture.clone(), this.texture.isRenderTargetTexture = !0;
    const t = Object.assign({}, e.texture.image);
    return this.texture.source = new vs(t), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class md extends dt {
  constructor(e = null, t = 1, i = 1, n = 1) {
    super(null), this.isDataArrayTexture = !0, this.image = { data: e, width: t, height: i, depth: n }, this.magFilter = yt, this.minFilter = yt, this.wrapR = Vt, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
class tm extends dt {
  constructor(e = null, t = 1, i = 1, n = 1) {
    super(null), this.isData3DTexture = !0, this.image = { data: e, width: t, height: i, depth: n }, this.magFilter = yt, this.minFilter = yt, this.wrapR = Vt, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
class Et {
  constructor(e = 0, t = 0, i = 0, n = 1) {
    this.isQuaternion = !0, this._x = e, this._y = t, this._z = i, this._w = n;
  }
  static slerpFlat(e, t, i, n, s, r, a) {
    let l = i[n + 0], c = i[n + 1], h = i[n + 2], u = i[n + 3];
    const d = s[r + 0], f = s[r + 1], m = s[r + 2], _ = s[r + 3];
    if (a === 0) {
      e[t + 0] = l, e[t + 1] = c, e[t + 2] = h, e[t + 3] = u;
      return;
    }
    if (a === 1) {
      e[t + 0] = d, e[t + 1] = f, e[t + 2] = m, e[t + 3] = _;
      return;
    }
    if (u !== _ || l !== d || c !== f || h !== m) {
      let p = 1 - a;
      const g = l * d + c * f + h * m + u * _, x = g >= 0 ? 1 : -1, y = 1 - g * g;
      if (y > Number.EPSILON) {
        const M = Math.sqrt(y), S = Math.atan2(M, g * x);
        p = Math.sin(p * S) / M, a = Math.sin(a * S) / M;
      }
      const v = a * x;
      if (l = l * p + d * v, c = c * p + f * v, h = h * p + m * v, u = u * p + _ * v, p === 1 - a) {
        const M = 1 / Math.sqrt(l * l + c * c + h * h + u * u);
        l *= M, c *= M, h *= M, u *= M;
      }
    }
    e[t] = l, e[t + 1] = c, e[t + 2] = h, e[t + 3] = u;
  }
  static multiplyQuaternionsFlat(e, t, i, n, s, r) {
    const a = i[n], l = i[n + 1], c = i[n + 2], h = i[n + 3], u = s[r], d = s[r + 1], f = s[r + 2], m = s[r + 3];
    return e[t] = a * m + h * u + l * f - c * d, e[t + 1] = l * m + h * d + c * u - a * f, e[t + 2] = c * m + h * f + a * d - l * u, e[t + 3] = h * m - a * u - l * d - c * f, e;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(e) {
    this._w = e, this._onChangeCallback();
  }
  set(e, t, i, n) {
    return this._x = e, this._y = t, this._z = i, this._w = n, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(e) {
    return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this;
  }
  setFromEuler(e, t) {
    const i = e._x, n = e._y, s = e._z, r = e._order, a = Math.cos, l = Math.sin, c = a(i / 2), h = a(n / 2), u = a(s / 2), d = l(i / 2), f = l(n / 2), m = l(s / 2);
    switch (r) {
      case "XYZ":
        this._x = d * h * u + c * f * m, this._y = c * f * u - d * h * m, this._z = c * h * m + d * f * u, this._w = c * h * u - d * f * m;
        break;
      case "YXZ":
        this._x = d * h * u + c * f * m, this._y = c * f * u - d * h * m, this._z = c * h * m - d * f * u, this._w = c * h * u + d * f * m;
        break;
      case "ZXY":
        this._x = d * h * u - c * f * m, this._y = c * f * u + d * h * m, this._z = c * h * m + d * f * u, this._w = c * h * u - d * f * m;
        break;
      case "ZYX":
        this._x = d * h * u - c * f * m, this._y = c * f * u + d * h * m, this._z = c * h * m - d * f * u, this._w = c * h * u + d * f * m;
        break;
      case "YZX":
        this._x = d * h * u + c * f * m, this._y = c * f * u + d * h * m, this._z = c * h * m - d * f * u, this._w = c * h * u - d * f * m;
        break;
      case "XZY":
        this._x = d * h * u - c * f * m, this._y = c * f * u - d * h * m, this._z = c * h * m + d * f * u, this._w = c * h * u + d * f * m;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + r);
    }
    return t !== !1 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(e, t) {
    const i = t / 2, n = Math.sin(i);
    return this._x = e.x * n, this._y = e.y * n, this._z = e.z * n, this._w = Math.cos(i), this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e) {
    const t = e.elements, i = t[0], n = t[4], s = t[8], r = t[1], a = t[5], l = t[9], c = t[2], h = t[6], u = t[10], d = i + a + u;
    if (d > 0) {
      const f = 0.5 / Math.sqrt(d + 1);
      this._w = 0.25 / f, this._x = (h - l) * f, this._y = (s - c) * f, this._z = (r - n) * f;
    } else if (i > a && i > u) {
      const f = 2 * Math.sqrt(1 + i - a - u);
      this._w = (h - l) / f, this._x = 0.25 * f, this._y = (n + r) / f, this._z = (s + c) / f;
    } else if (a > u) {
      const f = 2 * Math.sqrt(1 + a - i - u);
      this._w = (s - c) / f, this._x = (n + r) / f, this._y = 0.25 * f, this._z = (l + h) / f;
    } else {
      const f = 2 * Math.sqrt(1 + u - i - a);
      this._w = (r - n) / f, this._x = (s + c) / f, this._y = (l + h) / f, this._z = 0.25 * f;
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(e, t) {
    let i = e.dot(t) + 1;
    return i < Number.EPSILON ? (i = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = i) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = i)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = i), this.normalize();
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs(_t(this.dot(e), -1, 1)));
  }
  rotateTowards(e, t) {
    const i = this.angleTo(e);
    if (i === 0) return this;
    const n = Math.min(1, t / i);
    return this.slerp(e, n), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
  }
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let e = this.length();
    return e === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this;
  }
  multiply(e) {
    return this.multiplyQuaternions(this, e);
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  multiplyQuaternions(e, t) {
    const i = e._x, n = e._y, s = e._z, r = e._w, a = t._x, l = t._y, c = t._z, h = t._w;
    return this._x = i * h + r * a + n * c - s * l, this._y = n * h + r * l + s * a - i * c, this._z = s * h + r * c + i * l - n * a, this._w = r * h - i * a - n * l - s * c, this._onChangeCallback(), this;
  }
  slerp(e, t) {
    if (t === 0) return this;
    if (t === 1) return this.copy(e);
    const i = this._x, n = this._y, s = this._z, r = this._w;
    let a = r * e._w + i * e._x + n * e._y + s * e._z;
    if (a < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, a = -a) : this.copy(e), a >= 1)
      return this._w = r, this._x = i, this._y = n, this._z = s, this;
    const l = 1 - a * a;
    if (l <= Number.EPSILON) {
      const f = 1 - t;
      return this._w = f * r + t * this._w, this._x = f * i + t * this._x, this._y = f * n + t * this._y, this._z = f * s + t * this._z, this.normalize(), this._onChangeCallback(), this;
    }
    const c = Math.sqrt(l), h = Math.atan2(c, a), u = Math.sin((1 - t) * h) / c, d = Math.sin(t * h) / c;
    return this._w = r * u + this._w * d, this._x = i * u + this._x * d, this._y = n * u + this._y * d, this._z = s * u + this._z * d, this._onChangeCallback(), this;
  }
  slerpQuaternions(e, t, i) {
    return this.copy(e).slerp(t, i);
  }
  random() {
    const e = Math.random(), t = Math.sqrt(1 - e), i = Math.sqrt(e), n = 2 * Math.PI * Math.random(), s = 2 * Math.PI * Math.random();
    return this.set(
      t * Math.cos(n),
      i * Math.sin(s),
      i * Math.cos(s),
      t * Math.sin(n)
    );
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w;
  }
  fromArray(e, t = 0) {
    return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e;
  }
  fromBufferAttribute(e, t) {
    return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this;
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class b {
  constructor(e = 0, t = 0, i = 0) {
    b.prototype.isVector3 = !0, this.x = e, this.y = t, this.z = i;
  }
  set(e, t, i) {
    return i === void 0 && (i = this.z), this.x = e, this.y = t, this.z = i, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this;
  }
  multiplyVectors(e, t) {
    return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this;
  }
  applyEuler(e) {
    return this.applyQuaternion(rh.setFromEuler(e));
  }
  applyAxisAngle(e, t) {
    return this.applyQuaternion(rh.setFromAxisAngle(e, t));
  }
  applyMatrix3(e) {
    const t = this.x, i = this.y, n = this.z, s = e.elements;
    return this.x = s[0] * t + s[3] * i + s[6] * n, this.y = s[1] * t + s[4] * i + s[7] * n, this.z = s[2] * t + s[5] * i + s[8] * n, this;
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    const t = this.x, i = this.y, n = this.z, s = e.elements, r = 1 / (s[3] * t + s[7] * i + s[11] * n + s[15]);
    return this.x = (s[0] * t + s[4] * i + s[8] * n + s[12]) * r, this.y = (s[1] * t + s[5] * i + s[9] * n + s[13]) * r, this.z = (s[2] * t + s[6] * i + s[10] * n + s[14]) * r, this;
  }
  applyQuaternion(e) {
    const t = this.x, i = this.y, n = this.z, s = e.x, r = e.y, a = e.z, l = e.w, c = l * t + r * n - a * i, h = l * i + a * t - s * n, u = l * n + s * i - r * t, d = -s * t - r * i - a * n;
    return this.x = c * l + d * -s + h * -a - u * -r, this.y = h * l + d * -r + u * -s - c * -a, this.z = u * l + d * -a + c * -r - h * -s, this;
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix);
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld);
  }
  transformDirection(e) {
    const t = this.x, i = this.y, n = this.z, s = e.elements;
    return this.x = s[0] * t + s[4] * i + s[8] * n, this.y = s[1] * t + s[5] * i + s[9] * n, this.z = s[2] * t + s[6] * i + s[10] * n, this.normalize();
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this;
  }
  clampLength(e, t) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
  }
  roundToZero() {
    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  // TODO lengthSquared?
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this;
  }
  lerpVectors(e, t, i) {
    return this.x = e.x + (t.x - e.x) * i, this.y = e.y + (t.y - e.y) * i, this.z = e.z + (t.z - e.z) * i, this;
  }
  cross(e) {
    return this.crossVectors(this, e);
  }
  crossVectors(e, t) {
    const i = e.x, n = e.y, s = e.z, r = t.x, a = t.y, l = t.z;
    return this.x = n * l - s * a, this.y = s * r - i * l, this.z = i * a - n * r, this;
  }
  projectOnVector(e) {
    const t = e.lengthSq();
    if (t === 0) return this.set(0, 0, 0);
    const i = e.dot(this) / t;
    return this.copy(e).multiplyScalar(i);
  }
  projectOnPlane(e) {
    return yo.copy(this).projectOnVector(e), this.sub(yo);
  }
  reflect(e) {
    return this.sub(yo.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const i = this.dot(e) / t;
    return Math.acos(_t(i, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x, i = this.y - e.y, n = this.z - e.z;
    return t * t + i * i + n * n;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z);
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, t, i) {
    const n = Math.sin(t) * e;
    return this.x = n * Math.sin(i), this.y = Math.cos(t) * e, this.z = n * Math.cos(i), this;
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, t, i) {
    return this.x = e * Math.sin(t), this.y = i, this.z = e * Math.cos(t), this;
  }
  setFromMatrixPosition(e) {
    const t = e.elements;
    return this.x = t[12], this.y = t[13], this.z = t[14], this;
  }
  setFromMatrixScale(e) {
    const t = this.setFromMatrixColumn(e, 0).length(), i = this.setFromMatrixColumn(e, 1).length(), n = this.setFromMatrixColumn(e, 2).length();
    return this.x = t, this.y = i, this.z = n, this;
  }
  setFromMatrixColumn(e, t) {
    return this.fromArray(e.elements, t * 4);
  }
  setFromMatrix3Column(e, t) {
    return this.fromArray(e.elements, t * 3);
  }
  setFromEuler(e) {
    return this.x = e._x, this.y = e._y, this.z = e._z, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
  }
  randomDirection() {
    const e = (Math.random() - 0.5) * 2, t = Math.random() * Math.PI * 2, i = Math.sqrt(1 - e ** 2);
    return this.x = i * Math.cos(t), this.y = i * Math.sin(t), this.z = e, this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const yo = /* @__PURE__ */ new b(), rh = /* @__PURE__ */ new Et();
class Ht {
  constructor(e = new b(1 / 0, 1 / 0, 1 / 0), t = new b(-1 / 0, -1 / 0, -1 / 0)) {
    this.isBox3 = !0, this.min = e, this.max = t;
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromArray(e) {
    let t = 1 / 0, i = 1 / 0, n = 1 / 0, s = -1 / 0, r = -1 / 0, a = -1 / 0;
    for (let l = 0, c = e.length; l < c; l += 3) {
      const h = e[l], u = e[l + 1], d = e[l + 2];
      h < t && (t = h), u < i && (i = u), d < n && (n = d), h > s && (s = h), u > r && (r = u), d > a && (a = d);
    }
    return this.min.set(t, i, n), this.max.set(s, r, a), this;
  }
  setFromBufferAttribute(e) {
    let t = 1 / 0, i = 1 / 0, n = 1 / 0, s = -1 / 0, r = -1 / 0, a = -1 / 0;
    for (let l = 0, c = e.count; l < c; l++) {
      const h = e.getX(l), u = e.getY(l), d = e.getZ(l);
      h < t && (t = h), u < i && (i = u), d < n && (n = d), h > s && (s = h), u > r && (r = u), d > a && (a = d);
    }
    return this.min.set(t, i, n), this.max.set(s, r, a), this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, i = e.length; t < i; t++)
      this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const i = Mn.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(i), this.max.copy(e).add(i), this;
  }
  setFromObject(e, t = !1) {
    return this.makeEmpty(), this.expandByObject(e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  getCenter(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  expandByObject(e, t = !1) {
    e.updateWorldMatrix(!1, !1);
    const i = e.geometry;
    if (i !== void 0)
      if (t && i.attributes != null && i.attributes.position !== void 0) {
        const s = i.attributes.position;
        for (let r = 0, a = s.count; r < a; r++)
          Mn.fromBufferAttribute(s, r).applyMatrix4(e.matrixWorld), this.expandByPoint(Mn);
      } else
        i.boundingBox === null && i.computeBoundingBox(), xo.copy(i.boundingBox), xo.applyMatrix4(e.matrixWorld), this.union(xo);
    const n = e.children;
    for (let s = 0, r = n.length; s < r; s++)
      this.expandByObject(n[s], t);
    return this;
  }
  containsPoint(e) {
    return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z);
  }
  containsBox(e) {
    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z;
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(e) {
    return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z);
  }
  intersectsSphere(e) {
    return this.clampPoint(e.center, Mn), Mn.distanceToSquared(e.center) <= e.radius * e.radius;
  }
  intersectsPlane(e) {
    let t, i;
    return e.normal.x > 0 ? (t = e.normal.x * this.min.x, i = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, i = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, i += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, i += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, i += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, i += e.normal.z * this.min.z), t <= -e.constant && i >= -e.constant;
  }
  intersectsTriangle(e) {
    if (this.isEmpty())
      return !1;
    this.getCenter(Hs), Ur.subVectors(this.max, Hs), Wn.subVectors(e.a, Hs), Xn.subVectors(e.b, Hs), qn.subVectors(e.c, Hs), Zi.subVectors(Xn, Wn), Ji.subVectors(qn, Xn), Sn.subVectors(Wn, qn);
    let t = [
      0,
      -Zi.z,
      Zi.y,
      0,
      -Ji.z,
      Ji.y,
      0,
      -Sn.z,
      Sn.y,
      Zi.z,
      0,
      -Zi.x,
      Ji.z,
      0,
      -Ji.x,
      Sn.z,
      0,
      -Sn.x,
      -Zi.y,
      Zi.x,
      0,
      -Ji.y,
      Ji.x,
      0,
      -Sn.y,
      Sn.x,
      0
    ];
    return !wo(t, Wn, Xn, qn, Ur) || (t = [1, 0, 0, 0, 1, 0, 0, 0, 1], !wo(t, Wn, Xn, qn, Ur)) ? !1 : (Vr.crossVectors(Zi, Ji), t = [Vr.x, Vr.y, Vr.z], wo(t, Wn, Xn, qn, Ur));
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return Mn.copy(e).clamp(this.min, this.max).sub(e).length();
  }
  getBoundingSphere(e) {
    return this.getCenter(e.center), e.radius = this.getSize(Mn).length() * 0.5, e;
  }
  intersect(e) {
    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  applyMatrix4(e) {
    return this.isEmpty() ? this : (Ii[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), Ii[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), Ii[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), Ii[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), Ii[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), Ii[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), Ii[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), Ii[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(Ii), this);
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const Ii = [
  /* @__PURE__ */ new b(),
  /* @__PURE__ */ new b(),
  /* @__PURE__ */ new b(),
  /* @__PURE__ */ new b(),
  /* @__PURE__ */ new b(),
  /* @__PURE__ */ new b(),
  /* @__PURE__ */ new b(),
  /* @__PURE__ */ new b()
], Mn = /* @__PURE__ */ new b(), xo = /* @__PURE__ */ new Ht(), Wn = /* @__PURE__ */ new b(), Xn = /* @__PURE__ */ new b(), qn = /* @__PURE__ */ new b(), Zi = /* @__PURE__ */ new b(), Ji = /* @__PURE__ */ new b(), Sn = /* @__PURE__ */ new b(), Hs = /* @__PURE__ */ new b(), Ur = /* @__PURE__ */ new b(), Vr = /* @__PURE__ */ new b(), Tn = /* @__PURE__ */ new b();
function wo(o, e, t, i, n) {
  for (let s = 0, r = o.length - 3; s <= r; s += 3) {
    Tn.fromArray(o, s);
    const a = n.x * Math.abs(Tn.x) + n.y * Math.abs(Tn.y) + n.z * Math.abs(Tn.z), l = e.dot(Tn), c = t.dot(Tn), h = i.dot(Tn);
    if (Math.max(-Math.max(l, c, h), Math.min(l, c, h)) > a)
      return !1;
  }
  return !0;
}
const im = /* @__PURE__ */ new Ht(), Ws = /* @__PURE__ */ new b(), bo = /* @__PURE__ */ new b();
class Ci {
  constructor(e = new b(), t = -1) {
    this.center = e, this.radius = t;
  }
  set(e, t) {
    return this.center.copy(e), this.radius = t, this;
  }
  setFromPoints(e, t) {
    const i = this.center;
    t !== void 0 ? i.copy(t) : im.setFromPoints(e).getCenter(i);
    let n = 0;
    for (let s = 0, r = e.length; s < r; s++)
      n = Math.max(n, i.distanceToSquared(e[s]));
    return this.radius = Math.sqrt(n), this;
  }
  copy(e) {
    return this.center.copy(e.center), this.radius = e.radius, this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), this.radius = -1, this;
  }
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(e) {
    const t = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= t * t;
  }
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(e, t) {
    const i = this.center.distanceToSquared(e);
    return t.copy(e), i > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t;
  }
  getBoundingBox(e) {
    return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  }
  applyMatrix4(e) {
    return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this;
  }
  translate(e) {
    return this.center.add(e), this;
  }
  expandByPoint(e) {
    if (this.isEmpty())
      return this.center.copy(e), this.radius = 0, this;
    Ws.subVectors(e, this.center);
    const t = Ws.lengthSq();
    if (t > this.radius * this.radius) {
      const i = Math.sqrt(t), n = (i - this.radius) * 0.5;
      this.center.addScaledVector(Ws, n / i), this.radius += n;
    }
    return this;
  }
  union(e) {
    return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e), this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (bo.subVectors(e.center, this.center).setLength(e.radius), this.expandByPoint(Ws.copy(e.center).add(bo)), this.expandByPoint(Ws.copy(e.center).sub(bo))), this);
  }
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Di = /* @__PURE__ */ new b(), Mo = /* @__PURE__ */ new b(), Gr = /* @__PURE__ */ new b(), Ki = /* @__PURE__ */ new b(), So = /* @__PURE__ */ new b(), Hr = /* @__PURE__ */ new b(), To = /* @__PURE__ */ new b();
class ks {
  constructor(e = new b(), t = new b(0, 0, -1)) {
    this.origin = e, this.direction = t;
  }
  set(e, t) {
    return this.origin.copy(e), this.direction.copy(t), this;
  }
  copy(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
  }
  at(e, t) {
    return t.copy(this.direction).multiplyScalar(e).add(this.origin);
  }
  lookAt(e) {
    return this.direction.copy(e).sub(this.origin).normalize(), this;
  }
  recast(e) {
    return this.origin.copy(this.at(e, Di)), this;
  }
  closestPointToPoint(e, t) {
    t.subVectors(e, this.origin);
    const i = t.dot(this.direction);
    return i < 0 ? t.copy(this.origin) : t.copy(this.direction).multiplyScalar(i).add(this.origin);
  }
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  }
  distanceSqToPoint(e) {
    const t = Di.subVectors(e, this.origin).dot(this.direction);
    return t < 0 ? this.origin.distanceToSquared(e) : (Di.copy(this.direction).multiplyScalar(t).add(this.origin), Di.distanceToSquared(e));
  }
  distanceSqToSegment(e, t, i, n) {
    Mo.copy(e).add(t).multiplyScalar(0.5), Gr.copy(t).sub(e).normalize(), Ki.copy(this.origin).sub(Mo);
    const s = e.distanceTo(t) * 0.5, r = -this.direction.dot(Gr), a = Ki.dot(this.direction), l = -Ki.dot(Gr), c = Ki.lengthSq(), h = Math.abs(1 - r * r);
    let u, d, f, m;
    if (h > 0)
      if (u = r * l - a, d = r * a - l, m = s * h, u >= 0)
        if (d >= -m)
          if (d <= m) {
            const _ = 1 / h;
            u *= _, d *= _, f = u * (u + r * d + 2 * a) + d * (r * u + d + 2 * l) + c;
          } else
            d = s, u = Math.max(0, -(r * d + a)), f = -u * u + d * (d + 2 * l) + c;
        else
          d = -s, u = Math.max(0, -(r * d + a)), f = -u * u + d * (d + 2 * l) + c;
      else
        d <= -m ? (u = Math.max(0, -(-r * s + a)), d = u > 0 ? -s : Math.min(Math.max(-s, -l), s), f = -u * u + d * (d + 2 * l) + c) : d <= m ? (u = 0, d = Math.min(Math.max(-s, -l), s), f = d * (d + 2 * l) + c) : (u = Math.max(0, -(r * s + a)), d = u > 0 ? s : Math.min(Math.max(-s, -l), s), f = -u * u + d * (d + 2 * l) + c);
    else
      d = r > 0 ? -s : s, u = Math.max(0, -(r * d + a)), f = -u * u + d * (d + 2 * l) + c;
    return i && i.copy(this.direction).multiplyScalar(u).add(this.origin), n && n.copy(Gr).multiplyScalar(d).add(Mo), f;
  }
  intersectSphere(e, t) {
    Di.subVectors(e.center, this.origin);
    const i = Di.dot(this.direction), n = Di.dot(Di) - i * i, s = e.radius * e.radius;
    if (n > s) return null;
    const r = Math.sqrt(s - n), a = i - r, l = i + r;
    return a < 0 && l < 0 ? null : a < 0 ? this.at(l, t) : this.at(a, t);
  }
  intersectsSphere(e) {
    return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
  }
  distanceToPlane(e) {
    const t = e.normal.dot(this.direction);
    if (t === 0)
      return e.distanceToPoint(this.origin) === 0 ? 0 : null;
    const i = -(this.origin.dot(e.normal) + e.constant) / t;
    return i >= 0 ? i : null;
  }
  intersectPlane(e, t) {
    const i = this.distanceToPlane(e);
    return i === null ? null : this.at(i, t);
  }
  intersectsPlane(e) {
    const t = e.distanceToPoint(this.origin);
    return t === 0 || e.normal.dot(this.direction) * t < 0;
  }
  intersectBox(e, t) {
    let i, n, s, r, a, l;
    const c = 1 / this.direction.x, h = 1 / this.direction.y, u = 1 / this.direction.z, d = this.origin;
    return c >= 0 ? (i = (e.min.x - d.x) * c, n = (e.max.x - d.x) * c) : (i = (e.max.x - d.x) * c, n = (e.min.x - d.x) * c), h >= 0 ? (s = (e.min.y - d.y) * h, r = (e.max.y - d.y) * h) : (s = (e.max.y - d.y) * h, r = (e.min.y - d.y) * h), i > r || s > n || ((s > i || isNaN(i)) && (i = s), (r < n || isNaN(n)) && (n = r), u >= 0 ? (a = (e.min.z - d.z) * u, l = (e.max.z - d.z) * u) : (a = (e.max.z - d.z) * u, l = (e.min.z - d.z) * u), i > l || a > n) || ((a > i || i !== i) && (i = a), (l < n || n !== n) && (n = l), n < 0) ? null : this.at(i >= 0 ? i : n, t);
  }
  intersectsBox(e) {
    return this.intersectBox(e, Di) !== null;
  }
  intersectTriangle(e, t, i, n, s) {
    So.subVectors(t, e), Hr.subVectors(i, e), To.crossVectors(So, Hr);
    let r = this.direction.dot(To), a;
    if (r > 0) {
      if (n) return null;
      a = 1;
    } else if (r < 0)
      a = -1, r = -r;
    else
      return null;
    Ki.subVectors(this.origin, e);
    const l = a * this.direction.dot(Hr.crossVectors(Ki, Hr));
    if (l < 0)
      return null;
    const c = a * this.direction.dot(So.cross(Ki));
    if (c < 0 || l + c > r)
      return null;
    const h = -a * Ki.dot(To);
    return h < 0 ? null : this.at(h / r, s);
  }
  applyMatrix4(e) {
    return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this;
  }
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class ue {
  constructor() {
    ue.prototype.isMatrix4 = !0, this.elements = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ];
  }
  set(e, t, i, n, s, r, a, l, c, h, u, d, f, m, _, p) {
    const g = this.elements;
    return g[0] = e, g[4] = t, g[8] = i, g[12] = n, g[1] = s, g[5] = r, g[9] = a, g[13] = l, g[2] = c, g[6] = h, g[10] = u, g[14] = d, g[3] = f, g[7] = m, g[11] = _, g[15] = p, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  clone() {
    return new ue().fromArray(this.elements);
  }
  copy(e) {
    const t = this.elements, i = e.elements;
    return t[0] = i[0], t[1] = i[1], t[2] = i[2], t[3] = i[3], t[4] = i[4], t[5] = i[5], t[6] = i[6], t[7] = i[7], t[8] = i[8], t[9] = i[9], t[10] = i[10], t[11] = i[11], t[12] = i[12], t[13] = i[13], t[14] = i[14], t[15] = i[15], this;
  }
  copyPosition(e) {
    const t = this.elements, i = e.elements;
    return t[12] = i[12], t[13] = i[13], t[14] = i[14], this;
  }
  setFromMatrix3(e) {
    const t = e.elements;
    return this.set(
      t[0],
      t[3],
      t[6],
      0,
      t[1],
      t[4],
      t[7],
      0,
      t[2],
      t[5],
      t[8],
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractBasis(e, t, i) {
    return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), i.setFromMatrixColumn(this, 2), this;
  }
  makeBasis(e, t, i) {
    return this.set(
      e.x,
      t.x,
      i.x,
      0,
      e.y,
      t.y,
      i.y,
      0,
      e.z,
      t.z,
      i.z,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractRotation(e) {
    const t = this.elements, i = e.elements, n = 1 / jn.setFromMatrixColumn(e, 0).length(), s = 1 / jn.setFromMatrixColumn(e, 1).length(), r = 1 / jn.setFromMatrixColumn(e, 2).length();
    return t[0] = i[0] * n, t[1] = i[1] * n, t[2] = i[2] * n, t[3] = 0, t[4] = i[4] * s, t[5] = i[5] * s, t[6] = i[6] * s, t[7] = 0, t[8] = i[8] * r, t[9] = i[9] * r, t[10] = i[10] * r, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
  }
  makeRotationFromEuler(e) {
    const t = this.elements, i = e.x, n = e.y, s = e.z, r = Math.cos(i), a = Math.sin(i), l = Math.cos(n), c = Math.sin(n), h = Math.cos(s), u = Math.sin(s);
    if (e.order === "XYZ") {
      const d = r * h, f = r * u, m = a * h, _ = a * u;
      t[0] = l * h, t[4] = -l * u, t[8] = c, t[1] = f + m * c, t[5] = d - _ * c, t[9] = -a * l, t[2] = _ - d * c, t[6] = m + f * c, t[10] = r * l;
    } else if (e.order === "YXZ") {
      const d = l * h, f = l * u, m = c * h, _ = c * u;
      t[0] = d + _ * a, t[4] = m * a - f, t[8] = r * c, t[1] = r * u, t[5] = r * h, t[9] = -a, t[2] = f * a - m, t[6] = _ + d * a, t[10] = r * l;
    } else if (e.order === "ZXY") {
      const d = l * h, f = l * u, m = c * h, _ = c * u;
      t[0] = d - _ * a, t[4] = -r * u, t[8] = m + f * a, t[1] = f + m * a, t[5] = r * h, t[9] = _ - d * a, t[2] = -r * c, t[6] = a, t[10] = r * l;
    } else if (e.order === "ZYX") {
      const d = r * h, f = r * u, m = a * h, _ = a * u;
      t[0] = l * h, t[4] = m * c - f, t[8] = d * c + _, t[1] = l * u, t[5] = _ * c + d, t[9] = f * c - m, t[2] = -c, t[6] = a * l, t[10] = r * l;
    } else if (e.order === "YZX") {
      const d = r * l, f = r * c, m = a * l, _ = a * c;
      t[0] = l * h, t[4] = _ - d * u, t[8] = m * u + f, t[1] = u, t[5] = r * h, t[9] = -a * h, t[2] = -c * h, t[6] = f * u + m, t[10] = d - _ * u;
    } else if (e.order === "XZY") {
      const d = r * l, f = r * c, m = a * l, _ = a * c;
      t[0] = l * h, t[4] = -u, t[8] = c * h, t[1] = d * u + _, t[5] = r * h, t[9] = f * u - m, t[2] = m * u - f, t[6] = a * h, t[10] = _ * u + d;
    }
    return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
  }
  makeRotationFromQuaternion(e) {
    return this.compose(nm, e, sm);
  }
  lookAt(e, t, i) {
    const n = this.elements;
    return Zt.subVectors(e, t), Zt.lengthSq() === 0 && (Zt.z = 1), Zt.normalize(), $i.crossVectors(i, Zt), $i.lengthSq() === 0 && (Math.abs(i.z) === 1 ? Zt.x += 1e-4 : Zt.z += 1e-4, Zt.normalize(), $i.crossVectors(i, Zt)), $i.normalize(), Wr.crossVectors(Zt, $i), n[0] = $i.x, n[4] = Wr.x, n[8] = Zt.x, n[1] = $i.y, n[5] = Wr.y, n[9] = Zt.y, n[2] = $i.z, n[6] = Wr.z, n[10] = Zt.z, this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const i = e.elements, n = t.elements, s = this.elements, r = i[0], a = i[4], l = i[8], c = i[12], h = i[1], u = i[5], d = i[9], f = i[13], m = i[2], _ = i[6], p = i[10], g = i[14], x = i[3], y = i[7], v = i[11], M = i[15], S = n[0], A = n[4], w = n[8], E = n[12], P = n[1], z = n[5], V = n[9], O = n[13], D = n[2], H = n[6], Z = n[10], ie = n[14], K = n[3], ne = n[7], te = n[11], q = n[15];
    return s[0] = r * S + a * P + l * D + c * K, s[4] = r * A + a * z + l * H + c * ne, s[8] = r * w + a * V + l * Z + c * te, s[12] = r * E + a * O + l * ie + c * q, s[1] = h * S + u * P + d * D + f * K, s[5] = h * A + u * z + d * H + f * ne, s[9] = h * w + u * V + d * Z + f * te, s[13] = h * E + u * O + d * ie + f * q, s[2] = m * S + _ * P + p * D + g * K, s[6] = m * A + _ * z + p * H + g * ne, s[10] = m * w + _ * V + p * Z + g * te, s[14] = m * E + _ * O + p * ie + g * q, s[3] = x * S + y * P + v * D + M * K, s[7] = x * A + y * z + v * H + M * ne, s[11] = x * w + y * V + v * Z + M * te, s[15] = x * E + y * O + v * ie + M * q, this;
  }
  multiplyScalar(e) {
    const t = this.elements;
    return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this;
  }
  determinant() {
    const e = this.elements, t = e[0], i = e[4], n = e[8], s = e[12], r = e[1], a = e[5], l = e[9], c = e[13], h = e[2], u = e[6], d = e[10], f = e[14], m = e[3], _ = e[7], p = e[11], g = e[15];
    return m * (+s * l * u - n * c * u - s * a * d + i * c * d + n * a * f - i * l * f) + _ * (+t * l * f - t * c * d + s * r * d - n * r * f + n * c * h - s * l * h) + p * (+t * c * u - t * a * f - s * r * u + i * r * f + s * a * h - i * c * h) + g * (-n * a * h - t * l * u + t * a * d + n * r * u - i * r * d + i * l * h);
  }
  transpose() {
    const e = this.elements;
    let t;
    return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this;
  }
  setPosition(e, t, i) {
    const n = this.elements;
    return e.isVector3 ? (n[12] = e.x, n[13] = e.y, n[14] = e.z) : (n[12] = e, n[13] = t, n[14] = i), this;
  }
  invert() {
    const e = this.elements, t = e[0], i = e[1], n = e[2], s = e[3], r = e[4], a = e[5], l = e[6], c = e[7], h = e[8], u = e[9], d = e[10], f = e[11], m = e[12], _ = e[13], p = e[14], g = e[15], x = u * p * c - _ * d * c + _ * l * f - a * p * f - u * l * g + a * d * g, y = m * d * c - h * p * c - m * l * f + r * p * f + h * l * g - r * d * g, v = h * _ * c - m * u * c + m * a * f - r * _ * f - h * a * g + r * u * g, M = m * u * l - h * _ * l - m * a * d + r * _ * d + h * a * p - r * u * p, S = t * x + i * y + n * v + s * M;
    if (S === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const A = 1 / S;
    return e[0] = x * A, e[1] = (_ * d * s - u * p * s - _ * n * f + i * p * f + u * n * g - i * d * g) * A, e[2] = (a * p * s - _ * l * s + _ * n * c - i * p * c - a * n * g + i * l * g) * A, e[3] = (u * l * s - a * d * s - u * n * c + i * d * c + a * n * f - i * l * f) * A, e[4] = y * A, e[5] = (h * p * s - m * d * s + m * n * f - t * p * f - h * n * g + t * d * g) * A, e[6] = (m * l * s - r * p * s - m * n * c + t * p * c + r * n * g - t * l * g) * A, e[7] = (r * d * s - h * l * s + h * n * c - t * d * c - r * n * f + t * l * f) * A, e[8] = v * A, e[9] = (m * u * s - h * _ * s - m * i * f + t * _ * f + h * i * g - t * u * g) * A, e[10] = (r * _ * s - m * a * s + m * i * c - t * _ * c - r * i * g + t * a * g) * A, e[11] = (h * a * s - r * u * s - h * i * c + t * u * c + r * i * f - t * a * f) * A, e[12] = M * A, e[13] = (h * _ * n - m * u * n + m * i * d - t * _ * d - h * i * p + t * u * p) * A, e[14] = (m * a * n - r * _ * n - m * i * l + t * _ * l + r * i * p - t * a * p) * A, e[15] = (r * u * n - h * a * n + h * i * l - t * u * l - r * i * d + t * a * d) * A, this;
  }
  scale(e) {
    const t = this.elements, i = e.x, n = e.y, s = e.z;
    return t[0] *= i, t[4] *= n, t[8] *= s, t[1] *= i, t[5] *= n, t[9] *= s, t[2] *= i, t[6] *= n, t[10] *= s, t[3] *= i, t[7] *= n, t[11] *= s, this;
  }
  getMaxScaleOnAxis() {
    const e = this.elements, t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], i = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], n = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(t, i, n));
  }
  makeTranslation(e, t, i) {
    return this.set(
      1,
      0,
      0,
      e,
      0,
      1,
      0,
      t,
      0,
      0,
      1,
      i,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationX(e) {
    const t = Math.cos(e), i = Math.sin(e);
    return this.set(
      1,
      0,
      0,
      0,
      0,
      t,
      -i,
      0,
      0,
      i,
      t,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationY(e) {
    const t = Math.cos(e), i = Math.sin(e);
    return this.set(
      t,
      0,
      i,
      0,
      0,
      1,
      0,
      0,
      -i,
      0,
      t,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationZ(e) {
    const t = Math.cos(e), i = Math.sin(e);
    return this.set(
      t,
      -i,
      0,
      0,
      i,
      t,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationAxis(e, t) {
    const i = Math.cos(t), n = Math.sin(t), s = 1 - i, r = e.x, a = e.y, l = e.z, c = s * r, h = s * a;
    return this.set(
      c * r + i,
      c * a - n * l,
      c * l + n * a,
      0,
      c * a + n * l,
      h * a + i,
      h * l - n * r,
      0,
      c * l - n * a,
      h * l + n * r,
      s * l * l + i,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(e, t, i) {
    return this.set(
      e,
      0,
      0,
      0,
      0,
      t,
      0,
      0,
      0,
      0,
      i,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeShear(e, t, i, n, s, r) {
    return this.set(
      1,
      i,
      s,
      0,
      e,
      1,
      r,
      0,
      t,
      n,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  compose(e, t, i) {
    const n = this.elements, s = t._x, r = t._y, a = t._z, l = t._w, c = s + s, h = r + r, u = a + a, d = s * c, f = s * h, m = s * u, _ = r * h, p = r * u, g = a * u, x = l * c, y = l * h, v = l * u, M = i.x, S = i.y, A = i.z;
    return n[0] = (1 - (_ + g)) * M, n[1] = (f + v) * M, n[2] = (m - y) * M, n[3] = 0, n[4] = (f - v) * S, n[5] = (1 - (d + g)) * S, n[6] = (p + x) * S, n[7] = 0, n[8] = (m + y) * A, n[9] = (p - x) * A, n[10] = (1 - (d + _)) * A, n[11] = 0, n[12] = e.x, n[13] = e.y, n[14] = e.z, n[15] = 1, this;
  }
  decompose(e, t, i) {
    const n = this.elements;
    let s = jn.set(n[0], n[1], n[2]).length();
    const r = jn.set(n[4], n[5], n[6]).length(), a = jn.set(n[8], n[9], n[10]).length();
    this.determinant() < 0 && (s = -s), e.x = n[12], e.y = n[13], e.z = n[14], ui.copy(this);
    const c = 1 / s, h = 1 / r, u = 1 / a;
    return ui.elements[0] *= c, ui.elements[1] *= c, ui.elements[2] *= c, ui.elements[4] *= h, ui.elements[5] *= h, ui.elements[6] *= h, ui.elements[8] *= u, ui.elements[9] *= u, ui.elements[10] *= u, t.setFromRotationMatrix(ui), i.x = s, i.y = r, i.z = a, this;
  }
  makePerspective(e, t, i, n, s, r) {
    const a = this.elements, l = 2 * s / (t - e), c = 2 * s / (i - n), h = (t + e) / (t - e), u = (i + n) / (i - n), d = -(r + s) / (r - s), f = -2 * r * s / (r - s);
    return a[0] = l, a[4] = 0, a[8] = h, a[12] = 0, a[1] = 0, a[5] = c, a[9] = u, a[13] = 0, a[2] = 0, a[6] = 0, a[10] = d, a[14] = f, a[3] = 0, a[7] = 0, a[11] = -1, a[15] = 0, this;
  }
  makeOrthographic(e, t, i, n, s, r) {
    const a = this.elements, l = 1 / (t - e), c = 1 / (i - n), h = 1 / (r - s), u = (t + e) * l, d = (i + n) * c, f = (r + s) * h;
    return a[0] = 2 * l, a[4] = 0, a[8] = 0, a[12] = -u, a[1] = 0, a[5] = 2 * c, a[9] = 0, a[13] = -d, a[2] = 0, a[6] = 0, a[10] = -2 * h, a[14] = -f, a[3] = 0, a[7] = 0, a[11] = 0, a[15] = 1, this;
  }
  equals(e) {
    const t = this.elements, i = e.elements;
    for (let n = 0; n < 16; n++)
      if (t[n] !== i[n]) return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let i = 0; i < 16; i++)
      this.elements[i] = e[i + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const i = this.elements;
    return e[t] = i[0], e[t + 1] = i[1], e[t + 2] = i[2], e[t + 3] = i[3], e[t + 4] = i[4], e[t + 5] = i[5], e[t + 6] = i[6], e[t + 7] = i[7], e[t + 8] = i[8], e[t + 9] = i[9], e[t + 10] = i[10], e[t + 11] = i[11], e[t + 12] = i[12], e[t + 13] = i[13], e[t + 14] = i[14], e[t + 15] = i[15], e;
  }
}
const jn = /* @__PURE__ */ new b(), ui = /* @__PURE__ */ new ue(), nm = /* @__PURE__ */ new b(0, 0, 0), sm = /* @__PURE__ */ new b(1, 1, 1), $i = /* @__PURE__ */ new b(), Wr = /* @__PURE__ */ new b(), Zt = /* @__PURE__ */ new b(), ah = /* @__PURE__ */ new ue(), oh = /* @__PURE__ */ new Et();
class Kt {
  constructor(e = 0, t = 0, i = 0, n = Kt.DefaultOrder) {
    this.isEuler = !0, this._x = e, this._y = t, this._z = i, this._order = n;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(e) {
    this._order = e, this._onChangeCallback();
  }
  set(e, t, i, n = this._order) {
    return this._x = e, this._y = t, this._z = i, this._order = n, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e) {
    return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e, t = this._order, i = !0) {
    const n = e.elements, s = n[0], r = n[4], a = n[8], l = n[1], c = n[5], h = n[9], u = n[2], d = n[6], f = n[10];
    switch (t) {
      case "XYZ":
        this._y = Math.asin(_t(a, -1, 1)), Math.abs(a) < 0.9999999 ? (this._x = Math.atan2(-h, f), this._z = Math.atan2(-r, s)) : (this._x = Math.atan2(d, c), this._z = 0);
        break;
      case "YXZ":
        this._x = Math.asin(-_t(h, -1, 1)), Math.abs(h) < 0.9999999 ? (this._y = Math.atan2(a, f), this._z = Math.atan2(l, c)) : (this._y = Math.atan2(-u, s), this._z = 0);
        break;
      case "ZXY":
        this._x = Math.asin(_t(d, -1, 1)), Math.abs(d) < 0.9999999 ? (this._y = Math.atan2(-u, f), this._z = Math.atan2(-r, c)) : (this._y = 0, this._z = Math.atan2(l, s));
        break;
      case "ZYX":
        this._y = Math.asin(-_t(u, -1, 1)), Math.abs(u) < 0.9999999 ? (this._x = Math.atan2(d, f), this._z = Math.atan2(l, s)) : (this._x = 0, this._z = Math.atan2(-r, c));
        break;
      case "YZX":
        this._z = Math.asin(_t(l, -1, 1)), Math.abs(l) < 0.9999999 ? (this._x = Math.atan2(-h, c), this._y = Math.atan2(-u, s)) : (this._x = 0, this._y = Math.atan2(a, f));
        break;
      case "XZY":
        this._z = Math.asin(-_t(r, -1, 1)), Math.abs(r) < 0.9999999 ? (this._x = Math.atan2(d, c), this._y = Math.atan2(a, s)) : (this._x = Math.atan2(-h, f), this._y = 0);
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t);
    }
    return this._order = t, i === !0 && this._onChangeCallback(), this;
  }
  setFromQuaternion(e, t, i) {
    return ah.makeRotationFromQuaternion(e), this.setFromRotationMatrix(ah, t, i);
  }
  setFromVector3(e, t = this._order) {
    return this.set(e.x, e.y, e.z, t);
  }
  reorder(e) {
    return oh.setFromEuler(this), this.setFromQuaternion(oh, e);
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order;
  }
  fromArray(e) {
    return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e;
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
  // @deprecated since r138, 02cf0df1cb4575d5842fef9c85bb5a89fe020d53
  toVector3() {
    console.error("THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead");
  }
}
Kt.DefaultOrder = "XYZ";
Kt.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
class Bl {
  constructor() {
    this.mask = 1;
  }
  set(e) {
    this.mask = (1 << e | 0) >>> 0;
  }
  enable(e) {
    this.mask |= 1 << e | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(e) {
    this.mask ^= 1 << e | 0;
  }
  disable(e) {
    this.mask &= ~(1 << e | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(e) {
    return (this.mask & e.mask) !== 0;
  }
  isEnabled(e) {
    return (this.mask & (1 << e | 0)) !== 0;
  }
}
let rm = 0;
const lh = /* @__PURE__ */ new b(), Yn = /* @__PURE__ */ new Et(), Oi = /* @__PURE__ */ new ue(), Xr = /* @__PURE__ */ new b(), Xs = /* @__PURE__ */ new b(), am = /* @__PURE__ */ new b(), om = /* @__PURE__ */ new Et(), ch = /* @__PURE__ */ new b(1, 0, 0), hh = /* @__PURE__ */ new b(0, 1, 0), uh = /* @__PURE__ */ new b(0, 0, 1), lm = { type: "added" }, dh = { type: "removed" };
class tt extends gn {
  constructor() {
    super(), this.isObject3D = !0, Object.defineProperty(this, "id", { value: rm++ }), this.uuid = li(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = tt.DefaultUp.clone();
    const e = new b(), t = new Kt(), i = new Et(), n = new b(1, 1, 1);
    function s() {
      i.setFromEuler(t, !1);
    }
    function r() {
      t.setFromQuaternion(i, void 0, !1);
    }
    t._onChange(s), i._onChange(r), Object.defineProperties(this, {
      position: {
        configurable: !0,
        enumerable: !0,
        value: e
      },
      rotation: {
        configurable: !0,
        enumerable: !0,
        value: t
      },
      quaternion: {
        configurable: !0,
        enumerable: !0,
        value: i
      },
      scale: {
        configurable: !0,
        enumerable: !0,
        value: n
      },
      modelViewMatrix: {
        value: new ue()
      },
      normalMatrix: {
        value: new Gt()
      }
    }), this.matrix = new ue(), this.matrixWorld = new ue(), this.matrixAutoUpdate = tt.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.matrixWorldAutoUpdate = tt.DefaultMatrixWorldAutoUpdate, this.layers = new Bl(), this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {};
  }
  onBeforeRender() {
  }
  onAfterRender() {
  }
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  setRotationFromAxisAngle(e, t) {
    this.quaternion.setFromAxisAngle(e, t);
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0);
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  rotateOnAxis(e, t) {
    return Yn.setFromAxisAngle(e, t), this.quaternion.multiply(Yn), this;
  }
  rotateOnWorldAxis(e, t) {
    return Yn.setFromAxisAngle(e, t), this.quaternion.premultiply(Yn), this;
  }
  rotateX(e) {
    return this.rotateOnAxis(ch, e);
  }
  rotateY(e) {
    return this.rotateOnAxis(hh, e);
  }
  rotateZ(e) {
    return this.rotateOnAxis(uh, e);
  }
  translateOnAxis(e, t) {
    return lh.copy(e).applyQuaternion(this.quaternion), this.position.add(lh.multiplyScalar(t)), this;
  }
  translateX(e) {
    return this.translateOnAxis(ch, e);
  }
  translateY(e) {
    return this.translateOnAxis(hh, e);
  }
  translateZ(e) {
    return this.translateOnAxis(uh, e);
  }
  localToWorld(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(Oi.copy(this.matrixWorld).invert());
  }
  lookAt(e, t, i) {
    e.isVector3 ? Xr.copy(e) : Xr.set(e, t, i);
    const n = this.parent;
    this.updateWorldMatrix(!0, !1), Xs.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Oi.lookAt(Xs, Xr, this.up) : Oi.lookAt(Xr, Xs, this.up), this.quaternion.setFromRotationMatrix(Oi), n && (Oi.extractRotation(n.matrixWorld), Yn.setFromRotationMatrix(Oi), this.quaternion.premultiply(Yn.invert()));
  }
  add(e) {
    if (arguments.length > 1) {
      for (let t = 0; t < arguments.length; t++)
        this.add(arguments[t]);
      return this;
    }
    return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.parent !== null && e.parent.remove(e), e.parent = this, this.children.push(e), e.dispatchEvent(lm)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this);
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++)
        this.remove(arguments[i]);
      return this;
    }
    const t = this.children.indexOf(e);
    return t !== -1 && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(dh)), this;
  }
  removeFromParent() {
    const e = this.parent;
    return e !== null && e.remove(this), this;
  }
  clear() {
    for (let e = 0; e < this.children.length; e++) {
      const t = this.children[e];
      t.parent = null, t.dispatchEvent(dh);
    }
    return this.children.length = 0, this;
  }
  attach(e) {
    return this.updateWorldMatrix(!0, !1), Oi.copy(this.matrixWorld).invert(), e.parent !== null && (e.parent.updateWorldMatrix(!0, !1), Oi.multiply(e.parent.matrixWorld)), e.applyMatrix4(Oi), this.add(e), e.updateWorldMatrix(!1, !0), this;
  }
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  getObjectByProperty(e, t) {
    if (this[e] === t) return this;
    for (let i = 0, n = this.children.length; i < n; i++) {
      const r = this.children[i].getObjectByProperty(e, t);
      if (r !== void 0)
        return r;
    }
  }
  getObjectsByProperty(e, t) {
    let i = [];
    this[e] === t && i.push(this);
    for (let n = 0, s = this.children.length; n < s; n++) {
      const r = this.children[n].getObjectsByProperty(e, t);
      r.length > 0 && (i = i.concat(r));
    }
    return i;
  }
  getWorldPosition(e) {
    return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld);
  }
  getWorldQuaternion(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Xs, e, am), e;
  }
  getWorldScale(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Xs, om, e), e;
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const t = this.matrixWorld.elements;
    return e.set(t[8], t[9], t[10]).normalize();
  }
  raycast() {
  }
  traverse(e) {
    e(this);
    const t = this.children;
    for (let i = 0, n = t.length; i < n; i++)
      t[i].traverse(e);
  }
  traverseVisible(e) {
    if (this.visible === !1) return;
    e(this);
    const t = this.children;
    for (let i = 0, n = t.length; i < n; i++)
      t[i].traverseVisible(e);
  }
  traverseAncestors(e) {
    const t = this.parent;
    t !== null && (e(t), t.traverseAncestors(e));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
  }
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0);
    const t = this.children;
    for (let i = 0, n = t.length; i < n; i++) {
      const s = t[i];
      (s.matrixWorldAutoUpdate === !0 || e === !0) && s.updateMatrixWorld(e);
    }
  }
  updateWorldMatrix(e, t) {
    const i = this.parent;
    if (e === !0 && i !== null && i.matrixWorldAutoUpdate === !0 && i.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), t === !0) {
      const n = this.children;
      for (let s = 0, r = n.length; s < r; s++) {
        const a = n[s];
        a.matrixWorldAutoUpdate === !0 && a.updateWorldMatrix(!1, !0);
      }
    }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string", i = {};
    t && (e = {
      geometries: {},
      materials: {},
      textures: {},
      images: {},
      shapes: {},
      skeletons: {},
      animations: {},
      nodes: {}
    }, i.metadata = {
      version: 4.5,
      type: "Object",
      generator: "Object3D.toJSON"
    });
    const n = {};
    n.uuid = this.uuid, n.type = this.type, this.name !== "" && (n.name = this.name), this.castShadow === !0 && (n.castShadow = !0), this.receiveShadow === !0 && (n.receiveShadow = !0), this.visible === !1 && (n.visible = !1), this.frustumCulled === !1 && (n.frustumCulled = !1), this.renderOrder !== 0 && (n.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (n.userData = this.userData), n.layers = this.layers.mask, n.matrix = this.matrix.toArray(), this.matrixAutoUpdate === !1 && (n.matrixAutoUpdate = !1), this.isInstancedMesh && (n.type = "InstancedMesh", n.count = this.count, n.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (n.instanceColor = this.instanceColor.toJSON()));
    function s(a, l) {
      return a[l.uuid] === void 0 && (a[l.uuid] = l.toJSON(e)), l.uuid;
    }
    if (this.isScene)
      this.background && (this.background.isColor ? n.background = this.background.toJSON() : this.background.isTexture && (n.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (n.environment = this.environment.toJSON(e).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      n.geometry = s(e.geometries, this.geometry);
      const a = this.geometry.parameters;
      if (a !== void 0 && a.shapes !== void 0) {
        const l = a.shapes;
        if (Array.isArray(l))
          for (let c = 0, h = l.length; c < h; c++) {
            const u = l[c];
            s(e.shapes, u);
          }
        else
          s(e.shapes, l);
      }
    }
    if (this.isSkinnedMesh && (n.bindMode = this.bindMode, n.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (s(e.skeletons, this.skeleton), n.skeleton = this.skeleton.uuid)), this.material !== void 0)
      if (Array.isArray(this.material)) {
        const a = [];
        for (let l = 0, c = this.material.length; l < c; l++)
          a.push(s(e.materials, this.material[l]));
        n.material = a;
      } else
        n.material = s(e.materials, this.material);
    if (this.children.length > 0) {
      n.children = [];
      for (let a = 0; a < this.children.length; a++)
        n.children.push(this.children[a].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      n.animations = [];
      for (let a = 0; a < this.animations.length; a++) {
        const l = this.animations[a];
        n.animations.push(s(e.animations, l));
      }
    }
    if (t) {
      const a = r(e.geometries), l = r(e.materials), c = r(e.textures), h = r(e.images), u = r(e.shapes), d = r(e.skeletons), f = r(e.animations), m = r(e.nodes);
      a.length > 0 && (i.geometries = a), l.length > 0 && (i.materials = l), c.length > 0 && (i.textures = c), h.length > 0 && (i.images = h), u.length > 0 && (i.shapes = u), d.length > 0 && (i.skeletons = d), f.length > 0 && (i.animations = f), m.length > 0 && (i.nodes = m);
    }
    return i.object = n, i;
    function r(a) {
      const l = [];
      for (const c in a) {
        const h = a[c];
        delete h.metadata, l.push(h);
      }
      return l;
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  copy(e, t = !0) {
    if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.userData = JSON.parse(JSON.stringify(e.userData)), t === !0)
      for (let i = 0; i < e.children.length; i++) {
        const n = e.children[i];
        this.add(n.clone());
      }
    return this;
  }
}
tt.DefaultUp = /* @__PURE__ */ new b(0, 1, 0);
tt.DefaultMatrixAutoUpdate = !0;
tt.DefaultMatrixWorldAutoUpdate = !0;
const di = /* @__PURE__ */ new b(), Ni = /* @__PURE__ */ new b(), Ao = /* @__PURE__ */ new b(), ki = /* @__PURE__ */ new b(), Zn = /* @__PURE__ */ new b(), Jn = /* @__PURE__ */ new b(), fh = /* @__PURE__ */ new b(), Eo = /* @__PURE__ */ new b(), Co = /* @__PURE__ */ new b(), Lo = /* @__PURE__ */ new b();
class _i {
  constructor(e = new b(), t = new b(), i = new b()) {
    this.a = e, this.b = t, this.c = i;
  }
  static getNormal(e, t, i, n) {
    n.subVectors(i, t), di.subVectors(e, t), n.cross(di);
    const s = n.lengthSq();
    return s > 0 ? n.multiplyScalar(1 / Math.sqrt(s)) : n.set(0, 0, 0);
  }
  // static/instance method to calculate barycentric coordinates
  // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
  static getBarycoord(e, t, i, n, s) {
    di.subVectors(n, t), Ni.subVectors(i, t), Ao.subVectors(e, t);
    const r = di.dot(di), a = di.dot(Ni), l = di.dot(Ao), c = Ni.dot(Ni), h = Ni.dot(Ao), u = r * c - a * a;
    if (u === 0)
      return s.set(-2, -1, -1);
    const d = 1 / u, f = (c * l - a * h) * d, m = (r * h - a * l) * d;
    return s.set(1 - f - m, m, f);
  }
  static containsPoint(e, t, i, n) {
    return this.getBarycoord(e, t, i, n, ki), ki.x >= 0 && ki.y >= 0 && ki.x + ki.y <= 1;
  }
  static getUV(e, t, i, n, s, r, a, l) {
    return this.getBarycoord(e, t, i, n, ki), l.set(0, 0), l.addScaledVector(s, ki.x), l.addScaledVector(r, ki.y), l.addScaledVector(a, ki.z), l;
  }
  static isFrontFacing(e, t, i, n) {
    return di.subVectors(i, t), Ni.subVectors(e, t), di.cross(Ni).dot(n) < 0;
  }
  set(e, t, i) {
    return this.a.copy(e), this.b.copy(t), this.c.copy(i), this;
  }
  setFromPointsAndIndices(e, t, i, n) {
    return this.a.copy(e[t]), this.b.copy(e[i]), this.c.copy(e[n]), this;
  }
  setFromAttributeAndIndices(e, t, i, n) {
    return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, i), this.c.fromBufferAttribute(e, n), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  getArea() {
    return di.subVectors(this.c, this.b), Ni.subVectors(this.a, this.b), di.cross(Ni).length() * 0.5;
  }
  getMidpoint(e) {
    return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  getNormal(e) {
    return _i.getNormal(this.a, this.b, this.c, e);
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e, t) {
    return _i.getBarycoord(e, this.a, this.b, this.c, t);
  }
  getUV(e, t, i, n, s) {
    return _i.getUV(e, this.a, this.b, this.c, t, i, n, s);
  }
  containsPoint(e) {
    return _i.containsPoint(e, this.a, this.b, this.c);
  }
  isFrontFacing(e) {
    return _i.isFrontFacing(this.a, this.b, this.c, e);
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  closestPointToPoint(e, t) {
    const i = this.a, n = this.b, s = this.c;
    let r, a;
    Zn.subVectors(n, i), Jn.subVectors(s, i), Eo.subVectors(e, i);
    const l = Zn.dot(Eo), c = Jn.dot(Eo);
    if (l <= 0 && c <= 0)
      return t.copy(i);
    Co.subVectors(e, n);
    const h = Zn.dot(Co), u = Jn.dot(Co);
    if (h >= 0 && u <= h)
      return t.copy(n);
    const d = l * u - h * c;
    if (d <= 0 && l >= 0 && h <= 0)
      return r = l / (l - h), t.copy(i).addScaledVector(Zn, r);
    Lo.subVectors(e, s);
    const f = Zn.dot(Lo), m = Jn.dot(Lo);
    if (m >= 0 && f <= m)
      return t.copy(s);
    const _ = f * c - l * m;
    if (_ <= 0 && c >= 0 && m <= 0)
      return a = c / (c - m), t.copy(i).addScaledVector(Jn, a);
    const p = h * m - f * u;
    if (p <= 0 && u - h >= 0 && f - m >= 0)
      return fh.subVectors(s, n), a = (u - h) / (u - h + (f - m)), t.copy(n).addScaledVector(fh, a);
    const g = 1 / (p + _ + d);
    return r = _ * g, a = d * g, t.copy(i).addScaledVector(Zn, r).addScaledVector(Jn, a);
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
}
let cm = 0;
class Ct extends gn {
  constructor() {
    super(), this.isMaterial = !0, Object.defineProperty(this, "id", { value: cm++ }), this.uuid = li(), this.name = "", this.type = "Material", this.blending = bs, this.side = dn, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.blendSrc = ad, this.blendDst = od, this.blendEquation = ps, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = pl, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = Bp, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = po, this.stencilZFail = po, this.stencilZPass = po, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0;
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(e) {
    this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e;
  }
  onBuild() {
  }
  onBeforeRender() {
  }
  onBeforeCompile() {
  }
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(e) {
    if (e !== void 0)
      for (const t in e) {
        const i = e[t];
        if (i === void 0) {
          console.warn("THREE.Material: '" + t + "' parameter is undefined.");
          continue;
        }
        const n = this[t];
        if (n === void 0) {
          console.warn("THREE." + this.type + ": '" + t + "' is not a property of this material.");
          continue;
        }
        n && n.isColor ? n.set(i) : n && n.isVector3 && i && i.isVector3 ? n.copy(i) : this[t] = i;
      }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    t && (e = {
      textures: {},
      images: {}
    });
    const i = {
      metadata: {
        version: 4.5,
        type: "Material",
        generator: "Material.toJSON"
      }
    };
    i.uuid = this.uuid, i.type = this.type, this.name !== "" && (i.name = this.name), this.color && this.color.isColor && (i.color = this.color.getHex()), this.roughness !== void 0 && (i.roughness = this.roughness), this.metalness !== void 0 && (i.metalness = this.metalness), this.sheen !== void 0 && (i.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (i.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (i.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()), this.emissiveIntensity && this.emissiveIntensity !== 1 && (i.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (i.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (i.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (i.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (i.shininess = this.shininess), this.clearcoat !== void 0 && (i.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (i.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (i.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, i.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.iridescence !== void 0 && (i.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (i.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (i.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (i.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (i.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), this.map && this.map.isTexture && (i.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (i.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (i.lightMap = this.lightMap.toJSON(e).uuid, i.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (i.aoMap = this.aoMap.toJSON(e).uuid, i.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (i.bumpMap = this.bumpMap.toJSON(e).uuid, i.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (i.normalMap = this.normalMap.toJSON(e).uuid, i.normalMapType = this.normalMapType, i.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (i.displacementMap = this.displacementMap.toJSON(e).uuid, i.displacementScale = this.displacementScale, i.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (i.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (i.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(e).uuid, this.combine !== void 0 && (i.combine = this.combine)), this.envMapIntensity !== void 0 && (i.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (i.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (i.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(e).uuid), this.transmission !== void 0 && (i.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (i.transmissionMap = this.transmissionMap.toJSON(e).uuid), this.thickness !== void 0 && (i.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (i.thicknessMap = this.thicknessMap.toJSON(e).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (i.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (i.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (i.size = this.size), this.shadowSide !== null && (i.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (i.sizeAttenuation = this.sizeAttenuation), this.blending !== bs && (i.blending = this.blending), this.side !== dn && (i.side = this.side), this.vertexColors && (i.vertexColors = !0), this.opacity < 1 && (i.opacity = this.opacity), this.transparent === !0 && (i.transparent = this.transparent), i.depthFunc = this.depthFunc, i.depthTest = this.depthTest, i.depthWrite = this.depthWrite, i.colorWrite = this.colorWrite, i.stencilWrite = this.stencilWrite, i.stencilWriteMask = this.stencilWriteMask, i.stencilFunc = this.stencilFunc, i.stencilRef = this.stencilRef, i.stencilFuncMask = this.stencilFuncMask, i.stencilFail = this.stencilFail, i.stencilZFail = this.stencilZFail, i.stencilZPass = this.stencilZPass, this.rotation !== void 0 && this.rotation !== 0 && (i.rotation = this.rotation), this.polygonOffset === !0 && (i.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (i.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (i.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (i.linewidth = this.linewidth), this.dashSize !== void 0 && (i.dashSize = this.dashSize), this.gapSize !== void 0 && (i.gapSize = this.gapSize), this.scale !== void 0 && (i.scale = this.scale), this.dithering === !0 && (i.dithering = !0), this.alphaTest > 0 && (i.alphaTest = this.alphaTest), this.alphaToCoverage === !0 && (i.alphaToCoverage = this.alphaToCoverage), this.premultipliedAlpha === !0 && (i.premultipliedAlpha = this.premultipliedAlpha), this.wireframe === !0 && (i.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (i.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (i.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (i.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === !0 && (i.flatShading = this.flatShading), this.visible === !1 && (i.visible = !1), this.toneMapped === !1 && (i.toneMapped = !1), this.fog === !1 && (i.fog = !1), Object.keys(this.userData).length > 0 && (i.userData = this.userData);
    function n(s) {
      const r = [];
      for (const a in s) {
        const l = s[a];
        delete l.metadata, r.push(l);
      }
      return r;
    }
    if (t) {
      const s = n(e.textures), r = n(e.images);
      s.length > 0 && (i.textures = s), r.length > 0 && (i.images = r);
    }
    return i;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
    const t = e.clippingPlanes;
    let i = null;
    if (t !== null) {
      const n = t.length;
      i = new Array(n);
      for (let s = 0; s !== n; ++s)
        i[s] = t[s].clone();
    }
    return this.clippingPlanes = i, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
}
class gi extends Ct {
  constructor(e) {
    super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new de(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = Ya, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
  }
}
const mt = /* @__PURE__ */ new b(), qr = /* @__PURE__ */ new G();
class $e {
  constructor(e, t, i = !1) {
    if (Array.isArray(e))
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    this.isBufferAttribute = !0, this.name = "", this.array = e, this.itemSize = t, this.count = e !== void 0 ? e.length / t : 0, this.normalized = i, this.usage = ml, this.updateRange = { offset: 0, count: -1 }, this.version = 0;
  }
  onUploadCallback() {
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  copy(e) {
    return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this;
  }
  copyAt(e, t, i) {
    e *= this.itemSize, i *= t.itemSize;
    for (let n = 0, s = this.itemSize; n < s; n++)
      this.array[e + n] = t.array[i + n];
    return this;
  }
  copyArray(e) {
    return this.array.set(e), this;
  }
  applyMatrix3(e) {
    if (this.itemSize === 2)
      for (let t = 0, i = this.count; t < i; t++)
        qr.fromBufferAttribute(this, t), qr.applyMatrix3(e), this.setXY(t, qr.x, qr.y);
    else if (this.itemSize === 3)
      for (let t = 0, i = this.count; t < i; t++)
        mt.fromBufferAttribute(this, t), mt.applyMatrix3(e), this.setXYZ(t, mt.x, mt.y, mt.z);
    return this;
  }
  applyMatrix4(e) {
    for (let t = 0, i = this.count; t < i; t++)
      mt.fromBufferAttribute(this, t), mt.applyMatrix4(e), this.setXYZ(t, mt.x, mt.y, mt.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, i = this.count; t < i; t++)
      mt.fromBufferAttribute(this, t), mt.applyNormalMatrix(e), this.setXYZ(t, mt.x, mt.y, mt.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, i = this.count; t < i; t++)
      mt.fromBufferAttribute(this, t), mt.transformDirection(e), this.setXYZ(t, mt.x, mt.y, mt.z);
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  getX(e) {
    let t = this.array[e * this.itemSize];
    return this.normalized && (t = Hi(t, this.array)), t;
  }
  setX(e, t) {
    return this.normalized && (t = ot(t, this.array)), this.array[e * this.itemSize] = t, this;
  }
  getY(e) {
    let t = this.array[e * this.itemSize + 1];
    return this.normalized && (t = Hi(t, this.array)), t;
  }
  setY(e, t) {
    return this.normalized && (t = ot(t, this.array)), this.array[e * this.itemSize + 1] = t, this;
  }
  getZ(e) {
    let t = this.array[e * this.itemSize + 2];
    return this.normalized && (t = Hi(t, this.array)), t;
  }
  setZ(e, t) {
    return this.normalized && (t = ot(t, this.array)), this.array[e * this.itemSize + 2] = t, this;
  }
  getW(e) {
    let t = this.array[e * this.itemSize + 3];
    return this.normalized && (t = Hi(t, this.array)), t;
  }
  setW(e, t) {
    return this.normalized && (t = ot(t, this.array)), this.array[e * this.itemSize + 3] = t, this;
  }
  setXY(e, t, i) {
    return e *= this.itemSize, this.normalized && (t = ot(t, this.array), i = ot(i, this.array)), this.array[e + 0] = t, this.array[e + 1] = i, this;
  }
  setXYZ(e, t, i, n) {
    return e *= this.itemSize, this.normalized && (t = ot(t, this.array), i = ot(i, this.array), n = ot(n, this.array)), this.array[e + 0] = t, this.array[e + 1] = i, this.array[e + 2] = n, this;
  }
  setXYZW(e, t, i, n, s) {
    return e *= this.itemSize, this.normalized && (t = ot(t, this.array), i = ot(i, this.array), n = ot(n, this.array), s = ot(s, this.array)), this.array[e + 0] = t, this.array[e + 1] = i, this.array[e + 2] = n, this.array[e + 3] = s, this;
  }
  onUpload(e) {
    return this.onUploadCallback = e, this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const e = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized
    };
    return this.name !== "" && (e.name = this.name), this.usage !== ml && (e.usage = this.usage), (this.updateRange.offset !== 0 || this.updateRange.count !== -1) && (e.updateRange = this.updateRange), e;
  }
  // @deprecated
  copyColorsArray() {
    console.error("THREE.BufferAttribute: copyColorsArray() was removed in r144.");
  }
  copyVector2sArray() {
    console.error("THREE.BufferAttribute: copyVector2sArray() was removed in r144.");
  }
  copyVector3sArray() {
    console.error("THREE.BufferAttribute: copyVector3sArray() was removed in r144.");
  }
  copyVector4sArray() {
    console.error("THREE.BufferAttribute: copyVector4sArray() was removed in r144.");
  }
}
class Ul extends $e {
  constructor(e, t, i) {
    super(new Uint16Array(e), t, i);
  }
}
class _d extends $e {
  constructor(e, t, i) {
    super(new Uint32Array(e), t, i);
  }
}
class Ee extends $e {
  constructor(e, t, i) {
    super(new Float32Array(e), t, i);
  }
}
let hm = 0;
const ei = /* @__PURE__ */ new ue(), Po = /* @__PURE__ */ new tt(), Kn = /* @__PURE__ */ new b(), Jt = /* @__PURE__ */ new Ht(), qs = /* @__PURE__ */ new Ht(), Tt = /* @__PURE__ */ new b();
class Ue extends gn {
  constructor() {
    super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", { value: hm++ }), this.uuid = li(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
  }
  getIndex() {
    return this.index;
  }
  setIndex(e) {
    return Array.isArray(e) ? this.index = new (dd(e) ? _d : Ul)(e, 1) : this.index = e, this;
  }
  getAttribute(e) {
    return this.attributes[e];
  }
  setAttribute(e, t) {
    return this.attributes[e] = t, this;
  }
  deleteAttribute(e) {
    return delete this.attributes[e], this;
  }
  hasAttribute(e) {
    return this.attributes[e] !== void 0;
  }
  addGroup(e, t, i = 0) {
    this.groups.push({
      start: e,
      count: t,
      materialIndex: i
    });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(e, t) {
    this.drawRange.start = e, this.drawRange.count = t;
  }
  applyMatrix4(e) {
    const t = this.attributes.position;
    t !== void 0 && (t.applyMatrix4(e), t.needsUpdate = !0);
    const i = this.attributes.normal;
    if (i !== void 0) {
      const s = new Gt().getNormalMatrix(e);
      i.applyNormalMatrix(s), i.needsUpdate = !0;
    }
    const n = this.attributes.tangent;
    return n !== void 0 && (n.transformDirection(e), n.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  applyQuaternion(e) {
    return ei.makeRotationFromQuaternion(e), this.applyMatrix4(ei), this;
  }
  rotateX(e) {
    return ei.makeRotationX(e), this.applyMatrix4(ei), this;
  }
  rotateY(e) {
    return ei.makeRotationY(e), this.applyMatrix4(ei), this;
  }
  rotateZ(e) {
    return ei.makeRotationZ(e), this.applyMatrix4(ei), this;
  }
  translate(e, t, i) {
    return ei.makeTranslation(e, t, i), this.applyMatrix4(ei), this;
  }
  scale(e, t, i) {
    return ei.makeScale(e, t, i), this.applyMatrix4(ei), this;
  }
  lookAt(e) {
    return Po.lookAt(e), Po.updateMatrix(), this.applyMatrix4(Po.matrix), this;
  }
  center() {
    return this.computeBoundingBox(), this.boundingBox.getCenter(Kn).negate(), this.translate(Kn.x, Kn.y, Kn.z), this;
  }
  setFromPoints(e) {
    const t = [];
    for (let i = 0, n = e.length; i < n; i++) {
      const s = e[i];
      t.push(s.x, s.y, s.z || 0);
    }
    return this.setAttribute("position", new Ee(t, 3)), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new Ht());
    const e = this.attributes.position, t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingBox.set(
        new b(-1 / 0, -1 / 0, -1 / 0),
        new b(1 / 0, 1 / 0, 1 / 0)
      );
      return;
    }
    if (e !== void 0) {
      if (this.boundingBox.setFromBufferAttribute(e), t)
        for (let i = 0, n = t.length; i < n; i++) {
          const s = t[i];
          Jt.setFromBufferAttribute(s), this.morphTargetsRelative ? (Tt.addVectors(this.boundingBox.min, Jt.min), this.boundingBox.expandByPoint(Tt), Tt.addVectors(this.boundingBox.max, Jt.max), this.boundingBox.expandByPoint(Tt)) : (this.boundingBox.expandByPoint(Jt.min), this.boundingBox.expandByPoint(Jt.max));
        }
    } else
      this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new Ci());
    const e = this.attributes.position, t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingSphere.set(new b(), 1 / 0);
      return;
    }
    if (e) {
      const i = this.boundingSphere.center;
      if (Jt.setFromBufferAttribute(e), t)
        for (let s = 0, r = t.length; s < r; s++) {
          const a = t[s];
          qs.setFromBufferAttribute(a), this.morphTargetsRelative ? (Tt.addVectors(Jt.min, qs.min), Jt.expandByPoint(Tt), Tt.addVectors(Jt.max, qs.max), Jt.expandByPoint(Tt)) : (Jt.expandByPoint(qs.min), Jt.expandByPoint(qs.max));
        }
      Jt.getCenter(i);
      let n = 0;
      for (let s = 0, r = e.count; s < r; s++)
        Tt.fromBufferAttribute(e, s), n = Math.max(n, i.distanceToSquared(Tt));
      if (t)
        for (let s = 0, r = t.length; s < r; s++) {
          const a = t[s], l = this.morphTargetsRelative;
          for (let c = 0, h = a.count; c < h; c++)
            Tt.fromBufferAttribute(a, c), l && (Kn.fromBufferAttribute(e, c), Tt.add(Kn)), n = Math.max(n, i.distanceToSquared(Tt));
        }
      this.boundingSphere.radius = Math.sqrt(n), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
    }
  }
  computeTangents() {
    const e = this.index, t = this.attributes;
    if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) {
      console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      return;
    }
    const i = e.array, n = t.position.array, s = t.normal.array, r = t.uv.array, a = n.length / 3;
    this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new $e(new Float32Array(4 * a), 4));
    const l = this.getAttribute("tangent").array, c = [], h = [];
    for (let P = 0; P < a; P++)
      c[P] = new b(), h[P] = new b();
    const u = new b(), d = new b(), f = new b(), m = new G(), _ = new G(), p = new G(), g = new b(), x = new b();
    function y(P, z, V) {
      u.fromArray(n, P * 3), d.fromArray(n, z * 3), f.fromArray(n, V * 3), m.fromArray(r, P * 2), _.fromArray(r, z * 2), p.fromArray(r, V * 2), d.sub(u), f.sub(u), _.sub(m), p.sub(m);
      const O = 1 / (_.x * p.y - p.x * _.y);
      isFinite(O) && (g.copy(d).multiplyScalar(p.y).addScaledVector(f, -_.y).multiplyScalar(O), x.copy(f).multiplyScalar(_.x).addScaledVector(d, -p.x).multiplyScalar(O), c[P].add(g), c[z].add(g), c[V].add(g), h[P].add(x), h[z].add(x), h[V].add(x));
    }
    let v = this.groups;
    v.length === 0 && (v = [{
      start: 0,
      count: i.length
    }]);
    for (let P = 0, z = v.length; P < z; ++P) {
      const V = v[P], O = V.start, D = V.count;
      for (let H = O, Z = O + D; H < Z; H += 3)
        y(
          i[H + 0],
          i[H + 1],
          i[H + 2]
        );
    }
    const M = new b(), S = new b(), A = new b(), w = new b();
    function E(P) {
      A.fromArray(s, P * 3), w.copy(A);
      const z = c[P];
      M.copy(z), M.sub(A.multiplyScalar(A.dot(z))).normalize(), S.crossVectors(w, z);
      const O = S.dot(h[P]) < 0 ? -1 : 1;
      l[P * 4] = M.x, l[P * 4 + 1] = M.y, l[P * 4 + 2] = M.z, l[P * 4 + 3] = O;
    }
    for (let P = 0, z = v.length; P < z; ++P) {
      const V = v[P], O = V.start, D = V.count;
      for (let H = O, Z = O + D; H < Z; H += 3)
        E(i[H + 0]), E(i[H + 1]), E(i[H + 2]);
    }
  }
  computeVertexNormals() {
    const e = this.index, t = this.getAttribute("position");
    if (t !== void 0) {
      let i = this.getAttribute("normal");
      if (i === void 0)
        i = new $e(new Float32Array(t.count * 3), 3), this.setAttribute("normal", i);
      else
        for (let d = 0, f = i.count; d < f; d++)
          i.setXYZ(d, 0, 0, 0);
      const n = new b(), s = new b(), r = new b(), a = new b(), l = new b(), c = new b(), h = new b(), u = new b();
      if (e)
        for (let d = 0, f = e.count; d < f; d += 3) {
          const m = e.getX(d + 0), _ = e.getX(d + 1), p = e.getX(d + 2);
          n.fromBufferAttribute(t, m), s.fromBufferAttribute(t, _), r.fromBufferAttribute(t, p), h.subVectors(r, s), u.subVectors(n, s), h.cross(u), a.fromBufferAttribute(i, m), l.fromBufferAttribute(i, _), c.fromBufferAttribute(i, p), a.add(h), l.add(h), c.add(h), i.setXYZ(m, a.x, a.y, a.z), i.setXYZ(_, l.x, l.y, l.z), i.setXYZ(p, c.x, c.y, c.z);
        }
      else
        for (let d = 0, f = t.count; d < f; d += 3)
          n.fromBufferAttribute(t, d + 0), s.fromBufferAttribute(t, d + 1), r.fromBufferAttribute(t, d + 2), h.subVectors(r, s), u.subVectors(n, s), h.cross(u), i.setXYZ(d + 0, h.x, h.y, h.z), i.setXYZ(d + 1, h.x, h.y, h.z), i.setXYZ(d + 2, h.x, h.y, h.z);
      this.normalizeNormals(), i.needsUpdate = !0;
    }
  }
  // @deprecated since r144
  merge() {
    return console.error("THREE.BufferGeometry.merge() has been removed. Use THREE.BufferGeometryUtils.mergeBufferGeometries() instead."), this;
  }
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let t = 0, i = e.count; t < i; t++)
      Tt.fromBufferAttribute(e, t), Tt.normalize(), e.setXYZ(t, Tt.x, Tt.y, Tt.z);
  }
  toNonIndexed() {
    function e(a, l) {
      const c = a.array, h = a.itemSize, u = a.normalized, d = new c.constructor(l.length * h);
      let f = 0, m = 0;
      for (let _ = 0, p = l.length; _ < p; _++) {
        a.isInterleavedBufferAttribute ? f = l[_] * a.data.stride + a.offset : f = l[_] * h;
        for (let g = 0; g < h; g++)
          d[m++] = c[f++];
      }
      return new $e(d, h, u);
    }
    if (this.index === null)
      return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
    const t = new Ue(), i = this.index.array, n = this.attributes;
    for (const a in n) {
      const l = n[a], c = e(l, i);
      t.setAttribute(a, c);
    }
    const s = this.morphAttributes;
    for (const a in s) {
      const l = [], c = s[a];
      for (let h = 0, u = c.length; h < u; h++) {
        const d = c[h], f = e(d, i);
        l.push(f);
      }
      t.morphAttributes[a] = l;
    }
    t.morphTargetsRelative = this.morphTargetsRelative;
    const r = this.groups;
    for (let a = 0, l = r.length; a < l; a++) {
      const c = r[a];
      t.addGroup(c.start, c.count, c.materialIndex);
    }
    return t;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.5,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), this.parameters !== void 0) {
      const l = this.parameters;
      for (const c in l)
        l[c] !== void 0 && (e[c] = l[c]);
      return e;
    }
    e.data = { attributes: {} };
    const t = this.index;
    t !== null && (e.data.index = {
      type: t.array.constructor.name,
      array: Array.prototype.slice.call(t.array)
    });
    const i = this.attributes;
    for (const l in i) {
      const c = i[l];
      e.data.attributes[l] = c.toJSON(e.data);
    }
    const n = {};
    let s = !1;
    for (const l in this.morphAttributes) {
      const c = this.morphAttributes[l], h = [];
      for (let u = 0, d = c.length; u < d; u++) {
        const f = c[u];
        h.push(f.toJSON(e.data));
      }
      h.length > 0 && (n[l] = h, s = !0);
    }
    s && (e.data.morphAttributes = n, e.data.morphTargetsRelative = this.morphTargetsRelative);
    const r = this.groups;
    r.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(r)));
    const a = this.boundingSphere;
    return a !== null && (e.data.boundingSphere = {
      center: a.center.toArray(),
      radius: a.radius
    }), e;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
    const t = {};
    this.name = e.name;
    const i = e.index;
    i !== null && this.setIndex(i.clone(t));
    const n = e.attributes;
    for (const c in n) {
      const h = n[c];
      this.setAttribute(c, h.clone(t));
    }
    const s = e.morphAttributes;
    for (const c in s) {
      const h = [], u = s[c];
      for (let d = 0, f = u.length; d < f; d++)
        h.push(u[d].clone(t));
      this.morphAttributes[c] = h;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const r = e.groups;
    for (let c = 0, h = r.length; c < h; c++) {
      const u = r[c];
      this.addGroup(u.start, u.count, u.materialIndex);
    }
    const a = e.boundingBox;
    a !== null && (this.boundingBox = a.clone());
    const l = e.boundingSphere;
    return l !== null && (this.boundingSphere = l.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, e.parameters !== void 0 && (this.parameters = Object.assign({}, e.parameters)), this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const ph = /* @__PURE__ */ new ue(), $n = /* @__PURE__ */ new ks(), Ro = /* @__PURE__ */ new Ci(), js = /* @__PURE__ */ new b(), Ys = /* @__PURE__ */ new b(), Zs = /* @__PURE__ */ new b(), Io = /* @__PURE__ */ new b(), jr = /* @__PURE__ */ new b(), Yr = /* @__PURE__ */ new G(), Zr = /* @__PURE__ */ new G(), Jr = /* @__PURE__ */ new G(), Do = /* @__PURE__ */ new b(), Kr = /* @__PURE__ */ new b();
class st extends tt {
  constructor(e = new Ue(), t = new gi()) {
    super(), this.isMesh = !0, this.type = "Mesh", this.geometry = e, this.material = t, this.updateMorphTargets();
  }
  copy(e, t) {
    return super.copy(e, t), e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = e.material, this.geometry = e.geometry, this;
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes, i = Object.keys(t);
    if (i.length > 0) {
      const n = t[i[0]];
      if (n !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let s = 0, r = n.length; s < r; s++) {
          const a = n[s].name || String(s);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = s;
        }
      }
    }
  }
  getVertexPosition(e, t) {
    const i = this.geometry, n = i.attributes.position, s = i.morphAttributes.position, r = i.morphTargetsRelative;
    t.fromBufferAttribute(n, e);
    const a = this.morphTargetInfluences;
    if (s && a) {
      jr.set(0, 0, 0);
      for (let l = 0, c = s.length; l < c; l++) {
        const h = a[l], u = s[l];
        h !== 0 && (Io.fromBufferAttribute(u, e), r ? jr.addScaledVector(Io, h) : jr.addScaledVector(Io.sub(t), h));
      }
      t.add(jr);
    }
    return this.isSkinnedMesh && this.boneTransform(e, t), t;
  }
  raycast(e, t) {
    const i = this.geometry, n = this.material, s = this.matrixWorld;
    if (n === void 0 || (i.boundingSphere === null && i.computeBoundingSphere(), Ro.copy(i.boundingSphere), Ro.applyMatrix4(s), e.ray.intersectsSphere(Ro) === !1) || (ph.copy(s).invert(), $n.copy(e.ray).applyMatrix4(ph), i.boundingBox !== null && $n.intersectsBox(i.boundingBox) === !1))
      return;
    let r;
    const a = i.index, l = i.attributes.position, c = i.attributes.uv, h = i.attributes.uv2, u = i.groups, d = i.drawRange;
    if (a !== null)
      if (Array.isArray(n))
        for (let f = 0, m = u.length; f < m; f++) {
          const _ = u[f], p = n[_.materialIndex], g = Math.max(_.start, d.start), x = Math.min(a.count, Math.min(_.start + _.count, d.start + d.count));
          for (let y = g, v = x; y < v; y += 3) {
            const M = a.getX(y), S = a.getX(y + 1), A = a.getX(y + 2);
            r = $r(this, p, e, $n, c, h, M, S, A), r && (r.faceIndex = Math.floor(y / 3), r.face.materialIndex = _.materialIndex, t.push(r));
          }
        }
      else {
        const f = Math.max(0, d.start), m = Math.min(a.count, d.start + d.count);
        for (let _ = f, p = m; _ < p; _ += 3) {
          const g = a.getX(_), x = a.getX(_ + 1), y = a.getX(_ + 2);
          r = $r(this, n, e, $n, c, h, g, x, y), r && (r.faceIndex = Math.floor(_ / 3), t.push(r));
        }
      }
    else if (l !== void 0)
      if (Array.isArray(n))
        for (let f = 0, m = u.length; f < m; f++) {
          const _ = u[f], p = n[_.materialIndex], g = Math.max(_.start, d.start), x = Math.min(l.count, Math.min(_.start + _.count, d.start + d.count));
          for (let y = g, v = x; y < v; y += 3) {
            const M = y, S = y + 1, A = y + 2;
            r = $r(this, p, e, $n, c, h, M, S, A), r && (r.faceIndex = Math.floor(y / 3), r.face.materialIndex = _.materialIndex, t.push(r));
          }
        }
      else {
        const f = Math.max(0, d.start), m = Math.min(l.count, d.start + d.count);
        for (let _ = f, p = m; _ < p; _ += 3) {
          const g = _, x = _ + 1, y = _ + 2;
          r = $r(this, n, e, $n, c, h, g, x, y), r && (r.faceIndex = Math.floor(_ / 3), t.push(r));
        }
      }
  }
}
function um(o, e, t, i, n, s, r, a) {
  let l;
  if (e.side === oi ? l = i.intersectTriangle(r, s, n, !0, a) : l = i.intersectTriangle(n, s, r, e.side === dn, a), l === null) return null;
  Kr.copy(a), Kr.applyMatrix4(o.matrixWorld);
  const c = t.ray.origin.distanceTo(Kr);
  return c < t.near || c > t.far ? null : {
    distance: c,
    point: Kr.clone(),
    object: o
  };
}
function $r(o, e, t, i, n, s, r, a, l) {
  o.getVertexPosition(r, js), o.getVertexPosition(a, Ys), o.getVertexPosition(l, Zs);
  const c = um(o, e, t, i, js, Ys, Zs, Do);
  if (c) {
    n && (Yr.fromBufferAttribute(n, r), Zr.fromBufferAttribute(n, a), Jr.fromBufferAttribute(n, l), c.uv = _i.getUV(Do, js, Ys, Zs, Yr, Zr, Jr, new G())), s && (Yr.fromBufferAttribute(s, r), Zr.fromBufferAttribute(s, a), Jr.fromBufferAttribute(s, l), c.uv2 = _i.getUV(Do, js, Ys, Zs, Yr, Zr, Jr, new G()));
    const h = {
      a: r,
      b: a,
      c: l,
      normal: new b(),
      materialIndex: 0
    };
    _i.getNormal(js, Ys, Zs, h.normal), c.face = h;
  }
  return c;
}
class zs extends Ue {
  constructor(e = 1, t = 1, i = 1, n = 1, s = 1, r = 1) {
    super(), this.type = "BoxGeometry", this.parameters = {
      width: e,
      height: t,
      depth: i,
      widthSegments: n,
      heightSegments: s,
      depthSegments: r
    };
    const a = this;
    n = Math.floor(n), s = Math.floor(s), r = Math.floor(r);
    const l = [], c = [], h = [], u = [];
    let d = 0, f = 0;
    m("z", "y", "x", -1, -1, i, t, e, r, s, 0), m("z", "y", "x", 1, -1, i, t, -e, r, s, 1), m("x", "z", "y", 1, 1, e, i, t, n, r, 2), m("x", "z", "y", 1, -1, e, i, -t, n, r, 3), m("x", "y", "z", 1, -1, e, t, i, n, s, 4), m("x", "y", "z", -1, -1, e, t, -i, n, s, 5), this.setIndex(l), this.setAttribute("position", new Ee(c, 3)), this.setAttribute("normal", new Ee(h, 3)), this.setAttribute("uv", new Ee(u, 2));
    function m(_, p, g, x, y, v, M, S, A, w, E) {
      const P = v / A, z = M / w, V = v / 2, O = M / 2, D = S / 2, H = A + 1, Z = w + 1;
      let ie = 0, K = 0;
      const ne = new b();
      for (let te = 0; te < Z; te++) {
        const q = te * z - O;
        for (let W = 0; W < H; W++) {
          const le = W * P - V;
          ne[_] = le * x, ne[p] = q * y, ne[g] = D, c.push(ne.x, ne.y, ne.z), ne[_] = 0, ne[p] = 0, ne[g] = S > 0 ? 1 : -1, h.push(ne.x, ne.y, ne.z), u.push(W / A), u.push(1 - te / w), ie += 1;
        }
      }
      for (let te = 0; te < w; te++)
        for (let q = 0; q < A; q++) {
          const W = d + q + H * te, le = d + q + H * (te + 1), ae = d + (q + 1) + H * (te + 1), fe = d + (q + 1) + H * te;
          l.push(W, le, fe), l.push(le, ae, fe), K += 6;
        }
      a.addGroup(f, K, E), f += K, d += ie;
    }
  }
  static fromJSON(e) {
    return new zs(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments);
  }
}
function Ls(o) {
  const e = {};
  for (const t in o) {
    e[t] = {};
    for (const i in o[t]) {
      const n = o[t][i];
      n && (n.isColor || n.isMatrix3 || n.isMatrix4 || n.isVector2 || n.isVector3 || n.isVector4 || n.isTexture || n.isQuaternion) ? e[t][i] = n.clone() : Array.isArray(n) ? e[t][i] = n.slice() : e[t][i] = n;
    }
  }
  return e;
}
function Ft(o) {
  const e = {};
  for (let t = 0; t < o.length; t++) {
    const i = Ls(o[t]);
    for (const n in i)
      e[n] = i[n];
  }
  return e;
}
function dm(o) {
  const e = [];
  for (let t = 0; t < o.length; t++)
    e.push(o[t].clone());
  return e;
}
function gd(o) {
  return o.getRenderTarget() === null && o.outputEncoding === He ? Si : yr;
}
const Lr = { clone: Ls, merge: Ft };
var fm = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, pm = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class xt extends Ct {
  constructor(e) {
    super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = fm, this.fragmentShader = pm, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.extensions = {
      derivatives: !1,
      // set to use derivatives
      fragDepth: !1,
      // set to use fragment depth values
      drawBuffers: !1,
      // set to use draw buffers
      shaderTextureLOD: !1
      // set to use shader texture LOD
    }, this.defaultAttributeValues = {
      color: [1, 1, 1],
      uv: [0, 0],
      uv2: [0, 0]
    }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, e !== void 0 && this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = Ls(e.uniforms), this.uniformsGroups = dm(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    t.glslVersion = this.glslVersion, t.uniforms = {};
    for (const n in this.uniforms) {
      const r = this.uniforms[n].value;
      r && r.isTexture ? t.uniforms[n] = {
        type: "t",
        value: r.toJSON(e).uuid
      } : r && r.isColor ? t.uniforms[n] = {
        type: "c",
        value: r.getHex()
      } : r && r.isVector2 ? t.uniforms[n] = {
        type: "v2",
        value: r.toArray()
      } : r && r.isVector3 ? t.uniforms[n] = {
        type: "v3",
        value: r.toArray()
      } : r && r.isVector4 ? t.uniforms[n] = {
        type: "v4",
        value: r.toArray()
      } : r && r.isMatrix3 ? t.uniforms[n] = {
        type: "m3",
        value: r.toArray()
      } : r && r.isMatrix4 ? t.uniforms[n] = {
        type: "m4",
        value: r.toArray()
      } : t.uniforms[n] = {
        value: r
      };
    }
    Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader;
    const i = {};
    for (const n in this.extensions)
      this.extensions[n] === !0 && (i[n] = !0);
    return Object.keys(i).length > 0 && (t.extensions = i), t;
  }
}
class vd extends tt {
  constructor() {
    super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new ue(), this.projectionMatrix = new ue(), this.projectionMatrixInverse = new ue();
  }
  copy(e, t) {
    return super.copy(e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this;
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const t = this.matrixWorld.elements;
    return e.set(-t[8], -t[9], -t[10]).normalize();
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(e, t) {
    super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class gt extends vd {
  constructor(e = 50, t = 1, i = 0.1, n = 2e3) {
    super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = i, this.far = n, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
  }
  copy(e, t) {
    return super.copy(e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = e.view === null ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this;
  }
  /**
   * Sets the FOV by focal length in respect to the current .filmGauge.
   *
   * The default film gauge is 35, so that the focal length can be specified for
   * a 35mm (full frame) camera.
   *
   * Values for focal length and film gauge must have the same unit.
   */
  setFocalLength(e) {
    const t = 0.5 * this.getFilmHeight() / e;
    this.fov = xr * 2 * Math.atan(t), this.updateProjectionMatrix();
  }
  /**
   * Calculates the focal length from the current .fov and .filmGauge.
   */
  getFocalLength() {
    const e = Math.tan(Ss * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / e;
  }
  getEffectiveFOV() {
    return xr * 2 * Math.atan(
      Math.tan(Ss * 0.5 * this.fov) / this.zoom
    );
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  /**
   * Sets an offset in a larger frustum. This is useful for multi-window or
   * multi-monitor/multi-machine setups.
   *
   * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
   * the monitors are in grid like this
   *
   *   +---+---+---+
   *   | A | B | C |
   *   +---+---+---+
   *   | D | E | F |
   *   +---+---+---+
   *
   * then for each monitor you would call it like this
   *
   *   const w = 1920;
   *   const h = 1080;
   *   const fullWidth = w * 3;
   *   const fullHeight = h * 2;
   *
   *   --A--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
   *   --B--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
   *   --C--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
   *   --D--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
   *   --E--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
   *   --F--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
   *
   *   Note there is no reason monitors have to be the same size or in a grid.
   */
  setViewOffset(e, t, i, n, s, r) {
    this.aspect = e / t, this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = i, this.view.offsetY = n, this.view.width = s, this.view.height = r, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = this.near;
    let t = e * Math.tan(Ss * 0.5 * this.fov) / this.zoom, i = 2 * t, n = this.aspect * i, s = -0.5 * n;
    const r = this.view;
    if (this.view !== null && this.view.enabled) {
      const l = r.fullWidth, c = r.fullHeight;
      s += r.offsetX * n / l, t -= r.offsetY * i / c, n *= r.width / l, i *= r.height / c;
    }
    const a = this.filmOffset;
    a !== 0 && (s += e * a / this.getFilmWidth()), this.projectionMatrix.makePerspective(s, s + n, t, t - i, e, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, this.view !== null && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t;
  }
}
const Qn = -90, es = 1;
class mm extends tt {
  constructor(e, t, i) {
    super(), this.type = "CubeCamera", this.renderTarget = i;
    const n = new gt(Qn, es, e, t);
    n.layers = this.layers, n.up.set(0, 1, 0), n.lookAt(1, 0, 0), this.add(n);
    const s = new gt(Qn, es, e, t);
    s.layers = this.layers, s.up.set(0, 1, 0), s.lookAt(-1, 0, 0), this.add(s);
    const r = new gt(Qn, es, e, t);
    r.layers = this.layers, r.up.set(0, 0, -1), r.lookAt(0, 1, 0), this.add(r);
    const a = new gt(Qn, es, e, t);
    a.layers = this.layers, a.up.set(0, 0, 1), a.lookAt(0, -1, 0), this.add(a);
    const l = new gt(Qn, es, e, t);
    l.layers = this.layers, l.up.set(0, 1, 0), l.lookAt(0, 0, 1), this.add(l);
    const c = new gt(Qn, es, e, t);
    c.layers = this.layers, c.up.set(0, 1, 0), c.lookAt(0, 0, -1), this.add(c);
  }
  update(e, t) {
    this.parent === null && this.updateMatrixWorld();
    const i = this.renderTarget, [n, s, r, a, l, c] = this.children, h = e.getRenderTarget(), u = e.toneMapping, d = e.xr.enabled;
    e.toneMapping = Wi, e.xr.enabled = !1;
    const f = i.texture.generateMipmaps;
    i.texture.generateMipmaps = !1, e.setRenderTarget(i, 0), e.render(t, n), e.setRenderTarget(i, 1), e.render(t, s), e.setRenderTarget(i, 2), e.render(t, r), e.setRenderTarget(i, 3), e.render(t, a), e.setRenderTarget(i, 4), e.render(t, l), i.texture.generateMipmaps = f, e.setRenderTarget(i, 5), e.render(t, c), e.setRenderTarget(h), e.toneMapping = u, e.xr.enabled = d, i.texture.needsPMREMUpdate = !0;
  }
}
class Za extends dt {
  constructor(e, t, i, n, s, r, a, l, c, h) {
    e = e !== void 0 ? e : [], t = t !== void 0 ? t : Nn, super(e, t, i, n, s, r, a, l, c, h), this.isCubeTexture = !0, this.flipY = !1;
  }
  get images() {
    return this.image;
  }
  set images(e) {
    this.image = e;
  }
}
class _m extends Ot {
  constructor(e = 1, t = {}) {
    super(e, e, t), this.isWebGLCubeRenderTarget = !0;
    const i = { width: e, height: e, depth: 1 }, n = [i, i, i, i, i, i];
    this.texture = new Za(n, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.encoding), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = t.generateMipmaps !== void 0 ? t.generateMipmaps : !1, this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : Ut;
  }
  fromEquirectangularTexture(e, t) {
    this.texture.type = t.type, this.texture.encoding = t.encoding, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter;
    const i = {
      uniforms: {
        tEquirect: { value: null }
      },
      vertexShader: (
        /* glsl */
        `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`
      ),
      fragmentShader: (
        /* glsl */
        `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
      )
    }, n = new zs(5, 5, 5), s = new xt({
      name: "CubemapFromEquirect",
      uniforms: Ls(i.uniforms),
      vertexShader: i.vertexShader,
      fragmentShader: i.fragmentShader,
      side: oi,
      blending: Ti
    });
    s.uniforms.tEquirect.value = t;
    const r = new st(n, s), a = t.minFilter;
    return t.minFilter === fn && (t.minFilter = Ut), new mm(1, 10, this).update(e, r), t.minFilter = a, r.geometry.dispose(), r.material.dispose(), this;
  }
  clear(e, t, i, n) {
    const s = e.getRenderTarget();
    for (let r = 0; r < 6; r++)
      e.setRenderTarget(this, r), e.clear(t, i, n);
    e.setRenderTarget(s);
  }
}
const Oo = /* @__PURE__ */ new b(), gm = /* @__PURE__ */ new b(), vm = /* @__PURE__ */ new Gt();
class An {
  constructor(e = new b(1, 0, 0), t = 0) {
    this.isPlane = !0, this.normal = e, this.constant = t;
  }
  set(e, t) {
    return this.normal.copy(e), this.constant = t, this;
  }
  setComponents(e, t, i, n) {
    return this.normal.set(e, t, i), this.constant = n, this;
  }
  setFromNormalAndCoplanarPoint(e, t) {
    return this.normal.copy(e), this.constant = -t.dot(this.normal), this;
  }
  setFromCoplanarPoints(e, t, i) {
    const n = Oo.subVectors(i, t).cross(gm.subVectors(e, t)).normalize();
    return this.setFromNormalAndCoplanarPoint(n, e), this;
  }
  copy(e) {
    return this.normal.copy(e.normal), this.constant = e.constant, this;
  }
  normalize() {
    const e = 1 / this.normal.length();
    return this.normal.multiplyScalar(e), this.constant *= e, this;
  }
  negate() {
    return this.constant *= -1, this.normal.negate(), this;
  }
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant;
  }
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius;
  }
  projectPoint(e, t) {
    return t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e);
  }
  intersectLine(e, t) {
    const i = e.delta(Oo), n = this.normal.dot(i);
    if (n === 0)
      return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
    const s = -(e.start.dot(this.normal) + this.constant) / n;
    return s < 0 || s > 1 ? null : t.copy(i).multiplyScalar(s).add(e.start);
  }
  intersectsLine(e) {
    const t = this.distanceToPoint(e.start), i = this.distanceToPoint(e.end);
    return t < 0 && i > 0 || i < 0 && t > 0;
  }
  intersectsBox(e) {
    return e.intersectsPlane(this);
  }
  intersectsSphere(e) {
    return e.intersectsPlane(this);
  }
  coplanarPoint(e) {
    return e.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(e, t) {
    const i = t || vm.getNormalMatrix(e), n = this.coplanarPoint(Oo).applyMatrix4(e), s = this.normal.applyMatrix3(i).normalize();
    return this.constant = -n.dot(s), this;
  }
  translate(e) {
    return this.constant -= e.dot(this.normal), this;
  }
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const ts = /* @__PURE__ */ new Ci(), Qr = /* @__PURE__ */ new b();
class Ja {
  constructor(e = new An(), t = new An(), i = new An(), n = new An(), s = new An(), r = new An()) {
    this.planes = [e, t, i, n, s, r];
  }
  set(e, t, i, n, s, r) {
    const a = this.planes;
    return a[0].copy(e), a[1].copy(t), a[2].copy(i), a[3].copy(n), a[4].copy(s), a[5].copy(r), this;
  }
  copy(e) {
    const t = this.planes;
    for (let i = 0; i < 6; i++)
      t[i].copy(e.planes[i]);
    return this;
  }
  setFromProjectionMatrix(e) {
    const t = this.planes, i = e.elements, n = i[0], s = i[1], r = i[2], a = i[3], l = i[4], c = i[5], h = i[6], u = i[7], d = i[8], f = i[9], m = i[10], _ = i[11], p = i[12], g = i[13], x = i[14], y = i[15];
    return t[0].setComponents(a - n, u - l, _ - d, y - p).normalize(), t[1].setComponents(a + n, u + l, _ + d, y + p).normalize(), t[2].setComponents(a + s, u + c, _ + f, y + g).normalize(), t[3].setComponents(a - s, u - c, _ - f, y - g).normalize(), t[4].setComponents(a - r, u - h, _ - m, y - x).normalize(), t[5].setComponents(a + r, u + h, _ + m, y + x).normalize(), this;
  }
  intersectsObject(e) {
    const t = e.geometry;
    return t.boundingSphere === null && t.computeBoundingSphere(), ts.copy(t.boundingSphere).applyMatrix4(e.matrixWorld), this.intersectsSphere(ts);
  }
  intersectsSprite(e) {
    return ts.center.set(0, 0, 0), ts.radius = 0.7071067811865476, ts.applyMatrix4(e.matrixWorld), this.intersectsSphere(ts);
  }
  intersectsSphere(e) {
    const t = this.planes, i = e.center, n = -e.radius;
    for (let s = 0; s < 6; s++)
      if (t[s].distanceToPoint(i) < n)
        return !1;
    return !0;
  }
  intersectsBox(e) {
    const t = this.planes;
    for (let i = 0; i < 6; i++) {
      const n = t[i];
      if (Qr.x = n.normal.x > 0 ? e.max.x : e.min.x, Qr.y = n.normal.y > 0 ? e.max.y : e.min.y, Qr.z = n.normal.z > 0 ? e.max.z : e.min.z, n.distanceToPoint(Qr) < 0)
        return !1;
    }
    return !0;
  }
  containsPoint(e) {
    const t = this.planes;
    for (let i = 0; i < 6; i++)
      if (t[i].distanceToPoint(e) < 0)
        return !1;
    return !0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
function yd() {
  let o = null, e = !1, t = null, i = null;
  function n(s, r) {
    t(s, r), i = o.requestAnimationFrame(n);
  }
  return {
    start: function() {
      e !== !0 && t !== null && (i = o.requestAnimationFrame(n), e = !0);
    },
    stop: function() {
      o.cancelAnimationFrame(i), e = !1;
    },
    setAnimationLoop: function(s) {
      t = s;
    },
    setContext: function(s) {
      o = s;
    }
  };
}
function ym(o, e) {
  const t = e.isWebGL2, i = /* @__PURE__ */ new WeakMap();
  function n(c, h) {
    const u = c.array, d = c.usage, f = o.createBuffer();
    o.bindBuffer(h, f), o.bufferData(h, u, d), c.onUploadCallback();
    let m;
    if (u instanceof Float32Array)
      m = 5126;
    else if (u instanceof Uint16Array)
      if (c.isFloat16BufferAttribute)
        if (t)
          m = 5131;
        else
          throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
      else
        m = 5123;
    else if (u instanceof Int16Array)
      m = 5122;
    else if (u instanceof Uint32Array)
      m = 5125;
    else if (u instanceof Int32Array)
      m = 5124;
    else if (u instanceof Int8Array)
      m = 5120;
    else if (u instanceof Uint8Array)
      m = 5121;
    else if (u instanceof Uint8ClampedArray)
      m = 5121;
    else
      throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + u);
    return {
      buffer: f,
      type: m,
      bytesPerElement: u.BYTES_PER_ELEMENT,
      version: c.version
    };
  }
  function s(c, h, u) {
    const d = h.array, f = h.updateRange;
    o.bindBuffer(u, c), f.count === -1 ? o.bufferSubData(u, 0, d) : (t ? o.bufferSubData(
      u,
      f.offset * d.BYTES_PER_ELEMENT,
      d,
      f.offset,
      f.count
    ) : o.bufferSubData(
      u,
      f.offset * d.BYTES_PER_ELEMENT,
      d.subarray(f.offset, f.offset + f.count)
    ), f.count = -1), h.onUploadCallback();
  }
  function r(c) {
    return c.isInterleavedBufferAttribute && (c = c.data), i.get(c);
  }
  function a(c) {
    c.isInterleavedBufferAttribute && (c = c.data);
    const h = i.get(c);
    h && (o.deleteBuffer(h.buffer), i.delete(c));
  }
  function l(c, h) {
    if (c.isGLBufferAttribute) {
      const d = i.get(c);
      (!d || d.version < c.version) && i.set(c, {
        buffer: c.buffer,
        type: c.type,
        bytesPerElement: c.elementSize,
        version: c.version
      });
      return;
    }
    c.isInterleavedBufferAttribute && (c = c.data);
    const u = i.get(c);
    u === void 0 ? i.set(c, n(c, h)) : u.version < c.version && (s(u.buffer, c, h), u.version = c.version);
  }
  return {
    get: r,
    remove: a,
    update: l
  };
}
class Pr extends Ue {
  constructor(e = 1, t = 1, i = 1, n = 1) {
    super(), this.type = "PlaneGeometry", this.parameters = {
      width: e,
      height: t,
      widthSegments: i,
      heightSegments: n
    };
    const s = e / 2, r = t / 2, a = Math.floor(i), l = Math.floor(n), c = a + 1, h = l + 1, u = e / a, d = t / l, f = [], m = [], _ = [], p = [];
    for (let g = 0; g < h; g++) {
      const x = g * d - r;
      for (let y = 0; y < c; y++) {
        const v = y * u - s;
        m.push(v, -x, 0), _.push(0, 0, 1), p.push(y / a), p.push(1 - g / l);
      }
    }
    for (let g = 0; g < l; g++)
      for (let x = 0; x < a; x++) {
        const y = x + c * g, v = x + c * (g + 1), M = x + 1 + c * (g + 1), S = x + 1 + c * g;
        f.push(y, v, S), f.push(v, M, S);
      }
    this.setIndex(f), this.setAttribute("position", new Ee(m, 3)), this.setAttribute("normal", new Ee(_, 3)), this.setAttribute("uv", new Ee(p, 2));
  }
  static fromJSON(e) {
    return new Pr(e.width, e.height, e.widthSegments, e.heightSegments);
  }
}
var xm = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`, wm = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, bm = `#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`, Mm = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`, Sm = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`, Tm = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`, Am = "vec3 transformed = vec3( position );", Em = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`, Cm = `vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( V * D );
}
#ifdef USE_IRIDESCENCE
	vec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif`, Lm = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			 return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float R21 = R12;
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`, Pm = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = dFdx( surf_pos.xyz );
		vec3 vSigmaY = dFdy( surf_pos.xyz );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`, Rm = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`, Im = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`, Dm = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`, Om = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`, Nm = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`, km = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`, zm = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`, Fm = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`, Bm = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`, Um = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_v0 0.339
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_v1 0.276
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_v4 0.046
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_v5 0.016
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_v6 0.0038
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`, Vm = `vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`, Gm = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`, Hm = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`, Wm = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`, Xm = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`, qm = "gl_FragColor = linearToOutputTexel( gl_FragColor );", jm = `vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`, Ym = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`, Zm = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`, Jm = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`, Km = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`, $m = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`, Qm = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`, e_ = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`, t_ = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`, i_ = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`, n_ = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`, s_ = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vUv2 );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`, r_ = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`, a_ = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`, o_ = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`, l_ = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( PHYSICALLY_CORRECT_LIGHTS )
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#else
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`, c_ = `#if defined( USE_ENVMAP )
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
#endif`, h_ = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`, u_ = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`, d_ = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`, f_ = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`, p_ = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULARINTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;
		#endif
		#ifdef USE_SPECULARCOLORMAP
			specularColorFactor *= texture2D( specularColorMap, vUv ).rgb;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEENCOLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEENROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;
	#endif
#endif`, m_ = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
	#endif
	#ifdef USE_IRIDESCENCE
		reflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );
	#else
		reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`, __ = `
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometry.viewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`, g_ = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`, v_ = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`, y_ = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`, x_ = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, w_ = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`, b_ = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`, M_ = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`, S_ = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`, T_ = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`, A_ = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, E_ = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`, C_ = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`, L_ = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`, P_ = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`, R_ = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`, I_ = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`, D_ = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`, O_ = `#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`, N_ = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, k_ = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, z_ = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`, F_ = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );
		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );
	}
#endif`, B_ = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`, U_ = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );
	#endif
#endif`, V_ = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`, G_ = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`, H_ = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha + 0.1;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`, W_ = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`, X_ = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`, q_ = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`, j_ = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`, Y_ = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`, Z_ = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`, J_ = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`, K_ = `#if NUM_SPOT_LIGHT_COORDS > 0
  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
  uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`, $_ = `#if NUM_SPOT_LIGHT_COORDS > 0
  uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`, Q_ = `#if defined( USE_SHADOWMAP ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_COORDS > 0 || NUM_POINT_LIGHT_SHADOWS > 0
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;
	#endif
	#if NUM_DIR_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
#endif`, eg = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`, tg = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`, ig = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	uniform int boneTextureSize;
	mat4 getBoneMatrix( const in float i ) {
		float j = i * 4.0;
		float x = mod( j, float( boneTextureSize ) );
		float y = floor( j / float( boneTextureSize ) );
		float dx = 1.0 / float( boneTextureSize );
		float dy = 1.0 / float( boneTextureSize );
		y = dy * ( y + 0.5 );
		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
		mat4 bone = mat4( v1, v2, v3, v4 );
		return bone;
	}
#endif`, ng = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`, sg = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`, rg = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`, ag = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`, og = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`, lg = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`, cg = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmission = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmission.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmission.rgb, material.transmission );
#endif`, hg = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		#ifdef texture2DLodEXT
			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#else
			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#endif
	}
	vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return radiance;
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );
	}
#endif`, ug = `#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`, dg = `#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`, fg = `#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`, pg = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`, mg = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`, _g = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`, gg = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const vg = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`, yg = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`, xg = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, wg = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`, bg = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, Mg = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`, Sg = `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`, Tg = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`, Ag = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`, Eg = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`, Cg = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`, Lg = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`, Pg = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, Rg = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, Ig = `#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`, Dg = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, Og = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, Ng = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, kg = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`, zg = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, Fg = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`, Bg = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`, Ug = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, Vg = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, Gg = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`, Hg = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULARINTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
	#ifdef USE_SPECULARCOLORMAP
		uniform sampler2D specularColorMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEENCOLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEENROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, Wg = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, Xg = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, qg = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`, jg = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, Yg = `#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, Zg = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`, Jg = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, Kg = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`, Fe = {
  alphamap_fragment: xm,
  alphamap_pars_fragment: wm,
  alphatest_fragment: bm,
  alphatest_pars_fragment: Mm,
  aomap_fragment: Sm,
  aomap_pars_fragment: Tm,
  begin_vertex: Am,
  beginnormal_vertex: Em,
  bsdfs: Cm,
  iridescence_fragment: Lm,
  bumpmap_pars_fragment: Pm,
  clipping_planes_fragment: Rm,
  clipping_planes_pars_fragment: Im,
  clipping_planes_pars_vertex: Dm,
  clipping_planes_vertex: Om,
  color_fragment: Nm,
  color_pars_fragment: km,
  color_pars_vertex: zm,
  color_vertex: Fm,
  common: Bm,
  cube_uv_reflection_fragment: Um,
  defaultnormal_vertex: Vm,
  displacementmap_pars_vertex: Gm,
  displacementmap_vertex: Hm,
  emissivemap_fragment: Wm,
  emissivemap_pars_fragment: Xm,
  encodings_fragment: qm,
  encodings_pars_fragment: jm,
  envmap_fragment: Ym,
  envmap_common_pars_fragment: Zm,
  envmap_pars_fragment: Jm,
  envmap_pars_vertex: Km,
  envmap_physical_pars_fragment: c_,
  envmap_vertex: $m,
  fog_vertex: Qm,
  fog_pars_vertex: e_,
  fog_fragment: t_,
  fog_pars_fragment: i_,
  gradientmap_pars_fragment: n_,
  lightmap_fragment: s_,
  lightmap_pars_fragment: r_,
  lights_lambert_fragment: a_,
  lights_lambert_pars_fragment: o_,
  lights_pars_begin: l_,
  lights_toon_fragment: h_,
  lights_toon_pars_fragment: u_,
  lights_phong_fragment: d_,
  lights_phong_pars_fragment: f_,
  lights_physical_fragment: p_,
  lights_physical_pars_fragment: m_,
  lights_fragment_begin: __,
  lights_fragment_maps: g_,
  lights_fragment_end: v_,
  logdepthbuf_fragment: y_,
  logdepthbuf_pars_fragment: x_,
  logdepthbuf_pars_vertex: w_,
  logdepthbuf_vertex: b_,
  map_fragment: M_,
  map_pars_fragment: S_,
  map_particle_fragment: T_,
  map_particle_pars_fragment: A_,
  metalnessmap_fragment: E_,
  metalnessmap_pars_fragment: C_,
  morphcolor_vertex: L_,
  morphnormal_vertex: P_,
  morphtarget_pars_vertex: R_,
  morphtarget_vertex: I_,
  normal_fragment_begin: D_,
  normal_fragment_maps: O_,
  normal_pars_fragment: N_,
  normal_pars_vertex: k_,
  normal_vertex: z_,
  normalmap_pars_fragment: F_,
  clearcoat_normal_fragment_begin: B_,
  clearcoat_normal_fragment_maps: U_,
  clearcoat_pars_fragment: V_,
  iridescence_pars_fragment: G_,
  output_fragment: H_,
  packing: W_,
  premultiplied_alpha_fragment: X_,
  project_vertex: q_,
  dithering_fragment: j_,
  dithering_pars_fragment: Y_,
  roughnessmap_fragment: Z_,
  roughnessmap_pars_fragment: J_,
  shadowmap_pars_fragment: K_,
  shadowmap_pars_vertex: $_,
  shadowmap_vertex: Q_,
  shadowmask_pars_fragment: eg,
  skinbase_vertex: tg,
  skinning_pars_vertex: ig,
  skinning_vertex: ng,
  skinnormal_vertex: sg,
  specularmap_fragment: rg,
  specularmap_pars_fragment: ag,
  tonemapping_fragment: og,
  tonemapping_pars_fragment: lg,
  transmission_fragment: cg,
  transmission_pars_fragment: hg,
  uv_pars_fragment: ug,
  uv_pars_vertex: dg,
  uv_vertex: fg,
  uv2_pars_fragment: pg,
  uv2_pars_vertex: mg,
  uv2_vertex: _g,
  worldpos_vertex: gg,
  background_vert: vg,
  background_frag: yg,
  backgroundCube_vert: xg,
  backgroundCube_frag: wg,
  cube_vert: bg,
  cube_frag: Mg,
  depth_vert: Sg,
  depth_frag: Tg,
  distanceRGBA_vert: Ag,
  distanceRGBA_frag: Eg,
  equirect_vert: Cg,
  equirect_frag: Lg,
  linedashed_vert: Pg,
  linedashed_frag: Rg,
  meshbasic_vert: Ig,
  meshbasic_frag: Dg,
  meshlambert_vert: Og,
  meshlambert_frag: Ng,
  meshmatcap_vert: kg,
  meshmatcap_frag: zg,
  meshnormal_vert: Fg,
  meshnormal_frag: Bg,
  meshphong_vert: Ug,
  meshphong_frag: Vg,
  meshphysical_vert: Gg,
  meshphysical_frag: Hg,
  meshtoon_vert: Wg,
  meshtoon_frag: Xg,
  points_vert: qg,
  points_frag: jg,
  shadow_vert: Yg,
  shadow_frag: Zg,
  sprite_vert: Jg,
  sprite_frag: Kg
}, he = {
  common: {
    diffuse: { value: /* @__PURE__ */ new de(16777215) },
    opacity: { value: 1 },
    map: { value: null },
    uvTransform: { value: /* @__PURE__ */ new Gt() },
    uv2Transform: { value: /* @__PURE__ */ new Gt() },
    alphaMap: { value: null },
    alphaTest: { value: 0 }
  },
  specularmap: {
    specularMap: { value: null }
  },
  envmap: {
    envMap: { value: null },
    flipEnvMap: { value: -1 },
    reflectivity: { value: 1 },
    // basic, lambert, phong
    ior: { value: 1.5 },
    // physical
    refractionRatio: { value: 0.98 }
    // basic, lambert, phong
  },
  aomap: {
    aoMap: { value: null },
    aoMapIntensity: { value: 1 }
  },
  lightmap: {
    lightMap: { value: null },
    lightMapIntensity: { value: 1 }
  },
  emissivemap: {
    emissiveMap: { value: null }
  },
  bumpmap: {
    bumpMap: { value: null },
    bumpScale: { value: 1 }
  },
  normalmap: {
    normalMap: { value: null },
    normalScale: { value: /* @__PURE__ */ new G(1, 1) }
  },
  displacementmap: {
    displacementMap: { value: null },
    displacementScale: { value: 1 },
    displacementBias: { value: 0 }
  },
  roughnessmap: {
    roughnessMap: { value: null }
  },
  metalnessmap: {
    metalnessMap: { value: null }
  },
  gradientmap: {
    gradientMap: { value: null }
  },
  fog: {
    fogDensity: { value: 25e-5 },
    fogNear: { value: 1 },
    fogFar: { value: 2e3 },
    fogColor: { value: /* @__PURE__ */ new de(16777215) }
  },
  lights: {
    ambientLightColor: { value: [] },
    lightProbe: { value: [] },
    directionalLights: { value: [], properties: {
      direction: {},
      color: {}
    } },
    directionalLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    directionalShadowMap: { value: [] },
    directionalShadowMatrix: { value: [] },
    spotLights: { value: [], properties: {
      color: {},
      position: {},
      direction: {},
      distance: {},
      coneCos: {},
      penumbraCos: {},
      decay: {}
    } },
    spotLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    spotLightMap: { value: [] },
    spotShadowMap: { value: [] },
    spotLightMatrix: { value: [] },
    pointLights: { value: [], properties: {
      color: {},
      position: {},
      decay: {},
      distance: {}
    } },
    pointLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {},
      shadowCameraNear: {},
      shadowCameraFar: {}
    } },
    pointShadowMap: { value: [] },
    pointShadowMatrix: { value: [] },
    hemisphereLights: { value: [], properties: {
      direction: {},
      skyColor: {},
      groundColor: {}
    } },
    // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
    rectAreaLights: { value: [], properties: {
      color: {},
      position: {},
      width: {},
      height: {}
    } },
    ltc_1: { value: null },
    ltc_2: { value: null }
  },
  points: {
    diffuse: { value: /* @__PURE__ */ new de(16777215) },
    opacity: { value: 1 },
    size: { value: 1 },
    scale: { value: 1 },
    map: { value: null },
    alphaMap: { value: null },
    alphaTest: { value: 0 },
    uvTransform: { value: /* @__PURE__ */ new Gt() }
  },
  sprite: {
    diffuse: { value: /* @__PURE__ */ new de(16777215) },
    opacity: { value: 1 },
    center: { value: /* @__PURE__ */ new G(0.5, 0.5) },
    rotation: { value: 0 },
    map: { value: null },
    alphaMap: { value: null },
    alphaTest: { value: 0 },
    uvTransform: { value: /* @__PURE__ */ new Gt() }
  }
}, qt = {
  basic: {
    uniforms: /* @__PURE__ */ Ft([
      he.common,
      he.specularmap,
      he.envmap,
      he.aomap,
      he.lightmap,
      he.fog
    ]),
    vertexShader: Fe.meshbasic_vert,
    fragmentShader: Fe.meshbasic_frag
  },
  lambert: {
    uniforms: /* @__PURE__ */ Ft([
      he.common,
      he.specularmap,
      he.envmap,
      he.aomap,
      he.lightmap,
      he.emissivemap,
      he.bumpmap,
      he.normalmap,
      he.displacementmap,
      he.fog,
      he.lights,
      {
        emissive: { value: /* @__PURE__ */ new de(0) }
      }
    ]),
    vertexShader: Fe.meshlambert_vert,
    fragmentShader: Fe.meshlambert_frag
  },
  phong: {
    uniforms: /* @__PURE__ */ Ft([
      he.common,
      he.specularmap,
      he.envmap,
      he.aomap,
      he.lightmap,
      he.emissivemap,
      he.bumpmap,
      he.normalmap,
      he.displacementmap,
      he.fog,
      he.lights,
      {
        emissive: { value: /* @__PURE__ */ new de(0) },
        specular: { value: /* @__PURE__ */ new de(1118481) },
        shininess: { value: 30 }
      }
    ]),
    vertexShader: Fe.meshphong_vert,
    fragmentShader: Fe.meshphong_frag
  },
  standard: {
    uniforms: /* @__PURE__ */ Ft([
      he.common,
      he.envmap,
      he.aomap,
      he.lightmap,
      he.emissivemap,
      he.bumpmap,
      he.normalmap,
      he.displacementmap,
      he.roughnessmap,
      he.metalnessmap,
      he.fog,
      he.lights,
      {
        emissive: { value: /* @__PURE__ */ new de(0) },
        roughness: { value: 1 },
        metalness: { value: 0 },
        envMapIntensity: { value: 1 }
        // temporary
      }
    ]),
    vertexShader: Fe.meshphysical_vert,
    fragmentShader: Fe.meshphysical_frag
  },
  toon: {
    uniforms: /* @__PURE__ */ Ft([
      he.common,
      he.aomap,
      he.lightmap,
      he.emissivemap,
      he.bumpmap,
      he.normalmap,
      he.displacementmap,
      he.gradientmap,
      he.fog,
      he.lights,
      {
        emissive: { value: /* @__PURE__ */ new de(0) }
      }
    ]),
    vertexShader: Fe.meshtoon_vert,
    fragmentShader: Fe.meshtoon_frag
  },
  matcap: {
    uniforms: /* @__PURE__ */ Ft([
      he.common,
      he.bumpmap,
      he.normalmap,
      he.displacementmap,
      he.fog,
      {
        matcap: { value: null }
      }
    ]),
    vertexShader: Fe.meshmatcap_vert,
    fragmentShader: Fe.meshmatcap_frag
  },
  points: {
    uniforms: /* @__PURE__ */ Ft([
      he.points,
      he.fog
    ]),
    vertexShader: Fe.points_vert,
    fragmentShader: Fe.points_frag
  },
  dashed: {
    uniforms: /* @__PURE__ */ Ft([
      he.common,
      he.fog,
      {
        scale: { value: 1 },
        dashSize: { value: 1 },
        totalSize: { value: 2 }
      }
    ]),
    vertexShader: Fe.linedashed_vert,
    fragmentShader: Fe.linedashed_frag
  },
  depth: {
    uniforms: /* @__PURE__ */ Ft([
      he.common,
      he.displacementmap
    ]),
    vertexShader: Fe.depth_vert,
    fragmentShader: Fe.depth_frag
  },
  normal: {
    uniforms: /* @__PURE__ */ Ft([
      he.common,
      he.bumpmap,
      he.normalmap,
      he.displacementmap,
      {
        opacity: { value: 1 }
      }
    ]),
    vertexShader: Fe.meshnormal_vert,
    fragmentShader: Fe.meshnormal_frag
  },
  sprite: {
    uniforms: /* @__PURE__ */ Ft([
      he.sprite,
      he.fog
    ]),
    vertexShader: Fe.sprite_vert,
    fragmentShader: Fe.sprite_frag
  },
  background: {
    uniforms: {
      uvTransform: { value: /* @__PURE__ */ new Gt() },
      t2D: { value: null },
      backgroundIntensity: { value: 1 }
    },
    vertexShader: Fe.background_vert,
    fragmentShader: Fe.background_frag
  },
  backgroundCube: {
    uniforms: {
      envMap: { value: null },
      flipEnvMap: { value: -1 },
      backgroundBlurriness: { value: 0 },
      backgroundIntensity: { value: 1 }
    },
    vertexShader: Fe.backgroundCube_vert,
    fragmentShader: Fe.backgroundCube_frag
  },
  cube: {
    uniforms: {
      tCube: { value: null },
      tFlip: { value: -1 },
      opacity: { value: 1 }
    },
    vertexShader: Fe.cube_vert,
    fragmentShader: Fe.cube_frag
  },
  equirect: {
    uniforms: {
      tEquirect: { value: null }
    },
    vertexShader: Fe.equirect_vert,
    fragmentShader: Fe.equirect_frag
  },
  distanceRGBA: {
    uniforms: /* @__PURE__ */ Ft([
      he.common,
      he.displacementmap,
      {
        referencePosition: { value: /* @__PURE__ */ new b() },
        nearDistance: { value: 1 },
        farDistance: { value: 1e3 }
      }
    ]),
    vertexShader: Fe.distanceRGBA_vert,
    fragmentShader: Fe.distanceRGBA_frag
  },
  shadow: {
    uniforms: /* @__PURE__ */ Ft([
      he.lights,
      he.fog,
      {
        color: { value: /* @__PURE__ */ new de(0) },
        opacity: { value: 1 }
      }
    ]),
    vertexShader: Fe.shadow_vert,
    fragmentShader: Fe.shadow_frag
  }
};
qt.physical = {
  uniforms: /* @__PURE__ */ Ft([
    qt.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatNormalScale: { value: /* @__PURE__ */ new G(1, 1) },
      clearcoatNormalMap: { value: null },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      sheen: { value: 0 },
      sheenColor: { value: /* @__PURE__ */ new de(0) },
      sheenColorMap: { value: null },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionSamplerSize: { value: /* @__PURE__ */ new G() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: /* @__PURE__ */ new de(0) },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularColor: { value: /* @__PURE__ */ new de(1, 1, 1) },
      specularColorMap: { value: null }
    }
  ]),
  vertexShader: Fe.meshphysical_vert,
  fragmentShader: Fe.meshphysical_frag
};
const ea = { r: 0, b: 0, g: 0 };
function $g(o, e, t, i, n, s, r) {
  const a = new de(0);
  let l = s === !0 ? 0 : 1, c, h, u = null, d = 0, f = null;
  function m(p, g) {
    let x = !1, y = g.isScene === !0 ? g.background : null;
    y && y.isTexture && (y = (g.backgroundBlurriness > 0 ? t : e).get(y));
    const v = o.xr, M = v.getSession && v.getSession();
    M && M.environmentBlendMode === "additive" && (y = null), y === null ? _(a, l) : y && y.isColor && (_(y, 1), x = !0), (o.autoClear || x) && o.clear(o.autoClearColor, o.autoClearDepth, o.autoClearStencil), y && (y.isCubeTexture || y.mapping === Cr) ? (h === void 0 && (h = new st(
      new zs(1, 1, 1),
      new xt({
        name: "BackgroundCubeMaterial",
        uniforms: Ls(qt.backgroundCube.uniforms),
        vertexShader: qt.backgroundCube.vertexShader,
        fragmentShader: qt.backgroundCube.fragmentShader,
        side: oi,
        depthTest: !1,
        depthWrite: !1,
        fog: !1
      })
    ), h.geometry.deleteAttribute("normal"), h.geometry.deleteAttribute("uv"), h.onBeforeRender = function(S, A, w) {
      this.matrixWorld.copyPosition(w.matrixWorld);
    }, Object.defineProperty(h.material, "envMap", {
      get: function() {
        return this.uniforms.envMap.value;
      }
    }), n.update(h)), h.material.uniforms.envMap.value = y, h.material.uniforms.flipEnvMap.value = y.isCubeTexture && y.isRenderTargetTexture === !1 ? -1 : 1, h.material.uniforms.backgroundBlurriness.value = g.backgroundBlurriness, h.material.uniforms.backgroundIntensity.value = g.backgroundIntensity, h.material.toneMapped = y.encoding !== He, (u !== y || d !== y.version || f !== o.toneMapping) && (h.material.needsUpdate = !0, u = y, d = y.version, f = o.toneMapping), h.layers.enableAll(), p.unshift(h, h.geometry, h.material, 0, 0, null)) : y && y.isTexture && (c === void 0 && (c = new st(
      new Pr(2, 2),
      new xt({
        name: "BackgroundMaterial",
        uniforms: Ls(qt.background.uniforms),
        vertexShader: qt.background.vertexShader,
        fragmentShader: qt.background.fragmentShader,
        side: dn,
        depthTest: !1,
        depthWrite: !1,
        fog: !1
      })
    ), c.geometry.deleteAttribute("normal"), Object.defineProperty(c.material, "map", {
      get: function() {
        return this.uniforms.t2D.value;
      }
    }), n.update(c)), c.material.uniforms.t2D.value = y, c.material.uniforms.backgroundIntensity.value = g.backgroundIntensity, c.material.toneMapped = y.encoding !== He, y.matrixAutoUpdate === !0 && y.updateMatrix(), c.material.uniforms.uvTransform.value.copy(y.matrix), (u !== y || d !== y.version || f !== o.toneMapping) && (c.material.needsUpdate = !0, u = y, d = y.version, f = o.toneMapping), c.layers.enableAll(), p.unshift(c, c.geometry, c.material, 0, 0, null));
  }
  function _(p, g) {
    p.getRGB(ea, gd(o)), i.buffers.color.setClear(ea.r, ea.g, ea.b, g, r);
  }
  return {
    getClearColor: function() {
      return a;
    },
    setClearColor: function(p, g = 1) {
      a.set(p), l = g, _(a, l);
    },
    getClearAlpha: function() {
      return l;
    },
    setClearAlpha: function(p) {
      l = p, _(a, l);
    },
    render: m
  };
}
function Qg(o, e, t, i) {
  const n = o.getParameter(34921), s = i.isWebGL2 ? null : e.get("OES_vertex_array_object"), r = i.isWebGL2 || s !== null, a = {}, l = p(null);
  let c = l, h = !1;
  function u(D, H, Z, ie, K) {
    let ne = !1;
    if (r) {
      const te = _(ie, Z, H);
      c !== te && (c = te, f(c.object)), ne = g(D, ie, Z, K), ne && x(D, ie, Z, K);
    } else {
      const te = H.wireframe === !0;
      (c.geometry !== ie.id || c.program !== Z.id || c.wireframe !== te) && (c.geometry = ie.id, c.program = Z.id, c.wireframe = te, ne = !0);
    }
    K !== null && t.update(K, 34963), (ne || h) && (h = !1, w(D, H, Z, ie), K !== null && o.bindBuffer(34963, t.get(K).buffer));
  }
  function d() {
    return i.isWebGL2 ? o.createVertexArray() : s.createVertexArrayOES();
  }
  function f(D) {
    return i.isWebGL2 ? o.bindVertexArray(D) : s.bindVertexArrayOES(D);
  }
  function m(D) {
    return i.isWebGL2 ? o.deleteVertexArray(D) : s.deleteVertexArrayOES(D);
  }
  function _(D, H, Z) {
    const ie = Z.wireframe === !0;
    let K = a[D.id];
    K === void 0 && (K = {}, a[D.id] = K);
    let ne = K[H.id];
    ne === void 0 && (ne = {}, K[H.id] = ne);
    let te = ne[ie];
    return te === void 0 && (te = p(d()), ne[ie] = te), te;
  }
  function p(D) {
    const H = [], Z = [], ie = [];
    for (let K = 0; K < n; K++)
      H[K] = 0, Z[K] = 0, ie[K] = 0;
    return {
      // for backward compatibility on non-VAO support browser
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: H,
      enabledAttributes: Z,
      attributeDivisors: ie,
      object: D,
      attributes: {},
      index: null
    };
  }
  function g(D, H, Z, ie) {
    const K = c.attributes, ne = H.attributes;
    let te = 0;
    const q = Z.getAttributes();
    for (const W in q)
      if (q[W].location >= 0) {
        const ae = K[W];
        let fe = ne[W];
        if (fe === void 0 && (W === "instanceMatrix" && D.instanceMatrix && (fe = D.instanceMatrix), W === "instanceColor" && D.instanceColor && (fe = D.instanceColor)), ae === void 0 || ae.attribute !== fe || fe && ae.data !== fe.data) return !0;
        te++;
      }
    return c.attributesNum !== te || c.index !== ie;
  }
  function x(D, H, Z, ie) {
    const K = {}, ne = H.attributes;
    let te = 0;
    const q = Z.getAttributes();
    for (const W in q)
      if (q[W].location >= 0) {
        let ae = ne[W];
        ae === void 0 && (W === "instanceMatrix" && D.instanceMatrix && (ae = D.instanceMatrix), W === "instanceColor" && D.instanceColor && (ae = D.instanceColor));
        const fe = {};
        fe.attribute = ae, ae && ae.data && (fe.data = ae.data), K[W] = fe, te++;
      }
    c.attributes = K, c.attributesNum = te, c.index = ie;
  }
  function y() {
    const D = c.newAttributes;
    for (let H = 0, Z = D.length; H < Z; H++)
      D[H] = 0;
  }
  function v(D) {
    M(D, 0);
  }
  function M(D, H) {
    const Z = c.newAttributes, ie = c.enabledAttributes, K = c.attributeDivisors;
    Z[D] = 1, ie[D] === 0 && (o.enableVertexAttribArray(D), ie[D] = 1), K[D] !== H && ((i.isWebGL2 ? o : e.get("ANGLE_instanced_arrays"))[i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](D, H), K[D] = H);
  }
  function S() {
    const D = c.newAttributes, H = c.enabledAttributes;
    for (let Z = 0, ie = H.length; Z < ie; Z++)
      H[Z] !== D[Z] && (o.disableVertexAttribArray(Z), H[Z] = 0);
  }
  function A(D, H, Z, ie, K, ne) {
    i.isWebGL2 === !0 && (Z === 5124 || Z === 5125) ? o.vertexAttribIPointer(D, H, Z, K, ne) : o.vertexAttribPointer(D, H, Z, ie, K, ne);
  }
  function w(D, H, Z, ie) {
    if (i.isWebGL2 === !1 && (D.isInstancedMesh || ie.isInstancedBufferGeometry) && e.get("ANGLE_instanced_arrays") === null)
      return;
    y();
    const K = ie.attributes, ne = Z.getAttributes(), te = H.defaultAttributeValues;
    for (const q in ne) {
      const W = ne[q];
      if (W.location >= 0) {
        let le = K[q];
        if (le === void 0 && (q === "instanceMatrix" && D.instanceMatrix && (le = D.instanceMatrix), q === "instanceColor" && D.instanceColor && (le = D.instanceColor)), le !== void 0) {
          const ae = le.normalized, fe = le.itemSize, j = t.get(le);
          if (j === void 0) continue;
          const De = j.buffer, ye = j.type, Re = j.bytesPerElement;
          if (le.isInterleavedBufferAttribute) {
            const me = le.data, ze = me.stride, ee = le.offset;
            if (me.isInstancedInterleavedBuffer) {
              for (let Q = 0; Q < W.locationSize; Q++)
                M(W.location + Q, me.meshPerAttribute);
              D.isInstancedMesh !== !0 && ie._maxInstanceCount === void 0 && (ie._maxInstanceCount = me.meshPerAttribute * me.count);
            } else
              for (let Q = 0; Q < W.locationSize; Q++)
                v(W.location + Q);
            o.bindBuffer(34962, De);
            for (let Q = 0; Q < W.locationSize; Q++)
              A(
                W.location + Q,
                fe / W.locationSize,
                ye,
                ae,
                ze * Re,
                (ee + fe / W.locationSize * Q) * Re
              );
          } else {
            if (le.isInstancedBufferAttribute) {
              for (let me = 0; me < W.locationSize; me++)
                M(W.location + me, le.meshPerAttribute);
              D.isInstancedMesh !== !0 && ie._maxInstanceCount === void 0 && (ie._maxInstanceCount = le.meshPerAttribute * le.count);
            } else
              for (let me = 0; me < W.locationSize; me++)
                v(W.location + me);
            o.bindBuffer(34962, De);
            for (let me = 0; me < W.locationSize; me++)
              A(
                W.location + me,
                fe / W.locationSize,
                ye,
                ae,
                fe * Re,
                fe / W.locationSize * me * Re
              );
          }
        } else if (te !== void 0) {
          const ae = te[q];
          if (ae !== void 0)
            switch (ae.length) {
              case 2:
                o.vertexAttrib2fv(W.location, ae);
                break;
              case 3:
                o.vertexAttrib3fv(W.location, ae);
                break;
              case 4:
                o.vertexAttrib4fv(W.location, ae);
                break;
              default:
                o.vertexAttrib1fv(W.location, ae);
            }
        }
      }
    }
    S();
  }
  function E() {
    V();
    for (const D in a) {
      const H = a[D];
      for (const Z in H) {
        const ie = H[Z];
        for (const K in ie)
          m(ie[K].object), delete ie[K];
        delete H[Z];
      }
      delete a[D];
    }
  }
  function P(D) {
    if (a[D.id] === void 0) return;
    const H = a[D.id];
    for (const Z in H) {
      const ie = H[Z];
      for (const K in ie)
        m(ie[K].object), delete ie[K];
      delete H[Z];
    }
    delete a[D.id];
  }
  function z(D) {
    for (const H in a) {
      const Z = a[H];
      if (Z[D.id] === void 0) continue;
      const ie = Z[D.id];
      for (const K in ie)
        m(ie[K].object), delete ie[K];
      delete Z[D.id];
    }
  }
  function V() {
    O(), h = !0, c !== l && (c = l, f(c.object));
  }
  function O() {
    l.geometry = null, l.program = null, l.wireframe = !1;
  }
  return {
    setup: u,
    reset: V,
    resetDefaultState: O,
    dispose: E,
    releaseStatesOfGeometry: P,
    releaseStatesOfProgram: z,
    initAttributes: y,
    enableAttribute: v,
    disableUnusedAttributes: S
  };
}
function e0(o, e, t, i) {
  const n = i.isWebGL2;
  let s;
  function r(c) {
    s = c;
  }
  function a(c, h) {
    o.drawArrays(s, c, h), t.update(h, s, 1);
  }
  function l(c, h, u) {
    if (u === 0) return;
    let d, f;
    if (n)
      d = o, f = "drawArraysInstanced";
    else if (d = e.get("ANGLE_instanced_arrays"), f = "drawArraysInstancedANGLE", d === null) {
      console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
      return;
    }
    d[f](s, c, h, u), t.update(h, s, u);
  }
  this.setMode = r, this.render = a, this.renderInstances = l;
}
function t0(o, e, t) {
  let i;
  function n() {
    if (i !== void 0) return i;
    if (e.has("EXT_texture_filter_anisotropic") === !0) {
      const A = e.get("EXT_texture_filter_anisotropic");
      i = o.getParameter(A.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else
      i = 0;
    return i;
  }
  function s(A) {
    if (A === "highp") {
      if (o.getShaderPrecisionFormat(35633, 36338).precision > 0 && o.getShaderPrecisionFormat(35632, 36338).precision > 0)
        return "highp";
      A = "mediump";
    }
    return A === "mediump" && o.getShaderPrecisionFormat(35633, 36337).precision > 0 && o.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp";
  }
  const r = typeof WebGL2RenderingContext < "u" && o instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext < "u" && o instanceof WebGL2ComputeRenderingContext;
  let a = t.precision !== void 0 ? t.precision : "highp";
  const l = s(a);
  l !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", l, "instead."), a = l);
  const c = r || e.has("WEBGL_draw_buffers"), h = t.logarithmicDepthBuffer === !0, u = o.getParameter(34930), d = o.getParameter(35660), f = o.getParameter(3379), m = o.getParameter(34076), _ = o.getParameter(34921), p = o.getParameter(36347), g = o.getParameter(36348), x = o.getParameter(36349), y = d > 0, v = r || e.has("OES_texture_float"), M = y && v, S = r ? o.getParameter(36183) : 0;
  return {
    isWebGL2: r,
    drawBuffers: c,
    getMaxAnisotropy: n,
    getMaxPrecision: s,
    precision: a,
    logarithmicDepthBuffer: h,
    maxTextures: u,
    maxVertexTextures: d,
    maxTextureSize: f,
    maxCubemapSize: m,
    maxAttributes: _,
    maxVertexUniforms: p,
    maxVaryings: g,
    maxFragmentUniforms: x,
    vertexTextures: y,
    floatFragmentTextures: v,
    floatVertexTextures: M,
    maxSamples: S
  };
}
function i0(o) {
  const e = this;
  let t = null, i = 0, n = !1, s = !1;
  const r = new An(), a = new Gt(), l = { value: null, needsUpdate: !1 };
  this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function(u, d, f) {
    const m = u.length !== 0 || d || // enable state of previous frame - the clipping code has to
    // run another frame in order to reset the state:
    i !== 0 || n;
    return n = d, t = h(u, f, 0), i = u.length, m;
  }, this.beginShadows = function() {
    s = !0, h(null);
  }, this.endShadows = function() {
    s = !1, c();
  }, this.setState = function(u, d, f) {
    const m = u.clippingPlanes, _ = u.clipIntersection, p = u.clipShadows, g = o.get(u);
    if (!n || m === null || m.length === 0 || s && !p)
      s ? h(null) : c();
    else {
      const x = s ? 0 : i, y = x * 4;
      let v = g.clippingState || null;
      l.value = v, v = h(m, d, y, f);
      for (let M = 0; M !== y; ++M)
        v[M] = t[M];
      g.clippingState = v, this.numIntersection = _ ? this.numPlanes : 0, this.numPlanes += x;
    }
  };
  function c() {
    l.value !== t && (l.value = t, l.needsUpdate = i > 0), e.numPlanes = i, e.numIntersection = 0;
  }
  function h(u, d, f, m) {
    const _ = u !== null ? u.length : 0;
    let p = null;
    if (_ !== 0) {
      if (p = l.value, m !== !0 || p === null) {
        const g = f + _ * 4, x = d.matrixWorldInverse;
        a.getNormalMatrix(x), (p === null || p.length < g) && (p = new Float32Array(g));
        for (let y = 0, v = f; y !== _; ++y, v += 4)
          r.copy(u[y]).applyMatrix4(x, a), r.normal.toArray(p, v), p[v + 3] = r.constant;
      }
      l.value = p, l.needsUpdate = !0;
    }
    return e.numPlanes = _, e.numIntersection = 0, p;
  }
}
function n0(o) {
  let e = /* @__PURE__ */ new WeakMap();
  function t(r, a) {
    return a === mr ? r.mapping = Nn : a === Fa && (r.mapping = kn), r;
  }
  function i(r) {
    if (r && r.isTexture && r.isRenderTargetTexture === !1) {
      const a = r.mapping;
      if (a === mr || a === Fa)
        if (e.has(r)) {
          const l = e.get(r).texture;
          return t(l, r.mapping);
        } else {
          const l = r.image;
          if (l && l.height > 0) {
            const c = new _m(l.height / 2);
            return c.fromEquirectangularTexture(o, r), e.set(r, c), r.addEventListener("dispose", n), t(c.texture, r.mapping);
          } else
            return null;
        }
    }
    return r;
  }
  function n(r) {
    const a = r.target;
    a.removeEventListener("dispose", n);
    const l = e.get(a);
    l !== void 0 && (e.delete(a), l.dispose());
  }
  function s() {
    e = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: i,
    dispose: s
  };
}
class pn extends vd {
  constructor(e = -1, t = 1, i = 1, n = -1, s = 0.1, r = 2e3) {
    super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = i, this.bottom = n, this.near = s, this.far = r, this.updateProjectionMatrix();
  }
  copy(e, t) {
    return super.copy(e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = e.view === null ? null : Object.assign({}, e.view), this;
  }
  setViewOffset(e, t, i, n, s, r) {
    this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = i, this.view.offsetY = n, this.view.width = s, this.view.height = r, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = (this.right - this.left) / (2 * this.zoom), t = (this.top - this.bottom) / (2 * this.zoom), i = (this.right + this.left) / 2, n = (this.top + this.bottom) / 2;
    let s = i - e, r = i + e, a = n + t, l = n - t;
    if (this.view !== null && this.view.enabled) {
      const c = (this.right - this.left) / this.view.fullWidth / this.zoom, h = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      s += c * this.view.offsetX, r = s + c * this.view.width, a -= h * this.view.offsetY, l = a - h * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(s, r, a, l, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, this.view !== null && (t.object.view = Object.assign({}, this.view)), t;
  }
}
const ys = 4, mh = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582], Cn = 20, No = /* @__PURE__ */ new pn(), _h = /* @__PURE__ */ new de();
let ko = null;
const En = (1 + Math.sqrt(5)) / 2, is = 1 / En, gh = [
  /* @__PURE__ */ new b(1, 1, 1),
  /* @__PURE__ */ new b(-1, 1, 1),
  /* @__PURE__ */ new b(1, 1, -1),
  /* @__PURE__ */ new b(-1, 1, -1),
  /* @__PURE__ */ new b(0, En, is),
  /* @__PURE__ */ new b(0, En, -is),
  /* @__PURE__ */ new b(is, 0, En),
  /* @__PURE__ */ new b(-is, 0, En),
  /* @__PURE__ */ new b(En, is, 0),
  /* @__PURE__ */ new b(-En, is, 0)
];
class vh {
  constructor(e) {
    this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial);
  }
  /**
   * Generates a PMREM from a supplied Scene, which can be faster than using an
   * image if networking bandwidth is low. Optional sigma specifies a blur radius
   * in radians to be applied to the scene before PMREM generation. Optional near
   * and far planes ensure the scene is rendered in its entirety (the cubeCamera
   * is placed at the origin).
   */
  fromScene(e, t = 0, i = 0.1, n = 100) {
    ko = this._renderer.getRenderTarget(), this._setSize(256);
    const s = this._allocateTargets();
    return s.depthBuffer = !0, this._sceneToCubeUV(e, i, n, s), t > 0 && this._blur(s, 0, 0, t), this._applyPMREM(s), this._cleanup(s), s;
  }
  /**
   * Generates a PMREM from an equirectangular texture, which can be either LDR
   * or HDR. The ideal input image size is 1k (1024 x 512),
   * as this matches best with the 256 x 256 cubemap output.
   */
  fromEquirectangular(e, t = null) {
    return this._fromTexture(e, t);
  }
  /**
   * Generates a PMREM from an cubemap texture, which can be either LDR
   * or HDR. The ideal input cube size is 256 x 256,
   * as this matches best with the 256 x 256 cubemap output.
   */
  fromCubemap(e, t = null) {
    return this._fromTexture(e, t);
  }
  /**
   * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileCubemapShader() {
    this._cubemapMaterial === null && (this._cubemapMaterial = wh(), this._compileMaterial(this._cubemapMaterial));
  }
  /**
   * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileEquirectangularShader() {
    this._equirectMaterial === null && (this._equirectMaterial = xh(), this._compileMaterial(this._equirectMaterial));
  }
  /**
   * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
   * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
   * one of them will cause any others to also become unusable.
   */
  dispose() {
    this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose();
  }
  // private interface
  _setSize(e) {
    this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax);
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
    for (let e = 0; e < this._lodPlanes.length; e++)
      this._lodPlanes[e].dispose();
  }
  _cleanup(e) {
    this._renderer.setRenderTarget(ko), e.scissorTest = !1, ta(e, 0, 0, e.width, e.height);
  }
  _fromTexture(e, t) {
    e.mapping === Nn || e.mapping === kn ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), ko = this._renderer.getRenderTarget();
    const i = t || this._allocateTargets();
    return this._textureToCubeUV(e, i), this._applyPMREM(i), this._cleanup(i), i;
  }
  _allocateTargets() {
    const e = 3 * Math.max(this._cubeSize, 112), t = 4 * this._cubeSize, i = {
      magFilter: Ut,
      minFilter: Ut,
      generateMipmaps: !1,
      type: gr,
      format: ri,
      encoding: Fn,
      depthBuffer: !1
    }, n = yh(e, t, i);
    if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e) {
      this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = yh(e, t, i);
      const { _lodMax: s } = this;
      ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = s0(s)), this._blurMaterial = r0(s, e, t);
    }
    return n;
  }
  _compileMaterial(e) {
    const t = new st(this._lodPlanes[0], e);
    this._renderer.compile(t, No);
  }
  _sceneToCubeUV(e, t, i, n) {
    const a = new gt(90, 1, t, i), l = [1, -1, 1, 1, 1, 1], c = [1, 1, 1, -1, -1, -1], h = this._renderer, u = h.autoClear, d = h.toneMapping;
    h.getClearColor(_h), h.toneMapping = Wi, h.autoClear = !1;
    const f = new gi({
      name: "PMREM.Background",
      side: oi,
      depthWrite: !1,
      depthTest: !1
    }), m = new st(new zs(), f);
    let _ = !1;
    const p = e.background;
    p ? p.isColor && (f.color.copy(p), e.background = null, _ = !0) : (f.color.copy(_h), _ = !0);
    for (let g = 0; g < 6; g++) {
      const x = g % 3;
      x === 0 ? (a.up.set(0, l[g], 0), a.lookAt(c[g], 0, 0)) : x === 1 ? (a.up.set(0, 0, l[g]), a.lookAt(0, c[g], 0)) : (a.up.set(0, l[g], 0), a.lookAt(0, 0, c[g]));
      const y = this._cubeSize;
      ta(n, x * y, g > 2 ? y : 0, y, y), h.setRenderTarget(n), _ && h.render(m, a), h.render(e, a);
    }
    m.geometry.dispose(), m.material.dispose(), h.toneMapping = d, h.autoClear = u, e.background = p;
  }
  _textureToCubeUV(e, t) {
    const i = this._renderer, n = e.mapping === Nn || e.mapping === kn;
    n ? (this._cubemapMaterial === null && (this._cubemapMaterial = wh()), this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = xh());
    const s = n ? this._cubemapMaterial : this._equirectMaterial, r = new st(this._lodPlanes[0], s), a = s.uniforms;
    a.envMap.value = e;
    const l = this._cubeSize;
    ta(t, 0, 0, 3 * l, 2 * l), i.setRenderTarget(t), i.render(r, No);
  }
  _applyPMREM(e) {
    const t = this._renderer, i = t.autoClear;
    t.autoClear = !1;
    for (let n = 1; n < this._lodPlanes.length; n++) {
      const s = Math.sqrt(this._sigmas[n] * this._sigmas[n] - this._sigmas[n - 1] * this._sigmas[n - 1]), r = gh[(n - 1) % gh.length];
      this._blur(e, n - 1, n, s, r);
    }
    t.autoClear = i;
  }
  /**
   * This is a two-pass Gaussian blur for a cubemap. Normally this is done
   * vertically and horizontally, but this breaks down on a cube. Here we apply
   * the blur latitudinally (around the poles), and then longitudinally (towards
   * the poles) to approximate the orthogonally-separable blur. It is least
   * accurate at the poles, but still does a decent job.
   */
  _blur(e, t, i, n, s) {
    const r = this._pingPongRenderTarget;
    this._halfBlur(
      e,
      r,
      t,
      i,
      n,
      "latitudinal",
      s
    ), this._halfBlur(
      r,
      e,
      i,
      i,
      n,
      "longitudinal",
      s
    );
  }
  _halfBlur(e, t, i, n, s, r, a) {
    const l = this._renderer, c = this._blurMaterial;
    r !== "latitudinal" && r !== "longitudinal" && console.error(
      "blur direction must be either latitudinal or longitudinal!"
    );
    const h = 3, u = new st(this._lodPlanes[n], c), d = c.uniforms, f = this._sizeLods[i] - 1, m = isFinite(s) ? Math.PI / (2 * f) : 2 * Math.PI / (2 * Cn - 1), _ = s / m, p = isFinite(s) ? 1 + Math.floor(h * _) : Cn;
    p > Cn && console.warn(`sigmaRadians, ${s}, is too large and will clip, as it requested ${p} samples when the maximum is set to ${Cn}`);
    const g = [];
    let x = 0;
    for (let A = 0; A < Cn; ++A) {
      const w = A / _, E = Math.exp(-w * w / 2);
      g.push(E), A === 0 ? x += E : A < p && (x += 2 * E);
    }
    for (let A = 0; A < g.length; A++)
      g[A] = g[A] / x;
    d.envMap.value = e.texture, d.samples.value = p, d.weights.value = g, d.latitudinal.value = r === "latitudinal", a && (d.poleAxis.value = a);
    const { _lodMax: y } = this;
    d.dTheta.value = m, d.mipInt.value = y - i;
    const v = this._sizeLods[n], M = 3 * v * (n > y - ys ? n - y + ys : 0), S = 4 * (this._cubeSize - v);
    ta(t, M, S, 3 * v, 2 * v), l.setRenderTarget(t), l.render(u, No);
  }
}
function s0(o) {
  const e = [], t = [], i = [];
  let n = o;
  const s = o - ys + 1 + mh.length;
  for (let r = 0; r < s; r++) {
    const a = Math.pow(2, n);
    t.push(a);
    let l = 1 / a;
    r > o - ys ? l = mh[r - o + ys - 1] : r === 0 && (l = 0), i.push(l);
    const c = 1 / (a - 2), h = -c, u = 1 + c, d = [h, h, u, h, u, u, h, h, u, u, h, u], f = 6, m = 6, _ = 3, p = 2, g = 1, x = new Float32Array(_ * m * f), y = new Float32Array(p * m * f), v = new Float32Array(g * m * f);
    for (let S = 0; S < f; S++) {
      const A = S % 3 * 2 / 3 - 1, w = S > 2 ? 0 : -1, E = [
        A,
        w,
        0,
        A + 2 / 3,
        w,
        0,
        A + 2 / 3,
        w + 1,
        0,
        A,
        w,
        0,
        A + 2 / 3,
        w + 1,
        0,
        A,
        w + 1,
        0
      ];
      x.set(E, _ * m * S), y.set(d, p * m * S);
      const P = [S, S, S, S, S, S];
      v.set(P, g * m * S);
    }
    const M = new Ue();
    M.setAttribute("position", new $e(x, _)), M.setAttribute("uv", new $e(y, p)), M.setAttribute("faceIndex", new $e(v, g)), e.push(M), n > ys && n--;
  }
  return { lodPlanes: e, sizeLods: t, sigmas: i };
}
function yh(o, e, t) {
  const i = new Ot(o, e, t);
  return i.texture.mapping = Cr, i.texture.name = "PMREM.cubeUv", i.scissorTest = !0, i;
}
function ta(o, e, t, i, n) {
  o.viewport.set(e, t, i, n), o.scissor.set(e, t, i, n);
}
function r0(o, e, t) {
  const i = new Float32Array(Cn), n = new b(0, 1, 0);
  return new xt({
    name: "SphericalGaussianBlur",
    defines: {
      n: Cn,
      CUBEUV_TEXEL_WIDTH: 1 / e,
      CUBEUV_TEXEL_HEIGHT: 1 / t,
      CUBEUV_MAX_MIP: `${o}.0`
    },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: i },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: n }
    },
    vertexShader: Vl(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`
    ),
    blending: Ti,
    depthTest: !1,
    depthWrite: !1
  });
}
function xh() {
  return new xt({
    name: "EquirectangularToCubeUV",
    uniforms: {
      envMap: { value: null }
    },
    vertexShader: Vl(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`
    ),
    blending: Ti,
    depthTest: !1,
    depthWrite: !1
  });
}
function wh() {
  return new xt({
    name: "CubemapToCubeUV",
    uniforms: {
      envMap: { value: null },
      flipEnvMap: { value: -1 }
    },
    vertexShader: Vl(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`
    ),
    blending: Ti,
    depthTest: !1,
    depthWrite: !1
  });
}
function Vl() {
  return (
    /* glsl */
    `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
  );
}
function a0(o) {
  let e = /* @__PURE__ */ new WeakMap(), t = null;
  function i(a) {
    if (a && a.isTexture) {
      const l = a.mapping, c = l === mr || l === Fa, h = l === Nn || l === kn;
      if (c || h)
        if (a.isRenderTargetTexture && a.needsPMREMUpdate === !0) {
          a.needsPMREMUpdate = !1;
          let u = e.get(a);
          return t === null && (t = new vh(o)), u = c ? t.fromEquirectangular(a, u) : t.fromCubemap(a, u), e.set(a, u), u.texture;
        } else {
          if (e.has(a))
            return e.get(a).texture;
          {
            const u = a.image;
            if (c && u && u.height > 0 || h && u && n(u)) {
              t === null && (t = new vh(o));
              const d = c ? t.fromEquirectangular(a) : t.fromCubemap(a);
              return e.set(a, d), a.addEventListener("dispose", s), d.texture;
            } else
              return null;
          }
        }
    }
    return a;
  }
  function n(a) {
    let l = 0;
    const c = 6;
    for (let h = 0; h < c; h++)
      a[h] !== void 0 && l++;
    return l === c;
  }
  function s(a) {
    const l = a.target;
    l.removeEventListener("dispose", s);
    const c = e.get(l);
    c !== void 0 && (e.delete(l), c.dispose());
  }
  function r() {
    e = /* @__PURE__ */ new WeakMap(), t !== null && (t.dispose(), t = null);
  }
  return {
    get: i,
    dispose: r
  };
}
function o0(o) {
  const e = {};
  function t(i) {
    if (e[i] !== void 0)
      return e[i];
    let n;
    switch (i) {
      case "WEBGL_depth_texture":
        n = o.getExtension("WEBGL_depth_texture") || o.getExtension("MOZ_WEBGL_depth_texture") || o.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        n = o.getExtension("EXT_texture_filter_anisotropic") || o.getExtension("MOZ_EXT_texture_filter_anisotropic") || o.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        n = o.getExtension("WEBGL_compressed_texture_s3tc") || o.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || o.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        n = o.getExtension("WEBGL_compressed_texture_pvrtc") || o.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        n = o.getExtension(i);
    }
    return e[i] = n, n;
  }
  return {
    has: function(i) {
      return t(i) !== null;
    },
    init: function(i) {
      i.isWebGL2 ? t("EXT_color_buffer_float") : (t("WEBGL_depth_texture"), t("OES_texture_float"), t("OES_texture_half_float"), t("OES_texture_half_float_linear"), t("OES_standard_derivatives"), t("OES_element_index_uint"), t("OES_vertex_array_object"), t("ANGLE_instanced_arrays")), t("OES_texture_float_linear"), t("EXT_color_buffer_half_float"), t("WEBGL_multisampled_render_to_texture");
    },
    get: function(i) {
      const n = t(i);
      return n === null && console.warn("THREE.WebGLRenderer: " + i + " extension not supported."), n;
    }
  };
}
function l0(o, e, t, i) {
  const n = {}, s = /* @__PURE__ */ new WeakMap();
  function r(u) {
    const d = u.target;
    d.index !== null && e.remove(d.index);
    for (const m in d.attributes)
      e.remove(d.attributes[m]);
    d.removeEventListener("dispose", r), delete n[d.id];
    const f = s.get(d);
    f && (e.remove(f), s.delete(d)), i.releaseStatesOfGeometry(d), d.isInstancedBufferGeometry === !0 && delete d._maxInstanceCount, t.memory.geometries--;
  }
  function a(u, d) {
    return n[d.id] === !0 || (d.addEventListener("dispose", r), n[d.id] = !0, t.memory.geometries++), d;
  }
  function l(u) {
    const d = u.attributes;
    for (const m in d)
      e.update(d[m], 34962);
    const f = u.morphAttributes;
    for (const m in f) {
      const _ = f[m];
      for (let p = 0, g = _.length; p < g; p++)
        e.update(_[p], 34962);
    }
  }
  function c(u) {
    const d = [], f = u.index, m = u.attributes.position;
    let _ = 0;
    if (f !== null) {
      const x = f.array;
      _ = f.version;
      for (let y = 0, v = x.length; y < v; y += 3) {
        const M = x[y + 0], S = x[y + 1], A = x[y + 2];
        d.push(M, S, S, A, A, M);
      }
    } else {
      const x = m.array;
      _ = m.version;
      for (let y = 0, v = x.length / 3 - 1; y < v; y += 3) {
        const M = y + 0, S = y + 1, A = y + 2;
        d.push(M, S, S, A, A, M);
      }
    }
    const p = new (dd(d) ? _d : Ul)(d, 1);
    p.version = _;
    const g = s.get(u);
    g && e.remove(g), s.set(u, p);
  }
  function h(u) {
    const d = s.get(u);
    if (d) {
      const f = u.index;
      f !== null && d.version < f.version && c(u);
    } else
      c(u);
    return s.get(u);
  }
  return {
    get: a,
    update: l,
    getWireframeAttribute: h
  };
}
function c0(o, e, t, i) {
  const n = i.isWebGL2;
  let s;
  function r(d) {
    s = d;
  }
  let a, l;
  function c(d) {
    a = d.type, l = d.bytesPerElement;
  }
  function h(d, f) {
    o.drawElements(s, f, a, d * l), t.update(f, s, 1);
  }
  function u(d, f, m) {
    if (m === 0) return;
    let _, p;
    if (n)
      _ = o, p = "drawElementsInstanced";
    else if (_ = e.get("ANGLE_instanced_arrays"), p = "drawElementsInstancedANGLE", _ === null) {
      console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
      return;
    }
    _[p](s, f, a, d * l, m), t.update(f, s, m);
  }
  this.setMode = r, this.setIndex = c, this.render = h, this.renderInstances = u;
}
function h0(o) {
  const e = {
    geometries: 0,
    textures: 0
  }, t = {
    frame: 0,
    calls: 0,
    triangles: 0,
    points: 0,
    lines: 0
  };
  function i(s, r, a) {
    switch (t.calls++, r) {
      case 4:
        t.triangles += a * (s / 3);
        break;
      case 1:
        t.lines += a * (s / 2);
        break;
      case 3:
        t.lines += a * (s - 1);
        break;
      case 2:
        t.lines += a * s;
        break;
      case 0:
        t.points += a * s;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", r);
        break;
    }
  }
  function n() {
    t.frame++, t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0;
  }
  return {
    memory: e,
    render: t,
    programs: null,
    autoReset: !0,
    reset: n,
    update: i
  };
}
function u0(o, e) {
  return o[0] - e[0];
}
function d0(o, e) {
  return Math.abs(e[1]) - Math.abs(o[1]);
}
function f0(o, e, t) {
  const i = {}, n = new Float32Array(8), s = /* @__PURE__ */ new WeakMap(), r = new We(), a = [];
  for (let c = 0; c < 8; c++)
    a[c] = [c, 0];
  function l(c, h, u, d) {
    const f = c.morphTargetInfluences;
    if (e.isWebGL2 === !0) {
      const m = h.morphAttributes.position || h.morphAttributes.normal || h.morphAttributes.color, _ = m !== void 0 ? m.length : 0;
      let p = s.get(h);
      if (p === void 0 || p.count !== _) {
        let H = function() {
          O.dispose(), s.delete(h), h.removeEventListener("dispose", H);
        };
        p !== void 0 && p.texture.dispose();
        const y = h.morphAttributes.position !== void 0, v = h.morphAttributes.normal !== void 0, M = h.morphAttributes.color !== void 0, S = h.morphAttributes.position || [], A = h.morphAttributes.normal || [], w = h.morphAttributes.color || [];
        let E = 0;
        y === !0 && (E = 1), v === !0 && (E = 2), M === !0 && (E = 3);
        let P = h.attributes.position.count * E, z = 1;
        P > e.maxTextureSize && (z = Math.ceil(P / e.maxTextureSize), P = e.maxTextureSize);
        const V = new Float32Array(P * z * 4 * _), O = new md(V, P, z, _);
        O.type = cn, O.needsUpdate = !0;
        const D = E * 4;
        for (let Z = 0; Z < _; Z++) {
          const ie = S[Z], K = A[Z], ne = w[Z], te = P * z * 4 * Z;
          for (let q = 0; q < ie.count; q++) {
            const W = q * D;
            y === !0 && (r.fromBufferAttribute(ie, q), V[te + W + 0] = r.x, V[te + W + 1] = r.y, V[te + W + 2] = r.z, V[te + W + 3] = 0), v === !0 && (r.fromBufferAttribute(K, q), V[te + W + 4] = r.x, V[te + W + 5] = r.y, V[te + W + 6] = r.z, V[te + W + 7] = 0), M === !0 && (r.fromBufferAttribute(ne, q), V[te + W + 8] = r.x, V[te + W + 9] = r.y, V[te + W + 10] = r.z, V[te + W + 11] = ne.itemSize === 4 ? r.w : 1);
          }
        }
        p = {
          count: _,
          texture: O,
          size: new G(P, z)
        }, s.set(h, p), h.addEventListener("dispose", H);
      }
      let g = 0;
      for (let y = 0; y < f.length; y++)
        g += f[y];
      const x = h.morphTargetsRelative ? 1 : 1 - g;
      d.getUniforms().setValue(o, "morphTargetBaseInfluence", x), d.getUniforms().setValue(o, "morphTargetInfluences", f), d.getUniforms().setValue(o, "morphTargetsTexture", p.texture, t), d.getUniforms().setValue(o, "morphTargetsTextureSize", p.size);
    } else {
      const m = f === void 0 ? 0 : f.length;
      let _ = i[h.id];
      if (_ === void 0 || _.length !== m) {
        _ = [];
        for (let v = 0; v < m; v++)
          _[v] = [v, 0];
        i[h.id] = _;
      }
      for (let v = 0; v < m; v++) {
        const M = _[v];
        M[0] = v, M[1] = f[v];
      }
      _.sort(d0);
      for (let v = 0; v < 8; v++)
        v < m && _[v][1] ? (a[v][0] = _[v][0], a[v][1] = _[v][1]) : (a[v][0] = Number.MAX_SAFE_INTEGER, a[v][1] = 0);
      a.sort(u0);
      const p = h.morphAttributes.position, g = h.morphAttributes.normal;
      let x = 0;
      for (let v = 0; v < 8; v++) {
        const M = a[v], S = M[0], A = M[1];
        S !== Number.MAX_SAFE_INTEGER && A ? (p && h.getAttribute("morphTarget" + v) !== p[S] && h.setAttribute("morphTarget" + v, p[S]), g && h.getAttribute("morphNormal" + v) !== g[S] && h.setAttribute("morphNormal" + v, g[S]), n[v] = A, x += A) : (p && h.hasAttribute("morphTarget" + v) === !0 && h.deleteAttribute("morphTarget" + v), g && h.hasAttribute("morphNormal" + v) === !0 && h.deleteAttribute("morphNormal" + v), n[v] = 0);
      }
      const y = h.morphTargetsRelative ? 1 : 1 - x;
      d.getUniforms().setValue(o, "morphTargetBaseInfluence", y), d.getUniforms().setValue(o, "morphTargetInfluences", n);
    }
  }
  return {
    update: l
  };
}
function p0(o, e, t, i) {
  let n = /* @__PURE__ */ new WeakMap();
  function s(l) {
    const c = i.render.frame, h = l.geometry, u = e.get(l, h);
    return n.get(u) !== c && (e.update(u), n.set(u, c)), l.isInstancedMesh && (l.hasEventListener("dispose", a) === !1 && l.addEventListener("dispose", a), t.update(l.instanceMatrix, 34962), l.instanceColor !== null && t.update(l.instanceColor, 34962)), u;
  }
  function r() {
    n = /* @__PURE__ */ new WeakMap();
  }
  function a(l) {
    const c = l.target;
    c.removeEventListener("dispose", a), t.remove(c.instanceMatrix), c.instanceColor !== null && t.remove(c.instanceColor);
  }
  return {
    update: s,
    dispose: r
  };
}
const xd = /* @__PURE__ */ new dt(), wd = /* @__PURE__ */ new md(), bd = /* @__PURE__ */ new tm(), Md = /* @__PURE__ */ new Za(), bh = [], Mh = [], Sh = new Float32Array(16), Th = new Float32Array(9), Ah = new Float32Array(4);
function Fs(o, e, t) {
  const i = o[0];
  if (i <= 0 || i > 0) return o;
  const n = e * t;
  let s = bh[n];
  if (s === void 0 && (s = new Float32Array(n), bh[n] = s), e !== 0) {
    i.toArray(s, 0);
    for (let r = 1, a = 0; r !== e; ++r)
      a += t, o[r].toArray(s, a);
  }
  return s;
}
function wt(o, e) {
  if (o.length !== e.length) return !1;
  for (let t = 0, i = o.length; t < i; t++)
    if (o[t] !== e[t]) return !1;
  return !0;
}
function bt(o, e) {
  for (let t = 0, i = e.length; t < i; t++)
    o[t] = e[t];
}
function Ka(o, e) {
  let t = Mh[e];
  t === void 0 && (t = new Int32Array(e), Mh[e] = t);
  for (let i = 0; i !== e; ++i)
    t[i] = o.allocateTextureUnit();
  return t;
}
function m0(o, e) {
  const t = this.cache;
  t[0] !== e && (o.uniform1f(this.addr, e), t[0] = e);
}
function _0(o, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) && (o.uniform2f(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
  else {
    if (wt(t, e)) return;
    o.uniform2fv(this.addr, e), bt(t, e);
  }
}
function g0(o, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (o.uniform3f(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
  else if (e.r !== void 0)
    (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) && (o.uniform3f(this.addr, e.r, e.g, e.b), t[0] = e.r, t[1] = e.g, t[2] = e.b);
  else {
    if (wt(t, e)) return;
    o.uniform3fv(this.addr, e), bt(t, e);
  }
}
function v0(o, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (o.uniform4f(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
  else {
    if (wt(t, e)) return;
    o.uniform4fv(this.addr, e), bt(t, e);
  }
}
function y0(o, e) {
  const t = this.cache, i = e.elements;
  if (i === void 0) {
    if (wt(t, e)) return;
    o.uniformMatrix2fv(this.addr, !1, e), bt(t, e);
  } else {
    if (wt(t, i)) return;
    Ah.set(i), o.uniformMatrix2fv(this.addr, !1, Ah), bt(t, i);
  }
}
function x0(o, e) {
  const t = this.cache, i = e.elements;
  if (i === void 0) {
    if (wt(t, e)) return;
    o.uniformMatrix3fv(this.addr, !1, e), bt(t, e);
  } else {
    if (wt(t, i)) return;
    Th.set(i), o.uniformMatrix3fv(this.addr, !1, Th), bt(t, i);
  }
}
function w0(o, e) {
  const t = this.cache, i = e.elements;
  if (i === void 0) {
    if (wt(t, e)) return;
    o.uniformMatrix4fv(this.addr, !1, e), bt(t, e);
  } else {
    if (wt(t, i)) return;
    Sh.set(i), o.uniformMatrix4fv(this.addr, !1, Sh), bt(t, i);
  }
}
function b0(o, e) {
  const t = this.cache;
  t[0] !== e && (o.uniform1i(this.addr, e), t[0] = e);
}
function M0(o, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) && (o.uniform2i(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
  else {
    if (wt(t, e)) return;
    o.uniform2iv(this.addr, e), bt(t, e);
  }
}
function S0(o, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (o.uniform3i(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
  else {
    if (wt(t, e)) return;
    o.uniform3iv(this.addr, e), bt(t, e);
  }
}
function T0(o, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (o.uniform4i(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
  else {
    if (wt(t, e)) return;
    o.uniform4iv(this.addr, e), bt(t, e);
  }
}
function A0(o, e) {
  const t = this.cache;
  t[0] !== e && (o.uniform1ui(this.addr, e), t[0] = e);
}
function E0(o, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) && (o.uniform2ui(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
  else {
    if (wt(t, e)) return;
    o.uniform2uiv(this.addr, e), bt(t, e);
  }
}
function C0(o, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (o.uniform3ui(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
  else {
    if (wt(t, e)) return;
    o.uniform3uiv(this.addr, e), bt(t, e);
  }
}
function L0(o, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (o.uniform4ui(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
  else {
    if (wt(t, e)) return;
    o.uniform4uiv(this.addr, e), bt(t, e);
  }
}
function P0(o, e, t) {
  const i = this.cache, n = t.allocateTextureUnit();
  i[0] !== n && (o.uniform1i(this.addr, n), i[0] = n), t.setTexture2D(e || xd, n);
}
function R0(o, e, t) {
  const i = this.cache, n = t.allocateTextureUnit();
  i[0] !== n && (o.uniform1i(this.addr, n), i[0] = n), t.setTexture3D(e || bd, n);
}
function I0(o, e, t) {
  const i = this.cache, n = t.allocateTextureUnit();
  i[0] !== n && (o.uniform1i(this.addr, n), i[0] = n), t.setTextureCube(e || Md, n);
}
function D0(o, e, t) {
  const i = this.cache, n = t.allocateTextureUnit();
  i[0] !== n && (o.uniform1i(this.addr, n), i[0] = n), t.setTexture2DArray(e || wd, n);
}
function O0(o) {
  switch (o) {
    case 5126:
      return m0;
    case 35664:
      return _0;
    case 35665:
      return g0;
    case 35666:
      return v0;
    case 35674:
      return y0;
    case 35675:
      return x0;
    case 35676:
      return w0;
    case 5124:
    case 35670:
      return b0;
    case 35667:
    case 35671:
      return M0;
    case 35668:
    case 35672:
      return S0;
    case 35669:
    case 35673:
      return T0;
    case 5125:
      return A0;
    case 36294:
      return E0;
    case 36295:
      return C0;
    case 36296:
      return L0;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return P0;
    case 35679:
    case 36299:
    case 36307:
      return R0;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return I0;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return D0;
  }
}
function N0(o, e) {
  o.uniform1fv(this.addr, e);
}
function k0(o, e) {
  const t = Fs(e, this.size, 2);
  o.uniform2fv(this.addr, t);
}
function z0(o, e) {
  const t = Fs(e, this.size, 3);
  o.uniform3fv(this.addr, t);
}
function F0(o, e) {
  const t = Fs(e, this.size, 4);
  o.uniform4fv(this.addr, t);
}
function B0(o, e) {
  const t = Fs(e, this.size, 4);
  o.uniformMatrix2fv(this.addr, !1, t);
}
function U0(o, e) {
  const t = Fs(e, this.size, 9);
  o.uniformMatrix3fv(this.addr, !1, t);
}
function V0(o, e) {
  const t = Fs(e, this.size, 16);
  o.uniformMatrix4fv(this.addr, !1, t);
}
function G0(o, e) {
  o.uniform1iv(this.addr, e);
}
function H0(o, e) {
  o.uniform2iv(this.addr, e);
}
function W0(o, e) {
  o.uniform3iv(this.addr, e);
}
function X0(o, e) {
  o.uniform4iv(this.addr, e);
}
function q0(o, e) {
  o.uniform1uiv(this.addr, e);
}
function j0(o, e) {
  o.uniform2uiv(this.addr, e);
}
function Y0(o, e) {
  o.uniform3uiv(this.addr, e);
}
function Z0(o, e) {
  o.uniform4uiv(this.addr, e);
}
function J0(o, e, t) {
  const i = this.cache, n = e.length, s = Ka(t, n);
  wt(i, s) || (o.uniform1iv(this.addr, s), bt(i, s));
  for (let r = 0; r !== n; ++r)
    t.setTexture2D(e[r] || xd, s[r]);
}
function K0(o, e, t) {
  const i = this.cache, n = e.length, s = Ka(t, n);
  wt(i, s) || (o.uniform1iv(this.addr, s), bt(i, s));
  for (let r = 0; r !== n; ++r)
    t.setTexture3D(e[r] || bd, s[r]);
}
function $0(o, e, t) {
  const i = this.cache, n = e.length, s = Ka(t, n);
  wt(i, s) || (o.uniform1iv(this.addr, s), bt(i, s));
  for (let r = 0; r !== n; ++r)
    t.setTextureCube(e[r] || Md, s[r]);
}
function Q0(o, e, t) {
  const i = this.cache, n = e.length, s = Ka(t, n);
  wt(i, s) || (o.uniform1iv(this.addr, s), bt(i, s));
  for (let r = 0; r !== n; ++r)
    t.setTexture2DArray(e[r] || wd, s[r]);
}
function ev(o) {
  switch (o) {
    case 5126:
      return N0;
    case 35664:
      return k0;
    case 35665:
      return z0;
    case 35666:
      return F0;
    case 35674:
      return B0;
    case 35675:
      return U0;
    case 35676:
      return V0;
    case 5124:
    case 35670:
      return G0;
    case 35667:
    case 35671:
      return H0;
    case 35668:
    case 35672:
      return W0;
    case 35669:
    case 35673:
      return X0;
    case 5125:
      return q0;
    case 36294:
      return j0;
    case 36295:
      return Y0;
    case 36296:
      return Z0;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return J0;
    case 35679:
    case 36299:
    case 36307:
      return K0;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return $0;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return Q0;
  }
}
class tv {
  constructor(e, t, i) {
    this.id = e, this.addr = i, this.cache = [], this.setValue = O0(t.type);
  }
}
class iv {
  constructor(e, t, i) {
    this.id = e, this.addr = i, this.cache = [], this.size = t.size, this.setValue = ev(t.type);
  }
}
class nv {
  constructor(e) {
    this.id = e, this.seq = [], this.map = {};
  }
  setValue(e, t, i) {
    const n = this.seq;
    for (let s = 0, r = n.length; s !== r; ++s) {
      const a = n[s];
      a.setValue(e, t[a.id], i);
    }
  }
}
const zo = /(\w+)(\])?(\[|\.)?/g;
function Eh(o, e) {
  o.seq.push(e), o.map[e.id] = e;
}
function sv(o, e, t) {
  const i = o.name, n = i.length;
  for (zo.lastIndex = 0; ; ) {
    const s = zo.exec(i), r = zo.lastIndex;
    let a = s[1];
    const l = s[2] === "]", c = s[3];
    if (l && (a = a | 0), c === void 0 || c === "[" && r + 2 === n) {
      Eh(t, c === void 0 ? new tv(a, o, e) : new iv(a, o, e));
      break;
    } else {
      let u = t.map[a];
      u === void 0 && (u = new nv(a), Eh(t, u)), t = u;
    }
  }
}
class Ia {
  constructor(e, t) {
    this.seq = [], this.map = {};
    const i = e.getProgramParameter(t, 35718);
    for (let n = 0; n < i; ++n) {
      const s = e.getActiveUniform(t, n), r = e.getUniformLocation(t, s.name);
      sv(s, r, this);
    }
  }
  setValue(e, t, i, n) {
    const s = this.map[t];
    s !== void 0 && s.setValue(e, i, n);
  }
  setOptional(e, t, i) {
    const n = t[i];
    n !== void 0 && this.setValue(e, i, n);
  }
  static upload(e, t, i, n) {
    for (let s = 0, r = t.length; s !== r; ++s) {
      const a = t[s], l = i[a.id];
      l.needsUpdate !== !1 && a.setValue(e, l.value, n);
    }
  }
  static seqWithValue(e, t) {
    const i = [];
    for (let n = 0, s = e.length; n !== s; ++n) {
      const r = e[n];
      r.id in t && i.push(r);
    }
    return i;
  }
}
function Ch(o, e, t) {
  const i = o.createShader(e);
  return o.shaderSource(i, t), o.compileShader(i), i;
}
let rv = 0;
function av(o, e) {
  const t = o.split(`
`), i = [], n = Math.max(e - 6, 0), s = Math.min(e + 6, t.length);
  for (let r = n; r < s; r++) {
    const a = r + 1;
    i.push(`${a === e ? ">" : " "} ${a}: ${t[r]}`);
  }
  return i.join(`
`);
}
function ov(o) {
  switch (o) {
    case Fn:
      return ["Linear", "( value )"];
    case He:
      return ["sRGB", "( value )"];
    default:
      return console.warn("THREE.WebGLProgram: Unsupported encoding:", o), ["Linear", "( value )"];
  }
}
function Lh(o, e, t) {
  const i = o.getShaderParameter(e, 35713), n = o.getShaderInfoLog(e).trim();
  if (i && n === "") return "";
  const s = /ERROR: 0:(\d+)/.exec(n);
  if (s) {
    const r = parseInt(s[1]);
    return t.toUpperCase() + `

` + n + `

` + av(o.getShaderSource(e), r);
  } else
    return n;
}
function lv(o, e) {
  const t = ov(e);
  return "vec4 " + o + "( vec4 value ) { return LinearTo" + t[0] + t[1] + "; }";
}
function cv(o, e) {
  let t;
  switch (e) {
    case dp:
      t = "Linear";
      break;
    case fp:
      t = "Reinhard";
      break;
    case pp:
      t = "OptimizedCineon";
      break;
    case mp:
      t = "ACESFilmic";
      break;
    case _p:
      t = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), t = "Linear";
  }
  return "vec3 " + o + "( vec3 color ) { return " + t + "ToneMapping( color ); }";
}
function hv(o) {
  return [
    o.extensionDerivatives || o.envMapCubeUVHeight || o.bumpMap || o.tangentSpaceNormalMap || o.clearcoatNormalMap || o.flatShading || o.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "",
    (o.extensionFragDepth || o.logarithmicDepthBuffer) && o.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "",
    o.extensionDrawBuffers && o.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "",
    (o.extensionShaderTextureLOD || o.envMap || o.transmission) && o.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""
  ].filter(ar).join(`
`);
}
function uv(o) {
  const e = [];
  for (const t in o) {
    const i = o[t];
    i !== !1 && e.push("#define " + t + " " + i);
  }
  return e.join(`
`);
}
function dv(o, e) {
  const t = {}, i = o.getProgramParameter(e, 35721);
  for (let n = 0; n < i; n++) {
    const s = o.getActiveAttrib(e, n), r = s.name;
    let a = 1;
    s.type === 35674 && (a = 2), s.type === 35675 && (a = 3), s.type === 35676 && (a = 4), t[r] = {
      type: s.type,
      location: o.getAttribLocation(e, r),
      locationSize: a
    };
  }
  return t;
}
function ar(o) {
  return o !== "";
}
function Ph(o, e) {
  const t = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
  return o.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, t).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function Rh(o, e) {
  return o.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection);
}
const fv = /^[ \t]*#include +<([\w\d./]+)>/gm;
function vl(o) {
  return o.replace(fv, pv);
}
function pv(o, e) {
  const t = Fe[e];
  if (t === void 0)
    throw new Error("Can not resolve #include <" + e + ">");
  return vl(t);
}
const mv = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function Ih(o) {
  return o.replace(mv, _v);
}
function _v(o, e, t, i) {
  let n = "";
  for (let s = parseInt(e); s < parseInt(t); s++)
    n += i.replace(/\[\s*i\s*\]/g, "[ " + s + " ]").replace(/UNROLLED_LOOP_INDEX/g, s);
  return n;
}
function Dh(o) {
  let e = "precision " + o.precision + ` float;
precision ` + o.precision + " int;";
  return o.precision === "highp" ? e += `
#define HIGH_PRECISION` : o.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : o.precision === "lowp" && (e += `
#define LOW_PRECISION`), e;
}
function gv(o) {
  let e = "SHADOWMAP_TYPE_BASIC";
  return o.shadowMapType === rd ? e = "SHADOWMAP_TYPE_PCF" : o.shadowMapType === Wf ? e = "SHADOWMAP_TYPE_PCF_SOFT" : o.shadowMapType === rr && (e = "SHADOWMAP_TYPE_VSM"), e;
}
function vv(o) {
  let e = "ENVMAP_TYPE_CUBE";
  if (o.envMap)
    switch (o.envMapMode) {
      case Nn:
      case kn:
        e = "ENVMAP_TYPE_CUBE";
        break;
      case Cr:
        e = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  return e;
}
function yv(o) {
  let e = "ENVMAP_MODE_REFLECTION";
  if (o.envMap)
    switch (o.envMapMode) {
      case kn:
        e = "ENVMAP_MODE_REFRACTION";
        break;
    }
  return e;
}
function xv(o) {
  let e = "ENVMAP_BLENDING_NONE";
  if (o.envMap)
    switch (o.combine) {
      case Ya:
        e = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case hp:
        e = "ENVMAP_BLENDING_MIX";
        break;
      case up:
        e = "ENVMAP_BLENDING_ADD";
        break;
    }
  return e;
}
function wv(o) {
  const e = o.envMapCubeUVHeight;
  if (e === null) return null;
  const t = Math.log2(e) - 2, i = 1 / e;
  return { texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)), texelHeight: i, maxMip: t };
}
function bv(o, e, t, i) {
  const n = o.getContext(), s = t.defines;
  let r = t.vertexShader, a = t.fragmentShader;
  const l = gv(t), c = vv(t), h = yv(t), u = xv(t), d = wv(t), f = t.isWebGL2 ? "" : hv(t), m = uv(s), _ = n.createProgram();
  let p, g, x = t.glslVersion ? "#version " + t.glslVersion + `
` : "";
  t.isRawShaderMaterial ? (p = [
    m
  ].filter(ar).join(`
`), p.length > 0 && (p += `
`), g = [
    f,
    m
  ].filter(ar).join(`
`), g.length > 0 && (g += `
`)) : (p = [
    Dh(t),
    "#define SHADER_NAME " + t.shaderName,
    m,
    t.instancing ? "#define USE_INSTANCING" : "",
    t.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
    t.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
    t.useFog && t.fog ? "#define USE_FOG" : "",
    t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
    t.map ? "#define USE_MAP" : "",
    t.envMap ? "#define USE_ENVMAP" : "",
    t.envMap ? "#define " + h : "",
    t.lightMap ? "#define USE_LIGHTMAP" : "",
    t.aoMap ? "#define USE_AOMAP" : "",
    t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    t.bumpMap ? "#define USE_BUMPMAP" : "",
    t.normalMap ? "#define USE_NORMALMAP" : "",
    t.normalMap && t.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
    t.normalMap && t.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
    t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
    t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
    t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
    t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
    t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
    t.displacementMap && t.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "",
    t.specularMap ? "#define USE_SPECULARMAP" : "",
    t.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
    t.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
    t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    t.metalnessMap ? "#define USE_METALNESSMAP" : "",
    t.alphaMap ? "#define USE_ALPHAMAP" : "",
    t.transmission ? "#define USE_TRANSMISSION" : "",
    t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
    t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
    t.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
    t.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
    t.vertexTangents ? "#define USE_TANGENT" : "",
    t.vertexColors ? "#define USE_COLOR" : "",
    t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
    t.vertexUvs ? "#define USE_UV" : "",
    t.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
    t.flatShading ? "#define FLAT_SHADED" : "",
    t.skinning ? "#define USE_SKINNING" : "",
    t.morphTargets ? "#define USE_MORPHTARGETS" : "",
    t.morphNormals && t.flatShading === !1 ? "#define USE_MORPHNORMALS" : "",
    t.morphColors && t.isWebGL2 ? "#define USE_MORPHCOLORS" : "",
    t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "",
    t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride : "",
    t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount : "",
    t.doubleSided ? "#define DOUBLE_SIDED" : "",
    t.flipSided ? "#define FLIP_SIDED" : "",
    t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    t.shadowMapEnabled ? "#define " + l : "",
    t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
    t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
    t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
    "uniform mat4 modelMatrix;",
    "uniform mat4 modelViewMatrix;",
    "uniform mat4 projectionMatrix;",
    "uniform mat4 viewMatrix;",
    "uniform mat3 normalMatrix;",
    "uniform vec3 cameraPosition;",
    "uniform bool isOrthographic;",
    "#ifdef USE_INSTANCING",
    "	attribute mat4 instanceMatrix;",
    "#endif",
    "#ifdef USE_INSTANCING_COLOR",
    "	attribute vec3 instanceColor;",
    "#endif",
    "attribute vec3 position;",
    "attribute vec3 normal;",
    "attribute vec2 uv;",
    "#ifdef USE_TANGENT",
    "	attribute vec4 tangent;",
    "#endif",
    "#if defined( USE_COLOR_ALPHA )",
    "	attribute vec4 color;",
    "#elif defined( USE_COLOR )",
    "	attribute vec3 color;",
    "#endif",
    "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
    "	attribute vec3 morphTarget0;",
    "	attribute vec3 morphTarget1;",
    "	attribute vec3 morphTarget2;",
    "	attribute vec3 morphTarget3;",
    "	#ifdef USE_MORPHNORMALS",
    "		attribute vec3 morphNormal0;",
    "		attribute vec3 morphNormal1;",
    "		attribute vec3 morphNormal2;",
    "		attribute vec3 morphNormal3;",
    "	#else",
    "		attribute vec3 morphTarget4;",
    "		attribute vec3 morphTarget5;",
    "		attribute vec3 morphTarget6;",
    "		attribute vec3 morphTarget7;",
    "	#endif",
    "#endif",
    "#ifdef USE_SKINNING",
    "	attribute vec4 skinIndex;",
    "	attribute vec4 skinWeight;",
    "#endif",
    `
`
  ].filter(ar).join(`
`), g = [
    f,
    Dh(t),
    "#define SHADER_NAME " + t.shaderName,
    m,
    t.useFog && t.fog ? "#define USE_FOG" : "",
    t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
    t.map ? "#define USE_MAP" : "",
    t.matcap ? "#define USE_MATCAP" : "",
    t.envMap ? "#define USE_ENVMAP" : "",
    t.envMap ? "#define " + c : "",
    t.envMap ? "#define " + h : "",
    t.envMap ? "#define " + u : "",
    d ? "#define CUBEUV_TEXEL_WIDTH " + d.texelWidth : "",
    d ? "#define CUBEUV_TEXEL_HEIGHT " + d.texelHeight : "",
    d ? "#define CUBEUV_MAX_MIP " + d.maxMip + ".0" : "",
    t.lightMap ? "#define USE_LIGHTMAP" : "",
    t.aoMap ? "#define USE_AOMAP" : "",
    t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    t.bumpMap ? "#define USE_BUMPMAP" : "",
    t.normalMap ? "#define USE_NORMALMAP" : "",
    t.normalMap && t.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
    t.normalMap && t.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
    t.clearcoat ? "#define USE_CLEARCOAT" : "",
    t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
    t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
    t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
    t.iridescence ? "#define USE_IRIDESCENCE" : "",
    t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
    t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
    t.specularMap ? "#define USE_SPECULARMAP" : "",
    t.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
    t.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
    t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    t.metalnessMap ? "#define USE_METALNESSMAP" : "",
    t.alphaMap ? "#define USE_ALPHAMAP" : "",
    t.alphaTest ? "#define USE_ALPHATEST" : "",
    t.sheen ? "#define USE_SHEEN" : "",
    t.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
    t.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
    t.transmission ? "#define USE_TRANSMISSION" : "",
    t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
    t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
    t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
    t.vertexTangents ? "#define USE_TANGENT" : "",
    t.vertexColors || t.instancingColor ? "#define USE_COLOR" : "",
    t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
    t.vertexUvs ? "#define USE_UV" : "",
    t.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
    t.gradientMap ? "#define USE_GRADIENTMAP" : "",
    t.flatShading ? "#define FLAT_SHADED" : "",
    t.doubleSided ? "#define DOUBLE_SIDED" : "",
    t.flipSided ? "#define FLIP_SIDED" : "",
    t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    t.shadowMapEnabled ? "#define " + l : "",
    t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
    t.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "",
    t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
    t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
    "uniform mat4 viewMatrix;",
    "uniform vec3 cameraPosition;",
    "uniform bool isOrthographic;",
    t.toneMapping !== Wi ? "#define TONE_MAPPING" : "",
    t.toneMapping !== Wi ? Fe.tonemapping_pars_fragment : "",
    // this code is required here because it is used by the toneMapping() function defined below
    t.toneMapping !== Wi ? cv("toneMapping", t.toneMapping) : "",
    t.dithering ? "#define DITHERING" : "",
    t.opaque ? "#define OPAQUE" : "",
    Fe.encodings_pars_fragment,
    // this code is required here because it is used by the various encoding/decoding function defined below
    lv("linearToOutputTexel", t.outputEncoding),
    t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "",
    `
`
  ].filter(ar).join(`
`)), r = vl(r), r = Ph(r, t), r = Rh(r, t), a = vl(a), a = Ph(a, t), a = Rh(a, t), r = Ih(r), a = Ih(a), t.isWebGL2 && t.isRawShaderMaterial !== !0 && (x = `#version 300 es
`, p = [
    "precision mediump sampler2DArray;",
    "#define attribute in",
    "#define varying out",
    "#define texture2D texture"
  ].join(`
`) + `
` + p, g = [
    "#define varying in",
    t.glslVersion === nh ? "" : "layout(location = 0) out highp vec4 pc_fragColor;",
    t.glslVersion === nh ? "" : "#define gl_FragColor pc_fragColor",
    "#define gl_FragDepthEXT gl_FragDepth",
    "#define texture2D texture",
    "#define textureCube texture",
    "#define texture2DProj textureProj",
    "#define texture2DLodEXT textureLod",
    "#define texture2DProjLodEXT textureProjLod",
    "#define textureCubeLodEXT textureLod",
    "#define texture2DGradEXT textureGrad",
    "#define texture2DProjGradEXT textureProjGrad",
    "#define textureCubeGradEXT textureGrad"
  ].join(`
`) + `
` + g);
  const y = x + p + r, v = x + g + a, M = Ch(n, 35633, y), S = Ch(n, 35632, v);
  if (n.attachShader(_, M), n.attachShader(_, S), t.index0AttributeName !== void 0 ? n.bindAttribLocation(_, 0, t.index0AttributeName) : t.morphTargets === !0 && n.bindAttribLocation(_, 0, "position"), n.linkProgram(_), o.debug.checkShaderErrors) {
    const E = n.getProgramInfoLog(_).trim(), P = n.getShaderInfoLog(M).trim(), z = n.getShaderInfoLog(S).trim();
    let V = !0, O = !0;
    if (n.getProgramParameter(_, 35714) === !1) {
      V = !1;
      const D = Lh(n, M, "vertex"), H = Lh(n, S, "fragment");
      console.error(
        "THREE.WebGLProgram: Shader Error " + n.getError() + " - VALIDATE_STATUS " + n.getProgramParameter(_, 35715) + `

Program Info Log: ` + E + `
` + D + `
` + H
      );
    } else E !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", E) : (P === "" || z === "") && (O = !1);
    O && (this.diagnostics = {
      runnable: V,
      programLog: E,
      vertexShader: {
        log: P,
        prefix: p
      },
      fragmentShader: {
        log: z,
        prefix: g
      }
    });
  }
  n.deleteShader(M), n.deleteShader(S);
  let A;
  this.getUniforms = function() {
    return A === void 0 && (A = new Ia(n, _)), A;
  };
  let w;
  return this.getAttributes = function() {
    return w === void 0 && (w = dv(n, _)), w;
  }, this.destroy = function() {
    i.releaseStatesOfProgram(this), n.deleteProgram(_), this.program = void 0;
  }, this.name = t.shaderName, this.id = rv++, this.cacheKey = e, this.usedTimes = 1, this.program = _, this.vertexShader = M, this.fragmentShader = S, this;
}
let Mv = 0;
class Sv {
  constructor() {
    this.shaderCache = /* @__PURE__ */ new Map(), this.materialCache = /* @__PURE__ */ new Map();
  }
  update(e) {
    const t = e.vertexShader, i = e.fragmentShader, n = this._getShaderStage(t), s = this._getShaderStage(i), r = this._getShaderCacheForMaterial(e);
    return r.has(n) === !1 && (r.add(n), n.usedTimes++), r.has(s) === !1 && (r.add(s), s.usedTimes++), this;
  }
  remove(e) {
    const t = this.materialCache.get(e);
    for (const i of t)
      i.usedTimes--, i.usedTimes === 0 && this.shaderCache.delete(i.code);
    return this.materialCache.delete(e), this;
  }
  getVertexShaderID(e) {
    return this._getShaderStage(e.vertexShader).id;
  }
  getFragmentShaderID(e) {
    return this._getShaderStage(e.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear();
  }
  _getShaderCacheForMaterial(e) {
    const t = this.materialCache;
    let i = t.get(e);
    return i === void 0 && (i = /* @__PURE__ */ new Set(), t.set(e, i)), i;
  }
  _getShaderStage(e) {
    const t = this.shaderCache;
    let i = t.get(e);
    return i === void 0 && (i = new Tv(e), t.set(e, i)), i;
  }
}
class Tv {
  constructor(e) {
    this.id = Mv++, this.code = e, this.usedTimes = 0;
  }
}
function Av(o, e, t, i, n, s, r) {
  const a = new Bl(), l = new Sv(), c = [], h = n.isWebGL2, u = n.logarithmicDepthBuffer, d = n.vertexTextures;
  let f = n.precision;
  const m = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite"
  };
  function _(w, E, P, z, V) {
    const O = z.fog, D = V.geometry, H = w.isMeshStandardMaterial ? z.environment : null, Z = (w.isMeshStandardMaterial ? t : e).get(w.envMap || H), ie = Z && Z.mapping === Cr ? Z.image.height : null, K = m[w.type];
    w.precision !== null && (f = n.getMaxPrecision(w.precision), f !== w.precision && console.warn("THREE.WebGLProgram.getParameters:", w.precision, "not supported, using", f, "instead."));
    const ne = D.morphAttributes.position || D.morphAttributes.normal || D.morphAttributes.color, te = ne !== void 0 ? ne.length : 0;
    let q = 0;
    D.morphAttributes.position !== void 0 && (q = 1), D.morphAttributes.normal !== void 0 && (q = 2), D.morphAttributes.color !== void 0 && (q = 3);
    let W, le, ae, fe;
    if (K) {
      const ze = qt[K];
      W = ze.vertexShader, le = ze.fragmentShader;
    } else
      W = w.vertexShader, le = w.fragmentShader, l.update(w), ae = l.getVertexShaderID(w), fe = l.getFragmentShaderID(w);
    const j = o.getRenderTarget(), De = w.alphaTest > 0, ye = w.clearcoat > 0, Re = w.iridescence > 0;
    return {
      isWebGL2: h,
      shaderID: K,
      shaderName: w.type,
      vertexShader: W,
      fragmentShader: le,
      defines: w.defines,
      customVertexShaderID: ae,
      customFragmentShaderID: fe,
      isRawShaderMaterial: w.isRawShaderMaterial === !0,
      glslVersion: w.glslVersion,
      precision: f,
      instancing: V.isInstancedMesh === !0,
      instancingColor: V.isInstancedMesh === !0 && V.instanceColor !== null,
      supportsVertexTextures: d,
      outputEncoding: j === null ? o.outputEncoding : j.isXRRenderTarget === !0 ? j.texture.encoding : Fn,
      map: !!w.map,
      matcap: !!w.matcap,
      envMap: !!Z,
      envMapMode: Z && Z.mapping,
      envMapCubeUVHeight: ie,
      lightMap: !!w.lightMap,
      aoMap: !!w.aoMap,
      emissiveMap: !!w.emissiveMap,
      bumpMap: !!w.bumpMap,
      normalMap: !!w.normalMap,
      objectSpaceNormalMap: w.normalMapType === Fp,
      tangentSpaceNormalMap: w.normalMapType === Vn,
      decodeVideoTexture: !!w.map && w.map.isVideoTexture === !0 && w.map.encoding === He,
      clearcoat: ye,
      clearcoatMap: ye && !!w.clearcoatMap,
      clearcoatRoughnessMap: ye && !!w.clearcoatRoughnessMap,
      clearcoatNormalMap: ye && !!w.clearcoatNormalMap,
      iridescence: Re,
      iridescenceMap: Re && !!w.iridescenceMap,
      iridescenceThicknessMap: Re && !!w.iridescenceThicknessMap,
      displacementMap: !!w.displacementMap,
      roughnessMap: !!w.roughnessMap,
      metalnessMap: !!w.metalnessMap,
      specularMap: !!w.specularMap,
      specularIntensityMap: !!w.specularIntensityMap,
      specularColorMap: !!w.specularColorMap,
      opaque: w.transparent === !1 && w.blending === bs,
      alphaMap: !!w.alphaMap,
      alphaTest: De,
      gradientMap: !!w.gradientMap,
      sheen: w.sheen > 0,
      sheenColorMap: !!w.sheenColorMap,
      sheenRoughnessMap: !!w.sheenRoughnessMap,
      transmission: w.transmission > 0,
      transmissionMap: !!w.transmissionMap,
      thicknessMap: !!w.thicknessMap,
      combine: w.combine,
      vertexTangents: !!w.normalMap && !!D.attributes.tangent,
      vertexColors: w.vertexColors,
      vertexAlphas: w.vertexColors === !0 && !!D.attributes.color && D.attributes.color.itemSize === 4,
      vertexUvs: !!w.map || !!w.bumpMap || !!w.normalMap || !!w.specularMap || !!w.alphaMap || !!w.emissiveMap || !!w.roughnessMap || !!w.metalnessMap || !!w.clearcoatMap || !!w.clearcoatRoughnessMap || !!w.clearcoatNormalMap || !!w.iridescenceMap || !!w.iridescenceThicknessMap || !!w.displacementMap || !!w.transmissionMap || !!w.thicknessMap || !!w.specularIntensityMap || !!w.specularColorMap || !!w.sheenColorMap || !!w.sheenRoughnessMap,
      uvsVertexOnly: !(w.map || w.bumpMap || w.normalMap || w.specularMap || w.alphaMap || w.emissiveMap || w.roughnessMap || w.metalnessMap || w.clearcoatNormalMap || w.iridescenceMap || w.iridescenceThicknessMap || w.transmission > 0 || w.transmissionMap || w.thicknessMap || w.specularIntensityMap || w.specularColorMap || w.sheen > 0 || w.sheenColorMap || w.sheenRoughnessMap) && !!w.displacementMap,
      fog: !!O,
      useFog: w.fog === !0,
      fogExp2: O && O.isFogExp2,
      flatShading: !!w.flatShading,
      sizeAttenuation: w.sizeAttenuation,
      logarithmicDepthBuffer: u,
      skinning: V.isSkinnedMesh === !0,
      morphTargets: D.morphAttributes.position !== void 0,
      morphNormals: D.morphAttributes.normal !== void 0,
      morphColors: D.morphAttributes.color !== void 0,
      morphTargetsCount: te,
      morphTextureStride: q,
      numDirLights: E.directional.length,
      numPointLights: E.point.length,
      numSpotLights: E.spot.length,
      numSpotLightMaps: E.spotLightMap.length,
      numRectAreaLights: E.rectArea.length,
      numHemiLights: E.hemi.length,
      numDirLightShadows: E.directionalShadowMap.length,
      numPointLightShadows: E.pointShadowMap.length,
      numSpotLightShadows: E.spotShadowMap.length,
      numSpotLightShadowsWithMaps: E.numSpotLightShadowsWithMaps,
      numClippingPlanes: r.numPlanes,
      numClipIntersection: r.numIntersection,
      dithering: w.dithering,
      shadowMapEnabled: o.shadowMap.enabled && P.length > 0,
      shadowMapType: o.shadowMap.type,
      toneMapping: w.toneMapped ? o.toneMapping : Wi,
      physicallyCorrectLights: o.physicallyCorrectLights,
      premultipliedAlpha: w.premultipliedAlpha,
      doubleSided: w.side === ji,
      flipSided: w.side === oi,
      useDepthPacking: !!w.depthPacking,
      depthPacking: w.depthPacking || 0,
      index0AttributeName: w.index0AttributeName,
      extensionDerivatives: w.extensions && w.extensions.derivatives,
      extensionFragDepth: w.extensions && w.extensions.fragDepth,
      extensionDrawBuffers: w.extensions && w.extensions.drawBuffers,
      extensionShaderTextureLOD: w.extensions && w.extensions.shaderTextureLOD,
      rendererExtensionFragDepth: h || i.has("EXT_frag_depth"),
      rendererExtensionDrawBuffers: h || i.has("WEBGL_draw_buffers"),
      rendererExtensionShaderTextureLod: h || i.has("EXT_shader_texture_lod"),
      customProgramCacheKey: w.customProgramCacheKey()
    };
  }
  function p(w) {
    const E = [];
    if (w.shaderID ? E.push(w.shaderID) : (E.push(w.customVertexShaderID), E.push(w.customFragmentShaderID)), w.defines !== void 0)
      for (const P in w.defines)
        E.push(P), E.push(w.defines[P]);
    return w.isRawShaderMaterial === !1 && (g(E, w), x(E, w), E.push(o.outputEncoding)), E.push(w.customProgramCacheKey), E.join();
  }
  function g(w, E) {
    w.push(E.precision), w.push(E.outputEncoding), w.push(E.envMapMode), w.push(E.envMapCubeUVHeight), w.push(E.combine), w.push(E.vertexUvs), w.push(E.fogExp2), w.push(E.sizeAttenuation), w.push(E.morphTargetsCount), w.push(E.morphAttributeCount), w.push(E.numDirLights), w.push(E.numPointLights), w.push(E.numSpotLights), w.push(E.numSpotLightMaps), w.push(E.numHemiLights), w.push(E.numRectAreaLights), w.push(E.numDirLightShadows), w.push(E.numPointLightShadows), w.push(E.numSpotLightShadows), w.push(E.numSpotLightShadowsWithMaps), w.push(E.shadowMapType), w.push(E.toneMapping), w.push(E.numClippingPlanes), w.push(E.numClipIntersection), w.push(E.depthPacking);
  }
  function x(w, E) {
    a.disableAll(), E.isWebGL2 && a.enable(0), E.supportsVertexTextures && a.enable(1), E.instancing && a.enable(2), E.instancingColor && a.enable(3), E.map && a.enable(4), E.matcap && a.enable(5), E.envMap && a.enable(6), E.lightMap && a.enable(7), E.aoMap && a.enable(8), E.emissiveMap && a.enable(9), E.bumpMap && a.enable(10), E.normalMap && a.enable(11), E.objectSpaceNormalMap && a.enable(12), E.tangentSpaceNormalMap && a.enable(13), E.clearcoat && a.enable(14), E.clearcoatMap && a.enable(15), E.clearcoatRoughnessMap && a.enable(16), E.clearcoatNormalMap && a.enable(17), E.iridescence && a.enable(18), E.iridescenceMap && a.enable(19), E.iridescenceThicknessMap && a.enable(20), E.displacementMap && a.enable(21), E.specularMap && a.enable(22), E.roughnessMap && a.enable(23), E.metalnessMap && a.enable(24), E.gradientMap && a.enable(25), E.alphaMap && a.enable(26), E.alphaTest && a.enable(27), E.vertexColors && a.enable(28), E.vertexAlphas && a.enable(29), E.vertexUvs && a.enable(30), E.vertexTangents && a.enable(31), E.uvsVertexOnly && a.enable(32), w.push(a.mask), a.disableAll(), E.fog && a.enable(0), E.useFog && a.enable(1), E.flatShading && a.enable(2), E.logarithmicDepthBuffer && a.enable(3), E.skinning && a.enable(4), E.morphTargets && a.enable(5), E.morphNormals && a.enable(6), E.morphColors && a.enable(7), E.premultipliedAlpha && a.enable(8), E.shadowMapEnabled && a.enable(9), E.physicallyCorrectLights && a.enable(10), E.doubleSided && a.enable(11), E.flipSided && a.enable(12), E.useDepthPacking && a.enable(13), E.dithering && a.enable(14), E.specularIntensityMap && a.enable(15), E.specularColorMap && a.enable(16), E.transmission && a.enable(17), E.transmissionMap && a.enable(18), E.thicknessMap && a.enable(19), E.sheen && a.enable(20), E.sheenColorMap && a.enable(21), E.sheenRoughnessMap && a.enable(22), E.decodeVideoTexture && a.enable(23), E.opaque && a.enable(24), w.push(a.mask);
  }
  function y(w) {
    const E = m[w.type];
    let P;
    if (E) {
      const z = qt[E];
      P = Lr.clone(z.uniforms);
    } else
      P = w.uniforms;
    return P;
  }
  function v(w, E) {
    let P;
    for (let z = 0, V = c.length; z < V; z++) {
      const O = c[z];
      if (O.cacheKey === E) {
        P = O, ++P.usedTimes;
        break;
      }
    }
    return P === void 0 && (P = new bv(o, E, w, s), c.push(P)), P;
  }
  function M(w) {
    if (--w.usedTimes === 0) {
      const E = c.indexOf(w);
      c[E] = c[c.length - 1], c.pop(), w.destroy();
    }
  }
  function S(w) {
    l.remove(w);
  }
  function A() {
    l.dispose();
  }
  return {
    getParameters: _,
    getProgramCacheKey: p,
    getUniforms: y,
    acquireProgram: v,
    releaseProgram: M,
    releaseShaderCache: S,
    // Exposed for resource monitoring & error feedback via renderer.info:
    programs: c,
    dispose: A
  };
}
function Ev() {
  let o = /* @__PURE__ */ new WeakMap();
  function e(s) {
    let r = o.get(s);
    return r === void 0 && (r = {}, o.set(s, r)), r;
  }
  function t(s) {
    o.delete(s);
  }
  function i(s, r, a) {
    o.get(s)[r] = a;
  }
  function n() {
    o = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: e,
    remove: t,
    update: i,
    dispose: n
  };
}
function Cv(o, e) {
  return o.groupOrder !== e.groupOrder ? o.groupOrder - e.groupOrder : o.renderOrder !== e.renderOrder ? o.renderOrder - e.renderOrder : o.material.id !== e.material.id ? o.material.id - e.material.id : o.z !== e.z ? o.z - e.z : o.id - e.id;
}
function Oh(o, e) {
  return o.groupOrder !== e.groupOrder ? o.groupOrder - e.groupOrder : o.renderOrder !== e.renderOrder ? o.renderOrder - e.renderOrder : o.z !== e.z ? e.z - o.z : o.id - e.id;
}
function Nh() {
  const o = [];
  let e = 0;
  const t = [], i = [], n = [];
  function s() {
    e = 0, t.length = 0, i.length = 0, n.length = 0;
  }
  function r(u, d, f, m, _, p) {
    let g = o[e];
    return g === void 0 ? (g = {
      id: u.id,
      object: u,
      geometry: d,
      material: f,
      groupOrder: m,
      renderOrder: u.renderOrder,
      z: _,
      group: p
    }, o[e] = g) : (g.id = u.id, g.object = u, g.geometry = d, g.material = f, g.groupOrder = m, g.renderOrder = u.renderOrder, g.z = _, g.group = p), e++, g;
  }
  function a(u, d, f, m, _, p) {
    const g = r(u, d, f, m, _, p);
    f.transmission > 0 ? i.push(g) : f.transparent === !0 ? n.push(g) : t.push(g);
  }
  function l(u, d, f, m, _, p) {
    const g = r(u, d, f, m, _, p);
    f.transmission > 0 ? i.unshift(g) : f.transparent === !0 ? n.unshift(g) : t.unshift(g);
  }
  function c(u, d) {
    t.length > 1 && t.sort(u || Cv), i.length > 1 && i.sort(d || Oh), n.length > 1 && n.sort(d || Oh);
  }
  function h() {
    for (let u = e, d = o.length; u < d; u++) {
      const f = o[u];
      if (f.id === null) break;
      f.id = null, f.object = null, f.geometry = null, f.material = null, f.group = null;
    }
  }
  return {
    opaque: t,
    transmissive: i,
    transparent: n,
    init: s,
    push: a,
    unshift: l,
    finish: h,
    sort: c
  };
}
function Lv() {
  let o = /* @__PURE__ */ new WeakMap();
  function e(i, n) {
    const s = o.get(i);
    let r;
    return s === void 0 ? (r = new Nh(), o.set(i, [r])) : n >= s.length ? (r = new Nh(), s.push(r)) : r = s[n], r;
  }
  function t() {
    o = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: e,
    dispose: t
  };
}
function Pv() {
  const o = {};
  return {
    get: function(e) {
      if (o[e.id] !== void 0)
        return o[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = {
            direction: new b(),
            color: new de()
          };
          break;
        case "SpotLight":
          t = {
            position: new b(),
            direction: new b(),
            color: new de(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0
          };
          break;
        case "PointLight":
          t = {
            position: new b(),
            color: new de(),
            distance: 0,
            decay: 0
          };
          break;
        case "HemisphereLight":
          t = {
            direction: new b(),
            skyColor: new de(),
            groundColor: new de()
          };
          break;
        case "RectAreaLight":
          t = {
            color: new de(),
            position: new b(),
            halfWidth: new b(),
            halfHeight: new b()
          };
          break;
      }
      return o[e.id] = t, t;
    }
  };
}
function Rv() {
  const o = {};
  return {
    get: function(e) {
      if (o[e.id] !== void 0)
        return o[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new G()
          };
          break;
        case "SpotLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new G()
          };
          break;
        case "PointLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new G(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3
          };
          break;
      }
      return o[e.id] = t, t;
    }
  };
}
let Iv = 0;
function Dv(o, e) {
  return (e.castShadow ? 2 : 0) - (o.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (o.map ? 1 : 0);
}
function Ov(o, e) {
  const t = new Pv(), i = Rv(), n = {
    version: 0,
    hash: {
      directionalLength: -1,
      pointLength: -1,
      spotLength: -1,
      rectAreaLength: -1,
      hemiLength: -1,
      numDirectionalShadows: -1,
      numPointShadows: -1,
      numSpotShadows: -1,
      numSpotMaps: -1
    },
    ambient: [0, 0, 0],
    probe: [],
    directional: [],
    directionalShadow: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotLightMap: [],
    spotShadow: [],
    spotShadowMap: [],
    spotLightMatrix: [],
    rectArea: [],
    rectAreaLTC1: null,
    rectAreaLTC2: null,
    point: [],
    pointShadow: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: [],
    numSpotLightShadowsWithMaps: 0
  };
  for (let h = 0; h < 9; h++) n.probe.push(new b());
  const s = new b(), r = new ue(), a = new ue();
  function l(h, u) {
    let d = 0, f = 0, m = 0;
    for (let z = 0; z < 9; z++) n.probe[z].set(0, 0, 0);
    let _ = 0, p = 0, g = 0, x = 0, y = 0, v = 0, M = 0, S = 0, A = 0, w = 0;
    h.sort(Dv);
    const E = u !== !0 ? Math.PI : 1;
    for (let z = 0, V = h.length; z < V; z++) {
      const O = h[z], D = O.color, H = O.intensity, Z = O.distance, ie = O.shadow && O.shadow.map ? O.shadow.map.texture : null;
      if (O.isAmbientLight)
        d += D.r * H * E, f += D.g * H * E, m += D.b * H * E;
      else if (O.isLightProbe)
        for (let K = 0; K < 9; K++)
          n.probe[K].addScaledVector(O.sh.coefficients[K], H);
      else if (O.isDirectionalLight) {
        const K = t.get(O);
        if (K.color.copy(O.color).multiplyScalar(O.intensity * E), O.castShadow) {
          const ne = O.shadow, te = i.get(O);
          te.shadowBias = ne.bias, te.shadowNormalBias = ne.normalBias, te.shadowRadius = ne.radius, te.shadowMapSize = ne.mapSize, n.directionalShadow[_] = te, n.directionalShadowMap[_] = ie, n.directionalShadowMatrix[_] = O.shadow.matrix, v++;
        }
        n.directional[_] = K, _++;
      } else if (O.isSpotLight) {
        const K = t.get(O);
        K.position.setFromMatrixPosition(O.matrixWorld), K.color.copy(D).multiplyScalar(H * E), K.distance = Z, K.coneCos = Math.cos(O.angle), K.penumbraCos = Math.cos(O.angle * (1 - O.penumbra)), K.decay = O.decay, n.spot[g] = K;
        const ne = O.shadow;
        if (O.map && (n.spotLightMap[A] = O.map, A++, ne.updateMatrices(O), O.castShadow && w++), n.spotLightMatrix[g] = ne.matrix, O.castShadow) {
          const te = i.get(O);
          te.shadowBias = ne.bias, te.shadowNormalBias = ne.normalBias, te.shadowRadius = ne.radius, te.shadowMapSize = ne.mapSize, n.spotShadow[g] = te, n.spotShadowMap[g] = ie, S++;
        }
        g++;
      } else if (O.isRectAreaLight) {
        const K = t.get(O);
        K.color.copy(D).multiplyScalar(H), K.halfWidth.set(O.width * 0.5, 0, 0), K.halfHeight.set(0, O.height * 0.5, 0), n.rectArea[x] = K, x++;
      } else if (O.isPointLight) {
        const K = t.get(O);
        if (K.color.copy(O.color).multiplyScalar(O.intensity * E), K.distance = O.distance, K.decay = O.decay, O.castShadow) {
          const ne = O.shadow, te = i.get(O);
          te.shadowBias = ne.bias, te.shadowNormalBias = ne.normalBias, te.shadowRadius = ne.radius, te.shadowMapSize = ne.mapSize, te.shadowCameraNear = ne.camera.near, te.shadowCameraFar = ne.camera.far, n.pointShadow[p] = te, n.pointShadowMap[p] = ie, n.pointShadowMatrix[p] = O.shadow.matrix, M++;
        }
        n.point[p] = K, p++;
      } else if (O.isHemisphereLight) {
        const K = t.get(O);
        K.skyColor.copy(O.color).multiplyScalar(H * E), K.groundColor.copy(O.groundColor).multiplyScalar(H * E), n.hemi[y] = K, y++;
      }
    }
    x > 0 && (e.isWebGL2 || o.has("OES_texture_float_linear") === !0 ? (n.rectAreaLTC1 = he.LTC_FLOAT_1, n.rectAreaLTC2 = he.LTC_FLOAT_2) : o.has("OES_texture_half_float_linear") === !0 ? (n.rectAreaLTC1 = he.LTC_HALF_1, n.rectAreaLTC2 = he.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), n.ambient[0] = d, n.ambient[1] = f, n.ambient[2] = m;
    const P = n.hash;
    (P.directionalLength !== _ || P.pointLength !== p || P.spotLength !== g || P.rectAreaLength !== x || P.hemiLength !== y || P.numDirectionalShadows !== v || P.numPointShadows !== M || P.numSpotShadows !== S || P.numSpotMaps !== A) && (n.directional.length = _, n.spot.length = g, n.rectArea.length = x, n.point.length = p, n.hemi.length = y, n.directionalShadow.length = v, n.directionalShadowMap.length = v, n.pointShadow.length = M, n.pointShadowMap.length = M, n.spotShadow.length = S, n.spotShadowMap.length = S, n.directionalShadowMatrix.length = v, n.pointShadowMatrix.length = M, n.spotLightMatrix.length = S + A - w, n.spotLightMap.length = A, n.numSpotLightShadowsWithMaps = w, P.directionalLength = _, P.pointLength = p, P.spotLength = g, P.rectAreaLength = x, P.hemiLength = y, P.numDirectionalShadows = v, P.numPointShadows = M, P.numSpotShadows = S, P.numSpotMaps = A, n.version = Iv++);
  }
  function c(h, u) {
    let d = 0, f = 0, m = 0, _ = 0, p = 0;
    const g = u.matrixWorldInverse;
    for (let x = 0, y = h.length; x < y; x++) {
      const v = h[x];
      if (v.isDirectionalLight) {
        const M = n.directional[d];
        M.direction.setFromMatrixPosition(v.matrixWorld), s.setFromMatrixPosition(v.target.matrixWorld), M.direction.sub(s), M.direction.transformDirection(g), d++;
      } else if (v.isSpotLight) {
        const M = n.spot[m];
        M.position.setFromMatrixPosition(v.matrixWorld), M.position.applyMatrix4(g), M.direction.setFromMatrixPosition(v.matrixWorld), s.setFromMatrixPosition(v.target.matrixWorld), M.direction.sub(s), M.direction.transformDirection(g), m++;
      } else if (v.isRectAreaLight) {
        const M = n.rectArea[_];
        M.position.setFromMatrixPosition(v.matrixWorld), M.position.applyMatrix4(g), a.identity(), r.copy(v.matrixWorld), r.premultiply(g), a.extractRotation(r), M.halfWidth.set(v.width * 0.5, 0, 0), M.halfHeight.set(0, v.height * 0.5, 0), M.halfWidth.applyMatrix4(a), M.halfHeight.applyMatrix4(a), _++;
      } else if (v.isPointLight) {
        const M = n.point[f];
        M.position.setFromMatrixPosition(v.matrixWorld), M.position.applyMatrix4(g), f++;
      } else if (v.isHemisphereLight) {
        const M = n.hemi[p];
        M.direction.setFromMatrixPosition(v.matrixWorld), M.direction.transformDirection(g), p++;
      }
    }
  }
  return {
    setup: l,
    setupView: c,
    state: n
  };
}
function kh(o, e) {
  const t = new Ov(o, e), i = [], n = [];
  function s() {
    i.length = 0, n.length = 0;
  }
  function r(u) {
    i.push(u);
  }
  function a(u) {
    n.push(u);
  }
  function l(u) {
    t.setup(i, u);
  }
  function c(u) {
    t.setupView(i, u);
  }
  return {
    init: s,
    state: {
      lightsArray: i,
      shadowsArray: n,
      lights: t
    },
    setupLights: l,
    setupLightsView: c,
    pushLight: r,
    pushShadow: a
  };
}
function Nv(o, e) {
  let t = /* @__PURE__ */ new WeakMap();
  function i(s, r = 0) {
    const a = t.get(s);
    let l;
    return a === void 0 ? (l = new kh(o, e), t.set(s, [l])) : r >= a.length ? (l = new kh(o, e), a.push(l)) : l = a[r], l;
  }
  function n() {
    t = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: i,
    dispose: n
  };
}
class Gl extends Ct {
  constructor(e) {
    super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = zp, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this;
  }
}
class Sd extends Ct {
  constructor(e) {
    super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.referencePosition = new b(), this.nearDistance = 1, this.farDistance = 1e3, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.referencePosition.copy(e.referencePosition), this.nearDistance = e.nearDistance, this.farDistance = e.farDistance, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this;
  }
}
const kv = `void main() {
	gl_Position = vec4( position, 1.0 );
}`, zv = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function Fv(o, e, t) {
  let i = new Ja();
  const n = new G(), s = new G(), r = new We(), a = new Gl({ depthPacking: hd }), l = new Sd(), c = {}, h = t.maxTextureSize, u = { 0: oi, 1: dn, 2: ji }, d = new xt({
    defines: {
      VSM_SAMPLES: 8
    },
    uniforms: {
      shadow_pass: { value: null },
      resolution: { value: new G() },
      radius: { value: 4 }
    },
    vertexShader: kv,
    fragmentShader: zv
  }), f = d.clone();
  f.defines.HORIZONTAL_PASS = 1;
  const m = new Ue();
  m.setAttribute(
    "position",
    new $e(
      new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]),
      3
    )
  );
  const _ = new st(m, d), p = this;
  this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = rd, this.render = function(v, M, S) {
    if (p.enabled === !1 || p.autoUpdate === !1 && p.needsUpdate === !1 || v.length === 0) return;
    const A = o.getRenderTarget(), w = o.getActiveCubeFace(), E = o.getActiveMipmapLevel(), P = o.state;
    P.setBlending(Ti), P.buffers.color.setClear(1, 1, 1, 1), P.buffers.depth.setTest(!0), P.setScissorTest(!1);
    for (let z = 0, V = v.length; z < V; z++) {
      const O = v[z], D = O.shadow;
      if (D === void 0) {
        console.warn("THREE.WebGLShadowMap:", O, "has no shadow.");
        continue;
      }
      if (D.autoUpdate === !1 && D.needsUpdate === !1) continue;
      n.copy(D.mapSize);
      const H = D.getFrameExtents();
      if (n.multiply(H), s.copy(D.mapSize), (n.x > h || n.y > h) && (n.x > h && (s.x = Math.floor(h / H.x), n.x = s.x * H.x, D.mapSize.x = s.x), n.y > h && (s.y = Math.floor(h / H.y), n.y = s.y * H.y, D.mapSize.y = s.y)), D.map === null) {
        const ie = this.type !== rr ? { minFilter: yt, magFilter: yt } : {};
        D.map = new Ot(n.x, n.y, ie), D.map.texture.name = O.name + ".shadowMap", D.camera.updateProjectionMatrix();
      }
      o.setRenderTarget(D.map), o.clear();
      const Z = D.getViewportCount();
      for (let ie = 0; ie < Z; ie++) {
        const K = D.getViewport(ie);
        r.set(
          s.x * K.x,
          s.y * K.y,
          s.x * K.z,
          s.y * K.w
        ), P.viewport(r), D.updateMatrices(O, ie), i = D.getFrustum(), y(M, S, D.camera, O, this.type);
      }
      D.isPointLightShadow !== !0 && this.type === rr && g(D, S), D.needsUpdate = !1;
    }
    p.needsUpdate = !1, o.setRenderTarget(A, w, E);
  };
  function g(v, M) {
    const S = e.update(_);
    d.defines.VSM_SAMPLES !== v.blurSamples && (d.defines.VSM_SAMPLES = v.blurSamples, f.defines.VSM_SAMPLES = v.blurSamples, d.needsUpdate = !0, f.needsUpdate = !0), v.mapPass === null && (v.mapPass = new Ot(n.x, n.y)), d.uniforms.shadow_pass.value = v.map.texture, d.uniforms.resolution.value = v.mapSize, d.uniforms.radius.value = v.radius, o.setRenderTarget(v.mapPass), o.clear(), o.renderBufferDirect(M, null, S, d, _, null), f.uniforms.shadow_pass.value = v.mapPass.texture, f.uniforms.resolution.value = v.mapSize, f.uniforms.radius.value = v.radius, o.setRenderTarget(v.map), o.clear(), o.renderBufferDirect(M, null, S, f, _, null);
  }
  function x(v, M, S, A, w, E) {
    let P = null;
    const z = S.isPointLight === !0 ? v.customDistanceMaterial : v.customDepthMaterial;
    if (z !== void 0)
      P = z;
    else if (P = S.isPointLight === !0 ? l : a, o.localClippingEnabled && M.clipShadows === !0 && Array.isArray(M.clippingPlanes) && M.clippingPlanes.length !== 0 || M.displacementMap && M.displacementScale !== 0 || M.alphaMap && M.alphaTest > 0 || M.map && M.alphaTest > 0) {
      const V = P.uuid, O = M.uuid;
      let D = c[V];
      D === void 0 && (D = {}, c[V] = D);
      let H = D[O];
      H === void 0 && (H = P.clone(), D[O] = H), P = H;
    }
    return P.visible = M.visible, P.wireframe = M.wireframe, E === rr ? P.side = M.shadowSide !== null ? M.shadowSide : M.side : P.side = M.shadowSide !== null ? M.shadowSide : u[M.side], P.alphaMap = M.alphaMap, P.alphaTest = M.alphaTest, P.map = M.map, P.clipShadows = M.clipShadows, P.clippingPlanes = M.clippingPlanes, P.clipIntersection = M.clipIntersection, P.displacementMap = M.displacementMap, P.displacementScale = M.displacementScale, P.displacementBias = M.displacementBias, P.wireframeLinewidth = M.wireframeLinewidth, P.linewidth = M.linewidth, S.isPointLight === !0 && P.isMeshDistanceMaterial === !0 && (P.referencePosition.setFromMatrixPosition(S.matrixWorld), P.nearDistance = A, P.farDistance = w), P;
  }
  function y(v, M, S, A, w) {
    if (v.visible === !1) return;
    if (v.layers.test(M.layers) && (v.isMesh || v.isLine || v.isPoints) && (v.castShadow || v.receiveShadow && w === rr) && (!v.frustumCulled || i.intersectsObject(v))) {
      v.modelViewMatrix.multiplyMatrices(S.matrixWorldInverse, v.matrixWorld);
      const z = e.update(v), V = v.material;
      if (Array.isArray(V)) {
        const O = z.groups;
        for (let D = 0, H = O.length; D < H; D++) {
          const Z = O[D], ie = V[Z.materialIndex];
          if (ie && ie.visible) {
            const K = x(v, ie, A, S.near, S.far, w);
            o.renderBufferDirect(S, null, z, K, v, Z);
          }
        }
      } else if (V.visible) {
        const O = x(v, V, A, S.near, S.far, w);
        o.renderBufferDirect(S, null, z, O, v, null);
      }
    }
    const P = v.children;
    for (let z = 0, V = P.length; z < V; z++)
      y(P[z], M, S, A, w);
  }
}
function Bv(o, e, t) {
  const i = t.isWebGL2;
  function n() {
    let N = !1;
    const Y = new We();
    let re = null;
    const xe = new We(0, 0, 0, 0);
    return {
      setMask: function(Te) {
        re !== Te && !N && (o.colorMask(Te, Te, Te, Te), re = Te);
      },
      setLocked: function(Te) {
        N = Te;
      },
      setClear: function(Te, it, Mt, It, yn) {
        yn === !0 && (Te *= It, it *= It, Mt *= It), Y.set(Te, it, Mt, It), xe.equals(Y) === !1 && (o.clearColor(Te, it, Mt, It), xe.copy(Y));
      },
      reset: function() {
        N = !1, re = null, xe.set(-1, 0, 0, 0);
      }
    };
  }
  function s() {
    let N = !1, Y = null, re = null, xe = null;
    return {
      setTest: function(Te) {
        Te ? De(2929) : ye(2929);
      },
      setMask: function(Te) {
        Y !== Te && !N && (o.depthMask(Te), Y = Te);
      },
      setFunc: function(Te) {
        if (re !== Te) {
          switch (Te) {
            case np:
              o.depthFunc(512);
              break;
            case sp:
              o.depthFunc(519);
              break;
            case rp:
              o.depthFunc(513);
              break;
            case pl:
              o.depthFunc(515);
              break;
            case ap:
              o.depthFunc(514);
              break;
            case op:
              o.depthFunc(518);
              break;
            case lp:
              o.depthFunc(516);
              break;
            case cp:
              o.depthFunc(517);
              break;
            default:
              o.depthFunc(515);
          }
          re = Te;
        }
      },
      setLocked: function(Te) {
        N = Te;
      },
      setClear: function(Te) {
        xe !== Te && (o.clearDepth(Te), xe = Te);
      },
      reset: function() {
        N = !1, Y = null, re = null, xe = null;
      }
    };
  }
  function r() {
    let N = !1, Y = null, re = null, xe = null, Te = null, it = null, Mt = null, It = null, yn = null;
    return {
      setTest: function(ct) {
        N || (ct ? De(2960) : ye(2960));
      },
      setMask: function(ct) {
        Y !== ct && !N && (o.stencilMask(ct), Y = ct);
      },
      setFunc: function(ct, Pi, Qt) {
        (re !== ct || xe !== Pi || Te !== Qt) && (o.stencilFunc(ct, Pi, Qt), re = ct, xe = Pi, Te = Qt);
      },
      setOp: function(ct, Pi, Qt) {
        (it !== ct || Mt !== Pi || It !== Qt) && (o.stencilOp(ct, Pi, Qt), it = ct, Mt = Pi, It = Qt);
      },
      setLocked: function(ct) {
        N = ct;
      },
      setClear: function(ct) {
        yn !== ct && (o.clearStencil(ct), yn = ct);
      },
      reset: function() {
        N = !1, Y = null, re = null, xe = null, Te = null, it = null, Mt = null, It = null, yn = null;
      }
    };
  }
  const a = new n(), l = new s(), c = new r(), h = /* @__PURE__ */ new WeakMap(), u = /* @__PURE__ */ new WeakMap();
  let d = {}, f = {}, m = /* @__PURE__ */ new WeakMap(), _ = [], p = null, g = !1, x = null, y = null, v = null, M = null, S = null, A = null, w = null, E = !1, P = null, z = null, V = null, O = null, D = null;
  const H = o.getParameter(35661);
  let Z = !1, ie = 0;
  const K = o.getParameter(7938);
  K.indexOf("WebGL") !== -1 ? (ie = parseFloat(/^WebGL (\d)/.exec(K)[1]), Z = ie >= 1) : K.indexOf("OpenGL ES") !== -1 && (ie = parseFloat(/^OpenGL ES (\d)/.exec(K)[1]), Z = ie >= 2);
  let ne = null, te = {};
  const q = o.getParameter(3088), W = o.getParameter(2978), le = new We().fromArray(q), ae = new We().fromArray(W);
  function fe(N, Y, re) {
    const xe = new Uint8Array(4), Te = o.createTexture();
    o.bindTexture(N, Te), o.texParameteri(N, 10241, 9728), o.texParameteri(N, 10240, 9728);
    for (let it = 0; it < re; it++)
      o.texImage2D(Y + it, 0, 6408, 1, 1, 0, 6408, 5121, xe);
    return Te;
  }
  const j = {};
  j[3553] = fe(3553, 3553, 1), j[34067] = fe(34067, 34069, 6), a.setClear(0, 0, 0, 1), l.setClear(1), c.setClear(0), De(2929), l.setFunc(pl), pe(!1), Ne(Rc), De(2884), ce(Ti);
  function De(N) {
    d[N] !== !0 && (o.enable(N), d[N] = !0);
  }
  function ye(N) {
    d[N] !== !1 && (o.disable(N), d[N] = !1);
  }
  function Re(N, Y) {
    return f[N] !== Y ? (o.bindFramebuffer(N, Y), f[N] = Y, i && (N === 36009 && (f[36160] = Y), N === 36160 && (f[36009] = Y)), !0) : !1;
  }
  function me(N, Y) {
    let re = _, xe = !1;
    if (N)
      if (re = m.get(Y), re === void 0 && (re = [], m.set(Y, re)), N.isWebGLMultipleRenderTargets) {
        const Te = N.texture;
        if (re.length !== Te.length || re[0] !== 36064) {
          for (let it = 0, Mt = Te.length; it < Mt; it++)
            re[it] = 36064 + it;
          re.length = Te.length, xe = !0;
        }
      } else
        re[0] !== 36064 && (re[0] = 36064, xe = !0);
    else
      re[0] !== 1029 && (re[0] = 1029, xe = !0);
    xe && (t.isWebGL2 ? o.drawBuffers(re) : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(re));
  }
  function ze(N) {
    return p !== N ? (o.useProgram(N), p = N, !0) : !1;
  }
  const ee = {
    [ps]: 32774,
    [qf]: 32778,
    [jf]: 32779
  };
  if (i)
    ee[Oc] = 32775, ee[Nc] = 32776;
  else {
    const N = e.get("EXT_blend_minmax");
    N !== null && (ee[Oc] = N.MIN_EXT, ee[Nc] = N.MAX_EXT);
  }
  const Q = {
    [Yf]: 0,
    [Zf]: 1,
    [Jf]: 768,
    [ad]: 770,
    [ip]: 776,
    [ep]: 774,
    [$f]: 772,
    [Kf]: 769,
    [od]: 771,
    [tp]: 775,
    [Qf]: 773
  };
  function ce(N, Y, re, xe, Te, it, Mt, It) {
    if (N === Ti) {
      g === !0 && (ye(3042), g = !1);
      return;
    }
    if (g === !1 && (De(3042), g = !0), N !== Xf) {
      if (N !== x || It !== E) {
        if ((y !== ps || S !== ps) && (o.blendEquation(32774), y = ps, S = ps), It)
          switch (N) {
            case bs:
              o.blendFuncSeparate(1, 771, 1, 771);
              break;
            case za:
              o.blendFunc(1, 1);
              break;
            case Ic:
              o.blendFuncSeparate(0, 769, 0, 1);
              break;
            case Dc:
              o.blendFuncSeparate(0, 768, 0, 770);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", N);
              break;
          }
        else
          switch (N) {
            case bs:
              o.blendFuncSeparate(770, 771, 1, 771);
              break;
            case za:
              o.blendFunc(770, 1);
              break;
            case Ic:
              o.blendFuncSeparate(0, 769, 0, 1);
              break;
            case Dc:
              o.blendFunc(0, 768);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", N);
              break;
          }
        v = null, M = null, A = null, w = null, x = N, E = It;
      }
      return;
    }
    Te = Te || Y, it = it || re, Mt = Mt || xe, (Y !== y || Te !== S) && (o.blendEquationSeparate(ee[Y], ee[Te]), y = Y, S = Te), (re !== v || xe !== M || it !== A || Mt !== w) && (o.blendFuncSeparate(Q[re], Q[xe], Q[it], Q[Mt]), v = re, M = xe, A = it, w = Mt), x = N, E = !1;
  }
  function be(N, Y) {
    N.side === ji ? ye(2884) : De(2884);
    let re = N.side === oi;
    Y && (re = !re), pe(re), N.blending === bs && N.transparent === !1 ? ce(Ti) : ce(N.blending, N.blendEquation, N.blendSrc, N.blendDst, N.blendEquationAlpha, N.blendSrcAlpha, N.blendDstAlpha, N.premultipliedAlpha), l.setFunc(N.depthFunc), l.setTest(N.depthTest), l.setMask(N.depthWrite), a.setMask(N.colorWrite);
    const xe = N.stencilWrite;
    c.setTest(xe), xe && (c.setMask(N.stencilWriteMask), c.setFunc(N.stencilFunc, N.stencilRef, N.stencilFuncMask), c.setOp(N.stencilFail, N.stencilZFail, N.stencilZPass)), Ce(N.polygonOffset, N.polygonOffsetFactor, N.polygonOffsetUnits), N.alphaToCoverage === !0 ? De(32926) : ye(32926);
  }
  function pe(N) {
    P !== N && (N ? o.frontFace(2304) : o.frontFace(2305), P = N);
  }
  function Ne(N) {
    N !== Gf ? (De(2884), N !== z && (N === Rc ? o.cullFace(1029) : N === Hf ? o.cullFace(1028) : o.cullFace(1032))) : ye(2884), z = N;
  }
  function Le(N) {
    N !== V && (Z && o.lineWidth(N), V = N);
  }
  function Ce(N, Y, re) {
    N ? (De(32823), (O !== Y || D !== re) && (o.polygonOffset(Y, re), O = Y, D = re)) : ye(32823);
  }
  function rt(N) {
    N ? De(3089) : ye(3089);
  }
  function Qe(N) {
    N === void 0 && (N = 33984 + H - 1), ne !== N && (o.activeTexture(N), ne = N);
  }
  function L(N, Y, re) {
    re === void 0 && (ne === null ? re = 33984 + H - 1 : re = ne);
    let xe = te[re];
    xe === void 0 && (xe = { type: void 0, texture: void 0 }, te[re] = xe), (xe.type !== N || xe.texture !== Y) && (ne !== re && (o.activeTexture(re), ne = re), o.bindTexture(N, Y || j[N]), xe.type = N, xe.texture = Y);
  }
  function T() {
    const N = te[ne];
    N !== void 0 && N.type !== void 0 && (o.bindTexture(N.type, null), N.type = void 0, N.texture = void 0);
  }
  function X() {
    try {
      o.compressedTexImage2D.apply(o, arguments);
    } catch (N) {
      console.error("THREE.WebGLState:", N);
    }
  }
  function se() {
    try {
      o.compressedTexImage3D.apply(o, arguments);
    } catch (N) {
      console.error("THREE.WebGLState:", N);
    }
  }
  function oe() {
    try {
      o.texSubImage2D.apply(o, arguments);
    } catch (N) {
      console.error("THREE.WebGLState:", N);
    }
  }
  function _e() {
    try {
      o.texSubImage3D.apply(o, arguments);
    } catch (N) {
      console.error("THREE.WebGLState:", N);
    }
  }
  function Ie() {
    try {
      o.compressedTexSubImage2D.apply(o, arguments);
    } catch (N) {
      console.error("THREE.WebGLState:", N);
    }
  }
  function R() {
    try {
      o.compressedTexSubImage3D.apply(o, arguments);
    } catch (N) {
      console.error("THREE.WebGLState:", N);
    }
  }
  function F() {
    try {
      o.texStorage2D.apply(o, arguments);
    } catch (N) {
      console.error("THREE.WebGLState:", N);
    }
  }
  function ge() {
    try {
      o.texStorage3D.apply(o, arguments);
    } catch (N) {
      console.error("THREE.WebGLState:", N);
    }
  }
  function we() {
    try {
      o.texImage2D.apply(o, arguments);
    } catch (N) {
      console.error("THREE.WebGLState:", N);
    }
  }
  function ve() {
    try {
      o.texImage3D.apply(o, arguments);
    } catch (N) {
      console.error("THREE.WebGLState:", N);
    }
  }
  function Se(N) {
    le.equals(N) === !1 && (o.scissor(N.x, N.y, N.z, N.w), le.copy(N));
  }
  function Me(N) {
    ae.equals(N) === !1 && (o.viewport(N.x, N.y, N.z, N.w), ae.copy(N));
  }
  function Xe(N, Y) {
    let re = u.get(Y);
    re === void 0 && (re = /* @__PURE__ */ new WeakMap(), u.set(Y, re));
    let xe = re.get(N);
    xe === void 0 && (xe = o.getUniformBlockIndex(Y, N.name), re.set(N, xe));
  }
  function qe(N, Y) {
    const xe = u.get(Y).get(N);
    h.get(Y) !== xe && (o.uniformBlockBinding(Y, xe, N.__bindingPointIndex), h.set(Y, xe));
  }
  function at() {
    o.disable(3042), o.disable(2884), o.disable(2929), o.disable(32823), o.disable(3089), o.disable(2960), o.disable(32926), o.blendEquation(32774), o.blendFunc(1, 0), o.blendFuncSeparate(1, 0, 1, 0), o.colorMask(!0, !0, !0, !0), o.clearColor(0, 0, 0, 0), o.depthMask(!0), o.depthFunc(513), o.clearDepth(1), o.stencilMask(4294967295), o.stencilFunc(519, 0, 4294967295), o.stencilOp(7680, 7680, 7680), o.clearStencil(0), o.cullFace(1029), o.frontFace(2305), o.polygonOffset(0, 0), o.activeTexture(33984), o.bindFramebuffer(36160, null), i === !0 && (o.bindFramebuffer(36009, null), o.bindFramebuffer(36008, null)), o.useProgram(null), o.lineWidth(1), o.scissor(0, 0, o.canvas.width, o.canvas.height), o.viewport(0, 0, o.canvas.width, o.canvas.height), d = {}, ne = null, te = {}, f = {}, m = /* @__PURE__ */ new WeakMap(), _ = [], p = null, g = !1, x = null, y = null, v = null, M = null, S = null, A = null, w = null, E = !1, P = null, z = null, V = null, O = null, D = null, le.set(0, 0, o.canvas.width, o.canvas.height), ae.set(0, 0, o.canvas.width, o.canvas.height), a.reset(), l.reset(), c.reset();
  }
  return {
    buffers: {
      color: a,
      depth: l,
      stencil: c
    },
    enable: De,
    disable: ye,
    bindFramebuffer: Re,
    drawBuffers: me,
    useProgram: ze,
    setBlending: ce,
    setMaterial: be,
    setFlipSided: pe,
    setCullFace: Ne,
    setLineWidth: Le,
    setPolygonOffset: Ce,
    setScissorTest: rt,
    activeTexture: Qe,
    bindTexture: L,
    unbindTexture: T,
    compressedTexImage2D: X,
    compressedTexImage3D: se,
    texImage2D: we,
    texImage3D: ve,
    updateUBOMapping: Xe,
    uniformBlockBinding: qe,
    texStorage2D: F,
    texStorage3D: ge,
    texSubImage2D: oe,
    texSubImage3D: _e,
    compressedTexSubImage2D: Ie,
    compressedTexSubImage3D: R,
    scissor: Se,
    viewport: Me,
    reset: at
  };
}
function Uv(o, e, t, i, n, s, r) {
  const a = n.isWebGL2, l = n.maxTextures, c = n.maxCubemapSize, h = n.maxTextureSize, u = n.maxSamples, d = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null, f = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent), m = /* @__PURE__ */ new WeakMap();
  let _;
  const p = /* @__PURE__ */ new WeakMap();
  let g = !1;
  try {
    g = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch {
  }
  function x(L, T) {
    return g ? (
      // eslint-disable-next-line compat/compat
      new OffscreenCanvas(L, T)
    ) : wr("canvas");
  }
  function y(L, T, X, se) {
    let oe = 1;
    if ((L.width > se || L.height > se) && (oe = se / Math.max(L.width, L.height)), oe < 1 || T === !0)
      if (typeof HTMLImageElement < "u" && L instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && L instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && L instanceof ImageBitmap) {
        const _e = T ? Va : Math.floor, Ie = _e(oe * L.width), R = _e(oe * L.height);
        _ === void 0 && (_ = x(Ie, R));
        const F = X ? x(Ie, R) : _;
        return F.width = Ie, F.height = R, F.getContext("2d").drawImage(L, 0, 0, Ie, R), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + L.width + "x" + L.height + ") to (" + Ie + "x" + R + ")."), F;
      } else
        return "data" in L && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + L.width + "x" + L.height + ")."), L;
    return L;
  }
  function v(L) {
    return gl(L.width) && gl(L.height);
  }
  function M(L) {
    return a ? !1 : L.wrapS !== Vt || L.wrapT !== Vt || L.minFilter !== yt && L.minFilter !== Ut;
  }
  function S(L, T) {
    return L.generateMipmaps && T && L.minFilter !== yt && L.minFilter !== Ut;
  }
  function A(L) {
    o.generateMipmap(L);
  }
  function w(L, T, X, se, oe = !1) {
    if (a === !1) return T;
    if (L !== null) {
      if (o[L] !== void 0) return o[L];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + L + "'");
    }
    let _e = T;
    return T === 6403 && (X === 5126 && (_e = 33326), X === 5131 && (_e = 33325), X === 5121 && (_e = 33321)), T === 33319 && (X === 5126 && (_e = 33328), X === 5131 && (_e = 33327), X === 5121 && (_e = 33323)), T === 6408 && (X === 5126 && (_e = 34836), X === 5131 && (_e = 34842), X === 5121 && (_e = se === He && oe === !1 ? 35907 : 32856), X === 32819 && (_e = 32854), X === 32820 && (_e = 32855)), (_e === 33325 || _e === 33326 || _e === 33327 || _e === 33328 || _e === 34842 || _e === 34836) && e.get("EXT_color_buffer_float"), _e;
  }
  function E(L, T, X) {
    return S(L, X) === !0 || L.isFramebufferTexture && L.minFilter !== yt && L.minFilter !== Ut ? Math.log2(Math.max(T.width, T.height)) + 1 : L.mipmaps !== void 0 && L.mipmaps.length > 0 ? L.mipmaps.length : L.isCompressedTexture && Array.isArray(L.image) ? T.mipmaps.length : 1;
  }
  function P(L) {
    return L === yt || L === Ba || L === cr ? 9728 : 9729;
  }
  function z(L) {
    const T = L.target;
    T.removeEventListener("dispose", z), O(T), T.isVideoTexture && m.delete(T);
  }
  function V(L) {
    const T = L.target;
    T.removeEventListener("dispose", V), H(T);
  }
  function O(L) {
    const T = i.get(L);
    if (T.__webglInit === void 0) return;
    const X = L.source, se = p.get(X);
    if (se) {
      const oe = se[T.__cacheKey];
      oe.usedTimes--, oe.usedTimes === 0 && D(L), Object.keys(se).length === 0 && p.delete(X);
    }
    i.remove(L);
  }
  function D(L) {
    const T = i.get(L);
    o.deleteTexture(T.__webglTexture);
    const X = L.source, se = p.get(X);
    delete se[T.__cacheKey], r.memory.textures--;
  }
  function H(L) {
    const T = L.texture, X = i.get(L), se = i.get(T);
    if (se.__webglTexture !== void 0 && (o.deleteTexture(se.__webglTexture), r.memory.textures--), L.depthTexture && L.depthTexture.dispose(), L.isWebGLCubeRenderTarget)
      for (let oe = 0; oe < 6; oe++)
        o.deleteFramebuffer(X.__webglFramebuffer[oe]), X.__webglDepthbuffer && o.deleteRenderbuffer(X.__webglDepthbuffer[oe]);
    else {
      if (o.deleteFramebuffer(X.__webglFramebuffer), X.__webglDepthbuffer && o.deleteRenderbuffer(X.__webglDepthbuffer), X.__webglMultisampledFramebuffer && o.deleteFramebuffer(X.__webglMultisampledFramebuffer), X.__webglColorRenderbuffer)
        for (let oe = 0; oe < X.__webglColorRenderbuffer.length; oe++)
          X.__webglColorRenderbuffer[oe] && o.deleteRenderbuffer(X.__webglColorRenderbuffer[oe]);
      X.__webglDepthRenderbuffer && o.deleteRenderbuffer(X.__webglDepthRenderbuffer);
    }
    if (L.isWebGLMultipleRenderTargets)
      for (let oe = 0, _e = T.length; oe < _e; oe++) {
        const Ie = i.get(T[oe]);
        Ie.__webglTexture && (o.deleteTexture(Ie.__webglTexture), r.memory.textures--), i.remove(T[oe]);
      }
    i.remove(T), i.remove(L);
  }
  let Z = 0;
  function ie() {
    Z = 0;
  }
  function K() {
    const L = Z;
    return L >= l && console.warn("THREE.WebGLTextures: Trying to use " + L + " texture units while this GPU supports only " + l), Z += 1, L;
  }
  function ne(L) {
    const T = [];
    return T.push(L.wrapS), T.push(L.wrapT), T.push(L.wrapR || 0), T.push(L.magFilter), T.push(L.minFilter), T.push(L.anisotropy), T.push(L.internalFormat), T.push(L.format), T.push(L.type), T.push(L.generateMipmaps), T.push(L.premultiplyAlpha), T.push(L.flipY), T.push(L.unpackAlignment), T.push(L.encoding), T.join();
  }
  function te(L, T) {
    const X = i.get(L);
    if (L.isVideoTexture && rt(L), L.isRenderTargetTexture === !1 && L.version > 0 && X.__version !== L.version) {
      const se = L.image;
      if (se === null)
        console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
      else if (se.complete === !1)
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
      else {
        ye(X, L, T);
        return;
      }
    }
    t.bindTexture(3553, X.__webglTexture, 33984 + T);
  }
  function q(L, T) {
    const X = i.get(L);
    if (L.version > 0 && X.__version !== L.version) {
      ye(X, L, T);
      return;
    }
    t.bindTexture(35866, X.__webglTexture, 33984 + T);
  }
  function W(L, T) {
    const X = i.get(L);
    if (L.version > 0 && X.__version !== L.version) {
      ye(X, L, T);
      return;
    }
    t.bindTexture(32879, X.__webglTexture, 33984 + T);
  }
  function le(L, T) {
    const X = i.get(L);
    if (L.version > 0 && X.__version !== L.version) {
      Re(X, L, T);
      return;
    }
    t.bindTexture(34067, X.__webglTexture, 33984 + T);
  }
  const ae = {
    [Yi]: 10497,
    [Vt]: 33071,
    [_r]: 33648
  }, fe = {
    [yt]: 9728,
    [Ba]: 9984,
    [cr]: 9986,
    [Ut]: 9729,
    [kl]: 9985,
    [fn]: 9987
  };
  function j(L, T, X) {
    if (X ? (o.texParameteri(L, 10242, ae[T.wrapS]), o.texParameteri(L, 10243, ae[T.wrapT]), (L === 32879 || L === 35866) && o.texParameteri(L, 32882, ae[T.wrapR]), o.texParameteri(L, 10240, fe[T.magFilter]), o.texParameteri(L, 10241, fe[T.minFilter])) : (o.texParameteri(L, 10242, 33071), o.texParameteri(L, 10243, 33071), (L === 32879 || L === 35866) && o.texParameteri(L, 32882, 33071), (T.wrapS !== Vt || T.wrapT !== Vt) && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), o.texParameteri(L, 10240, P(T.magFilter)), o.texParameteri(L, 10241, P(T.minFilter)), T.minFilter !== yt && T.minFilter !== Ut && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), e.has("EXT_texture_filter_anisotropic") === !0) {
      const se = e.get("EXT_texture_filter_anisotropic");
      if (T.magFilter === yt || T.minFilter !== cr && T.minFilter !== fn || T.type === cn && e.has("OES_texture_float_linear") === !1 || a === !1 && T.type === gr && e.has("OES_texture_half_float_linear") === !1) return;
      (T.anisotropy > 1 || i.get(T).__currentAnisotropy) && (o.texParameterf(L, se.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(T.anisotropy, n.getMaxAnisotropy())), i.get(T).__currentAnisotropy = T.anisotropy);
    }
  }
  function De(L, T) {
    let X = !1;
    L.__webglInit === void 0 && (L.__webglInit = !0, T.addEventListener("dispose", z));
    const se = T.source;
    let oe = p.get(se);
    oe === void 0 && (oe = {}, p.set(se, oe));
    const _e = ne(T);
    if (_e !== L.__cacheKey) {
      oe[_e] === void 0 && (oe[_e] = {
        texture: o.createTexture(),
        usedTimes: 0
      }, r.memory.textures++, X = !0), oe[_e].usedTimes++;
      const Ie = oe[L.__cacheKey];
      Ie !== void 0 && (oe[L.__cacheKey].usedTimes--, Ie.usedTimes === 0 && D(T)), L.__cacheKey = _e, L.__webglTexture = oe[_e].texture;
    }
    return X;
  }
  function ye(L, T, X) {
    let se = 3553;
    (T.isDataArrayTexture || T.isCompressedArrayTexture) && (se = 35866), T.isData3DTexture && (se = 32879);
    const oe = De(L, T), _e = T.source;
    t.bindTexture(se, L.__webglTexture, 33984 + X);
    const Ie = i.get(_e);
    if (_e.version !== Ie.__version || oe === !0) {
      t.activeTexture(33984 + X), o.pixelStorei(37440, T.flipY), o.pixelStorei(37441, T.premultiplyAlpha), o.pixelStorei(3317, T.unpackAlignment), o.pixelStorei(37443, 0);
      const R = M(T) && v(T.image) === !1;
      let F = y(T.image, R, !1, h);
      F = Qe(T, F);
      const ge = v(F) || a, we = s.convert(T.format, T.encoding);
      let ve = s.convert(T.type), Se = w(T.internalFormat, we, ve, T.encoding, T.isVideoTexture);
      j(se, T, ge);
      let Me;
      const Xe = T.mipmaps, qe = a && T.isVideoTexture !== !0, at = Ie.__version === void 0 || oe === !0, N = E(T, F, ge);
      if (T.isDepthTexture)
        Se = 6402, a ? T.type === cn ? Se = 36012 : T.type === Ln ? Se = 33190 : T.type === Ms ? Se = 35056 : Se = 33189 : T.type === cn && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), T.format === In && Se === 6402 && T.type !== ld && T.type !== Ln && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), T.type = Ln, ve = s.convert(T.type)), T.format === Es && Se === 6402 && (Se = 34041, T.type !== Ms && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), T.type = Ms, ve = s.convert(T.type))), at && (qe ? t.texStorage2D(3553, 1, Se, F.width, F.height) : t.texImage2D(3553, 0, Se, F.width, F.height, 0, we, ve, null));
      else if (T.isDataTexture)
        if (Xe.length > 0 && ge) {
          qe && at && t.texStorage2D(3553, N, Se, Xe[0].width, Xe[0].height);
          for (let Y = 0, re = Xe.length; Y < re; Y++)
            Me = Xe[Y], qe ? t.texSubImage2D(3553, Y, 0, 0, Me.width, Me.height, we, ve, Me.data) : t.texImage2D(3553, Y, Se, Me.width, Me.height, 0, we, ve, Me.data);
          T.generateMipmaps = !1;
        } else
          qe ? (at && t.texStorage2D(3553, N, Se, F.width, F.height), t.texSubImage2D(3553, 0, 0, 0, F.width, F.height, we, ve, F.data)) : t.texImage2D(3553, 0, Se, F.width, F.height, 0, we, ve, F.data);
      else if (T.isCompressedTexture)
        if (T.isCompressedArrayTexture) {
          qe && at && t.texStorage3D(35866, N, Se, Xe[0].width, Xe[0].height, F.depth);
          for (let Y = 0, re = Xe.length; Y < re; Y++)
            Me = Xe[Y], T.format !== ri ? we !== null ? qe ? t.compressedTexSubImage3D(35866, Y, 0, 0, 0, Me.width, Me.height, F.depth, we, Me.data, 0, 0) : t.compressedTexImage3D(35866, Y, Se, Me.width, Me.height, F.depth, 0, Me.data, 0, 0) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : qe ? t.texSubImage3D(35866, Y, 0, 0, 0, Me.width, Me.height, F.depth, we, ve, Me.data) : t.texImage3D(35866, Y, Se, Me.width, Me.height, F.depth, 0, we, ve, Me.data);
        } else {
          qe && at && t.texStorage2D(3553, N, Se, Xe[0].width, Xe[0].height);
          for (let Y = 0, re = Xe.length; Y < re; Y++)
            Me = Xe[Y], T.format !== ri ? we !== null ? qe ? t.compressedTexSubImage2D(3553, Y, 0, 0, Me.width, Me.height, we, Me.data) : t.compressedTexImage2D(3553, Y, Se, Me.width, Me.height, 0, Me.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : qe ? t.texSubImage2D(3553, Y, 0, 0, Me.width, Me.height, we, ve, Me.data) : t.texImage2D(3553, Y, Se, Me.width, Me.height, 0, we, ve, Me.data);
        }
      else if (T.isDataArrayTexture)
        qe ? (at && t.texStorage3D(35866, N, Se, F.width, F.height, F.depth), t.texSubImage3D(35866, 0, 0, 0, 0, F.width, F.height, F.depth, we, ve, F.data)) : t.texImage3D(35866, 0, Se, F.width, F.height, F.depth, 0, we, ve, F.data);
      else if (T.isData3DTexture)
        qe ? (at && t.texStorage3D(32879, N, Se, F.width, F.height, F.depth), t.texSubImage3D(32879, 0, 0, 0, 0, F.width, F.height, F.depth, we, ve, F.data)) : t.texImage3D(32879, 0, Se, F.width, F.height, F.depth, 0, we, ve, F.data);
      else if (T.isFramebufferTexture) {
        if (at)
          if (qe)
            t.texStorage2D(3553, N, Se, F.width, F.height);
          else {
            let Y = F.width, re = F.height;
            for (let xe = 0; xe < N; xe++)
              t.texImage2D(3553, xe, Se, Y, re, 0, we, ve, null), Y >>= 1, re >>= 1;
          }
      } else if (Xe.length > 0 && ge) {
        qe && at && t.texStorage2D(3553, N, Se, Xe[0].width, Xe[0].height);
        for (let Y = 0, re = Xe.length; Y < re; Y++)
          Me = Xe[Y], qe ? t.texSubImage2D(3553, Y, 0, 0, we, ve, Me) : t.texImage2D(3553, Y, Se, we, ve, Me);
        T.generateMipmaps = !1;
      } else
        qe ? (at && t.texStorage2D(3553, N, Se, F.width, F.height), t.texSubImage2D(3553, 0, 0, 0, we, ve, F)) : t.texImage2D(3553, 0, Se, we, ve, F);
      S(T, ge) && A(se), Ie.__version = _e.version, T.onUpdate && T.onUpdate(T);
    }
    L.__version = T.version;
  }
  function Re(L, T, X) {
    if (T.image.length !== 6) return;
    const se = De(L, T), oe = T.source;
    t.bindTexture(34067, L.__webglTexture, 33984 + X);
    const _e = i.get(oe);
    if (oe.version !== _e.__version || se === !0) {
      t.activeTexture(33984 + X), o.pixelStorei(37440, T.flipY), o.pixelStorei(37441, T.premultiplyAlpha), o.pixelStorei(3317, T.unpackAlignment), o.pixelStorei(37443, 0);
      const Ie = T.isCompressedTexture || T.image[0].isCompressedTexture, R = T.image[0] && T.image[0].isDataTexture, F = [];
      for (let Y = 0; Y < 6; Y++)
        !Ie && !R ? F[Y] = y(T.image[Y], !1, !0, c) : F[Y] = R ? T.image[Y].image : T.image[Y], F[Y] = Qe(T, F[Y]);
      const ge = F[0], we = v(ge) || a, ve = s.convert(T.format, T.encoding), Se = s.convert(T.type), Me = w(T.internalFormat, ve, Se, T.encoding), Xe = a && T.isVideoTexture !== !0, qe = _e.__version === void 0 || se === !0;
      let at = E(T, ge, we);
      j(34067, T, we);
      let N;
      if (Ie) {
        Xe && qe && t.texStorage2D(34067, at, Me, ge.width, ge.height);
        for (let Y = 0; Y < 6; Y++) {
          N = F[Y].mipmaps;
          for (let re = 0; re < N.length; re++) {
            const xe = N[re];
            T.format !== ri ? ve !== null ? Xe ? t.compressedTexSubImage2D(34069 + Y, re, 0, 0, xe.width, xe.height, ve, xe.data) : t.compressedTexImage2D(34069 + Y, re, Me, xe.width, xe.height, 0, xe.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : Xe ? t.texSubImage2D(34069 + Y, re, 0, 0, xe.width, xe.height, ve, Se, xe.data) : t.texImage2D(34069 + Y, re, Me, xe.width, xe.height, 0, ve, Se, xe.data);
          }
        }
      } else {
        N = T.mipmaps, Xe && qe && (N.length > 0 && at++, t.texStorage2D(34067, at, Me, F[0].width, F[0].height));
        for (let Y = 0; Y < 6; Y++)
          if (R) {
            Xe ? t.texSubImage2D(34069 + Y, 0, 0, 0, F[Y].width, F[Y].height, ve, Se, F[Y].data) : t.texImage2D(34069 + Y, 0, Me, F[Y].width, F[Y].height, 0, ve, Se, F[Y].data);
            for (let re = 0; re < N.length; re++) {
              const Te = N[re].image[Y].image;
              Xe ? t.texSubImage2D(34069 + Y, re + 1, 0, 0, Te.width, Te.height, ve, Se, Te.data) : t.texImage2D(34069 + Y, re + 1, Me, Te.width, Te.height, 0, ve, Se, Te.data);
            }
          } else {
            Xe ? t.texSubImage2D(34069 + Y, 0, 0, 0, ve, Se, F[Y]) : t.texImage2D(34069 + Y, 0, Me, ve, Se, F[Y]);
            for (let re = 0; re < N.length; re++) {
              const xe = N[re];
              Xe ? t.texSubImage2D(34069 + Y, re + 1, 0, 0, ve, Se, xe.image[Y]) : t.texImage2D(34069 + Y, re + 1, Me, ve, Se, xe.image[Y]);
            }
          }
      }
      S(T, we) && A(34067), _e.__version = oe.version, T.onUpdate && T.onUpdate(T);
    }
    L.__version = T.version;
  }
  function me(L, T, X, se, oe) {
    const _e = s.convert(X.format, X.encoding), Ie = s.convert(X.type), R = w(X.internalFormat, _e, Ie, X.encoding);
    i.get(T).__hasExternalTextures || (oe === 32879 || oe === 35866 ? t.texImage3D(oe, 0, R, T.width, T.height, T.depth, 0, _e, Ie, null) : t.texImage2D(oe, 0, R, T.width, T.height, 0, _e, Ie, null)), t.bindFramebuffer(36160, L), Ce(T) ? d.framebufferTexture2DMultisampleEXT(36160, se, oe, i.get(X).__webglTexture, 0, Le(T)) : (oe === 3553 || oe >= 34069 && oe <= 34074) && o.framebufferTexture2D(36160, se, oe, i.get(X).__webglTexture, 0), t.bindFramebuffer(36160, null);
  }
  function ze(L, T, X) {
    if (o.bindRenderbuffer(36161, L), T.depthBuffer && !T.stencilBuffer) {
      let se = 33189;
      if (X || Ce(T)) {
        const oe = T.depthTexture;
        oe && oe.isDepthTexture && (oe.type === cn ? se = 36012 : oe.type === Ln && (se = 33190));
        const _e = Le(T);
        Ce(T) ? d.renderbufferStorageMultisampleEXT(36161, _e, se, T.width, T.height) : o.renderbufferStorageMultisample(36161, _e, se, T.width, T.height);
      } else
        o.renderbufferStorage(36161, se, T.width, T.height);
      o.framebufferRenderbuffer(36160, 36096, 36161, L);
    } else if (T.depthBuffer && T.stencilBuffer) {
      const se = Le(T);
      X && Ce(T) === !1 ? o.renderbufferStorageMultisample(36161, se, 35056, T.width, T.height) : Ce(T) ? d.renderbufferStorageMultisampleEXT(36161, se, 35056, T.width, T.height) : o.renderbufferStorage(36161, 34041, T.width, T.height), o.framebufferRenderbuffer(36160, 33306, 36161, L);
    } else {
      const se = T.isWebGLMultipleRenderTargets === !0 ? T.texture : [T.texture];
      for (let oe = 0; oe < se.length; oe++) {
        const _e = se[oe], Ie = s.convert(_e.format, _e.encoding), R = s.convert(_e.type), F = w(_e.internalFormat, Ie, R, _e.encoding), ge = Le(T);
        X && Ce(T) === !1 ? o.renderbufferStorageMultisample(36161, ge, F, T.width, T.height) : Ce(T) ? d.renderbufferStorageMultisampleEXT(36161, ge, F, T.width, T.height) : o.renderbufferStorage(36161, F, T.width, T.height);
      }
    }
    o.bindRenderbuffer(36161, null);
  }
  function ee(L, T) {
    if (T && T.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
    if (t.bindFramebuffer(36160, L), !(T.depthTexture && T.depthTexture.isDepthTexture))
      throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
    (!i.get(T.depthTexture).__webglTexture || T.depthTexture.image.width !== T.width || T.depthTexture.image.height !== T.height) && (T.depthTexture.image.width = T.width, T.depthTexture.image.height = T.height, T.depthTexture.needsUpdate = !0), te(T.depthTexture, 0);
    const se = i.get(T.depthTexture).__webglTexture, oe = Le(T);
    if (T.depthTexture.format === In)
      Ce(T) ? d.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, se, 0, oe) : o.framebufferTexture2D(36160, 36096, 3553, se, 0);
    else if (T.depthTexture.format === Es)
      Ce(T) ? d.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, se, 0, oe) : o.framebufferTexture2D(36160, 33306, 3553, se, 0);
    else
      throw new Error("Unknown depthTexture format");
  }
  function Q(L) {
    const T = i.get(L), X = L.isWebGLCubeRenderTarget === !0;
    if (L.depthTexture && !T.__autoAllocateDepthBuffer) {
      if (X) throw new Error("target.depthTexture not supported in Cube render targets");
      ee(T.__webglFramebuffer, L);
    } else if (X) {
      T.__webglDepthbuffer = [];
      for (let se = 0; se < 6; se++)
        t.bindFramebuffer(36160, T.__webglFramebuffer[se]), T.__webglDepthbuffer[se] = o.createRenderbuffer(), ze(T.__webglDepthbuffer[se], L, !1);
    } else
      t.bindFramebuffer(36160, T.__webglFramebuffer), T.__webglDepthbuffer = o.createRenderbuffer(), ze(T.__webglDepthbuffer, L, !1);
    t.bindFramebuffer(36160, null);
  }
  function ce(L, T, X) {
    const se = i.get(L);
    T !== void 0 && me(se.__webglFramebuffer, L, L.texture, 36064, 3553), X !== void 0 && Q(L);
  }
  function be(L) {
    const T = L.texture, X = i.get(L), se = i.get(T);
    L.addEventListener("dispose", V), L.isWebGLMultipleRenderTargets !== !0 && (se.__webglTexture === void 0 && (se.__webglTexture = o.createTexture()), se.__version = T.version, r.memory.textures++);
    const oe = L.isWebGLCubeRenderTarget === !0, _e = L.isWebGLMultipleRenderTargets === !0, Ie = v(L) || a;
    if (oe) {
      X.__webglFramebuffer = [];
      for (let R = 0; R < 6; R++)
        X.__webglFramebuffer[R] = o.createFramebuffer();
    } else {
      if (X.__webglFramebuffer = o.createFramebuffer(), _e)
        if (n.drawBuffers) {
          const R = L.texture;
          for (let F = 0, ge = R.length; F < ge; F++) {
            const we = i.get(R[F]);
            we.__webglTexture === void 0 && (we.__webglTexture = o.createTexture(), r.memory.textures++);
          }
        } else
          console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
      if (a && L.samples > 0 && Ce(L) === !1) {
        const R = _e ? T : [T];
        X.__webglMultisampledFramebuffer = o.createFramebuffer(), X.__webglColorRenderbuffer = [], t.bindFramebuffer(36160, X.__webglMultisampledFramebuffer);
        for (let F = 0; F < R.length; F++) {
          const ge = R[F];
          X.__webglColorRenderbuffer[F] = o.createRenderbuffer(), o.bindRenderbuffer(36161, X.__webglColorRenderbuffer[F]);
          const we = s.convert(ge.format, ge.encoding), ve = s.convert(ge.type), Se = w(ge.internalFormat, we, ve, ge.encoding, L.isXRRenderTarget === !0), Me = Le(L);
          o.renderbufferStorageMultisample(36161, Me, Se, L.width, L.height), o.framebufferRenderbuffer(36160, 36064 + F, 36161, X.__webglColorRenderbuffer[F]);
        }
        o.bindRenderbuffer(36161, null), L.depthBuffer && (X.__webglDepthRenderbuffer = o.createRenderbuffer(), ze(X.__webglDepthRenderbuffer, L, !0)), t.bindFramebuffer(36160, null);
      }
    }
    if (oe) {
      t.bindTexture(34067, se.__webglTexture), j(34067, T, Ie);
      for (let R = 0; R < 6; R++)
        me(X.__webglFramebuffer[R], L, T, 36064, 34069 + R);
      S(T, Ie) && A(34067), t.unbindTexture();
    } else if (_e) {
      const R = L.texture;
      for (let F = 0, ge = R.length; F < ge; F++) {
        const we = R[F], ve = i.get(we);
        t.bindTexture(3553, ve.__webglTexture), j(3553, we, Ie), me(X.__webglFramebuffer, L, we, 36064 + F, 3553), S(we, Ie) && A(3553);
      }
      t.unbindTexture();
    } else {
      let R = 3553;
      (L.isWebGL3DRenderTarget || L.isWebGLArrayRenderTarget) && (a ? R = L.isWebGL3DRenderTarget ? 32879 : 35866 : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")), t.bindTexture(R, se.__webglTexture), j(R, T, Ie), me(X.__webglFramebuffer, L, T, 36064, R), S(T, Ie) && A(R), t.unbindTexture();
    }
    L.depthBuffer && Q(L);
  }
  function pe(L) {
    const T = v(L) || a, X = L.isWebGLMultipleRenderTargets === !0 ? L.texture : [L.texture];
    for (let se = 0, oe = X.length; se < oe; se++) {
      const _e = X[se];
      if (S(_e, T)) {
        const Ie = L.isWebGLCubeRenderTarget ? 34067 : 3553, R = i.get(_e).__webglTexture;
        t.bindTexture(Ie, R), A(Ie), t.unbindTexture();
      }
    }
  }
  function Ne(L) {
    if (a && L.samples > 0 && Ce(L) === !1) {
      const T = L.isWebGLMultipleRenderTargets ? L.texture : [L.texture], X = L.width, se = L.height;
      let oe = 16384;
      const _e = [], Ie = L.stencilBuffer ? 33306 : 36096, R = i.get(L), F = L.isWebGLMultipleRenderTargets === !0;
      if (F)
        for (let ge = 0; ge < T.length; ge++)
          t.bindFramebuffer(36160, R.__webglMultisampledFramebuffer), o.framebufferRenderbuffer(36160, 36064 + ge, 36161, null), t.bindFramebuffer(36160, R.__webglFramebuffer), o.framebufferTexture2D(36009, 36064 + ge, 3553, null, 0);
      t.bindFramebuffer(36008, R.__webglMultisampledFramebuffer), t.bindFramebuffer(36009, R.__webglFramebuffer);
      for (let ge = 0; ge < T.length; ge++) {
        _e.push(36064 + ge), L.depthBuffer && _e.push(Ie);
        const we = R.__ignoreDepthValues !== void 0 ? R.__ignoreDepthValues : !1;
        if (we === !1 && (L.depthBuffer && (oe |= 256), L.stencilBuffer && (oe |= 1024)), F && o.framebufferRenderbuffer(36008, 36064, 36161, R.__webglColorRenderbuffer[ge]), we === !0 && (o.invalidateFramebuffer(36008, [Ie]), o.invalidateFramebuffer(36009, [Ie])), F) {
          const ve = i.get(T[ge]).__webglTexture;
          o.framebufferTexture2D(36009, 36064, 3553, ve, 0);
        }
        o.blitFramebuffer(0, 0, X, se, 0, 0, X, se, oe, 9728), f && o.invalidateFramebuffer(36008, _e);
      }
      if (t.bindFramebuffer(36008, null), t.bindFramebuffer(36009, null), F)
        for (let ge = 0; ge < T.length; ge++) {
          t.bindFramebuffer(36160, R.__webglMultisampledFramebuffer), o.framebufferRenderbuffer(36160, 36064 + ge, 36161, R.__webglColorRenderbuffer[ge]);
          const we = i.get(T[ge]).__webglTexture;
          t.bindFramebuffer(36160, R.__webglFramebuffer), o.framebufferTexture2D(36009, 36064 + ge, 3553, we, 0);
        }
      t.bindFramebuffer(36009, R.__webglMultisampledFramebuffer);
    }
  }
  function Le(L) {
    return Math.min(u, L.samples);
  }
  function Ce(L) {
    const T = i.get(L);
    return a && L.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && T.__useRenderToTexture !== !1;
  }
  function rt(L) {
    const T = r.render.frame;
    m.get(L) !== T && (m.set(L, T), L.update());
  }
  function Qe(L, T) {
    const X = L.encoding, se = L.format, oe = L.type;
    return L.isCompressedTexture === !0 || L.isVideoTexture === !0 || L.format === _l || X !== Fn && (X === He ? a === !1 ? e.has("EXT_sRGB") === !0 && se === ri ? (L.format = _l, L.minFilter = Ut, L.generateMipmaps = !1) : T = pd.sRGBToLinear(T) : (se !== ri || oe !== zn) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture encoding:", X)), T;
  }
  this.allocateTextureUnit = K, this.resetTextureUnits = ie, this.setTexture2D = te, this.setTexture2DArray = q, this.setTexture3D = W, this.setTextureCube = le, this.rebindTextures = ce, this.setupRenderTarget = be, this.updateRenderTargetMipmap = pe, this.updateMultisampleRenderTarget = Ne, this.setupDepthRenderbuffer = Q, this.setupFrameBufferTexture = me, this.useMultisampledRTT = Ce;
}
function Vv(o, e, t) {
  const i = t.isWebGL2;
  function n(s, r = null) {
    let a;
    if (s === zn) return 5121;
    if (s === xp) return 32819;
    if (s === wp) return 32820;
    if (s === gp) return 5120;
    if (s === vp) return 5122;
    if (s === ld) return 5123;
    if (s === yp) return 5124;
    if (s === Ln) return 5125;
    if (s === cn) return 5126;
    if (s === gr)
      return i ? 5131 : (a = e.get("OES_texture_half_float"), a !== null ? a.HALF_FLOAT_OES : null);
    if (s === bp) return 6406;
    if (s === ri) return 6408;
    if (s === Sp) return 6409;
    if (s === Tp) return 6410;
    if (s === In) return 6402;
    if (s === Es) return 34041;
    if (s === Mp)
      return console.warn("THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228"), 6408;
    if (s === _l)
      return a = e.get("EXT_sRGB"), a !== null ? a.SRGB_ALPHA_EXT : null;
    if (s === Ap) return 6403;
    if (s === Ep) return 36244;
    if (s === Cp) return 33319;
    if (s === Lp) return 33320;
    if (s === Pp) return 36249;
    if (s === lo || s === co || s === ho || s === uo)
      if (r === He)
        if (a = e.get("WEBGL_compressed_texture_s3tc_srgb"), a !== null) {
          if (s === lo) return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (s === co) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (s === ho) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (s === uo) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else
          return null;
      else if (a = e.get("WEBGL_compressed_texture_s3tc"), a !== null) {
        if (s === lo) return a.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (s === co) return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (s === ho) return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (s === uo) return a.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else
        return null;
    if (s === kc || s === zc || s === Fc || s === Bc)
      if (a = e.get("WEBGL_compressed_texture_pvrtc"), a !== null) {
        if (s === kc) return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (s === zc) return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (s === Fc) return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (s === Bc) return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else
        return null;
    if (s === Rp)
      return a = e.get("WEBGL_compressed_texture_etc1"), a !== null ? a.COMPRESSED_RGB_ETC1_WEBGL : null;
    if (s === Uc || s === Vc)
      if (a = e.get("WEBGL_compressed_texture_etc"), a !== null) {
        if (s === Uc) return r === He ? a.COMPRESSED_SRGB8_ETC2 : a.COMPRESSED_RGB8_ETC2;
        if (s === Vc) return r === He ? a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : a.COMPRESSED_RGBA8_ETC2_EAC;
      } else
        return null;
    if (s === Gc || s === Hc || s === Wc || s === Xc || s === qc || s === jc || s === Yc || s === Zc || s === Jc || s === Kc || s === $c || s === Qc || s === eh || s === th)
      if (a = e.get("WEBGL_compressed_texture_astc"), a !== null) {
        if (s === Gc) return r === He ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : a.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (s === Hc) return r === He ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : a.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (s === Wc) return r === He ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : a.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (s === Xc) return r === He ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : a.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (s === qc) return r === He ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : a.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (s === jc) return r === He ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : a.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (s === Yc) return r === He ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : a.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (s === Zc) return r === He ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : a.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (s === Jc) return r === He ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : a.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (s === Kc) return r === He ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : a.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (s === $c) return r === He ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : a.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (s === Qc) return r === He ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : a.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (s === eh) return r === He ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : a.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (s === th) return r === He ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : a.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else
        return null;
    if (s === ih)
      if (a = e.get("EXT_texture_compression_bptc"), a !== null) {
        if (s === ih) return r === He ? a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : a.COMPRESSED_RGBA_BPTC_UNORM_EXT;
      } else
        return null;
    return s === Ms ? i ? 34042 : (a = e.get("WEBGL_depth_texture"), a !== null ? a.UNSIGNED_INT_24_8_WEBGL : null) : o[s] !== void 0 ? o[s] : null;
  }
  return { convert: n };
}
class Gv extends gt {
  constructor(e = []) {
    super(), this.isArrayCamera = !0, this.cameras = e;
  }
}
let nt = class extends tt {
  constructor() {
    super(), this.isGroup = !0, this.type = "Group";
  }
};
const Hv = { type: "move" };
class Fo {
  constructor() {
    this._targetRay = null, this._grip = null, this._hand = null;
  }
  getHandSpace() {
    return this._hand === null && (this._hand = new nt(), this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = { pinching: !1 }), this._hand;
  }
  getTargetRaySpace() {
    return this._targetRay === null && (this._targetRay = new nt(), this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new b(), this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new b()), this._targetRay;
  }
  getGripSpace() {
    return this._grip === null && (this._grip = new nt(), this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new b(), this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new b()), this._grip;
  }
  dispatchEvent(e) {
    return this._targetRay !== null && this._targetRay.dispatchEvent(e), this._grip !== null && this._grip.dispatchEvent(e), this._hand !== null && this._hand.dispatchEvent(e), this;
  }
  connect(e) {
    if (e && e.hand) {
      const t = this._hand;
      if (t)
        for (const i of e.hand.values())
          this._getHandJoint(t, i);
    }
    return this.dispatchEvent({ type: "connected", data: e }), this;
  }
  disconnect(e) {
    return this.dispatchEvent({ type: "disconnected", data: e }), this._targetRay !== null && (this._targetRay.visible = !1), this._grip !== null && (this._grip.visible = !1), this._hand !== null && (this._hand.visible = !1), this;
  }
  update(e, t, i) {
    let n = null, s = null, r = null;
    const a = this._targetRay, l = this._grip, c = this._hand;
    if (e && t.session.visibilityState !== "visible-blurred") {
      if (c && e.hand) {
        r = !0;
        for (const _ of e.hand.values()) {
          const p = t.getJointPose(_, i), g = this._getHandJoint(c, _);
          p !== null && (g.matrix.fromArray(p.transform.matrix), g.matrix.decompose(g.position, g.rotation, g.scale), g.jointRadius = p.radius), g.visible = p !== null;
        }
        const h = c.joints["index-finger-tip"], u = c.joints["thumb-tip"], d = h.position.distanceTo(u.position), f = 0.02, m = 5e-3;
        c.inputState.pinching && d > f + m ? (c.inputState.pinching = !1, this.dispatchEvent({
          type: "pinchend",
          handedness: e.handedness,
          target: this
        })) : !c.inputState.pinching && d <= f - m && (c.inputState.pinching = !0, this.dispatchEvent({
          type: "pinchstart",
          handedness: e.handedness,
          target: this
        }));
      } else
        l !== null && e.gripSpace && (s = t.getPose(e.gripSpace, i), s !== null && (l.matrix.fromArray(s.transform.matrix), l.matrix.decompose(l.position, l.rotation, l.scale), s.linearVelocity ? (l.hasLinearVelocity = !0, l.linearVelocity.copy(s.linearVelocity)) : l.hasLinearVelocity = !1, s.angularVelocity ? (l.hasAngularVelocity = !0, l.angularVelocity.copy(s.angularVelocity)) : l.hasAngularVelocity = !1));
      a !== null && (n = t.getPose(e.targetRaySpace, i), n === null && s !== null && (n = s), n !== null && (a.matrix.fromArray(n.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale), n.linearVelocity ? (a.hasLinearVelocity = !0, a.linearVelocity.copy(n.linearVelocity)) : a.hasLinearVelocity = !1, n.angularVelocity ? (a.hasAngularVelocity = !0, a.angularVelocity.copy(n.angularVelocity)) : a.hasAngularVelocity = !1, this.dispatchEvent(Hv)));
    }
    return a !== null && (a.visible = n !== null), l !== null && (l.visible = s !== null), c !== null && (c.visible = r !== null), this;
  }
  // private method
  _getHandJoint(e, t) {
    if (e.joints[t.jointName] === void 0) {
      const i = new nt();
      i.matrixAutoUpdate = !1, i.visible = !1, e.joints[t.jointName] = i, e.add(i);
    }
    return e.joints[t.jointName];
  }
}
class Wv extends dt {
  constructor(e, t, i, n, s, r, a, l, c, h) {
    if (h = h !== void 0 ? h : In, h !== In && h !== Es)
      throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    i === void 0 && h === In && (i = Ln), i === void 0 && h === Es && (i = Ms), super(null, n, s, r, a, l, h, i, c), this.isDepthTexture = !0, this.image = { width: e, height: t }, this.magFilter = a !== void 0 ? a : yt, this.minFilter = l !== void 0 ? l : yt, this.flipY = !1, this.generateMipmaps = !1;
  }
}
class Xv extends gn {
  constructor(e, t) {
    super();
    const i = this;
    let n = null, s = 1, r = null, a = "local-floor", l = null, c = null, h = null, u = null, d = null, f = null;
    const m = t.getContextAttributes();
    let _ = null, p = null;
    const g = [], x = [], y = /* @__PURE__ */ new Set(), v = /* @__PURE__ */ new Map(), M = new gt();
    M.layers.enable(1), M.viewport = new We();
    const S = new gt();
    S.layers.enable(2), S.viewport = new We();
    const A = [M, S], w = new Gv();
    w.layers.enable(1), w.layers.enable(2);
    let E = null, P = null;
    this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(q) {
      let W = g[q];
      return W === void 0 && (W = new Fo(), g[q] = W), W.getTargetRaySpace();
    }, this.getControllerGrip = function(q) {
      let W = g[q];
      return W === void 0 && (W = new Fo(), g[q] = W), W.getGripSpace();
    }, this.getHand = function(q) {
      let W = g[q];
      return W === void 0 && (W = new Fo(), g[q] = W), W.getHandSpace();
    };
    function z(q) {
      const W = x.indexOf(q.inputSource);
      if (W === -1)
        return;
      const le = g[W];
      le !== void 0 && le.dispatchEvent({ type: q.type, data: q.inputSource });
    }
    function V() {
      n.removeEventListener("select", z), n.removeEventListener("selectstart", z), n.removeEventListener("selectend", z), n.removeEventListener("squeeze", z), n.removeEventListener("squeezestart", z), n.removeEventListener("squeezeend", z), n.removeEventListener("end", V), n.removeEventListener("inputsourceschange", O);
      for (let q = 0; q < g.length; q++) {
        const W = x[q];
        W !== null && (x[q] = null, g[q].disconnect(W));
      }
      E = null, P = null, e.setRenderTarget(_), d = null, u = null, h = null, n = null, p = null, te.stop(), i.isPresenting = !1, i.dispatchEvent({ type: "sessionend" });
    }
    this.setFramebufferScaleFactor = function(q) {
      s = q, i.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
    }, this.setReferenceSpaceType = function(q) {
      a = q, i.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
    }, this.getReferenceSpace = function() {
      return l || r;
    }, this.setReferenceSpace = function(q) {
      l = q;
    }, this.getBaseLayer = function() {
      return u !== null ? u : d;
    }, this.getBinding = function() {
      return h;
    }, this.getFrame = function() {
      return f;
    }, this.getSession = function() {
      return n;
    }, this.setSession = async function(q) {
      if (n = q, n !== null) {
        if (_ = e.getRenderTarget(), n.addEventListener("select", z), n.addEventListener("selectstart", z), n.addEventListener("selectend", z), n.addEventListener("squeeze", z), n.addEventListener("squeezestart", z), n.addEventListener("squeezeend", z), n.addEventListener("end", V), n.addEventListener("inputsourceschange", O), m.xrCompatible !== !0 && await t.makeXRCompatible(), n.renderState.layers === void 0 || e.capabilities.isWebGL2 === !1) {
          const W = {
            antialias: n.renderState.layers === void 0 ? m.antialias : !0,
            alpha: m.alpha,
            depth: m.depth,
            stencil: m.stencil,
            framebufferScaleFactor: s
          };
          d = new XRWebGLLayer(n, t, W), n.updateRenderState({ baseLayer: d }), p = new Ot(
            d.framebufferWidth,
            d.framebufferHeight,
            {
              format: ri,
              type: zn,
              encoding: e.outputEncoding,
              stencilBuffer: m.stencil
            }
          );
        } else {
          let W = null, le = null, ae = null;
          m.depth && (ae = m.stencil ? 35056 : 33190, W = m.stencil ? Es : In, le = m.stencil ? Ms : Ln);
          const fe = {
            colorFormat: 32856,
            depthFormat: ae,
            scaleFactor: s
          };
          h = new XRWebGLBinding(n, t), u = h.createProjectionLayer(fe), n.updateRenderState({ layers: [u] }), p = new Ot(
            u.textureWidth,
            u.textureHeight,
            {
              format: ri,
              type: zn,
              depthTexture: new Wv(u.textureWidth, u.textureHeight, le, void 0, void 0, void 0, void 0, void 0, void 0, W),
              stencilBuffer: m.stencil,
              encoding: e.outputEncoding,
              samples: m.antialias ? 4 : 0
            }
          );
          const j = e.properties.get(p);
          j.__ignoreDepthValues = u.ignoreDepthValues;
        }
        p.isXRRenderTarget = !0, this.setFoveation(1), l = null, r = await n.requestReferenceSpace(a), te.setContext(n), te.start(), i.isPresenting = !0, i.dispatchEvent({ type: "sessionstart" });
      }
    };
    function O(q) {
      for (let W = 0; W < q.removed.length; W++) {
        const le = q.removed[W], ae = x.indexOf(le);
        ae >= 0 && (x[ae] = null, g[ae].disconnect(le));
      }
      for (let W = 0; W < q.added.length; W++) {
        const le = q.added[W];
        let ae = x.indexOf(le);
        if (ae === -1) {
          for (let j = 0; j < g.length; j++)
            if (j >= x.length) {
              x.push(le), ae = j;
              break;
            } else if (x[j] === null) {
              x[j] = le, ae = j;
              break;
            }
          if (ae === -1) break;
        }
        const fe = g[ae];
        fe && fe.connect(le);
      }
    }
    const D = new b(), H = new b();
    function Z(q, W, le) {
      D.setFromMatrixPosition(W.matrixWorld), H.setFromMatrixPosition(le.matrixWorld);
      const ae = D.distanceTo(H), fe = W.projectionMatrix.elements, j = le.projectionMatrix.elements, De = fe[14] / (fe[10] - 1), ye = fe[14] / (fe[10] + 1), Re = (fe[9] + 1) / fe[5], me = (fe[9] - 1) / fe[5], ze = (fe[8] - 1) / fe[0], ee = (j[8] + 1) / j[0], Q = De * ze, ce = De * ee, be = ae / (-ze + ee), pe = be * -ze;
      W.matrixWorld.decompose(q.position, q.quaternion, q.scale), q.translateX(pe), q.translateZ(be), q.matrixWorld.compose(q.position, q.quaternion, q.scale), q.matrixWorldInverse.copy(q.matrixWorld).invert();
      const Ne = De + be, Le = ye + be, Ce = Q - pe, rt = ce + (ae - pe), Qe = Re * ye / Le * Ne, L = me * ye / Le * Ne;
      q.projectionMatrix.makePerspective(Ce, rt, Qe, L, Ne, Le);
    }
    function ie(q, W) {
      W === null ? q.matrixWorld.copy(q.matrix) : q.matrixWorld.multiplyMatrices(W.matrixWorld, q.matrix), q.matrixWorldInverse.copy(q.matrixWorld).invert();
    }
    this.updateCamera = function(q) {
      if (n === null) return;
      w.near = S.near = M.near = q.near, w.far = S.far = M.far = q.far, (E !== w.near || P !== w.far) && (n.updateRenderState({
        depthNear: w.near,
        depthFar: w.far
      }), E = w.near, P = w.far);
      const W = q.parent, le = w.cameras;
      ie(w, W);
      for (let fe = 0; fe < le.length; fe++)
        ie(le[fe], W);
      w.matrixWorld.decompose(w.position, w.quaternion, w.scale), q.matrix.copy(w.matrix), q.matrix.decompose(q.position, q.quaternion, q.scale);
      const ae = q.children;
      for (let fe = 0, j = ae.length; fe < j; fe++)
        ae[fe].updateMatrixWorld(!0);
      le.length === 2 ? Z(w, M, S) : w.projectionMatrix.copy(M.projectionMatrix);
    }, this.getCamera = function() {
      return w;
    }, this.getFoveation = function() {
      if (u !== null)
        return u.fixedFoveation;
      if (d !== null)
        return d.fixedFoveation;
    }, this.setFoveation = function(q) {
      u !== null && (u.fixedFoveation = q), d !== null && d.fixedFoveation !== void 0 && (d.fixedFoveation = q);
    }, this.getPlanes = function() {
      return y;
    };
    let K = null;
    function ne(q, W) {
      if (c = W.getViewerPose(l || r), f = W, c !== null) {
        const le = c.views;
        d !== null && (e.setRenderTargetFramebuffer(p, d.framebuffer), e.setRenderTarget(p));
        let ae = !1;
        le.length !== w.cameras.length && (w.cameras.length = 0, ae = !0);
        for (let fe = 0; fe < le.length; fe++) {
          const j = le[fe];
          let De = null;
          if (d !== null)
            De = d.getViewport(j);
          else {
            const Re = h.getViewSubImage(u, j);
            De = Re.viewport, fe === 0 && (e.setRenderTargetTextures(
              p,
              Re.colorTexture,
              u.ignoreDepthValues ? void 0 : Re.depthStencilTexture
            ), e.setRenderTarget(p));
          }
          let ye = A[fe];
          ye === void 0 && (ye = new gt(), ye.layers.enable(fe), ye.viewport = new We(), A[fe] = ye), ye.matrix.fromArray(j.transform.matrix), ye.projectionMatrix.fromArray(j.projectionMatrix), ye.viewport.set(De.x, De.y, De.width, De.height), fe === 0 && w.matrix.copy(ye.matrix), ae === !0 && w.cameras.push(ye);
        }
      }
      for (let le = 0; le < g.length; le++) {
        const ae = x[le], fe = g[le];
        ae !== null && fe !== void 0 && fe.update(ae, W, l || r);
      }
      if (K && K(q, W), W.detectedPlanes) {
        i.dispatchEvent({ type: "planesdetected", data: W.detectedPlanes });
        let le = null;
        for (const ae of y)
          W.detectedPlanes.has(ae) || (le === null && (le = []), le.push(ae));
        if (le !== null)
          for (const ae of le)
            y.delete(ae), v.delete(ae), i.dispatchEvent({ type: "planeremoved", data: ae });
        for (const ae of W.detectedPlanes)
          if (!y.has(ae))
            y.add(ae), v.set(ae, W.lastChangedTime), i.dispatchEvent({ type: "planeadded", data: ae });
          else {
            const fe = v.get(ae);
            ae.lastChangedTime > fe && (v.set(ae, ae.lastChangedTime), i.dispatchEvent({ type: "planechanged", data: ae }));
          }
      }
      f = null;
    }
    const te = new yd();
    te.setAnimationLoop(ne), this.setAnimationLoop = function(q) {
      K = q;
    }, this.dispose = function() {
    };
  }
}
function qv(o, e) {
  function t(_, p) {
    p.color.getRGB(_.fogColor.value, gd(o)), p.isFog ? (_.fogNear.value = p.near, _.fogFar.value = p.far) : p.isFogExp2 && (_.fogDensity.value = p.density);
  }
  function i(_, p, g, x, y) {
    p.isMeshBasicMaterial || p.isMeshLambertMaterial ? n(_, p) : p.isMeshToonMaterial ? (n(_, p), h(_, p)) : p.isMeshPhongMaterial ? (n(_, p), c(_, p)) : p.isMeshStandardMaterial ? (n(_, p), u(_, p), p.isMeshPhysicalMaterial && d(_, p, y)) : p.isMeshMatcapMaterial ? (n(_, p), f(_, p)) : p.isMeshDepthMaterial ? n(_, p) : p.isMeshDistanceMaterial ? (n(_, p), m(_, p)) : p.isMeshNormalMaterial ? n(_, p) : p.isLineBasicMaterial ? (s(_, p), p.isLineDashedMaterial && r(_, p)) : p.isPointsMaterial ? a(_, p, g, x) : p.isSpriteMaterial ? l(_, p) : p.isShadowMaterial ? (_.color.value.copy(p.color), _.opacity.value = p.opacity) : p.isShaderMaterial && (p.uniformsNeedUpdate = !1);
  }
  function n(_, p) {
    _.opacity.value = p.opacity, p.color && _.diffuse.value.copy(p.color), p.emissive && _.emissive.value.copy(p.emissive).multiplyScalar(p.emissiveIntensity), p.map && (_.map.value = p.map), p.alphaMap && (_.alphaMap.value = p.alphaMap), p.bumpMap && (_.bumpMap.value = p.bumpMap, _.bumpScale.value = p.bumpScale, p.side === oi && (_.bumpScale.value *= -1)), p.displacementMap && (_.displacementMap.value = p.displacementMap, _.displacementScale.value = p.displacementScale, _.displacementBias.value = p.displacementBias), p.emissiveMap && (_.emissiveMap.value = p.emissiveMap), p.normalMap && (_.normalMap.value = p.normalMap, _.normalScale.value.copy(p.normalScale), p.side === oi && _.normalScale.value.negate()), p.specularMap && (_.specularMap.value = p.specularMap), p.alphaTest > 0 && (_.alphaTest.value = p.alphaTest);
    const g = e.get(p).envMap;
    if (g && (_.envMap.value = g, _.flipEnvMap.value = g.isCubeTexture && g.isRenderTargetTexture === !1 ? -1 : 1, _.reflectivity.value = p.reflectivity, _.ior.value = p.ior, _.refractionRatio.value = p.refractionRatio), p.lightMap) {
      _.lightMap.value = p.lightMap;
      const v = o.physicallyCorrectLights !== !0 ? Math.PI : 1;
      _.lightMapIntensity.value = p.lightMapIntensity * v;
    }
    p.aoMap && (_.aoMap.value = p.aoMap, _.aoMapIntensity.value = p.aoMapIntensity);
    let x;
    p.map ? x = p.map : p.specularMap ? x = p.specularMap : p.displacementMap ? x = p.displacementMap : p.normalMap ? x = p.normalMap : p.bumpMap ? x = p.bumpMap : p.roughnessMap ? x = p.roughnessMap : p.metalnessMap ? x = p.metalnessMap : p.alphaMap ? x = p.alphaMap : p.emissiveMap ? x = p.emissiveMap : p.clearcoatMap ? x = p.clearcoatMap : p.clearcoatNormalMap ? x = p.clearcoatNormalMap : p.clearcoatRoughnessMap ? x = p.clearcoatRoughnessMap : p.iridescenceMap ? x = p.iridescenceMap : p.iridescenceThicknessMap ? x = p.iridescenceThicknessMap : p.specularIntensityMap ? x = p.specularIntensityMap : p.specularColorMap ? x = p.specularColorMap : p.transmissionMap ? x = p.transmissionMap : p.thicknessMap ? x = p.thicknessMap : p.sheenColorMap ? x = p.sheenColorMap : p.sheenRoughnessMap && (x = p.sheenRoughnessMap), x !== void 0 && (x.isWebGLRenderTarget && (x = x.texture), x.matrixAutoUpdate === !0 && x.updateMatrix(), _.uvTransform.value.copy(x.matrix));
    let y;
    p.aoMap ? y = p.aoMap : p.lightMap && (y = p.lightMap), y !== void 0 && (y.isWebGLRenderTarget && (y = y.texture), y.matrixAutoUpdate === !0 && y.updateMatrix(), _.uv2Transform.value.copy(y.matrix));
  }
  function s(_, p) {
    _.diffuse.value.copy(p.color), _.opacity.value = p.opacity;
  }
  function r(_, p) {
    _.dashSize.value = p.dashSize, _.totalSize.value = p.dashSize + p.gapSize, _.scale.value = p.scale;
  }
  function a(_, p, g, x) {
    _.diffuse.value.copy(p.color), _.opacity.value = p.opacity, _.size.value = p.size * g, _.scale.value = x * 0.5, p.map && (_.map.value = p.map), p.alphaMap && (_.alphaMap.value = p.alphaMap), p.alphaTest > 0 && (_.alphaTest.value = p.alphaTest);
    let y;
    p.map ? y = p.map : p.alphaMap && (y = p.alphaMap), y !== void 0 && (y.matrixAutoUpdate === !0 && y.updateMatrix(), _.uvTransform.value.copy(y.matrix));
  }
  function l(_, p) {
    _.diffuse.value.copy(p.color), _.opacity.value = p.opacity, _.rotation.value = p.rotation, p.map && (_.map.value = p.map), p.alphaMap && (_.alphaMap.value = p.alphaMap), p.alphaTest > 0 && (_.alphaTest.value = p.alphaTest);
    let g;
    p.map ? g = p.map : p.alphaMap && (g = p.alphaMap), g !== void 0 && (g.matrixAutoUpdate === !0 && g.updateMatrix(), _.uvTransform.value.copy(g.matrix));
  }
  function c(_, p) {
    _.specular.value.copy(p.specular), _.shininess.value = Math.max(p.shininess, 1e-4);
  }
  function h(_, p) {
    p.gradientMap && (_.gradientMap.value = p.gradientMap);
  }
  function u(_, p) {
    _.roughness.value = p.roughness, _.metalness.value = p.metalness, p.roughnessMap && (_.roughnessMap.value = p.roughnessMap), p.metalnessMap && (_.metalnessMap.value = p.metalnessMap), e.get(p).envMap && (_.envMapIntensity.value = p.envMapIntensity);
  }
  function d(_, p, g) {
    _.ior.value = p.ior, p.sheen > 0 && (_.sheenColor.value.copy(p.sheenColor).multiplyScalar(p.sheen), _.sheenRoughness.value = p.sheenRoughness, p.sheenColorMap && (_.sheenColorMap.value = p.sheenColorMap), p.sheenRoughnessMap && (_.sheenRoughnessMap.value = p.sheenRoughnessMap)), p.clearcoat > 0 && (_.clearcoat.value = p.clearcoat, _.clearcoatRoughness.value = p.clearcoatRoughness, p.clearcoatMap && (_.clearcoatMap.value = p.clearcoatMap), p.clearcoatRoughnessMap && (_.clearcoatRoughnessMap.value = p.clearcoatRoughnessMap), p.clearcoatNormalMap && (_.clearcoatNormalScale.value.copy(p.clearcoatNormalScale), _.clearcoatNormalMap.value = p.clearcoatNormalMap, p.side === oi && _.clearcoatNormalScale.value.negate())), p.iridescence > 0 && (_.iridescence.value = p.iridescence, _.iridescenceIOR.value = p.iridescenceIOR, _.iridescenceThicknessMinimum.value = p.iridescenceThicknessRange[0], _.iridescenceThicknessMaximum.value = p.iridescenceThicknessRange[1], p.iridescenceMap && (_.iridescenceMap.value = p.iridescenceMap), p.iridescenceThicknessMap && (_.iridescenceThicknessMap.value = p.iridescenceThicknessMap)), p.transmission > 0 && (_.transmission.value = p.transmission, _.transmissionSamplerMap.value = g.texture, _.transmissionSamplerSize.value.set(g.width, g.height), p.transmissionMap && (_.transmissionMap.value = p.transmissionMap), _.thickness.value = p.thickness, p.thicknessMap && (_.thicknessMap.value = p.thicknessMap), _.attenuationDistance.value = p.attenuationDistance, _.attenuationColor.value.copy(p.attenuationColor)), _.specularIntensity.value = p.specularIntensity, _.specularColor.value.copy(p.specularColor), p.specularIntensityMap && (_.specularIntensityMap.value = p.specularIntensityMap), p.specularColorMap && (_.specularColorMap.value = p.specularColorMap);
  }
  function f(_, p) {
    p.matcap && (_.matcap.value = p.matcap);
  }
  function m(_, p) {
    _.referencePosition.value.copy(p.referencePosition), _.nearDistance.value = p.nearDistance, _.farDistance.value = p.farDistance;
  }
  return {
    refreshFogUniforms: t,
    refreshMaterialUniforms: i
  };
}
function jv(o, e, t, i) {
  let n = {}, s = {}, r = [];
  const a = t.isWebGL2 ? o.getParameter(35375) : 0;
  function l(x, y) {
    const v = y.program;
    i.uniformBlockBinding(x, v);
  }
  function c(x, y) {
    let v = n[x.id];
    v === void 0 && (m(x), v = h(x), n[x.id] = v, x.addEventListener("dispose", p));
    const M = y.program;
    i.updateUBOMapping(x, M);
    const S = e.render.frame;
    s[x.id] !== S && (d(x), s[x.id] = S);
  }
  function h(x) {
    const y = u();
    x.__bindingPointIndex = y;
    const v = o.createBuffer(), M = x.__size, S = x.usage;
    return o.bindBuffer(35345, v), o.bufferData(35345, M, S), o.bindBuffer(35345, null), o.bindBufferBase(35345, y, v), v;
  }
  function u() {
    for (let x = 0; x < a; x++)
      if (r.indexOf(x) === -1)
        return r.push(x), x;
    return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0;
  }
  function d(x) {
    const y = n[x.id], v = x.uniforms, M = x.__cache;
    o.bindBuffer(35345, y);
    for (let S = 0, A = v.length; S < A; S++) {
      const w = v[S];
      if (f(w, S, M) === !0) {
        const E = w.__offset, P = Array.isArray(w.value) ? w.value : [w.value];
        let z = 0;
        for (let V = 0; V < P.length; V++) {
          const O = P[V], D = _(O);
          typeof O == "number" ? (w.__data[0] = O, o.bufferSubData(35345, E + z, w.__data)) : O.isMatrix3 ? (w.__data[0] = O.elements[0], w.__data[1] = O.elements[1], w.__data[2] = O.elements[2], w.__data[3] = O.elements[0], w.__data[4] = O.elements[3], w.__data[5] = O.elements[4], w.__data[6] = O.elements[5], w.__data[7] = O.elements[0], w.__data[8] = O.elements[6], w.__data[9] = O.elements[7], w.__data[10] = O.elements[8], w.__data[11] = O.elements[0]) : (O.toArray(w.__data, z), z += D.storage / Float32Array.BYTES_PER_ELEMENT);
        }
        o.bufferSubData(35345, E, w.__data);
      }
    }
    o.bindBuffer(35345, null);
  }
  function f(x, y, v) {
    const M = x.value;
    if (v[y] === void 0) {
      if (typeof M == "number")
        v[y] = M;
      else {
        const S = Array.isArray(M) ? M : [M], A = [];
        for (let w = 0; w < S.length; w++)
          A.push(S[w].clone());
        v[y] = A;
      }
      return !0;
    } else if (typeof M == "number") {
      if (v[y] !== M)
        return v[y] = M, !0;
    } else {
      const S = Array.isArray(v[y]) ? v[y] : [v[y]], A = Array.isArray(M) ? M : [M];
      for (let w = 0; w < S.length; w++) {
        const E = S[w];
        if (E.equals(A[w]) === !1)
          return E.copy(A[w]), !0;
      }
    }
    return !1;
  }
  function m(x) {
    const y = x.uniforms;
    let v = 0;
    const M = 16;
    let S = 0;
    for (let A = 0, w = y.length; A < w; A++) {
      const E = y[A], P = {
        boundary: 0,
        // bytes
        storage: 0
        // bytes
      }, z = Array.isArray(E.value) ? E.value : [E.value];
      for (let V = 0, O = z.length; V < O; V++) {
        const D = z[V], H = _(D);
        P.boundary += H.boundary, P.storage += H.storage;
      }
      if (E.__data = new Float32Array(P.storage / Float32Array.BYTES_PER_ELEMENT), E.__offset = v, A > 0) {
        S = v % M;
        const V = M - S;
        S !== 0 && V - P.boundary < 0 && (v += M - S, E.__offset = v);
      }
      v += P.storage;
    }
    return S = v % M, S > 0 && (v += M - S), x.__size = v, x.__cache = {}, this;
  }
  function _(x) {
    const y = {
      boundary: 0,
      // bytes
      storage: 0
      // bytes
    };
    return typeof x == "number" ? (y.boundary = 4, y.storage = 4) : x.isVector2 ? (y.boundary = 8, y.storage = 8) : x.isVector3 || x.isColor ? (y.boundary = 16, y.storage = 12) : x.isVector4 ? (y.boundary = 16, y.storage = 16) : x.isMatrix3 ? (y.boundary = 48, y.storage = 48) : x.isMatrix4 ? (y.boundary = 64, y.storage = 64) : x.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", x), y;
  }
  function p(x) {
    const y = x.target;
    y.removeEventListener("dispose", p);
    const v = r.indexOf(y.__bindingPointIndex);
    r.splice(v, 1), o.deleteBuffer(n[y.id]), delete n[y.id], delete s[y.id];
  }
  function g() {
    for (const x in n)
      o.deleteBuffer(n[x]);
    r = [], n = {}, s = {};
  }
  return {
    bind: l,
    update: c,
    dispose: g
  };
}
function Yv() {
  const o = wr("canvas");
  return o.style.display = "block", o;
}
function Da(o = {}) {
  this.isWebGLRenderer = !0;
  const e = o.canvas !== void 0 ? o.canvas : Yv(), t = o.context !== void 0 ? o.context : null, i = o.depth !== void 0 ? o.depth : !0, n = o.stencil !== void 0 ? o.stencil : !0, s = o.antialias !== void 0 ? o.antialias : !1, r = o.premultipliedAlpha !== void 0 ? o.premultipliedAlpha : !0, a = o.preserveDrawingBuffer !== void 0 ? o.preserveDrawingBuffer : !1, l = o.powerPreference !== void 0 ? o.powerPreference : "default", c = o.failIfMajorPerformanceCaveat !== void 0 ? o.failIfMajorPerformanceCaveat : !1;
  let h;
  t !== null ? h = t.getContextAttributes().alpha : h = o.alpha !== void 0 ? o.alpha : !1;
  let u = null, d = null;
  const f = [], m = [];
  this.domElement = e, this.debug = {
    /**
     * Enables error checking and reporting when shader programs are being compiled
     * @type {boolean}
     */
    checkShaderErrors: !0
  }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.outputEncoding = Fn, this.physicallyCorrectLights = !1, this.toneMapping = Wi, this.toneMappingExposure = 1;
  const _ = this;
  let p = !1, g = 0, x = 0, y = null, v = -1, M = null;
  const S = new We(), A = new We();
  let w = null, E = e.width, P = e.height, z = 1, V = null, O = null;
  const D = new We(0, 0, E, P), H = new We(0, 0, E, P);
  let Z = !1;
  const ie = new Ja();
  let K = !1, ne = !1, te = null;
  const q = new ue(), W = new G(), le = new b(), ae = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 };
  function fe() {
    return y === null ? z : 1;
  }
  let j = t;
  function De(C, U) {
    for (let J = 0; J < C.length; J++) {
      const B = C[J], $ = e.getContext(B, U);
      if ($ !== null) return $;
    }
    return null;
  }
  try {
    const C = {
      alpha: !0,
      depth: i,
      stencil: n,
      antialias: s,
      premultipliedAlpha: r,
      preserveDrawingBuffer: a,
      powerPreference: l,
      failIfMajorPerformanceCaveat: c
    };
    if ("setAttribute" in e && e.setAttribute("data-engine", `three.js r${Ol}`), e.addEventListener("webglcontextlost", Se, !1), e.addEventListener("webglcontextrestored", Me, !1), e.addEventListener("webglcontextcreationerror", Xe, !1), j === null) {
      const U = ["webgl2", "webgl", "experimental-webgl"];
      if (_.isWebGL1Renderer === !0 && U.shift(), j = De(U, C), j === null)
        throw De(U) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
    }
    j.getShaderPrecisionFormat === void 0 && (j.getShaderPrecisionFormat = function() {
      return { rangeMin: 1, rangeMax: 1, precision: 1 };
    });
  } catch (C) {
    throw console.error("THREE.WebGLRenderer: " + C.message), C;
  }
  let ye, Re, me, ze, ee, Q, ce, be, pe, Ne, Le, Ce, rt, Qe, L, T, X, se, oe, _e, Ie, R, F, ge;
  function we() {
    ye = new o0(j), Re = new t0(j, ye, o), ye.init(Re), R = new Vv(j, ye, Re), me = new Bv(j, ye, Re), ze = new h0(), ee = new Ev(), Q = new Uv(j, ye, me, ee, Re, R, ze), ce = new n0(_), be = new a0(_), pe = new ym(j, Re), F = new Qg(j, ye, pe, Re), Ne = new l0(j, pe, ze, F), Le = new p0(j, Ne, pe, ze), oe = new f0(j, Re, Q), T = new i0(ee), Ce = new Av(_, ce, be, ye, Re, F, T), rt = new qv(_, ee), Qe = new Lv(), L = new Nv(ye, Re), se = new $g(_, ce, be, me, Le, h, r), X = new Fv(_, Le, Re), ge = new jv(j, ze, Re, me), _e = new e0(j, ye, ze, Re), Ie = new c0(j, ye, ze, Re), ze.programs = Ce.programs, _.capabilities = Re, _.extensions = ye, _.properties = ee, _.renderLists = Qe, _.shadowMap = X, _.state = me, _.info = ze;
  }
  we();
  const ve = new Xv(_, j);
  this.xr = ve, this.getContext = function() {
    return j;
  }, this.getContextAttributes = function() {
    return j.getContextAttributes();
  }, this.forceContextLoss = function() {
    const C = ye.get("WEBGL_lose_context");
    C && C.loseContext();
  }, this.forceContextRestore = function() {
    const C = ye.get("WEBGL_lose_context");
    C && C.restoreContext();
  }, this.getPixelRatio = function() {
    return z;
  }, this.setPixelRatio = function(C) {
    C !== void 0 && (z = C, this.setSize(E, P, !1));
  }, this.getSize = function(C) {
    return C.set(E, P);
  }, this.setSize = function(C, U, J) {
    if (ve.isPresenting) {
      console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
      return;
    }
    E = C, P = U, e.width = Math.floor(C * z), e.height = Math.floor(U * z), J !== !1 && (e.style.width = C + "px", e.style.height = U + "px"), this.setViewport(0, 0, C, U);
  }, this.getDrawingBufferSize = function(C) {
    return C.set(E * z, P * z).floor();
  }, this.setDrawingBufferSize = function(C, U, J) {
    E = C, P = U, z = J, e.width = Math.floor(C * J), e.height = Math.floor(U * J), this.setViewport(0, 0, C, U);
  }, this.getCurrentViewport = function(C) {
    return C.copy(S);
  }, this.getViewport = function(C) {
    return C.copy(D);
  }, this.setViewport = function(C, U, J, B) {
    C.isVector4 ? D.set(C.x, C.y, C.z, C.w) : D.set(C, U, J, B), me.viewport(S.copy(D).multiplyScalar(z).floor());
  }, this.getScissor = function(C) {
    return C.copy(H);
  }, this.setScissor = function(C, U, J, B) {
    C.isVector4 ? H.set(C.x, C.y, C.z, C.w) : H.set(C, U, J, B), me.scissor(A.copy(H).multiplyScalar(z).floor());
  }, this.getScissorTest = function() {
    return Z;
  }, this.setScissorTest = function(C) {
    me.setScissorTest(Z = C);
  }, this.setOpaqueSort = function(C) {
    V = C;
  }, this.setTransparentSort = function(C) {
    O = C;
  }, this.getClearColor = function(C) {
    return C.copy(se.getClearColor());
  }, this.setClearColor = function() {
    se.setClearColor.apply(se, arguments);
  }, this.getClearAlpha = function() {
    return se.getClearAlpha();
  }, this.setClearAlpha = function() {
    se.setClearAlpha.apply(se, arguments);
  }, this.clear = function(C = !0, U = !0, J = !0) {
    let B = 0;
    C && (B |= 16384), U && (B |= 256), J && (B |= 1024), j.clear(B);
  }, this.clearColor = function() {
    this.clear(!0, !1, !1);
  }, this.clearDepth = function() {
    this.clear(!1, !0, !1);
  }, this.clearStencil = function() {
    this.clear(!1, !1, !0);
  }, this.dispose = function() {
    e.removeEventListener("webglcontextlost", Se, !1), e.removeEventListener("webglcontextrestored", Me, !1), e.removeEventListener("webglcontextcreationerror", Xe, !1), Qe.dispose(), L.dispose(), ee.dispose(), ce.dispose(), be.dispose(), Le.dispose(), F.dispose(), ge.dispose(), Ce.dispose(), ve.dispose(), ve.removeEventListener("sessionstart", xe), ve.removeEventListener("sessionend", Te), te && (te.dispose(), te = null), it.stop();
  };
  function Se(C) {
    C.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), p = !0;
  }
  function Me() {
    console.log("THREE.WebGLRenderer: Context Restored."), p = !1;
    const C = ze.autoReset, U = X.enabled, J = X.autoUpdate, B = X.needsUpdate, $ = X.type;
    we(), ze.autoReset = C, X.enabled = U, X.autoUpdate = J, X.needsUpdate = B, X.type = $;
  }
  function Xe(C) {
    console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", C.statusMessage);
  }
  function qe(C) {
    const U = C.target;
    U.removeEventListener("dispose", qe), at(U);
  }
  function at(C) {
    N(C), ee.remove(C);
  }
  function N(C) {
    const U = ee.get(C).programs;
    U !== void 0 && (U.forEach(function(J) {
      Ce.releaseProgram(J);
    }), C.isShaderMaterial && Ce.releaseShaderCache(C));
  }
  this.renderBufferDirect = function(C, U, J, B, $, Pe) {
    U === null && (U = ae);
    const ke = $.isMesh && $.matrixWorld.determinant() < 0, Be = Nf(C, U, J, B, $);
    me.setMaterial(B, ke);
    let Ve = J.index, et = 1;
    B.wireframe === !0 && (Ve = Ne.getWireframeAttribute(J), et = 2);
    const je = J.drawRange, Ye = J.attributes.position;
    let ft = je.start * et, jt = (je.start + je.count) * et;
    Pe !== null && (ft = Math.max(ft, Pe.start * et), jt = Math.min(jt, (Pe.start + Pe.count) * et)), Ve !== null ? (ft = Math.max(ft, 0), jt = Math.min(jt, Ve.count)) : Ye != null && (ft = Math.max(ft, 0), jt = Math.min(jt, Ye.count));
    const Ri = jt - ft;
    if (Ri < 0 || Ri === 1 / 0) return;
    F.setup($, B, Be, J, Ve);
    let xn, pt = _e;
    if (Ve !== null && (xn = pe.get(Ve), pt = Ie, pt.setIndex(xn)), $.isMesh)
      B.wireframe === !0 ? (me.setLineWidth(B.wireframeLinewidth * fe()), pt.setMode(1)) : pt.setMode(4);
    else if ($.isLine) {
      let Ze = B.linewidth;
      Ze === void 0 && (Ze = 1), me.setLineWidth(Ze * fe()), $.isLineSegments ? pt.setMode(1) : $.isLineLoop ? pt.setMode(2) : pt.setMode(3);
    } else $.isPoints ? pt.setMode(0) : $.isSprite && pt.setMode(4);
    if ($.isInstancedMesh)
      pt.renderInstances(ft, Ri, $.count);
    else if (J.isInstancedBufferGeometry) {
      const Ze = J._maxInstanceCount !== void 0 ? J._maxInstanceCount : 1 / 0, so = Math.min(J.instanceCount, Ze);
      pt.renderInstances(ft, Ri, so);
    } else
      pt.render(ft, Ri);
  }, this.compile = function(C, U) {
    function J(B, $, Pe) {
      B.transparent === !0 && B.side === zr ? (B.side = oi, B.needsUpdate = !0, Qt(B, $, Pe), B.side = dn, B.needsUpdate = !0, Qt(B, $, Pe), B.side = zr) : Qt(B, $, Pe);
    }
    d = L.get(C), d.init(), m.push(d), C.traverseVisible(function(B) {
      B.isLight && B.layers.test(U.layers) && (d.pushLight(B), B.castShadow && d.pushShadow(B));
    }), d.setupLights(_.physicallyCorrectLights), C.traverse(function(B) {
      const $ = B.material;
      if ($)
        if (Array.isArray($))
          for (let Pe = 0; Pe < $.length; Pe++) {
            const ke = $[Pe];
            J(ke, C, B);
          }
        else
          J($, C, B);
    }), m.pop(), d = null;
  };
  let Y = null;
  function re(C) {
    Y && Y(C);
  }
  function xe() {
    it.stop();
  }
  function Te() {
    it.start();
  }
  const it = new yd();
  it.setAnimationLoop(re), typeof self < "u" && it.setContext(self), this.setAnimationLoop = function(C) {
    Y = C, ve.setAnimationLoop(C), C === null ? it.stop() : it.start();
  }, ve.addEventListener("sessionstart", xe), ve.addEventListener("sessionend", Te), this.render = function(C, U) {
    if (U !== void 0 && U.isCamera !== !0) {
      console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
      return;
    }
    if (p === !0) return;
    C.matrixWorldAutoUpdate === !0 && C.updateMatrixWorld(), U.parent === null && U.matrixWorldAutoUpdate === !0 && U.updateMatrixWorld(), ve.enabled === !0 && ve.isPresenting === !0 && (ve.cameraAutoUpdate === !0 && ve.updateCamera(U), U = ve.getCamera()), C.isScene === !0 && C.onBeforeRender(_, C, U, y), d = L.get(C, m.length), d.init(), m.push(d), q.multiplyMatrices(U.projectionMatrix, U.matrixWorldInverse), ie.setFromProjectionMatrix(q), ne = this.localClippingEnabled, K = T.init(this.clippingPlanes, ne, U), u = Qe.get(C, f.length), u.init(), f.push(u), Mt(C, U, 0, _.sortObjects), u.finish(), _.sortObjects === !0 && u.sort(V, O), K === !0 && T.beginShadows();
    const J = d.state.shadowsArray;
    if (X.render(J, C, U), K === !0 && T.endShadows(), this.info.autoReset === !0 && this.info.reset(), se.render(u, C), d.setupLights(_.physicallyCorrectLights), U.isArrayCamera) {
      const B = U.cameras;
      for (let $ = 0, Pe = B.length; $ < Pe; $++) {
        const ke = B[$];
        It(u, C, ke, ke.viewport);
      }
    } else
      It(u, C, U);
    y !== null && (Q.updateMultisampleRenderTarget(y), Q.updateRenderTargetMipmap(y)), C.isScene === !0 && C.onAfterRender(_, C, U), F.resetDefaultState(), v = -1, M = null, m.pop(), m.length > 0 ? d = m[m.length - 1] : d = null, f.pop(), f.length > 0 ? u = f[f.length - 1] : u = null;
  };
  function Mt(C, U, J, B) {
    if (C.visible === !1) return;
    if (C.layers.test(U.layers)) {
      if (C.isGroup)
        J = C.renderOrder;
      else if (C.isLOD)
        C.autoUpdate === !0 && C.update(U);
      else if (C.isLight)
        d.pushLight(C), C.castShadow && d.pushShadow(C);
      else if (C.isSprite) {
        if (!C.frustumCulled || ie.intersectsSprite(C)) {
          B && le.setFromMatrixPosition(C.matrixWorld).applyMatrix4(q);
          const ke = Le.update(C), Be = C.material;
          Be.visible && u.push(C, ke, Be, J, le.z, null);
        }
      } else if ((C.isMesh || C.isLine || C.isPoints) && (C.isSkinnedMesh && C.skeleton.frame !== ze.render.frame && (C.skeleton.update(), C.skeleton.frame = ze.render.frame), !C.frustumCulled || ie.intersectsObject(C))) {
        B && le.setFromMatrixPosition(C.matrixWorld).applyMatrix4(q);
        const ke = Le.update(C), Be = C.material;
        if (Array.isArray(Be)) {
          const Ve = ke.groups;
          for (let et = 0, je = Ve.length; et < je; et++) {
            const Ye = Ve[et], ft = Be[Ye.materialIndex];
            ft && ft.visible && u.push(C, ke, ft, J, le.z, Ye);
          }
        } else Be.visible && u.push(C, ke, Be, J, le.z, null);
      }
    }
    const Pe = C.children;
    for (let ke = 0, Be = Pe.length; ke < Be; ke++)
      Mt(Pe[ke], U, J, B);
  }
  function It(C, U, J, B) {
    const $ = C.opaque, Pe = C.transmissive, ke = C.transparent;
    d.setupLightsView(J), Pe.length > 0 && yn($, U, J), B && me.viewport(S.copy(B)), $.length > 0 && ct($, U, J), Pe.length > 0 && ct(Pe, U, J), ke.length > 0 && ct(ke, U, J), me.buffers.depth.setTest(!0), me.buffers.depth.setMask(!0), me.buffers.color.setMask(!0), me.setPolygonOffset(!1);
  }
  function yn(C, U, J) {
    const B = Re.isWebGL2;
    te === null && (te = new Ot(1, 1, {
      generateMipmaps: !0,
      type: ye.has("EXT_color_buffer_half_float") ? gr : zn,
      minFilter: fn,
      samples: B && s === !0 ? 4 : 0
    })), _.getDrawingBufferSize(W), B ? te.setSize(W.x, W.y) : te.setSize(Va(W.x), Va(W.y));
    const $ = _.getRenderTarget();
    _.setRenderTarget(te), _.clear();
    const Pe = _.toneMapping;
    _.toneMapping = Wi, ct(C, U, J), _.toneMapping = Pe, Q.updateMultisampleRenderTarget(te), Q.updateRenderTargetMipmap(te), _.setRenderTarget($);
  }
  function ct(C, U, J) {
    const B = U.isScene === !0 ? U.overrideMaterial : null;
    for (let $ = 0, Pe = C.length; $ < Pe; $++) {
      const ke = C[$], Be = ke.object, Ve = ke.geometry, et = B === null ? ke.material : B, je = ke.group;
      Be.layers.test(J.layers) && Pi(Be, U, J, Ve, et, je);
    }
  }
  function Pi(C, U, J, B, $, Pe) {
    C.onBeforeRender(_, U, J, B, $, Pe), C.modelViewMatrix.multiplyMatrices(J.matrixWorldInverse, C.matrixWorld), C.normalMatrix.getNormalMatrix(C.modelViewMatrix), $.onBeforeRender(_, U, J, B, C, Pe), $.transparent === !0 && $.side === zr ? ($.side = oi, $.needsUpdate = !0, _.renderBufferDirect(J, U, B, $, C, Pe), $.side = dn, $.needsUpdate = !0, _.renderBufferDirect(J, U, B, $, C, Pe), $.side = zr) : _.renderBufferDirect(J, U, B, $, C, Pe), C.onAfterRender(_, U, J, B, $, Pe);
  }
  function Qt(C, U, J) {
    U.isScene !== !0 && (U = ae);
    const B = ee.get(C), $ = d.state.lights, Pe = d.state.shadowsArray, ke = $.state.version, Be = Ce.getParameters(C, $.state, Pe, U, J), Ve = Ce.getProgramCacheKey(Be);
    let et = B.programs;
    B.environment = C.isMeshStandardMaterial ? U.environment : null, B.fog = U.fog, B.envMap = (C.isMeshStandardMaterial ? be : ce).get(C.envMap || B.environment), et === void 0 && (C.addEventListener("dispose", qe), et = /* @__PURE__ */ new Map(), B.programs = et);
    let je = et.get(Ve);
    if (je !== void 0) {
      if (B.currentProgram === je && B.lightsStateVersion === ke)
        return Cc(C, Be), je;
    } else
      Be.uniforms = Ce.getUniforms(C), C.onBuild(J, Be, _), C.onBeforeCompile(Be, _), je = Ce.acquireProgram(Be, Ve), et.set(Ve, je), B.uniforms = Be.uniforms;
    const Ye = B.uniforms;
    (!C.isShaderMaterial && !C.isRawShaderMaterial || C.clipping === !0) && (Ye.clippingPlanes = T.uniform), Cc(C, Be), B.needsLights = zf(C), B.lightsStateVersion = ke, B.needsLights && (Ye.ambientLightColor.value = $.state.ambient, Ye.lightProbe.value = $.state.probe, Ye.directionalLights.value = $.state.directional, Ye.directionalLightShadows.value = $.state.directionalShadow, Ye.spotLights.value = $.state.spot, Ye.spotLightShadows.value = $.state.spotShadow, Ye.rectAreaLights.value = $.state.rectArea, Ye.ltc_1.value = $.state.rectAreaLTC1, Ye.ltc_2.value = $.state.rectAreaLTC2, Ye.pointLights.value = $.state.point, Ye.pointLightShadows.value = $.state.pointShadow, Ye.hemisphereLights.value = $.state.hemi, Ye.directionalShadowMap.value = $.state.directionalShadowMap, Ye.directionalShadowMatrix.value = $.state.directionalShadowMatrix, Ye.spotShadowMap.value = $.state.spotShadowMap, Ye.spotLightMatrix.value = $.state.spotLightMatrix, Ye.spotLightMap.value = $.state.spotLightMap, Ye.pointShadowMap.value = $.state.pointShadowMap, Ye.pointShadowMatrix.value = $.state.pointShadowMatrix);
    const ft = je.getUniforms(), jt = Ia.seqWithValue(ft.seq, Ye);
    return B.currentProgram = je, B.uniformsList = jt, je;
  }
  function Cc(C, U) {
    const J = ee.get(C);
    J.outputEncoding = U.outputEncoding, J.instancing = U.instancing, J.skinning = U.skinning, J.morphTargets = U.morphTargets, J.morphNormals = U.morphNormals, J.morphColors = U.morphColors, J.morphTargetsCount = U.morphTargetsCount, J.numClippingPlanes = U.numClippingPlanes, J.numIntersection = U.numClipIntersection, J.vertexAlphas = U.vertexAlphas, J.vertexTangents = U.vertexTangents, J.toneMapping = U.toneMapping;
  }
  function Nf(C, U, J, B, $) {
    U.isScene !== !0 && (U = ae), Q.resetTextureUnits();
    const Pe = U.fog, ke = B.isMeshStandardMaterial ? U.environment : null, Be = y === null ? _.outputEncoding : y.isXRRenderTarget === !0 ? y.texture.encoding : Fn, Ve = (B.isMeshStandardMaterial ? be : ce).get(B.envMap || ke), et = B.vertexColors === !0 && !!J.attributes.color && J.attributes.color.itemSize === 4, je = !!B.normalMap && !!J.attributes.tangent, Ye = !!J.morphAttributes.position, ft = !!J.morphAttributes.normal, jt = !!J.morphAttributes.color, Ri = B.toneMapped ? _.toneMapping : Wi, xn = J.morphAttributes.position || J.morphAttributes.normal || J.morphAttributes.color, pt = xn !== void 0 ? xn.length : 0, Ze = ee.get(B), so = d.state.lights;
    if (K === !0 && (ne === !0 || C !== M)) {
      const Yt = C === M && B.id === v;
      T.setState(B, C, Yt);
    }
    let St = !1;
    B.version === Ze.__version ? (Ze.needsLights && Ze.lightsStateVersion !== so.state.version || Ze.outputEncoding !== Be || $.isInstancedMesh && Ze.instancing === !1 || !$.isInstancedMesh && Ze.instancing === !0 || $.isSkinnedMesh && Ze.skinning === !1 || !$.isSkinnedMesh && Ze.skinning === !0 || Ze.envMap !== Ve || B.fog === !0 && Ze.fog !== Pe || Ze.numClippingPlanes !== void 0 && (Ze.numClippingPlanes !== T.numPlanes || Ze.numIntersection !== T.numIntersection) || Ze.vertexAlphas !== et || Ze.vertexTangents !== je || Ze.morphTargets !== Ye || Ze.morphNormals !== ft || Ze.morphColors !== jt || Ze.toneMapping !== Ri || Re.isWebGL2 === !0 && Ze.morphTargetsCount !== pt) && (St = !0) : (St = !0, Ze.__version = B.version);
    let wn = Ze.currentProgram;
    St === !0 && (wn = Qt(B, U, $));
    let Lc = !1, Gs = !1, ro = !1;
    const Nt = wn.getUniforms(), bn = Ze.uniforms;
    if (me.useProgram(wn.program) && (Lc = !0, Gs = !0, ro = !0), B.id !== v && (v = B.id, Gs = !0), Lc || M !== C) {
      if (Nt.setValue(j, "projectionMatrix", C.projectionMatrix), Re.logarithmicDepthBuffer && Nt.setValue(
        j,
        "logDepthBufFC",
        2 / (Math.log(C.far + 1) / Math.LN2)
      ), M !== C && (M = C, Gs = !0, ro = !0), B.isShaderMaterial || B.isMeshPhongMaterial || B.isMeshToonMaterial || B.isMeshStandardMaterial || B.envMap) {
        const Yt = Nt.map.cameraPosition;
        Yt !== void 0 && Yt.setValue(
          j,
          le.setFromMatrixPosition(C.matrixWorld)
        );
      }
      (B.isMeshPhongMaterial || B.isMeshToonMaterial || B.isMeshLambertMaterial || B.isMeshBasicMaterial || B.isMeshStandardMaterial || B.isShaderMaterial) && Nt.setValue(j, "isOrthographic", C.isOrthographicCamera === !0), (B.isMeshPhongMaterial || B.isMeshToonMaterial || B.isMeshLambertMaterial || B.isMeshBasicMaterial || B.isMeshStandardMaterial || B.isShaderMaterial || B.isShadowMaterial || $.isSkinnedMesh) && Nt.setValue(j, "viewMatrix", C.matrixWorldInverse);
    }
    if ($.isSkinnedMesh) {
      Nt.setOptional(j, $, "bindMatrix"), Nt.setOptional(j, $, "bindMatrixInverse");
      const Yt = $.skeleton;
      Yt && (Re.floatVertexTextures ? (Yt.boneTexture === null && Yt.computeBoneTexture(), Nt.setValue(j, "boneTexture", Yt.boneTexture, Q), Nt.setValue(j, "boneTextureSize", Yt.boneTextureSize)) : console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."));
    }
    const ao = J.morphAttributes;
    if ((ao.position !== void 0 || ao.normal !== void 0 || ao.color !== void 0 && Re.isWebGL2 === !0) && oe.update($, J, B, wn), (Gs || Ze.receiveShadow !== $.receiveShadow) && (Ze.receiveShadow = $.receiveShadow, Nt.setValue(j, "receiveShadow", $.receiveShadow)), B.isMeshGouraudMaterial && B.envMap !== null && (bn.envMap.value = Ve, bn.flipEnvMap.value = Ve.isCubeTexture && Ve.isRenderTargetTexture === !1 ? -1 : 1), Gs && (Nt.setValue(j, "toneMappingExposure", _.toneMappingExposure), Ze.needsLights && kf(bn, ro), Pe && B.fog === !0 && rt.refreshFogUniforms(bn, Pe), rt.refreshMaterialUniforms(bn, B, z, P, te), Ia.upload(j, Ze.uniformsList, bn, Q)), B.isShaderMaterial && B.uniformsNeedUpdate === !0 && (Ia.upload(j, Ze.uniformsList, bn, Q), B.uniformsNeedUpdate = !1), B.isSpriteMaterial && Nt.setValue(j, "center", $.center), Nt.setValue(j, "modelViewMatrix", $.modelViewMatrix), Nt.setValue(j, "normalMatrix", $.normalMatrix), Nt.setValue(j, "modelMatrix", $.matrixWorld), B.isShaderMaterial || B.isRawShaderMaterial) {
      const Yt = B.uniformsGroups;
      for (let oo = 0, Ff = Yt.length; oo < Ff; oo++)
        if (Re.isWebGL2) {
          const Pc = Yt[oo];
          ge.update(Pc, wn), ge.bind(Pc, wn);
        } else
          console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.");
    }
    return wn;
  }
  function kf(C, U) {
    C.ambientLightColor.needsUpdate = U, C.lightProbe.needsUpdate = U, C.directionalLights.needsUpdate = U, C.directionalLightShadows.needsUpdate = U, C.pointLights.needsUpdate = U, C.pointLightShadows.needsUpdate = U, C.spotLights.needsUpdate = U, C.spotLightShadows.needsUpdate = U, C.rectAreaLights.needsUpdate = U, C.hemisphereLights.needsUpdate = U;
  }
  function zf(C) {
    return C.isMeshLambertMaterial || C.isMeshToonMaterial || C.isMeshPhongMaterial || C.isMeshStandardMaterial || C.isShadowMaterial || C.isShaderMaterial && C.lights === !0;
  }
  this.getActiveCubeFace = function() {
    return g;
  }, this.getActiveMipmapLevel = function() {
    return x;
  }, this.getRenderTarget = function() {
    return y;
  }, this.setRenderTargetTextures = function(C, U, J) {
    ee.get(C.texture).__webglTexture = U, ee.get(C.depthTexture).__webglTexture = J;
    const B = ee.get(C);
    B.__hasExternalTextures = !0, B.__hasExternalTextures && (B.__autoAllocateDepthBuffer = J === void 0, B.__autoAllocateDepthBuffer || ye.has("WEBGL_multisampled_render_to_texture") === !0 && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), B.__useRenderToTexture = !1));
  }, this.setRenderTargetFramebuffer = function(C, U) {
    const J = ee.get(C);
    J.__webglFramebuffer = U, J.__useDefaultFramebuffer = U === void 0;
  }, this.setRenderTarget = function(C, U = 0, J = 0) {
    y = C, g = U, x = J;
    let B = !0, $ = null, Pe = !1, ke = !1;
    if (C) {
      const Ve = ee.get(C);
      Ve.__useDefaultFramebuffer !== void 0 ? (me.bindFramebuffer(36160, null), B = !1) : Ve.__webglFramebuffer === void 0 ? Q.setupRenderTarget(C) : Ve.__hasExternalTextures && Q.rebindTextures(C, ee.get(C.texture).__webglTexture, ee.get(C.depthTexture).__webglTexture);
      const et = C.texture;
      (et.isData3DTexture || et.isDataArrayTexture || et.isCompressedArrayTexture) && (ke = !0);
      const je = ee.get(C).__webglFramebuffer;
      C.isWebGLCubeRenderTarget ? ($ = je[U], Pe = !0) : Re.isWebGL2 && C.samples > 0 && Q.useMultisampledRTT(C) === !1 ? $ = ee.get(C).__webglMultisampledFramebuffer : $ = je, S.copy(C.viewport), A.copy(C.scissor), w = C.scissorTest;
    } else
      S.copy(D).multiplyScalar(z).floor(), A.copy(H).multiplyScalar(z).floor(), w = Z;
    if (me.bindFramebuffer(36160, $) && Re.drawBuffers && B && me.drawBuffers(C, $), me.viewport(S), me.scissor(A), me.setScissorTest(w), Pe) {
      const Ve = ee.get(C.texture);
      j.framebufferTexture2D(36160, 36064, 34069 + U, Ve.__webglTexture, J);
    } else if (ke) {
      const Ve = ee.get(C.texture), et = U || 0;
      j.framebufferTextureLayer(36160, 36064, Ve.__webglTexture, J || 0, et);
    }
    v = -1;
  }, this.readRenderTargetPixels = function(C, U, J, B, $, Pe, ke) {
    if (!(C && C.isWebGLRenderTarget)) {
      console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
      return;
    }
    let Be = ee.get(C).__webglFramebuffer;
    if (C.isWebGLCubeRenderTarget && ke !== void 0 && (Be = Be[ke]), Be) {
      me.bindFramebuffer(36160, Be);
      try {
        const Ve = C.texture, et = Ve.format, je = Ve.type;
        if (et !== ri && R.convert(et) !== j.getParameter(35739)) {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
          return;
        }
        const Ye = je === gr && (ye.has("EXT_color_buffer_half_float") || Re.isWebGL2 && ye.has("EXT_color_buffer_float"));
        if (je !== zn && R.convert(je) !== j.getParameter(35738) && // Edge and Chrome Mac < 52 (#9513)
        !(je === cn && (Re.isWebGL2 || ye.has("OES_texture_float") || ye.has("WEBGL_color_buffer_float"))) && // Chrome Mac >= 52 and Firefox
        !Ye) {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
          return;
        }
        U >= 0 && U <= C.width - B && J >= 0 && J <= C.height - $ && j.readPixels(U, J, B, $, R.convert(et), R.convert(je), Pe);
      } finally {
        const Ve = y !== null ? ee.get(y).__webglFramebuffer : null;
        me.bindFramebuffer(36160, Ve);
      }
    }
  }, this.copyFramebufferToTexture = function(C, U, J = 0) {
    const B = Math.pow(2, -J), $ = Math.floor(U.image.width * B), Pe = Math.floor(U.image.height * B);
    Q.setTexture2D(U, 0), j.copyTexSubImage2D(3553, J, 0, 0, C.x, C.y, $, Pe), me.unbindTexture();
  }, this.copyTextureToTexture = function(C, U, J, B = 0) {
    const $ = U.image.width, Pe = U.image.height, ke = R.convert(J.format), Be = R.convert(J.type);
    Q.setTexture2D(J, 0), j.pixelStorei(37440, J.flipY), j.pixelStorei(37441, J.premultiplyAlpha), j.pixelStorei(3317, J.unpackAlignment), U.isDataTexture ? j.texSubImage2D(3553, B, C.x, C.y, $, Pe, ke, Be, U.image.data) : U.isCompressedTexture ? j.compressedTexSubImage2D(3553, B, C.x, C.y, U.mipmaps[0].width, U.mipmaps[0].height, ke, U.mipmaps[0].data) : j.texSubImage2D(3553, B, C.x, C.y, ke, Be, U.image), B === 0 && J.generateMipmaps && j.generateMipmap(3553), me.unbindTexture();
  }, this.copyTextureToTexture3D = function(C, U, J, B, $ = 0) {
    if (_.isWebGL1Renderer) {
      console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
      return;
    }
    const Pe = C.max.x - C.min.x + 1, ke = C.max.y - C.min.y + 1, Be = C.max.z - C.min.z + 1, Ve = R.convert(B.format), et = R.convert(B.type);
    let je;
    if (B.isData3DTexture)
      Q.setTexture3D(B, 0), je = 32879;
    else if (B.isDataArrayTexture)
      Q.setTexture2DArray(B, 0), je = 35866;
    else {
      console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
      return;
    }
    j.pixelStorei(37440, B.flipY), j.pixelStorei(37441, B.premultiplyAlpha), j.pixelStorei(3317, B.unpackAlignment);
    const Ye = j.getParameter(3314), ft = j.getParameter(32878), jt = j.getParameter(3316), Ri = j.getParameter(3315), xn = j.getParameter(32877), pt = J.isCompressedTexture ? J.mipmaps[0] : J.image;
    j.pixelStorei(3314, pt.width), j.pixelStorei(32878, pt.height), j.pixelStorei(3316, C.min.x), j.pixelStorei(3315, C.min.y), j.pixelStorei(32877, C.min.z), J.isDataTexture || J.isData3DTexture ? j.texSubImage3D(je, $, U.x, U.y, U.z, Pe, ke, Be, Ve, et, pt.data) : J.isCompressedArrayTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), j.compressedTexSubImage3D(je, $, U.x, U.y, U.z, Pe, ke, Be, Ve, pt.data)) : j.texSubImage3D(je, $, U.x, U.y, U.z, Pe, ke, Be, Ve, et, pt), j.pixelStorei(3314, Ye), j.pixelStorei(32878, ft), j.pixelStorei(3316, jt), j.pixelStorei(3315, Ri), j.pixelStorei(32877, xn), $ === 0 && B.generateMipmaps && j.generateMipmap(je), me.unbindTexture();
  }, this.initTexture = function(C) {
    C.isCubeTexture ? Q.setTextureCube(C, 0) : C.isData3DTexture ? Q.setTexture3D(C, 0) : C.isDataArrayTexture || C.isCompressedArrayTexture ? Q.setTexture2DArray(C, 0) : Q.setTexture2D(C, 0), me.unbindTexture();
  }, this.resetState = function() {
    g = 0, x = 0, y = null, me.reset(), F.reset();
  }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
}
class Zv extends Da {
}
Zv.prototype.isWebGL1Renderer = !0;
class Hl {
  constructor(e, t = 25e-5) {
    this.isFogExp2 = !0, this.name = "", this.color = new de(e), this.density = t;
  }
  clone() {
    return new Hl(this.color, this.density);
  }
  toJSON() {
    return {
      type: "FogExp2",
      color: this.color.getHex(),
      density: this.density
    };
  }
}
class Wl {
  constructor(e, t = 1, i = 1e3) {
    this.isFog = !0, this.name = "", this.color = new de(e), this.near = t, this.far = i;
  }
  clone() {
    return new Wl(this.color, this.near, this.far);
  }
  toJSON() {
    return {
      type: "Fog",
      color: this.color.getHex(),
      near: this.near,
      far: this.far
    };
  }
}
class or extends tt {
  constructor() {
    super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  copy(e, t) {
    return super.copy(e, t), e.background !== null && (this.background = e.background.clone()), e.environment !== null && (this.environment = e.environment.clone()), e.fog !== null && (this.fog = e.fog.clone()), this.backgroundBlurriness = e.backgroundBlurriness, this.backgroundIntensity = e.backgroundIntensity, e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()), this.matrixAutoUpdate = e.matrixAutoUpdate, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return this.fog !== null && (t.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (t.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (t.backgroundIntensity = this.backgroundIntensity), t;
  }
  // @deprecated
  get autoUpdate() {
    return console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."), this.matrixWorldAutoUpdate;
  }
  set autoUpdate(e) {
    console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."), this.matrixWorldAutoUpdate = e;
  }
}
class $a {
  constructor(e, t) {
    this.isInterleavedBuffer = !0, this.array = e, this.stride = t, this.count = e !== void 0 ? e.length / t : 0, this.usage = ml, this.updateRange = { offset: 0, count: -1 }, this.version = 0, this.uuid = li();
  }
  onUploadCallback() {
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  copy(e) {
    return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this;
  }
  copyAt(e, t, i) {
    e *= this.stride, i *= t.stride;
    for (let n = 0, s = this.stride; n < s; n++)
      this.array[e + n] = t.array[i + n];
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  clone(e) {
    e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = li()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
    const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]), i = new this.constructor(t, this.stride);
    return i.setUsage(this.usage), i;
  }
  onUpload(e) {
    return this.onUploadCallback = e, this;
  }
  toJSON(e) {
    return e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = li()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), {
      uuid: this.uuid,
      buffer: this.array.buffer._uuid,
      type: this.array.constructor.name,
      stride: this.stride
    };
  }
}
const zt = /* @__PURE__ */ new b();
class $t {
  constructor(e, t, i, n = !1) {
    this.isInterleavedBufferAttribute = !0, this.name = "", this.data = e, this.itemSize = t, this.offset = i, this.normalized = n;
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(e) {
    this.data.needsUpdate = e;
  }
  applyMatrix4(e) {
    for (let t = 0, i = this.data.count; t < i; t++)
      zt.fromBufferAttribute(this, t), zt.applyMatrix4(e), this.setXYZ(t, zt.x, zt.y, zt.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, i = this.count; t < i; t++)
      zt.fromBufferAttribute(this, t), zt.applyNormalMatrix(e), this.setXYZ(t, zt.x, zt.y, zt.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, i = this.count; t < i; t++)
      zt.fromBufferAttribute(this, t), zt.transformDirection(e), this.setXYZ(t, zt.x, zt.y, zt.z);
    return this;
  }
  setX(e, t) {
    return this.normalized && (t = ot(t, this.array)), this.data.array[e * this.data.stride + this.offset] = t, this;
  }
  setY(e, t) {
    return this.normalized && (t = ot(t, this.array)), this.data.array[e * this.data.stride + this.offset + 1] = t, this;
  }
  setZ(e, t) {
    return this.normalized && (t = ot(t, this.array)), this.data.array[e * this.data.stride + this.offset + 2] = t, this;
  }
  setW(e, t) {
    return this.normalized && (t = ot(t, this.array)), this.data.array[e * this.data.stride + this.offset + 3] = t, this;
  }
  getX(e) {
    let t = this.data.array[e * this.data.stride + this.offset];
    return this.normalized && (t = Hi(t, this.array)), t;
  }
  getY(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 1];
    return this.normalized && (t = Hi(t, this.array)), t;
  }
  getZ(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 2];
    return this.normalized && (t = Hi(t, this.array)), t;
  }
  getW(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 3];
    return this.normalized && (t = Hi(t, this.array)), t;
  }
  setXY(e, t, i) {
    return e = e * this.data.stride + this.offset, this.normalized && (t = ot(t, this.array), i = ot(i, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = i, this;
  }
  setXYZ(e, t, i, n) {
    return e = e * this.data.stride + this.offset, this.normalized && (t = ot(t, this.array), i = ot(i, this.array), n = ot(n, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = i, this.data.array[e + 2] = n, this;
  }
  setXYZW(e, t, i, n, s) {
    return e = e * this.data.stride + this.offset, this.normalized && (t = ot(t, this.array), i = ot(i, this.array), n = ot(n, this.array), s = ot(s, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = i, this.data.array[e + 2] = n, this.data.array[e + 3] = s, this;
  }
  clone(e) {
    if (e === void 0) {
      console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
      const t = [];
      for (let i = 0; i < this.count; i++) {
        const n = i * this.data.stride + this.offset;
        for (let s = 0; s < this.itemSize; s++)
          t.push(this.data.array[n + s]);
      }
      return new $e(new this.array.constructor(t), this.itemSize, this.normalized);
    } else
      return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new $t(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
  }
  toJSON(e) {
    if (e === void 0) {
      console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
      const t = [];
      for (let i = 0; i < this.count; i++) {
        const n = i * this.data.stride + this.offset;
        for (let s = 0; s < this.itemSize; s++)
          t.push(this.data.array[n + s]);
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: t,
        normalized: this.normalized
      };
    } else
      return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), {
        isInterleavedBufferAttribute: !0,
        itemSize: this.itemSize,
        data: this.data.uuid,
        offset: this.offset,
        normalized: this.normalized
      };
  }
}
class Xl extends Ct {
  constructor(e) {
    super(), this.isSpriteMaterial = !0, this.type = "SpriteMaterial", this.color = new de(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this;
  }
}
let ns;
const Js = /* @__PURE__ */ new b(), ss = /* @__PURE__ */ new b(), rs = /* @__PURE__ */ new b(), as = /* @__PURE__ */ new G(), Ks = /* @__PURE__ */ new G(), Td = /* @__PURE__ */ new ue(), ia = /* @__PURE__ */ new b(), $s = /* @__PURE__ */ new b(), na = /* @__PURE__ */ new b(), zh = /* @__PURE__ */ new G(), Bo = /* @__PURE__ */ new G(), Fh = /* @__PURE__ */ new G();
class Ad extends tt {
  constructor(e) {
    if (super(), this.isSprite = !0, this.type = "Sprite", ns === void 0) {
      ns = new Ue();
      const t = new Float32Array([
        -0.5,
        -0.5,
        0,
        0,
        0,
        0.5,
        -0.5,
        0,
        1,
        0,
        0.5,
        0.5,
        0,
        1,
        1,
        -0.5,
        0.5,
        0,
        0,
        1
      ]), i = new $a(t, 5);
      ns.setIndex([0, 1, 2, 0, 2, 3]), ns.setAttribute("position", new $t(i, 3, 0, !1)), ns.setAttribute("uv", new $t(i, 2, 3, !1));
    }
    this.geometry = ns, this.material = e !== void 0 ? e : new Xl(), this.center = new G(0.5, 0.5);
  }
  raycast(e, t) {
    e.camera === null && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), ss.setFromMatrixScale(this.matrixWorld), Td.copy(e.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld), rs.setFromMatrixPosition(this.modelViewMatrix), e.camera.isPerspectiveCamera && this.material.sizeAttenuation === !1 && ss.multiplyScalar(-rs.z);
    const i = this.material.rotation;
    let n, s;
    i !== 0 && (s = Math.cos(i), n = Math.sin(i));
    const r = this.center;
    sa(ia.set(-0.5, -0.5, 0), rs, r, ss, n, s), sa($s.set(0.5, -0.5, 0), rs, r, ss, n, s), sa(na.set(0.5, 0.5, 0), rs, r, ss, n, s), zh.set(0, 0), Bo.set(1, 0), Fh.set(1, 1);
    let a = e.ray.intersectTriangle(ia, $s, na, !1, Js);
    if (a === null && (sa($s.set(-0.5, 0.5, 0), rs, r, ss, n, s), Bo.set(0, 1), a = e.ray.intersectTriangle(ia, na, $s, !1, Js), a === null))
      return;
    const l = e.ray.origin.distanceTo(Js);
    l < e.near || l > e.far || t.push({
      distance: l,
      point: Js.clone(),
      uv: _i.getUV(Js, ia, $s, na, zh, Bo, Fh, new G()),
      face: null,
      object: this
    });
  }
  copy(e, t) {
    return super.copy(e, t), e.center !== void 0 && this.center.copy(e.center), this.material = e.material, this;
  }
}
function sa(o, e, t, i, n, s) {
  as.subVectors(o, t).addScalar(0.5).multiply(i), n !== void 0 ? (Ks.x = s * as.x - n * as.y, Ks.y = n * as.x + s * as.y) : Ks.copy(as), o.copy(e), o.x += Ks.x, o.y += Ks.y, o.applyMatrix4(Td);
}
const ra = /* @__PURE__ */ new b(), Bh = /* @__PURE__ */ new b();
class Jv extends tt {
  constructor() {
    super(), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, {
      levels: {
        enumerable: !0,
        value: []
      },
      isLOD: {
        value: !0
      }
    }), this.autoUpdate = !0;
  }
  copy(e) {
    super.copy(e, !1);
    const t = e.levels;
    for (let i = 0, n = t.length; i < n; i++) {
      const s = t[i];
      this.addLevel(s.object.clone(), s.distance, s.hysteresis);
    }
    return this.autoUpdate = e.autoUpdate, this;
  }
  addLevel(e, t = 0, i = 0) {
    t = Math.abs(t);
    const n = this.levels;
    let s;
    for (s = 0; s < n.length && !(t < n[s].distance); s++)
      ;
    return n.splice(s, 0, { distance: t, hysteresis: i, object: e }), this.add(e), this;
  }
  getCurrentLevel() {
    return this._currentLevel;
  }
  getObjectForDistance(e) {
    const t = this.levels;
    if (t.length > 0) {
      let i, n;
      for (i = 1, n = t.length; i < n; i++) {
        let s = t[i].distance;
        if (t[i].object.visible && (s -= s * t[i].hysteresis), e < s)
          break;
      }
      return t[i - 1].object;
    }
    return null;
  }
  raycast(e, t) {
    if (this.levels.length > 0) {
      ra.setFromMatrixPosition(this.matrixWorld);
      const n = e.ray.origin.distanceTo(ra);
      this.getObjectForDistance(n).raycast(e, t);
    }
  }
  update(e) {
    const t = this.levels;
    if (t.length > 1) {
      ra.setFromMatrixPosition(e.matrixWorld), Bh.setFromMatrixPosition(this.matrixWorld);
      const i = ra.distanceTo(Bh) / e.zoom;
      t[0].object.visible = !0;
      let n, s;
      for (n = 1, s = t.length; n < s; n++) {
        let r = t[n].distance;
        if (t[n].object.visible && (r -= r * t[n].hysteresis), i >= r)
          t[n - 1].object.visible = !1, t[n].object.visible = !0;
        else
          break;
      }
      for (this._currentLevel = n - 1; n < s; n++)
        t[n].object.visible = !1;
    }
  }
  toJSON(e) {
    const t = super.toJSON(e);
    this.autoUpdate === !1 && (t.object.autoUpdate = !1), t.object.levels = [];
    const i = this.levels;
    for (let n = 0, s = i.length; n < s; n++) {
      const r = i[n];
      t.object.levels.push({
        object: r.object.uuid,
        distance: r.distance,
        hysteresis: r.hysteresis
      });
    }
    return t;
  }
}
const Uh = /* @__PURE__ */ new b(), Vh = /* @__PURE__ */ new We(), Gh = /* @__PURE__ */ new We(), Kv = /* @__PURE__ */ new b(), Hh = /* @__PURE__ */ new ue();
class ql extends st {
  constructor(e, t) {
    super(e, t), this.isSkinnedMesh = !0, this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new ue(), this.bindMatrixInverse = new ue();
  }
  copy(e, t) {
    return super.copy(e, t), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, this;
  }
  bind(e, t) {
    this.skeleton = e, t === void 0 && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.copy(t).invert();
  }
  pose() {
    this.skeleton.pose();
  }
  normalizeSkinWeights() {
    const e = new We(), t = this.geometry.attributes.skinWeight;
    for (let i = 0, n = t.count; i < n; i++) {
      e.fromBufferAttribute(t, i);
      const s = 1 / e.manhattanLength();
      s !== 1 / 0 ? e.multiplyScalar(s) : e.set(1, 0, 0, 0), t.setXYZW(i, e.x, e.y, e.z, e.w);
    }
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.bindMode === "attached" ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === "detached" ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
  }
  boneTransform(e, t) {
    const i = this.skeleton, n = this.geometry;
    Vh.fromBufferAttribute(n.attributes.skinIndex, e), Gh.fromBufferAttribute(n.attributes.skinWeight, e), Uh.copy(t).applyMatrix4(this.bindMatrix), t.set(0, 0, 0);
    for (let s = 0; s < 4; s++) {
      const r = Gh.getComponent(s);
      if (r !== 0) {
        const a = Vh.getComponent(s);
        Hh.multiplyMatrices(i.bones[a].matrixWorld, i.boneInverses[a]), t.addScaledVector(Kv.copy(Uh).applyMatrix4(Hh), r);
      }
    }
    return t.applyMatrix4(this.bindMatrixInverse);
  }
}
class br extends tt {
  constructor() {
    super(), this.isBone = !0, this.type = "Bone";
  }
}
class Oa extends dt {
  constructor(e = null, t = 1, i = 1, n, s, r, a, l, c = yt, h = yt, u, d) {
    super(null, r, a, l, c, h, n, s, u, d), this.isDataTexture = !0, this.image = { data: e, width: t, height: i }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
const Wh = /* @__PURE__ */ new ue(), $v = /* @__PURE__ */ new ue();
class Rr {
  constructor(e = [], t = []) {
    this.uuid = li(), this.bones = e.slice(0), this.boneInverses = t, this.boneMatrices = null, this.boneTexture = null, this.boneTextureSize = 0, this.frame = -1, this.init();
  }
  init() {
    const e = this.bones, t = this.boneInverses;
    if (this.boneMatrices = new Float32Array(e.length * 16), t.length === 0)
      this.calculateInverses();
    else if (e.length !== t.length) {
      console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
      for (let i = 0, n = this.bones.length; i < n; i++)
        this.boneInverses.push(new ue());
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const i = new ue();
      this.bones[e] && i.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(i);
    }
  }
  pose() {
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const i = this.bones[e];
      i && i.matrixWorld.copy(this.boneInverses[e]).invert();
    }
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const i = this.bones[e];
      i && (i.parent && i.parent.isBone ? (i.matrix.copy(i.parent.matrixWorld).invert(), i.matrix.multiply(i.matrixWorld)) : i.matrix.copy(i.matrixWorld), i.matrix.decompose(i.position, i.quaternion, i.scale));
    }
  }
  update() {
    const e = this.bones, t = this.boneInverses, i = this.boneMatrices, n = this.boneTexture;
    for (let s = 0, r = e.length; s < r; s++) {
      const a = e[s] ? e[s].matrixWorld : $v;
      Wh.multiplyMatrices(a, t[s]), Wh.toArray(i, s * 16);
    }
    n !== null && (n.needsUpdate = !0);
  }
  clone() {
    return new Rr(this.bones, this.boneInverses);
  }
  computeBoneTexture() {
    let e = Math.sqrt(this.bones.length * 4);
    e = ud(e), e = Math.max(e, 4);
    const t = new Float32Array(e * e * 4);
    t.set(this.boneMatrices);
    const i = new Oa(t, e, e, ri, cn);
    return i.needsUpdate = !0, this.boneMatrices = t, this.boneTexture = i, this.boneTextureSize = e, this;
  }
  getBoneByName(e) {
    for (let t = 0, i = this.bones.length; t < i; t++) {
      const n = this.bones[t];
      if (n.name === e)
        return n;
    }
  }
  dispose() {
    this.boneTexture !== null && (this.boneTexture.dispose(), this.boneTexture = null);
  }
  fromJSON(e, t) {
    this.uuid = e.uuid;
    for (let i = 0, n = e.bones.length; i < n; i++) {
      const s = e.bones[i];
      let r = t[s];
      r === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", s), r = new br()), this.bones.push(r), this.boneInverses.push(new ue().fromArray(e.boneInverses[i]));
    }
    return this.init(), this;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.5,
        type: "Skeleton",
        generator: "Skeleton.toJSON"
      },
      bones: [],
      boneInverses: []
    };
    e.uuid = this.uuid;
    const t = this.bones, i = this.boneInverses;
    for (let n = 0, s = t.length; n < s; n++) {
      const r = t[n];
      e.bones.push(r.uuid);
      const a = i[n];
      e.boneInverses.push(a.toArray());
    }
    return e;
  }
}
class Mr extends $e {
  constructor(e, t, i, n = 1) {
    super(e, t, i), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = n;
  }
  copy(e) {
    return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e;
  }
}
const Xh = /* @__PURE__ */ new ue(), qh = /* @__PURE__ */ new ue(), aa = [], Qv = /* @__PURE__ */ new ue(), Qs = /* @__PURE__ */ new st();
class jl extends st {
  constructor(e, t, i) {
    super(e, t), this.isInstancedMesh = !0, this.instanceMatrix = new Mr(new Float32Array(i * 16), 16), this.instanceColor = null, this.count = i, this.frustumCulled = !1;
    for (let n = 0; n < i; n++)
      this.setMatrixAt(n, Qv);
  }
  copy(e, t) {
    return super.copy(e, t), this.instanceMatrix.copy(e.instanceMatrix), e.instanceColor !== null && (this.instanceColor = e.instanceColor.clone()), this.count = e.count, this;
  }
  getColorAt(e, t) {
    t.fromArray(this.instanceColor.array, e * 3);
  }
  getMatrixAt(e, t) {
    t.fromArray(this.instanceMatrix.array, e * 16);
  }
  raycast(e, t) {
    const i = this.matrixWorld, n = this.count;
    if (Qs.geometry = this.geometry, Qs.material = this.material, Qs.material !== void 0)
      for (let s = 0; s < n; s++) {
        this.getMatrixAt(s, Xh), qh.multiplyMatrices(i, Xh), Qs.matrixWorld = qh, Qs.raycast(e, aa);
        for (let r = 0, a = aa.length; r < a; r++) {
          const l = aa[r];
          l.instanceId = s, l.object = this, t.push(l);
        }
        aa.length = 0;
      }
  }
  setColorAt(e, t) {
    this.instanceColor === null && (this.instanceColor = new Mr(new Float32Array(this.instanceMatrix.count * 3), 3)), t.toArray(this.instanceColor.array, e * 3);
  }
  setMatrixAt(e, t) {
    t.toArray(this.instanceMatrix.array, e * 16);
  }
  updateMorphTargets() {
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class mn extends Ct {
  constructor(e) {
    super(), this.isLineBasicMaterial = !0, this.type = "LineBasicMaterial", this.color = new de(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.fog = e.fog, this;
  }
}
const jh = /* @__PURE__ */ new b(), Yh = /* @__PURE__ */ new b(), Zh = /* @__PURE__ */ new ue(), Uo = /* @__PURE__ */ new ks(), oa = /* @__PURE__ */ new Ci();
class Bn extends tt {
  constructor(e = new Ue(), t = new mn()) {
    super(), this.isLine = !0, this.type = "Line", this.geometry = e, this.material = t, this.updateMorphTargets();
  }
  copy(e, t) {
    return super.copy(e, t), this.material = e.material, this.geometry = e.geometry, this;
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position, i = [0];
      for (let n = 1, s = t.count; n < s; n++)
        jh.fromBufferAttribute(t, n - 1), Yh.fromBufferAttribute(t, n), i[n] = i[n - 1], i[n] += jh.distanceTo(Yh);
      e.setAttribute("lineDistance", new Ee(i, 1));
    } else
      console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    return this;
  }
  raycast(e, t) {
    const i = this.geometry, n = this.matrixWorld, s = e.params.Line.threshold, r = i.drawRange;
    if (i.boundingSphere === null && i.computeBoundingSphere(), oa.copy(i.boundingSphere), oa.applyMatrix4(n), oa.radius += s, e.ray.intersectsSphere(oa) === !1) return;
    Zh.copy(n).invert(), Uo.copy(e.ray).applyMatrix4(Zh);
    const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3), l = a * a, c = new b(), h = new b(), u = new b(), d = new b(), f = this.isLineSegments ? 2 : 1, m = i.index, p = i.attributes.position;
    if (m !== null) {
      const g = Math.max(0, r.start), x = Math.min(m.count, r.start + r.count);
      for (let y = g, v = x - 1; y < v; y += f) {
        const M = m.getX(y), S = m.getX(y + 1);
        if (c.fromBufferAttribute(p, M), h.fromBufferAttribute(p, S), Uo.distanceSqToSegment(c, h, d, u) > l) continue;
        d.applyMatrix4(this.matrixWorld);
        const w = e.ray.origin.distanceTo(d);
        w < e.near || w > e.far || t.push({
          distance: w,
          // What do we want? intersection point on the ray or on the segment??
          // point: raycaster.ray.at( distance ),
          point: u.clone().applyMatrix4(this.matrixWorld),
          index: y,
          face: null,
          faceIndex: null,
          object: this
        });
      }
    } else {
      const g = Math.max(0, r.start), x = Math.min(p.count, r.start + r.count);
      for (let y = g, v = x - 1; y < v; y += f) {
        if (c.fromBufferAttribute(p, y), h.fromBufferAttribute(p, y + 1), Uo.distanceSqToSegment(c, h, d, u) > l) continue;
        d.applyMatrix4(this.matrixWorld);
        const S = e.ray.origin.distanceTo(d);
        S < e.near || S > e.far || t.push({
          distance: S,
          // What do we want? intersection point on the ray or on the segment??
          // point: raycaster.ray.at( distance ),
          point: u.clone().applyMatrix4(this.matrixWorld),
          index: y,
          face: null,
          faceIndex: null,
          object: this
        });
      }
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes, i = Object.keys(t);
    if (i.length > 0) {
      const n = t[i[0]];
      if (n !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let s = 0, r = n.length; s < r; s++) {
          const a = n[s].name || String(s);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = s;
        }
      }
    }
  }
}
const Jh = /* @__PURE__ */ new b(), Kh = /* @__PURE__ */ new b();
class Yl extends Bn {
  constructor(e, t) {
    super(e, t), this.isLineSegments = !0, this.type = "LineSegments";
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position, i = [];
      for (let n = 0, s = t.count; n < s; n += 2)
        Jh.fromBufferAttribute(t, n), Kh.fromBufferAttribute(t, n + 1), i[n] = n === 0 ? 0 : i[n - 1], i[n + 1] = i[n] + Jh.distanceTo(Kh);
      e.setAttribute("lineDistance", new Ee(i, 1));
    } else
      console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    return this;
  }
}
class Ed extends Bn {
  constructor(e, t) {
    super(e, t), this.isLineLoop = !0, this.type = "LineLoop";
  }
}
class Qa extends Ct {
  constructor(e) {
    super(), this.isPointsMaterial = !0, this.type = "PointsMaterial", this.color = new de(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this;
  }
}
const $h = /* @__PURE__ */ new ue(), yl = /* @__PURE__ */ new ks(), la = /* @__PURE__ */ new Ci(), ca = /* @__PURE__ */ new b();
class Zl extends tt {
  constructor(e = new Ue(), t = new Qa()) {
    super(), this.isPoints = !0, this.type = "Points", this.geometry = e, this.material = t, this.updateMorphTargets();
  }
  copy(e, t) {
    return super.copy(e, t), this.material = e.material, this.geometry = e.geometry, this;
  }
  raycast(e, t) {
    const i = this.geometry, n = this.matrixWorld, s = e.params.Points.threshold, r = i.drawRange;
    if (i.boundingSphere === null && i.computeBoundingSphere(), la.copy(i.boundingSphere), la.applyMatrix4(n), la.radius += s, e.ray.intersectsSphere(la) === !1) return;
    $h.copy(n).invert(), yl.copy(e.ray).applyMatrix4($h);
    const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3), l = a * a, c = i.index, u = i.attributes.position;
    if (c !== null) {
      const d = Math.max(0, r.start), f = Math.min(c.count, r.start + r.count);
      for (let m = d, _ = f; m < _; m++) {
        const p = c.getX(m);
        ca.fromBufferAttribute(u, p), Qh(ca, p, l, n, e, t, this);
      }
    } else {
      const d = Math.max(0, r.start), f = Math.min(u.count, r.start + r.count);
      for (let m = d, _ = f; m < _; m++)
        ca.fromBufferAttribute(u, m), Qh(ca, m, l, n, e, t, this);
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes, i = Object.keys(t);
    if (i.length > 0) {
      const n = t[i[0]];
      if (n !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let s = 0, r = n.length; s < r; s++) {
          const a = n[s].name || String(s);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = s;
        }
      }
    }
  }
}
function Qh(o, e, t, i, n, s, r) {
  const a = yl.distanceSqToPoint(o);
  if (a < t) {
    const l = new b();
    yl.closestPointToPoint(o, l), l.applyMatrix4(i);
    const c = n.ray.origin.distanceTo(l);
    if (c < n.near || c > n.far) return;
    s.push({
      distance: c,
      distanceToRay: Math.sqrt(a),
      point: l,
      index: e,
      face: null,
      object: r
    });
  }
}
class yi {
  constructor() {
    this.type = "Curve", this.arcLengthDivisions = 200;
  }
  // Virtual base class method to overwrite and implement in subclasses
  //	- t [0 .. 1]
  getPoint() {
    return console.warn("THREE.Curve: .getPoint() not implemented."), null;
  }
  // Get point at relative position in curve according to arc length
  // - u [0 .. 1]
  getPointAt(e, t) {
    const i = this.getUtoTmapping(e);
    return this.getPoint(i, t);
  }
  // Get sequence of points using getPoint( t )
  getPoints(e = 5) {
    const t = [];
    for (let i = 0; i <= e; i++)
      t.push(this.getPoint(i / e));
    return t;
  }
  // Get sequence of points using getPointAt( u )
  getSpacedPoints(e = 5) {
    const t = [];
    for (let i = 0; i <= e; i++)
      t.push(this.getPointAt(i / e));
    return t;
  }
  // Get total curve arc length
  getLength() {
    const e = this.getLengths();
    return e[e.length - 1];
  }
  // Get list of cumulative segment lengths
  getLengths(e = this.arcLengthDivisions) {
    if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate)
      return this.cacheArcLengths;
    this.needsUpdate = !1;
    const t = [];
    let i, n = this.getPoint(0), s = 0;
    t.push(0);
    for (let r = 1; r <= e; r++)
      i = this.getPoint(r / e), s += i.distanceTo(n), t.push(s), n = i;
    return this.cacheArcLengths = t, t;
  }
  updateArcLengths() {
    this.needsUpdate = !0, this.getLengths();
  }
  // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
  getUtoTmapping(e, t) {
    const i = this.getLengths();
    let n = 0;
    const s = i.length;
    let r;
    t ? r = t : r = e * i[s - 1];
    let a = 0, l = s - 1, c;
    for (; a <= l; )
      if (n = Math.floor(a + (l - a) / 2), c = i[n] - r, c < 0)
        a = n + 1;
      else if (c > 0)
        l = n - 1;
      else {
        l = n;
        break;
      }
    if (n = l, i[n] === r)
      return n / (s - 1);
    const h = i[n], d = i[n + 1] - h, f = (r - h) / d;
    return (n + f) / (s - 1);
  }
  // Returns a unit vector tangent at t
  // In case any sub curve does not implement its tangent derivation,
  // 2 points a small delta apart will be used to find its gradient
  // which seems to give a reasonable approximation
  getTangent(e, t) {
    let n = e - 1e-4, s = e + 1e-4;
    n < 0 && (n = 0), s > 1 && (s = 1);
    const r = this.getPoint(n), a = this.getPoint(s), l = t || (r.isVector2 ? new G() : new b());
    return l.copy(a).sub(r).normalize(), l;
  }
  getTangentAt(e, t) {
    const i = this.getUtoTmapping(e);
    return this.getTangent(i, t);
  }
  computeFrenetFrames(e, t) {
    const i = new b(), n = [], s = [], r = [], a = new b(), l = new ue();
    for (let f = 0; f <= e; f++) {
      const m = f / e;
      n[f] = this.getTangentAt(m, new b());
    }
    s[0] = new b(), r[0] = new b();
    let c = Number.MAX_VALUE;
    const h = Math.abs(n[0].x), u = Math.abs(n[0].y), d = Math.abs(n[0].z);
    h <= c && (c = h, i.set(1, 0, 0)), u <= c && (c = u, i.set(0, 1, 0)), d <= c && i.set(0, 0, 1), a.crossVectors(n[0], i).normalize(), s[0].crossVectors(n[0], a), r[0].crossVectors(n[0], s[0]);
    for (let f = 1; f <= e; f++) {
      if (s[f] = s[f - 1].clone(), r[f] = r[f - 1].clone(), a.crossVectors(n[f - 1], n[f]), a.length() > Number.EPSILON) {
        a.normalize();
        const m = Math.acos(_t(n[f - 1].dot(n[f]), -1, 1));
        s[f].applyMatrix4(l.makeRotationAxis(a, m));
      }
      r[f].crossVectors(n[f], s[f]);
    }
    if (t === !0) {
      let f = Math.acos(_t(s[0].dot(s[e]), -1, 1));
      f /= e, n[0].dot(a.crossVectors(s[0], s[e])) > 0 && (f = -f);
      for (let m = 1; m <= e; m++)
        s[m].applyMatrix4(l.makeRotationAxis(n[m], f * m)), r[m].crossVectors(n[m], s[m]);
    }
    return {
      tangents: n,
      normals: s,
      binormals: r
    };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.5,
        type: "Curve",
        generator: "Curve.toJSON"
      }
    };
    return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e;
  }
  fromJSON(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
}
class Jl extends yi {
  constructor(e = 0, t = 0, i = 1, n = 1, s = 0, r = Math.PI * 2, a = !1, l = 0) {
    super(), this.isEllipseCurve = !0, this.type = "EllipseCurve", this.aX = e, this.aY = t, this.xRadius = i, this.yRadius = n, this.aStartAngle = s, this.aEndAngle = r, this.aClockwise = a, this.aRotation = l;
  }
  getPoint(e, t) {
    const i = t || new G(), n = Math.PI * 2;
    let s = this.aEndAngle - this.aStartAngle;
    const r = Math.abs(s) < Number.EPSILON;
    for (; s < 0; ) s += n;
    for (; s > n; ) s -= n;
    s < Number.EPSILON && (r ? s = 0 : s = n), this.aClockwise === !0 && !r && (s === n ? s = -n : s = s - n);
    const a = this.aStartAngle + e * s;
    let l = this.aX + this.xRadius * Math.cos(a), c = this.aY + this.yRadius * Math.sin(a);
    if (this.aRotation !== 0) {
      const h = Math.cos(this.aRotation), u = Math.sin(this.aRotation), d = l - this.aX, f = c - this.aY;
      l = d * h - f * u + this.aX, c = d * u + f * h + this.aY;
    }
    return i.set(l, c);
  }
  copy(e) {
    return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
  }
}
class ey extends Jl {
  constructor(e, t, i, n, s, r) {
    super(e, t, i, i, n, s, r), this.isArcCurve = !0, this.type = "ArcCurve";
  }
}
function Kl() {
  let o = 0, e = 0, t = 0, i = 0;
  function n(s, r, a, l) {
    o = s, e = a, t = -3 * s + 3 * r - 2 * a - l, i = 2 * s - 2 * r + a + l;
  }
  return {
    initCatmullRom: function(s, r, a, l, c) {
      n(r, a, c * (a - s), c * (l - r));
    },
    initNonuniformCatmullRom: function(s, r, a, l, c, h, u) {
      let d = (r - s) / c - (a - s) / (c + h) + (a - r) / h, f = (a - r) / h - (l - r) / (h + u) + (l - a) / u;
      d *= h, f *= h, n(r, a, d, f);
    },
    calc: function(s) {
      const r = s * s, a = r * s;
      return o + e * s + t * r + i * a;
    }
  };
}
const ha = /* @__PURE__ */ new b(), Vo = /* @__PURE__ */ new Kl(), Go = /* @__PURE__ */ new Kl(), Ho = /* @__PURE__ */ new Kl();
class ty extends yi {
  constructor(e = [], t = !1, i = "centripetal", n = 0.5) {
    super(), this.isCatmullRomCurve3 = !0, this.type = "CatmullRomCurve3", this.points = e, this.closed = t, this.curveType = i, this.tension = n;
  }
  getPoint(e, t = new b()) {
    const i = t, n = this.points, s = n.length, r = (s - (this.closed ? 0 : 1)) * e;
    let a = Math.floor(r), l = r - a;
    this.closed ? a += a > 0 ? 0 : (Math.floor(Math.abs(a) / s) + 1) * s : l === 0 && a === s - 1 && (a = s - 2, l = 1);
    let c, h;
    this.closed || a > 0 ? c = n[(a - 1) % s] : (ha.subVectors(n[0], n[1]).add(n[0]), c = ha);
    const u = n[a % s], d = n[(a + 1) % s];
    if (this.closed || a + 2 < s ? h = n[(a + 2) % s] : (ha.subVectors(n[s - 1], n[s - 2]).add(n[s - 1]), h = ha), this.curveType === "centripetal" || this.curveType === "chordal") {
      const f = this.curveType === "chordal" ? 0.5 : 0.25;
      let m = Math.pow(c.distanceToSquared(u), f), _ = Math.pow(u.distanceToSquared(d), f), p = Math.pow(d.distanceToSquared(h), f);
      _ < 1e-4 && (_ = 1), m < 1e-4 && (m = _), p < 1e-4 && (p = _), Vo.initNonuniformCatmullRom(c.x, u.x, d.x, h.x, m, _, p), Go.initNonuniformCatmullRom(c.y, u.y, d.y, h.y, m, _, p), Ho.initNonuniformCatmullRom(c.z, u.z, d.z, h.z, m, _, p);
    } else this.curveType === "catmullrom" && (Vo.initCatmullRom(c.x, u.x, d.x, h.x, this.tension), Go.initCatmullRom(c.y, u.y, d.y, h.y, this.tension), Ho.initCatmullRom(c.z, u.z, d.z, h.z, this.tension));
    return i.set(
      Vo.calc(l),
      Go.calc(l),
      Ho.calc(l)
    ), i;
  }
  copy(e) {
    super.copy(e), this.points = [];
    for (let t = 0, i = e.points.length; t < i; t++) {
      const n = e.points[t];
      this.points.push(n.clone());
    }
    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, i = this.points.length; t < i; t++) {
      const n = this.points[t];
      e.points.push(n.toArray());
    }
    return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.points = [];
    for (let t = 0, i = e.points.length; t < i; t++) {
      const n = e.points[t];
      this.points.push(new b().fromArray(n));
    }
    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
  }
}
function eu(o, e, t, i, n) {
  const s = (i - e) * 0.5, r = (n - t) * 0.5, a = o * o, l = o * a;
  return (2 * t - 2 * i + s + r) * l + (-3 * t + 3 * i - 2 * s - r) * a + s * o + t;
}
function iy(o, e) {
  const t = 1 - o;
  return t * t * e;
}
function ny(o, e) {
  return 2 * (1 - o) * o * e;
}
function sy(o, e) {
  return o * o * e;
}
function ur(o, e, t, i) {
  return iy(o, e) + ny(o, t) + sy(o, i);
}
function ry(o, e) {
  const t = 1 - o;
  return t * t * t * e;
}
function ay(o, e) {
  const t = 1 - o;
  return 3 * t * t * o * e;
}
function oy(o, e) {
  return 3 * (1 - o) * o * o * e;
}
function ly(o, e) {
  return o * o * o * e;
}
function dr(o, e, t, i, n) {
  return ry(o, e) + ay(o, t) + oy(o, i) + ly(o, n);
}
class Cd extends yi {
  constructor(e = new G(), t = new G(), i = new G(), n = new G()) {
    super(), this.isCubicBezierCurve = !0, this.type = "CubicBezierCurve", this.v0 = e, this.v1 = t, this.v2 = i, this.v3 = n;
  }
  getPoint(e, t = new G()) {
    const i = t, n = this.v0, s = this.v1, r = this.v2, a = this.v3;
    return i.set(
      dr(e, n.x, s.x, r.x, a.x),
      dr(e, n.y, s.y, r.y, a.y)
    ), i;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
  }
}
class cy extends yi {
  constructor(e = new b(), t = new b(), i = new b(), n = new b()) {
    super(), this.isCubicBezierCurve3 = !0, this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = i, this.v3 = n;
  }
  getPoint(e, t = new b()) {
    const i = t, n = this.v0, s = this.v1, r = this.v2, a = this.v3;
    return i.set(
      dr(e, n.x, s.x, r.x, a.x),
      dr(e, n.y, s.y, r.y, a.y),
      dr(e, n.z, s.z, r.z, a.z)
    ), i;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
  }
}
class $l extends yi {
  constructor(e = new G(), t = new G()) {
    super(), this.isLineCurve = !0, this.type = "LineCurve", this.v1 = e, this.v2 = t;
  }
  getPoint(e, t = new G()) {
    const i = t;
    return e === 1 ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)), i;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t) {
    const i = t || new G();
    return i.copy(this.v2).sub(this.v1).normalize(), i;
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class hy extends yi {
  constructor(e = new b(), t = new b()) {
    super(), this.isLineCurve3 = !0, this.type = "LineCurve3", this.v1 = e, this.v2 = t;
  }
  getPoint(e, t = new b()) {
    const i = t;
    return e === 1 ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)), i;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class Ld extends yi {
  constructor(e = new G(), t = new G(), i = new G()) {
    super(), this.isQuadraticBezierCurve = !0, this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = t, this.v2 = i;
  }
  getPoint(e, t = new G()) {
    const i = t, n = this.v0, s = this.v1, r = this.v2;
    return i.set(
      ur(e, n.x, s.x, r.x),
      ur(e, n.y, s.y, r.y)
    ), i;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class Pd extends yi {
  constructor(e = new b(), t = new b(), i = new b()) {
    super(), this.isQuadraticBezierCurve3 = !0, this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = i;
  }
  getPoint(e, t = new b()) {
    const i = t, n = this.v0, s = this.v1, r = this.v2;
    return i.set(
      ur(e, n.x, s.x, r.x),
      ur(e, n.y, s.y, r.y),
      ur(e, n.z, s.z, r.z)
    ), i;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class Rd extends yi {
  constructor(e = []) {
    super(), this.isSplineCurve = !0, this.type = "SplineCurve", this.points = e;
  }
  getPoint(e, t = new G()) {
    const i = t, n = this.points, s = (n.length - 1) * e, r = Math.floor(s), a = s - r, l = n[r === 0 ? r : r - 1], c = n[r], h = n[r > n.length - 2 ? n.length - 1 : r + 1], u = n[r > n.length - 3 ? n.length - 1 : r + 2];
    return i.set(
      eu(a, l.x, c.x, h.x, u.x),
      eu(a, l.y, c.y, h.y, u.y)
    ), i;
  }
  copy(e) {
    super.copy(e), this.points = [];
    for (let t = 0, i = e.points.length; t < i; t++) {
      const n = e.points[t];
      this.points.push(n.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, i = this.points.length; t < i; t++) {
      const n = this.points[t];
      e.points.push(n.toArray());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.points = [];
    for (let t = 0, i = e.points.length; t < i; t++) {
      const n = e.points[t];
      this.points.push(new G().fromArray(n));
    }
    return this;
  }
}
var Ql = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ArcCurve: ey,
  CatmullRomCurve3: ty,
  CubicBezierCurve: Cd,
  CubicBezierCurve3: cy,
  EllipseCurve: Jl,
  LineCurve: $l,
  LineCurve3: hy,
  QuadraticBezierCurve: Ld,
  QuadraticBezierCurve3: Pd,
  SplineCurve: Rd
});
class uy extends yi {
  constructor() {
    super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1;
  }
  add(e) {
    this.curves.push(e);
  }
  closePath() {
    const e = this.curves[0].getPoint(0), t = this.curves[this.curves.length - 1].getPoint(1);
    e.equals(t) || this.curves.push(new $l(t, e));
  }
  // To get accurate point with reference to
  // entire path distance at time t,
  // following has to be done:
  // 1. Length of each sub path have to be known
  // 2. Locate and identify type of curve
  // 3. Get t for the curve
  // 4. Return curve.getPointAt(t')
  getPoint(e, t) {
    const i = e * this.getLength(), n = this.getCurveLengths();
    let s = 0;
    for (; s < n.length; ) {
      if (n[s] >= i) {
        const r = n[s] - i, a = this.curves[s], l = a.getLength(), c = l === 0 ? 0 : 1 - r / l;
        return a.getPointAt(c, t);
      }
      s++;
    }
    return null;
  }
  // We cannot use the default THREE.Curve getPoint() with getLength() because in
  // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
  // getPoint() depends on getLength
  getLength() {
    const e = this.getCurveLengths();
    return e[e.length - 1];
  }
  // cacheLengths must be recalculated.
  updateArcLengths() {
    this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths();
  }
  // Compute lengths and cache them
  // We cannot overwrite getLengths() because UtoT mapping uses it.
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
      return this.cacheLengths;
    const e = [];
    let t = 0;
    for (let i = 0, n = this.curves.length; i < n; i++)
      t += this.curves[i].getLength(), e.push(t);
    return this.cacheLengths = e, e;
  }
  getSpacedPoints(e = 40) {
    const t = [];
    for (let i = 0; i <= e; i++)
      t.push(this.getPoint(i / e));
    return this.autoClose && t.push(t[0]), t;
  }
  getPoints(e = 12) {
    const t = [];
    let i;
    for (let n = 0, s = this.curves; n < s.length; n++) {
      const r = s[n], a = r.isEllipseCurve ? e * 2 : r.isLineCurve || r.isLineCurve3 ? 1 : r.isSplineCurve ? e * r.points.length : e, l = r.getPoints(a);
      for (let c = 0; c < l.length; c++) {
        const h = l[c];
        i && i.equals(h) || (t.push(h), i = h);
      }
    }
    return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]), t;
  }
  copy(e) {
    super.copy(e), this.curves = [];
    for (let t = 0, i = e.curves.length; t < i; t++) {
      const n = e.curves[t];
      this.curves.push(n.clone());
    }
    return this.autoClose = e.autoClose, this;
  }
  toJSON() {
    const e = super.toJSON();
    e.autoClose = this.autoClose, e.curves = [];
    for (let t = 0, i = this.curves.length; t < i; t++) {
      const n = this.curves[t];
      e.curves.push(n.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.autoClose = e.autoClose, this.curves = [];
    for (let t = 0, i = e.curves.length; t < i; t++) {
      const n = e.curves[t];
      this.curves.push(new Ql[n.type]().fromJSON(n));
    }
    return this;
  }
}
class xl extends uy {
  constructor(e) {
    super(), this.type = "Path", this.currentPoint = new G(), e && this.setFromPoints(e);
  }
  setFromPoints(e) {
    this.moveTo(e[0].x, e[0].y);
    for (let t = 1, i = e.length; t < i; t++)
      this.lineTo(e[t].x, e[t].y);
    return this;
  }
  moveTo(e, t) {
    return this.currentPoint.set(e, t), this;
  }
  lineTo(e, t) {
    const i = new $l(this.currentPoint.clone(), new G(e, t));
    return this.curves.push(i), this.currentPoint.set(e, t), this;
  }
  quadraticCurveTo(e, t, i, n) {
    const s = new Ld(
      this.currentPoint.clone(),
      new G(e, t),
      new G(i, n)
    );
    return this.curves.push(s), this.currentPoint.set(i, n), this;
  }
  bezierCurveTo(e, t, i, n, s, r) {
    const a = new Cd(
      this.currentPoint.clone(),
      new G(e, t),
      new G(i, n),
      new G(s, r)
    );
    return this.curves.push(a), this.currentPoint.set(s, r), this;
  }
  splineThru(e) {
    const t = [this.currentPoint.clone()].concat(e), i = new Rd(t);
    return this.curves.push(i), this.currentPoint.copy(e[e.length - 1]), this;
  }
  arc(e, t, i, n, s, r) {
    const a = this.currentPoint.x, l = this.currentPoint.y;
    return this.absarc(
      e + a,
      t + l,
      i,
      n,
      s,
      r
    ), this;
  }
  absarc(e, t, i, n, s, r) {
    return this.absellipse(e, t, i, i, n, s, r), this;
  }
  ellipse(e, t, i, n, s, r, a, l) {
    const c = this.currentPoint.x, h = this.currentPoint.y;
    return this.absellipse(e + c, t + h, i, n, s, r, a, l), this;
  }
  absellipse(e, t, i, n, s, r, a, l) {
    const c = new Jl(e, t, i, n, s, r, a, l);
    if (this.curves.length > 0) {
      const u = c.getPoint(0);
      u.equals(this.currentPoint) || this.lineTo(u.x, u.y);
    }
    this.curves.push(c);
    const h = c.getPoint(1);
    return this.currentPoint.copy(h), this;
  }
  copy(e) {
    return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.currentPoint = this.currentPoint.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this;
  }
}
class eo extends Ue {
  constructor(e = [new G(0, -0.5), new G(0.5, 0), new G(0, 0.5)], t = 12, i = 0, n = Math.PI * 2) {
    super(), this.type = "LatheGeometry", this.parameters = {
      points: e,
      segments: t,
      phiStart: i,
      phiLength: n
    }, t = Math.floor(t), n = _t(n, 0, Math.PI * 2);
    const s = [], r = [], a = [], l = [], c = [], h = 1 / t, u = new b(), d = new G(), f = new b(), m = new b(), _ = new b();
    let p = 0, g = 0;
    for (let x = 0; x <= e.length - 1; x++)
      switch (x) {
        case 0:
          p = e[x + 1].x - e[x].x, g = e[x + 1].y - e[x].y, f.x = g * 1, f.y = -p, f.z = g * 0, _.copy(f), f.normalize(), l.push(f.x, f.y, f.z);
          break;
        case e.length - 1:
          l.push(_.x, _.y, _.z);
          break;
        default:
          p = e[x + 1].x - e[x].x, g = e[x + 1].y - e[x].y, f.x = g * 1, f.y = -p, f.z = g * 0, m.copy(f), f.x += _.x, f.y += _.y, f.z += _.z, f.normalize(), l.push(f.x, f.y, f.z), _.copy(m);
      }
    for (let x = 0; x <= t; x++) {
      const y = i + x * h * n, v = Math.sin(y), M = Math.cos(y);
      for (let S = 0; S <= e.length - 1; S++) {
        u.x = e[S].x * v, u.y = e[S].y, u.z = e[S].x * M, r.push(u.x, u.y, u.z), d.x = x / t, d.y = S / (e.length - 1), a.push(d.x, d.y);
        const A = l[3 * S + 0] * v, w = l[3 * S + 1], E = l[3 * S + 0] * M;
        c.push(A, w, E);
      }
    }
    for (let x = 0; x < t; x++)
      for (let y = 0; y < e.length - 1; y++) {
        const v = y + x * e.length, M = v, S = v + e.length, A = v + e.length + 1, w = v + 1;
        s.push(M, S, w), s.push(A, w, S);
      }
    this.setIndex(s), this.setAttribute("position", new Ee(r, 3)), this.setAttribute("uv", new Ee(a, 2)), this.setAttribute("normal", new Ee(c, 3));
  }
  static fromJSON(e) {
    return new eo(e.points, e.segments, e.phiStart, e.phiLength);
  }
}
class ec extends eo {
  constructor(e = 1, t = 1, i = 4, n = 8) {
    const s = new xl();
    s.absarc(0, -t / 2, e, Math.PI * 1.5, 0), s.absarc(0, t / 2, e, 0, Math.PI * 0.5), super(s.getPoints(i), n), this.type = "CapsuleGeometry", this.parameters = {
      radius: e,
      height: t,
      capSegments: i,
      radialSegments: n
    };
  }
  static fromJSON(e) {
    return new ec(e.radius, e.length, e.capSegments, e.radialSegments);
  }
}
class tc extends Ue {
  constructor(e = 1, t = 32, i = 0, n = Math.PI * 2) {
    super(), this.type = "CircleGeometry", this.parameters = {
      radius: e,
      segments: t,
      thetaStart: i,
      thetaLength: n
    }, t = Math.max(3, t);
    const s = [], r = [], a = [], l = [], c = new b(), h = new G();
    r.push(0, 0, 0), a.push(0, 0, 1), l.push(0.5, 0.5);
    for (let u = 0, d = 3; u <= t; u++, d += 3) {
      const f = i + u / t * n;
      c.x = e * Math.cos(f), c.y = e * Math.sin(f), r.push(c.x, c.y, c.z), a.push(0, 0, 1), h.x = (r[d] / e + 1) / 2, h.y = (r[d + 1] / e + 1) / 2, l.push(h.x, h.y);
    }
    for (let u = 1; u <= t; u++)
      s.push(u, u + 1, 0);
    this.setIndex(s), this.setAttribute("position", new Ee(r, 3)), this.setAttribute("normal", new Ee(a, 3)), this.setAttribute("uv", new Ee(l, 2));
  }
  static fromJSON(e) {
    return new tc(e.radius, e.segments, e.thetaStart, e.thetaLength);
  }
}
class Ir extends Ue {
  constructor(e = 1, t = 1, i = 1, n = 32, s = 1, r = !1, a = 0, l = Math.PI * 2) {
    super(), this.type = "CylinderGeometry", this.parameters = {
      radiusTop: e,
      radiusBottom: t,
      height: i,
      radialSegments: n,
      heightSegments: s,
      openEnded: r,
      thetaStart: a,
      thetaLength: l
    };
    const c = this;
    n = Math.floor(n), s = Math.floor(s);
    const h = [], u = [], d = [], f = [];
    let m = 0;
    const _ = [], p = i / 2;
    let g = 0;
    x(), r === !1 && (e > 0 && y(!0), t > 0 && y(!1)), this.setIndex(h), this.setAttribute("position", new Ee(u, 3)), this.setAttribute("normal", new Ee(d, 3)), this.setAttribute("uv", new Ee(f, 2));
    function x() {
      const v = new b(), M = new b();
      let S = 0;
      const A = (t - e) / i;
      for (let w = 0; w <= s; w++) {
        const E = [], P = w / s, z = P * (t - e) + e;
        for (let V = 0; V <= n; V++) {
          const O = V / n, D = O * l + a, H = Math.sin(D), Z = Math.cos(D);
          M.x = z * H, M.y = -P * i + p, M.z = z * Z, u.push(M.x, M.y, M.z), v.set(H, A, Z).normalize(), d.push(v.x, v.y, v.z), f.push(O, 1 - P), E.push(m++);
        }
        _.push(E);
      }
      for (let w = 0; w < n; w++)
        for (let E = 0; E < s; E++) {
          const P = _[E][w], z = _[E + 1][w], V = _[E + 1][w + 1], O = _[E][w + 1];
          h.push(P, z, O), h.push(z, V, O), S += 6;
        }
      c.addGroup(g, S, 0), g += S;
    }
    function y(v) {
      const M = m, S = new G(), A = new b();
      let w = 0;
      const E = v === !0 ? e : t, P = v === !0 ? 1 : -1;
      for (let V = 1; V <= n; V++)
        u.push(0, p * P, 0), d.push(0, P, 0), f.push(0.5, 0.5), m++;
      const z = m;
      for (let V = 0; V <= n; V++) {
        const D = V / n * l + a, H = Math.cos(D), Z = Math.sin(D);
        A.x = E * Z, A.y = p * P, A.z = E * H, u.push(A.x, A.y, A.z), d.push(0, P, 0), S.x = H * 0.5 + 0.5, S.y = Z * 0.5 * P + 0.5, f.push(S.x, S.y), m++;
      }
      for (let V = 0; V < n; V++) {
        const O = M + V, D = z + V;
        v === !0 ? h.push(D, D + 1, O) : h.push(D + 1, D, O), w += 3;
      }
      c.addGroup(g, w, v === !0 ? 1 : 2), g += w;
    }
  }
  static fromJSON(e) {
    return new Ir(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
class ic extends Ir {
  constructor(e = 1, t = 1, i = 32, n = 1, s = !1, r = 0, a = Math.PI * 2) {
    super(0, e, t, i, n, s, r, a), this.type = "ConeGeometry", this.parameters = {
      radius: e,
      height: t,
      radialSegments: i,
      heightSegments: n,
      openEnded: s,
      thetaStart: r,
      thetaLength: a
    };
  }
  static fromJSON(e) {
    return new ic(e.radius, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
class Gn extends Ue {
  constructor(e = [], t = [], i = 1, n = 0) {
    super(), this.type = "PolyhedronGeometry", this.parameters = {
      vertices: e,
      indices: t,
      radius: i,
      detail: n
    };
    const s = [], r = [];
    a(n), c(i), h(), this.setAttribute("position", new Ee(s, 3)), this.setAttribute("normal", new Ee(s.slice(), 3)), this.setAttribute("uv", new Ee(r, 2)), n === 0 ? this.computeVertexNormals() : this.normalizeNormals();
    function a(x) {
      const y = new b(), v = new b(), M = new b();
      for (let S = 0; S < t.length; S += 3)
        f(t[S + 0], y), f(t[S + 1], v), f(t[S + 2], M), l(y, v, M, x);
    }
    function l(x, y, v, M) {
      const S = M + 1, A = [];
      for (let w = 0; w <= S; w++) {
        A[w] = [];
        const E = x.clone().lerp(v, w / S), P = y.clone().lerp(v, w / S), z = S - w;
        for (let V = 0; V <= z; V++)
          V === 0 && w === S ? A[w][V] = E : A[w][V] = E.clone().lerp(P, V / z);
      }
      for (let w = 0; w < S; w++)
        for (let E = 0; E < 2 * (S - w) - 1; E++) {
          const P = Math.floor(E / 2);
          E % 2 === 0 ? (d(A[w][P + 1]), d(A[w + 1][P]), d(A[w][P])) : (d(A[w][P + 1]), d(A[w + 1][P + 1]), d(A[w + 1][P]));
        }
    }
    function c(x) {
      const y = new b();
      for (let v = 0; v < s.length; v += 3)
        y.x = s[v + 0], y.y = s[v + 1], y.z = s[v + 2], y.normalize().multiplyScalar(x), s[v + 0] = y.x, s[v + 1] = y.y, s[v + 2] = y.z;
    }
    function h() {
      const x = new b();
      for (let y = 0; y < s.length; y += 3) {
        x.x = s[y + 0], x.y = s[y + 1], x.z = s[y + 2];
        const v = p(x) / 2 / Math.PI + 0.5, M = g(x) / Math.PI + 0.5;
        r.push(v, 1 - M);
      }
      m(), u();
    }
    function u() {
      for (let x = 0; x < r.length; x += 6) {
        const y = r[x + 0], v = r[x + 2], M = r[x + 4], S = Math.max(y, v, M), A = Math.min(y, v, M);
        S > 0.9 && A < 0.1 && (y < 0.2 && (r[x + 0] += 1), v < 0.2 && (r[x + 2] += 1), M < 0.2 && (r[x + 4] += 1));
      }
    }
    function d(x) {
      s.push(x.x, x.y, x.z);
    }
    function f(x, y) {
      const v = x * 3;
      y.x = e[v + 0], y.y = e[v + 1], y.z = e[v + 2];
    }
    function m() {
      const x = new b(), y = new b(), v = new b(), M = new b(), S = new G(), A = new G(), w = new G();
      for (let E = 0, P = 0; E < s.length; E += 9, P += 6) {
        x.set(s[E + 0], s[E + 1], s[E + 2]), y.set(s[E + 3], s[E + 4], s[E + 5]), v.set(s[E + 6], s[E + 7], s[E + 8]), S.set(r[P + 0], r[P + 1]), A.set(r[P + 2], r[P + 3]), w.set(r[P + 4], r[P + 5]), M.copy(x).add(y).add(v).divideScalar(3);
        const z = p(M);
        _(S, P + 0, x, z), _(A, P + 2, y, z), _(w, P + 4, v, z);
      }
    }
    function _(x, y, v, M) {
      M < 0 && x.x === 1 && (r[y] = x.x - 1), v.x === 0 && v.z === 0 && (r[y] = M / 2 / Math.PI + 0.5);
    }
    function p(x) {
      return Math.atan2(x.z, -x.x);
    }
    function g(x) {
      return Math.atan2(-x.y, Math.sqrt(x.x * x.x + x.z * x.z));
    }
  }
  static fromJSON(e) {
    return new Gn(e.vertices, e.indices, e.radius, e.details);
  }
}
class nc extends Gn {
  constructor(e = 1, t = 0) {
    const i = (1 + Math.sqrt(5)) / 2, n = 1 / i, s = [
      // (±1, ±1, ±1)
      -1,
      -1,
      -1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      -1,
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      1,
      1,
      -1,
      1,
      1,
      1,
      // (0, ±1/φ, ±φ)
      0,
      -n,
      -i,
      0,
      -n,
      i,
      0,
      n,
      -i,
      0,
      n,
      i,
      // (±1/φ, ±φ, 0)
      -n,
      -i,
      0,
      -n,
      i,
      0,
      n,
      -i,
      0,
      n,
      i,
      0,
      // (±φ, 0, ±1/φ)
      -i,
      0,
      -n,
      i,
      0,
      -n,
      -i,
      0,
      n,
      i,
      0,
      n
    ], r = [
      3,
      11,
      7,
      3,
      7,
      15,
      3,
      15,
      13,
      7,
      19,
      17,
      7,
      17,
      6,
      7,
      6,
      15,
      17,
      4,
      8,
      17,
      8,
      10,
      17,
      10,
      6,
      8,
      0,
      16,
      8,
      16,
      2,
      8,
      2,
      10,
      0,
      12,
      1,
      0,
      1,
      18,
      0,
      18,
      16,
      6,
      10,
      2,
      6,
      2,
      13,
      6,
      13,
      15,
      2,
      16,
      18,
      2,
      18,
      3,
      2,
      3,
      13,
      18,
      1,
      9,
      18,
      9,
      11,
      18,
      11,
      3,
      4,
      14,
      12,
      4,
      12,
      0,
      4,
      0,
      8,
      11,
      9,
      5,
      11,
      5,
      19,
      11,
      19,
      7,
      19,
      5,
      14,
      19,
      14,
      4,
      19,
      4,
      17,
      1,
      12,
      14,
      1,
      14,
      5,
      1,
      5,
      9
    ];
    super(s, r, e, t), this.type = "DodecahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new nc(e.radius, e.detail);
  }
}
const ua = /* @__PURE__ */ new b(), da = /* @__PURE__ */ new b(), Wo = /* @__PURE__ */ new b(), fa = /* @__PURE__ */ new _i();
class dy extends Ue {
  constructor(e = null, t = 1) {
    if (super(), this.type = "EdgesGeometry", this.parameters = {
      geometry: e,
      thresholdAngle: t
    }, e !== null) {
      const n = Math.pow(10, 4), s = Math.cos(Ss * t), r = e.getIndex(), a = e.getAttribute("position"), l = r ? r.count : a.count, c = [0, 0, 0], h = ["a", "b", "c"], u = new Array(3), d = {}, f = [];
      for (let m = 0; m < l; m += 3) {
        r ? (c[0] = r.getX(m), c[1] = r.getX(m + 1), c[2] = r.getX(m + 2)) : (c[0] = m, c[1] = m + 1, c[2] = m + 2);
        const { a: _, b: p, c: g } = fa;
        if (_.fromBufferAttribute(a, c[0]), p.fromBufferAttribute(a, c[1]), g.fromBufferAttribute(a, c[2]), fa.getNormal(Wo), u[0] = `${Math.round(_.x * n)},${Math.round(_.y * n)},${Math.round(_.z * n)}`, u[1] = `${Math.round(p.x * n)},${Math.round(p.y * n)},${Math.round(p.z * n)}`, u[2] = `${Math.round(g.x * n)},${Math.round(g.y * n)},${Math.round(g.z * n)}`, !(u[0] === u[1] || u[1] === u[2] || u[2] === u[0]))
          for (let x = 0; x < 3; x++) {
            const y = (x + 1) % 3, v = u[x], M = u[y], S = fa[h[x]], A = fa[h[y]], w = `${v}_${M}`, E = `${M}_${v}`;
            E in d && d[E] ? (Wo.dot(d[E].normal) <= s && (f.push(S.x, S.y, S.z), f.push(A.x, A.y, A.z)), d[E] = null) : w in d || (d[w] = {
              index0: c[x],
              index1: c[y],
              normal: Wo.clone()
            });
          }
      }
      for (const m in d)
        if (d[m]) {
          const { index0: _, index1: p } = d[m];
          ua.fromBufferAttribute(a, _), da.fromBufferAttribute(a, p), f.push(ua.x, ua.y, ua.z), f.push(da.x, da.y, da.z);
        }
      this.setAttribute("position", new Ee(f, 3));
    }
  }
}
class sc extends xl {
  constructor(e) {
    super(e), this.uuid = li(), this.type = "Shape", this.holes = [];
  }
  getPointsHoles(e) {
    const t = [];
    for (let i = 0, n = this.holes.length; i < n; i++)
      t[i] = this.holes[i].getPoints(e);
    return t;
  }
  // get points of shape and holes (keypoints based on segments parameter)
  extractPoints(e) {
    return {
      shape: this.getPoints(e),
      holes: this.getPointsHoles(e)
    };
  }
  copy(e) {
    super.copy(e), this.holes = [];
    for (let t = 0, i = e.holes.length; t < i; t++) {
      const n = e.holes[t];
      this.holes.push(n.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.uuid = this.uuid, e.holes = [];
    for (let t = 0, i = this.holes.length; t < i; t++) {
      const n = this.holes[t];
      e.holes.push(n.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.uuid = e.uuid, this.holes = [];
    for (let t = 0, i = e.holes.length; t < i; t++) {
      const n = e.holes[t];
      this.holes.push(new xl().fromJSON(n));
    }
    return this;
  }
}
const fy = {
  triangulate: function(o, e, t = 2) {
    const i = e && e.length, n = i ? e[0] * t : o.length;
    let s = Id(o, 0, n, t, !0);
    const r = [];
    if (!s || s.next === s.prev) return r;
    let a, l, c, h, u, d, f;
    if (i && (s = vy(o, e, s, t)), o.length > 80 * t) {
      a = c = o[0], l = h = o[1];
      for (let m = t; m < n; m += t)
        u = o[m], d = o[m + 1], u < a && (a = u), d < l && (l = d), u > c && (c = u), d > h && (h = d);
      f = Math.max(c - a, h - l), f = f !== 0 ? 32767 / f : 0;
    }
    return Sr(s, r, t, a, l, f, 0), r;
  }
};
function Id(o, e, t, i, n) {
  let s, r;
  if (n === Ly(o, e, t, i) > 0)
    for (s = e; s < t; s += i) r = tu(s, o[s], o[s + 1], r);
  else
    for (s = t - i; s >= e; s -= i) r = tu(s, o[s], o[s + 1], r);
  return r && to(r, r.next) && (Ar(r), r = r.next), r;
}
function Un(o, e) {
  if (!o) return o;
  e || (e = o);
  let t = o, i;
  do
    if (i = !1, !t.steiner && (to(t, t.next) || ht(t.prev, t, t.next) === 0)) {
      if (Ar(t), t = e = t.prev, t === t.next) break;
      i = !0;
    } else
      t = t.next;
  while (i || t !== e);
  return e;
}
function Sr(o, e, t, i, n, s, r) {
  if (!o) return;
  !r && s && My(o, i, n, s);
  let a = o, l, c;
  for (; o.prev !== o.next; ) {
    if (l = o.prev, c = o.next, s ? my(o, i, n, s) : py(o)) {
      e.push(l.i / t | 0), e.push(o.i / t | 0), e.push(c.i / t | 0), Ar(o), o = c.next, a = c.next;
      continue;
    }
    if (o = c, o === a) {
      r ? r === 1 ? (o = _y(Un(o), e, t), Sr(o, e, t, i, n, s, 2)) : r === 2 && gy(o, e, t, i, n, s) : Sr(Un(o), e, t, i, n, s, 1);
      break;
    }
  }
}
function py(o) {
  const e = o.prev, t = o, i = o.next;
  if (ht(e, t, i) >= 0) return !1;
  const n = e.x, s = t.x, r = i.x, a = e.y, l = t.y, c = i.y, h = n < s ? n < r ? n : r : s < r ? s : r, u = a < l ? a < c ? a : c : l < c ? l : c, d = n > s ? n > r ? n : r : s > r ? s : r, f = a > l ? a > c ? a : c : l > c ? l : c;
  let m = i.next;
  for (; m !== e; ) {
    if (m.x >= h && m.x <= d && m.y >= u && m.y <= f && xs(n, a, s, l, r, c, m.x, m.y) && ht(m.prev, m, m.next) >= 0) return !1;
    m = m.next;
  }
  return !0;
}
function my(o, e, t, i) {
  const n = o.prev, s = o, r = o.next;
  if (ht(n, s, r) >= 0) return !1;
  const a = n.x, l = s.x, c = r.x, h = n.y, u = s.y, d = r.y, f = a < l ? a < c ? a : c : l < c ? l : c, m = h < u ? h < d ? h : d : u < d ? u : d, _ = a > l ? a > c ? a : c : l > c ? l : c, p = h > u ? h > d ? h : d : u > d ? u : d, g = wl(f, m, e, t, i), x = wl(_, p, e, t, i);
  let y = o.prevZ, v = o.nextZ;
  for (; y && y.z >= g && v && v.z <= x; ) {
    if (y.x >= f && y.x <= _ && y.y >= m && y.y <= p && y !== n && y !== r && xs(a, h, l, u, c, d, y.x, y.y) && ht(y.prev, y, y.next) >= 0 || (y = y.prevZ, v.x >= f && v.x <= _ && v.y >= m && v.y <= p && v !== n && v !== r && xs(a, h, l, u, c, d, v.x, v.y) && ht(v.prev, v, v.next) >= 0)) return !1;
    v = v.nextZ;
  }
  for (; y && y.z >= g; ) {
    if (y.x >= f && y.x <= _ && y.y >= m && y.y <= p && y !== n && y !== r && xs(a, h, l, u, c, d, y.x, y.y) && ht(y.prev, y, y.next) >= 0) return !1;
    y = y.prevZ;
  }
  for (; v && v.z <= x; ) {
    if (v.x >= f && v.x <= _ && v.y >= m && v.y <= p && v !== n && v !== r && xs(a, h, l, u, c, d, v.x, v.y) && ht(v.prev, v, v.next) >= 0) return !1;
    v = v.nextZ;
  }
  return !0;
}
function _y(o, e, t) {
  let i = o;
  do {
    const n = i.prev, s = i.next.next;
    !to(n, s) && Dd(n, i, i.next, s) && Tr(n, s) && Tr(s, n) && (e.push(n.i / t | 0), e.push(i.i / t | 0), e.push(s.i / t | 0), Ar(i), Ar(i.next), i = o = s), i = i.next;
  } while (i !== o);
  return Un(i);
}
function gy(o, e, t, i, n, s) {
  let r = o;
  do {
    let a = r.next.next;
    for (; a !== r.prev; ) {
      if (r.i !== a.i && Ay(r, a)) {
        let l = Od(r, a);
        r = Un(r, r.next), l = Un(l, l.next), Sr(r, e, t, i, n, s, 0), Sr(l, e, t, i, n, s, 0);
        return;
      }
      a = a.next;
    }
    r = r.next;
  } while (r !== o);
}
function vy(o, e, t, i) {
  const n = [];
  let s, r, a, l, c;
  for (s = 0, r = e.length; s < r; s++)
    a = e[s] * i, l = s < r - 1 ? e[s + 1] * i : o.length, c = Id(o, a, l, i, !1), c === c.next && (c.steiner = !0), n.push(Ty(c));
  for (n.sort(yy), s = 0; s < n.length; s++)
    t = xy(n[s], t);
  return t;
}
function yy(o, e) {
  return o.x - e.x;
}
function xy(o, e) {
  const t = wy(o, e);
  if (!t)
    return e;
  const i = Od(t, o);
  return Un(i, i.next), Un(t, t.next);
}
function wy(o, e) {
  let t = e, i = -1 / 0, n;
  const s = o.x, r = o.y;
  do {
    if (r <= t.y && r >= t.next.y && t.next.y !== t.y) {
      const d = t.x + (r - t.y) * (t.next.x - t.x) / (t.next.y - t.y);
      if (d <= s && d > i && (i = d, n = t.x < t.next.x ? t : t.next, d === s))
        return n;
    }
    t = t.next;
  } while (t !== e);
  if (!n) return null;
  const a = n, l = n.x, c = n.y;
  let h = 1 / 0, u;
  t = n;
  do
    s >= t.x && t.x >= l && s !== t.x && xs(r < c ? s : i, r, l, c, r < c ? i : s, r, t.x, t.y) && (u = Math.abs(r - t.y) / (s - t.x), Tr(t, o) && (u < h || u === h && (t.x > n.x || t.x === n.x && by(n, t))) && (n = t, h = u)), t = t.next;
  while (t !== a);
  return n;
}
function by(o, e) {
  return ht(o.prev, o, e.prev) < 0 && ht(e.next, o, o.next) < 0;
}
function My(o, e, t, i) {
  let n = o;
  do
    n.z === 0 && (n.z = wl(n.x, n.y, e, t, i)), n.prevZ = n.prev, n.nextZ = n.next, n = n.next;
  while (n !== o);
  n.prevZ.nextZ = null, n.prevZ = null, Sy(n);
}
function Sy(o) {
  let e, t, i, n, s, r, a, l, c = 1;
  do {
    for (t = o, o = null, s = null, r = 0; t; ) {
      for (r++, i = t, a = 0, e = 0; e < c && (a++, i = i.nextZ, !!i); e++)
        ;
      for (l = c; a > 0 || l > 0 && i; )
        a !== 0 && (l === 0 || !i || t.z <= i.z) ? (n = t, t = t.nextZ, a--) : (n = i, i = i.nextZ, l--), s ? s.nextZ = n : o = n, n.prevZ = s, s = n;
      t = i;
    }
    s.nextZ = null, c *= 2;
  } while (r > 1);
  return o;
}
function wl(o, e, t, i, n) {
  return o = (o - t) * n | 0, e = (e - i) * n | 0, o = (o | o << 8) & 16711935, o = (o | o << 4) & 252645135, o = (o | o << 2) & 858993459, o = (o | o << 1) & 1431655765, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, o | e << 1;
}
function Ty(o) {
  let e = o, t = o;
  do
    (e.x < t.x || e.x === t.x && e.y < t.y) && (t = e), e = e.next;
  while (e !== o);
  return t;
}
function xs(o, e, t, i, n, s, r, a) {
  return (n - r) * (e - a) >= (o - r) * (s - a) && (o - r) * (i - a) >= (t - r) * (e - a) && (t - r) * (s - a) >= (n - r) * (i - a);
}
function Ay(o, e) {
  return o.next.i !== e.i && o.prev.i !== e.i && !Ey(o, e) && // dones't intersect other edges
  (Tr(o, e) && Tr(e, o) && Cy(o, e) && // locally visible
  (ht(o.prev, o, e.prev) || ht(o, e.prev, e)) || // does not create opposite-facing sectors
  to(o, e) && ht(o.prev, o, o.next) > 0 && ht(e.prev, e, e.next) > 0);
}
function ht(o, e, t) {
  return (e.y - o.y) * (t.x - e.x) - (e.x - o.x) * (t.y - e.y);
}
function to(o, e) {
  return o.x === e.x && o.y === e.y;
}
function Dd(o, e, t, i) {
  const n = ma(ht(o, e, t)), s = ma(ht(o, e, i)), r = ma(ht(t, i, o)), a = ma(ht(t, i, e));
  return !!(n !== s && r !== a || n === 0 && pa(o, t, e) || s === 0 && pa(o, i, e) || r === 0 && pa(t, o, i) || a === 0 && pa(t, e, i));
}
function pa(o, e, t) {
  return e.x <= Math.max(o.x, t.x) && e.x >= Math.min(o.x, t.x) && e.y <= Math.max(o.y, t.y) && e.y >= Math.min(o.y, t.y);
}
function ma(o) {
  return o > 0 ? 1 : o < 0 ? -1 : 0;
}
function Ey(o, e) {
  let t = o;
  do {
    if (t.i !== o.i && t.next.i !== o.i && t.i !== e.i && t.next.i !== e.i && Dd(t, t.next, o, e)) return !0;
    t = t.next;
  } while (t !== o);
  return !1;
}
function Tr(o, e) {
  return ht(o.prev, o, o.next) < 0 ? ht(o, e, o.next) >= 0 && ht(o, o.prev, e) >= 0 : ht(o, e, o.prev) < 0 || ht(o, o.next, e) < 0;
}
function Cy(o, e) {
  let t = o, i = !1;
  const n = (o.x + e.x) / 2, s = (o.y + e.y) / 2;
  do
    t.y > s != t.next.y > s && t.next.y !== t.y && n < (t.next.x - t.x) * (s - t.y) / (t.next.y - t.y) + t.x && (i = !i), t = t.next;
  while (t !== o);
  return i;
}
function Od(o, e) {
  const t = new bl(o.i, o.x, o.y), i = new bl(e.i, e.x, e.y), n = o.next, s = e.prev;
  return o.next = e, e.prev = o, t.next = n, n.prev = t, i.next = t, t.prev = i, s.next = i, i.prev = s, i;
}
function tu(o, e, t, i) {
  const n = new bl(o, e, t);
  return i ? (n.next = i.next, n.prev = i, i.next.prev = n, i.next = n) : (n.prev = n, n.next = n), n;
}
function Ar(o) {
  o.next.prev = o.prev, o.prev.next = o.next, o.prevZ && (o.prevZ.nextZ = o.nextZ), o.nextZ && (o.nextZ.prevZ = o.prevZ);
}
function bl(o, e, t) {
  this.i = o, this.x = e, this.y = t, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1;
}
function Ly(o, e, t, i) {
  let n = 0;
  for (let s = e, r = t - i; s < t; s += i)
    n += (o[r] - o[s]) * (o[s + 1] + o[r + 1]), r = s;
  return n;
}
class Xi {
  // calculate area of the contour polygon
  static area(e) {
    const t = e.length;
    let i = 0;
    for (let n = t - 1, s = 0; s < t; n = s++)
      i += e[n].x * e[s].y - e[s].x * e[n].y;
    return i * 0.5;
  }
  static isClockWise(e) {
    return Xi.area(e) < 0;
  }
  static triangulateShape(e, t) {
    const i = [], n = [], s = [];
    iu(e), nu(i, e);
    let r = e.length;
    t.forEach(iu);
    for (let l = 0; l < t.length; l++)
      n.push(r), r += t[l].length, nu(i, t[l]);
    const a = fy.triangulate(i, n);
    for (let l = 0; l < a.length; l += 3)
      s.push(a.slice(l, l + 3));
    return s;
  }
}
function iu(o) {
  const e = o.length;
  e > 2 && o[e - 1].equals(o[0]) && o.pop();
}
function nu(o, e) {
  for (let t = 0; t < e.length; t++)
    o.push(e[t].x), o.push(e[t].y);
}
class rc extends Ue {
  constructor(e = new sc([new G(0.5, 0.5), new G(-0.5, 0.5), new G(-0.5, -0.5), new G(0.5, -0.5)]), t = {}) {
    super(), this.type = "ExtrudeGeometry", this.parameters = {
      shapes: e,
      options: t
    }, e = Array.isArray(e) ? e : [e];
    const i = this, n = [], s = [];
    for (let a = 0, l = e.length; a < l; a++) {
      const c = e[a];
      r(c);
    }
    this.setAttribute("position", new Ee(n, 3)), this.setAttribute("uv", new Ee(s, 2)), this.computeVertexNormals();
    function r(a) {
      const l = [], c = t.curveSegments !== void 0 ? t.curveSegments : 12, h = t.steps !== void 0 ? t.steps : 1, u = t.depth !== void 0 ? t.depth : 1;
      let d = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0, f = t.bevelThickness !== void 0 ? t.bevelThickness : 0.2, m = t.bevelSize !== void 0 ? t.bevelSize : f - 0.1, _ = t.bevelOffset !== void 0 ? t.bevelOffset : 0, p = t.bevelSegments !== void 0 ? t.bevelSegments : 3;
      const g = t.extrudePath, x = t.UVGenerator !== void 0 ? t.UVGenerator : Py;
      let y, v = !1, M, S, A, w;
      g && (y = g.getSpacedPoints(h), v = !0, d = !1, M = g.computeFrenetFrames(h, !1), S = new b(), A = new b(), w = new b()), d || (p = 0, f = 0, m = 0, _ = 0);
      const E = a.extractPoints(c);
      let P = E.shape;
      const z = E.holes;
      if (!Xi.isClockWise(P)) {
        P = P.reverse();
        for (let ee = 0, Q = z.length; ee < Q; ee++) {
          const ce = z[ee];
          Xi.isClockWise(ce) && (z[ee] = ce.reverse());
        }
      }
      const O = Xi.triangulateShape(P, z), D = P;
      for (let ee = 0, Q = z.length; ee < Q; ee++) {
        const ce = z[ee];
        P = P.concat(ce);
      }
      function H(ee, Q, ce) {
        return Q || console.error("THREE.ExtrudeGeometry: vec does not exist"), Q.clone().multiplyScalar(ce).add(ee);
      }
      const Z = P.length, ie = O.length;
      function K(ee, Q, ce) {
        let be, pe, Ne;
        const Le = ee.x - Q.x, Ce = ee.y - Q.y, rt = ce.x - ee.x, Qe = ce.y - ee.y, L = Le * Le + Ce * Ce, T = Le * Qe - Ce * rt;
        if (Math.abs(T) > Number.EPSILON) {
          const X = Math.sqrt(L), se = Math.sqrt(rt * rt + Qe * Qe), oe = Q.x - Ce / X, _e = Q.y + Le / X, Ie = ce.x - Qe / se, R = ce.y + rt / se, F = ((Ie - oe) * Qe - (R - _e) * rt) / (Le * Qe - Ce * rt);
          be = oe + Le * F - ee.x, pe = _e + Ce * F - ee.y;
          const ge = be * be + pe * pe;
          if (ge <= 2)
            return new G(be, pe);
          Ne = Math.sqrt(ge / 2);
        } else {
          let X = !1;
          Le > Number.EPSILON ? rt > Number.EPSILON && (X = !0) : Le < -Number.EPSILON ? rt < -Number.EPSILON && (X = !0) : Math.sign(Ce) === Math.sign(Qe) && (X = !0), X ? (be = -Ce, pe = Le, Ne = Math.sqrt(L)) : (be = Le, pe = Ce, Ne = Math.sqrt(L / 2));
        }
        return new G(be / Ne, pe / Ne);
      }
      const ne = [];
      for (let ee = 0, Q = D.length, ce = Q - 1, be = ee + 1; ee < Q; ee++, ce++, be++)
        ce === Q && (ce = 0), be === Q && (be = 0), ne[ee] = K(D[ee], D[ce], D[be]);
      const te = [];
      let q, W = ne.concat();
      for (let ee = 0, Q = z.length; ee < Q; ee++) {
        const ce = z[ee];
        q = [];
        for (let be = 0, pe = ce.length, Ne = pe - 1, Le = be + 1; be < pe; be++, Ne++, Le++)
          Ne === pe && (Ne = 0), Le === pe && (Le = 0), q[be] = K(ce[be], ce[Ne], ce[Le]);
        te.push(q), W = W.concat(q);
      }
      for (let ee = 0; ee < p; ee++) {
        const Q = ee / p, ce = f * Math.cos(Q * Math.PI / 2), be = m * Math.sin(Q * Math.PI / 2) + _;
        for (let pe = 0, Ne = D.length; pe < Ne; pe++) {
          const Le = H(D[pe], ne[pe], be);
          De(Le.x, Le.y, -ce);
        }
        for (let pe = 0, Ne = z.length; pe < Ne; pe++) {
          const Le = z[pe];
          q = te[pe];
          for (let Ce = 0, rt = Le.length; Ce < rt; Ce++) {
            const Qe = H(Le[Ce], q[Ce], be);
            De(Qe.x, Qe.y, -ce);
          }
        }
      }
      const le = m + _;
      for (let ee = 0; ee < Z; ee++) {
        const Q = d ? H(P[ee], W[ee], le) : P[ee];
        v ? (A.copy(M.normals[0]).multiplyScalar(Q.x), S.copy(M.binormals[0]).multiplyScalar(Q.y), w.copy(y[0]).add(A).add(S), De(w.x, w.y, w.z)) : De(Q.x, Q.y, 0);
      }
      for (let ee = 1; ee <= h; ee++)
        for (let Q = 0; Q < Z; Q++) {
          const ce = d ? H(P[Q], W[Q], le) : P[Q];
          v ? (A.copy(M.normals[ee]).multiplyScalar(ce.x), S.copy(M.binormals[ee]).multiplyScalar(ce.y), w.copy(y[ee]).add(A).add(S), De(w.x, w.y, w.z)) : De(ce.x, ce.y, u / h * ee);
        }
      for (let ee = p - 1; ee >= 0; ee--) {
        const Q = ee / p, ce = f * Math.cos(Q * Math.PI / 2), be = m * Math.sin(Q * Math.PI / 2) + _;
        for (let pe = 0, Ne = D.length; pe < Ne; pe++) {
          const Le = H(D[pe], ne[pe], be);
          De(Le.x, Le.y, u + ce);
        }
        for (let pe = 0, Ne = z.length; pe < Ne; pe++) {
          const Le = z[pe];
          q = te[pe];
          for (let Ce = 0, rt = Le.length; Ce < rt; Ce++) {
            const Qe = H(Le[Ce], q[Ce], be);
            v ? De(Qe.x, Qe.y + y[h - 1].y, y[h - 1].x + ce) : De(Qe.x, Qe.y, u + ce);
          }
        }
      }
      ae(), fe();
      function ae() {
        const ee = n.length / 3;
        if (d) {
          let Q = 0, ce = Z * Q;
          for (let be = 0; be < ie; be++) {
            const pe = O[be];
            ye(pe[2] + ce, pe[1] + ce, pe[0] + ce);
          }
          Q = h + p * 2, ce = Z * Q;
          for (let be = 0; be < ie; be++) {
            const pe = O[be];
            ye(pe[0] + ce, pe[1] + ce, pe[2] + ce);
          }
        } else {
          for (let Q = 0; Q < ie; Q++) {
            const ce = O[Q];
            ye(ce[2], ce[1], ce[0]);
          }
          for (let Q = 0; Q < ie; Q++) {
            const ce = O[Q];
            ye(ce[0] + Z * h, ce[1] + Z * h, ce[2] + Z * h);
          }
        }
        i.addGroup(ee, n.length / 3 - ee, 0);
      }
      function fe() {
        const ee = n.length / 3;
        let Q = 0;
        j(D, Q), Q += D.length;
        for (let ce = 0, be = z.length; ce < be; ce++) {
          const pe = z[ce];
          j(pe, Q), Q += pe.length;
        }
        i.addGroup(ee, n.length / 3 - ee, 1);
      }
      function j(ee, Q) {
        let ce = ee.length;
        for (; --ce >= 0; ) {
          const be = ce;
          let pe = ce - 1;
          pe < 0 && (pe = ee.length - 1);
          for (let Ne = 0, Le = h + p * 2; Ne < Le; Ne++) {
            const Ce = Z * Ne, rt = Z * (Ne + 1), Qe = Q + be + Ce, L = Q + pe + Ce, T = Q + pe + rt, X = Q + be + rt;
            Re(Qe, L, T, X);
          }
        }
      }
      function De(ee, Q, ce) {
        l.push(ee), l.push(Q), l.push(ce);
      }
      function ye(ee, Q, ce) {
        me(ee), me(Q), me(ce);
        const be = n.length / 3, pe = x.generateTopUV(i, n, be - 3, be - 2, be - 1);
        ze(pe[0]), ze(pe[1]), ze(pe[2]);
      }
      function Re(ee, Q, ce, be) {
        me(ee), me(Q), me(be), me(Q), me(ce), me(be);
        const pe = n.length / 3, Ne = x.generateSideWallUV(i, n, pe - 6, pe - 3, pe - 2, pe - 1);
        ze(Ne[0]), ze(Ne[1]), ze(Ne[3]), ze(Ne[1]), ze(Ne[2]), ze(Ne[3]);
      }
      function me(ee) {
        n.push(l[ee * 3 + 0]), n.push(l[ee * 3 + 1]), n.push(l[ee * 3 + 2]);
      }
      function ze(ee) {
        s.push(ee.x), s.push(ee.y);
      }
    }
  }
  toJSON() {
    const e = super.toJSON(), t = this.parameters.shapes, i = this.parameters.options;
    return Ry(t, i, e);
  }
  static fromJSON(e, t) {
    const i = [];
    for (let s = 0, r = e.shapes.length; s < r; s++) {
      const a = t[e.shapes[s]];
      i.push(a);
    }
    const n = e.options.extrudePath;
    return n !== void 0 && (e.options.extrudePath = new Ql[n.type]().fromJSON(n)), new rc(i, e.options);
  }
}
const Py = {
  generateTopUV: function(o, e, t, i, n) {
    const s = e[t * 3], r = e[t * 3 + 1], a = e[i * 3], l = e[i * 3 + 1], c = e[n * 3], h = e[n * 3 + 1];
    return [
      new G(s, r),
      new G(a, l),
      new G(c, h)
    ];
  },
  generateSideWallUV: function(o, e, t, i, n, s) {
    const r = e[t * 3], a = e[t * 3 + 1], l = e[t * 3 + 2], c = e[i * 3], h = e[i * 3 + 1], u = e[i * 3 + 2], d = e[n * 3], f = e[n * 3 + 1], m = e[n * 3 + 2], _ = e[s * 3], p = e[s * 3 + 1], g = e[s * 3 + 2];
    return Math.abs(a - h) < Math.abs(r - c) ? [
      new G(r, 1 - l),
      new G(c, 1 - u),
      new G(d, 1 - m),
      new G(_, 1 - g)
    ] : [
      new G(a, 1 - l),
      new G(h, 1 - u),
      new G(f, 1 - m),
      new G(p, 1 - g)
    ];
  }
};
function Ry(o, e, t) {
  if (t.shapes = [], Array.isArray(o))
    for (let i = 0, n = o.length; i < n; i++) {
      const s = o[i];
      t.shapes.push(s.uuid);
    }
  else
    t.shapes.push(o.uuid);
  return t.options = Object.assign({}, e), e.extrudePath !== void 0 && (t.options.extrudePath = e.extrudePath.toJSON()), t;
}
class ac extends Gn {
  constructor(e = 1, t = 0) {
    const i = (1 + Math.sqrt(5)) / 2, n = [
      -1,
      i,
      0,
      1,
      i,
      0,
      -1,
      -i,
      0,
      1,
      -i,
      0,
      0,
      -1,
      i,
      0,
      1,
      i,
      0,
      -1,
      -i,
      0,
      1,
      -i,
      i,
      0,
      -1,
      i,
      0,
      1,
      -i,
      0,
      -1,
      -i,
      0,
      1
    ], s = [
      0,
      11,
      5,
      0,
      5,
      1,
      0,
      1,
      7,
      0,
      7,
      10,
      0,
      10,
      11,
      1,
      5,
      9,
      5,
      11,
      4,
      11,
      10,
      2,
      10,
      7,
      6,
      7,
      1,
      8,
      3,
      9,
      4,
      3,
      4,
      2,
      3,
      2,
      6,
      3,
      6,
      8,
      3,
      8,
      9,
      4,
      9,
      5,
      2,
      4,
      11,
      6,
      2,
      10,
      8,
      6,
      7,
      9,
      8,
      1
    ];
    super(n, s, e, t), this.type = "IcosahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new ac(e.radius, e.detail);
  }
}
class oc extends Gn {
  constructor(e = 1, t = 0) {
    const i = [
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1
    ], n = [
      0,
      2,
      4,
      0,
      4,
      3,
      0,
      3,
      5,
      0,
      5,
      2,
      1,
      2,
      5,
      1,
      5,
      3,
      1,
      3,
      4,
      1,
      4,
      2
    ];
    super(i, n, e, t), this.type = "OctahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new oc(e.radius, e.detail);
  }
}
class lc extends Ue {
  constructor(e = 0.5, t = 1, i = 32, n = 1, s = 0, r = Math.PI * 2) {
    super(), this.type = "RingGeometry", this.parameters = {
      innerRadius: e,
      outerRadius: t,
      thetaSegments: i,
      phiSegments: n,
      thetaStart: s,
      thetaLength: r
    }, i = Math.max(3, i), n = Math.max(1, n);
    const a = [], l = [], c = [], h = [];
    let u = e;
    const d = (t - e) / n, f = new b(), m = new G();
    for (let _ = 0; _ <= n; _++) {
      for (let p = 0; p <= i; p++) {
        const g = s + p / i * r;
        f.x = u * Math.cos(g), f.y = u * Math.sin(g), l.push(f.x, f.y, f.z), c.push(0, 0, 1), m.x = (f.x / t + 1) / 2, m.y = (f.y / t + 1) / 2, h.push(m.x, m.y);
      }
      u += d;
    }
    for (let _ = 0; _ < n; _++) {
      const p = _ * (i + 1);
      for (let g = 0; g < i; g++) {
        const x = g + p, y = x, v = x + i + 1, M = x + i + 2, S = x + 1;
        a.push(y, v, S), a.push(v, M, S);
      }
    }
    this.setIndex(a), this.setAttribute("position", new Ee(l, 3)), this.setAttribute("normal", new Ee(c, 3)), this.setAttribute("uv", new Ee(h, 2));
  }
  static fromJSON(e) {
    return new lc(e.innerRadius, e.outerRadius, e.thetaSegments, e.phiSegments, e.thetaStart, e.thetaLength);
  }
}
class cc extends Ue {
  constructor(e = new sc([new G(0, 0.5), new G(-0.5, -0.5), new G(0.5, -0.5)]), t = 12) {
    super(), this.type = "ShapeGeometry", this.parameters = {
      shapes: e,
      curveSegments: t
    };
    const i = [], n = [], s = [], r = [];
    let a = 0, l = 0;
    if (Array.isArray(e) === !1)
      c(e);
    else
      for (let h = 0; h < e.length; h++)
        c(e[h]), this.addGroup(a, l, h), a += l, l = 0;
    this.setIndex(i), this.setAttribute("position", new Ee(n, 3)), this.setAttribute("normal", new Ee(s, 3)), this.setAttribute("uv", new Ee(r, 2));
    function c(h) {
      const u = n.length / 3, d = h.extractPoints(t);
      let f = d.shape;
      const m = d.holes;
      Xi.isClockWise(f) === !1 && (f = f.reverse());
      for (let p = 0, g = m.length; p < g; p++) {
        const x = m[p];
        Xi.isClockWise(x) === !0 && (m[p] = x.reverse());
      }
      const _ = Xi.triangulateShape(f, m);
      for (let p = 0, g = m.length; p < g; p++) {
        const x = m[p];
        f = f.concat(x);
      }
      for (let p = 0, g = f.length; p < g; p++) {
        const x = f[p];
        n.push(x.x, x.y, 0), s.push(0, 0, 1), r.push(x.x, x.y);
      }
      for (let p = 0, g = _.length; p < g; p++) {
        const x = _[p], y = x[0] + u, v = x[1] + u, M = x[2] + u;
        i.push(y, v, M), l += 3;
      }
    }
  }
  toJSON() {
    const e = super.toJSON(), t = this.parameters.shapes;
    return Iy(t, e);
  }
  static fromJSON(e, t) {
    const i = [];
    for (let n = 0, s = e.shapes.length; n < s; n++) {
      const r = t[e.shapes[n]];
      i.push(r);
    }
    return new cc(i, e.curveSegments);
  }
}
function Iy(o, e) {
  if (e.shapes = [], Array.isArray(o))
    for (let t = 0, i = o.length; t < i; t++) {
      const n = o[t];
      e.shapes.push(n.uuid);
    }
  else
    e.shapes.push(o.uuid);
  return e;
}
class hc extends Ue {
  constructor(e = 1, t = 32, i = 16, n = 0, s = Math.PI * 2, r = 0, a = Math.PI) {
    super(), this.type = "SphereGeometry", this.parameters = {
      radius: e,
      widthSegments: t,
      heightSegments: i,
      phiStart: n,
      phiLength: s,
      thetaStart: r,
      thetaLength: a
    }, t = Math.max(3, Math.floor(t)), i = Math.max(2, Math.floor(i));
    const l = Math.min(r + a, Math.PI);
    let c = 0;
    const h = [], u = new b(), d = new b(), f = [], m = [], _ = [], p = [];
    for (let g = 0; g <= i; g++) {
      const x = [], y = g / i;
      let v = 0;
      g == 0 && r == 0 ? v = 0.5 / t : g == i && l == Math.PI && (v = -0.5 / t);
      for (let M = 0; M <= t; M++) {
        const S = M / t;
        u.x = -e * Math.cos(n + S * s) * Math.sin(r + y * a), u.y = e * Math.cos(r + y * a), u.z = e * Math.sin(n + S * s) * Math.sin(r + y * a), m.push(u.x, u.y, u.z), d.copy(u).normalize(), _.push(d.x, d.y, d.z), p.push(S + v, 1 - y), x.push(c++);
      }
      h.push(x);
    }
    for (let g = 0; g < i; g++)
      for (let x = 0; x < t; x++) {
        const y = h[g][x + 1], v = h[g][x], M = h[g + 1][x], S = h[g + 1][x + 1];
        (g !== 0 || r > 0) && f.push(y, v, S), (g !== i - 1 || l < Math.PI) && f.push(v, M, S);
      }
    this.setIndex(f), this.setAttribute("position", new Ee(m, 3)), this.setAttribute("normal", new Ee(_, 3)), this.setAttribute("uv", new Ee(p, 2));
  }
  static fromJSON(e) {
    return new hc(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength);
  }
}
class uc extends Gn {
  constructor(e = 1, t = 0) {
    const i = [
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      1,
      -1,
      -1
    ], n = [
      2,
      1,
      0,
      0,
      3,
      2,
      1,
      3,
      0,
      2,
      3,
      1
    ];
    super(i, n, e, t), this.type = "TetrahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new uc(e.radius, e.detail);
  }
}
class dc extends Ue {
  constructor(e = 1, t = 0.4, i = 12, n = 48, s = Math.PI * 2) {
    super(), this.type = "TorusGeometry", this.parameters = {
      radius: e,
      tube: t,
      radialSegments: i,
      tubularSegments: n,
      arc: s
    }, i = Math.floor(i), n = Math.floor(n);
    const r = [], a = [], l = [], c = [], h = new b(), u = new b(), d = new b();
    for (let f = 0; f <= i; f++)
      for (let m = 0; m <= n; m++) {
        const _ = m / n * s, p = f / i * Math.PI * 2;
        u.x = (e + t * Math.cos(p)) * Math.cos(_), u.y = (e + t * Math.cos(p)) * Math.sin(_), u.z = t * Math.sin(p), a.push(u.x, u.y, u.z), h.x = e * Math.cos(_), h.y = e * Math.sin(_), d.subVectors(u, h).normalize(), l.push(d.x, d.y, d.z), c.push(m / n), c.push(f / i);
      }
    for (let f = 1; f <= i; f++)
      for (let m = 1; m <= n; m++) {
        const _ = (n + 1) * f + m - 1, p = (n + 1) * (f - 1) + m - 1, g = (n + 1) * (f - 1) + m, x = (n + 1) * f + m;
        r.push(_, p, x), r.push(p, g, x);
      }
    this.setIndex(r), this.setAttribute("position", new Ee(a, 3)), this.setAttribute("normal", new Ee(l, 3)), this.setAttribute("uv", new Ee(c, 2));
  }
  static fromJSON(e) {
    return new dc(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc);
  }
}
class fc extends Ue {
  constructor(e = 1, t = 0.4, i = 64, n = 8, s = 2, r = 3) {
    super(), this.type = "TorusKnotGeometry", this.parameters = {
      radius: e,
      tube: t,
      tubularSegments: i,
      radialSegments: n,
      p: s,
      q: r
    }, i = Math.floor(i), n = Math.floor(n);
    const a = [], l = [], c = [], h = [], u = new b(), d = new b(), f = new b(), m = new b(), _ = new b(), p = new b(), g = new b();
    for (let y = 0; y <= i; ++y) {
      const v = y / i * s * Math.PI * 2;
      x(v, s, r, e, f), x(v + 0.01, s, r, e, m), p.subVectors(m, f), g.addVectors(m, f), _.crossVectors(p, g), g.crossVectors(_, p), _.normalize(), g.normalize();
      for (let M = 0; M <= n; ++M) {
        const S = M / n * Math.PI * 2, A = -t * Math.cos(S), w = t * Math.sin(S);
        u.x = f.x + (A * g.x + w * _.x), u.y = f.y + (A * g.y + w * _.y), u.z = f.z + (A * g.z + w * _.z), l.push(u.x, u.y, u.z), d.subVectors(u, f).normalize(), c.push(d.x, d.y, d.z), h.push(y / i), h.push(M / n);
      }
    }
    for (let y = 1; y <= i; y++)
      for (let v = 1; v <= n; v++) {
        const M = (n + 1) * (y - 1) + (v - 1), S = (n + 1) * y + (v - 1), A = (n + 1) * y + v, w = (n + 1) * (y - 1) + v;
        a.push(M, S, w), a.push(S, A, w);
      }
    this.setIndex(a), this.setAttribute("position", new Ee(l, 3)), this.setAttribute("normal", new Ee(c, 3)), this.setAttribute("uv", new Ee(h, 2));
    function x(y, v, M, S, A) {
      const w = Math.cos(y), E = Math.sin(y), P = M / v * y, z = Math.cos(P);
      A.x = S * (2 + z) * 0.5 * w, A.y = S * (2 + z) * E * 0.5, A.z = S * Math.sin(P) * 0.5;
    }
  }
  static fromJSON(e) {
    return new fc(e.radius, e.tube, e.tubularSegments, e.radialSegments, e.p, e.q);
  }
}
class pc extends Ue {
  constructor(e = new Pd(new b(-1, -1, 0), new b(-1, 1, 0), new b(1, 1, 0)), t = 64, i = 1, n = 8, s = !1) {
    super(), this.type = "TubeGeometry", this.parameters = {
      path: e,
      tubularSegments: t,
      radius: i,
      radialSegments: n,
      closed: s
    };
    const r = e.computeFrenetFrames(t, s);
    this.tangents = r.tangents, this.normals = r.normals, this.binormals = r.binormals;
    const a = new b(), l = new b(), c = new G();
    let h = new b();
    const u = [], d = [], f = [], m = [];
    _(), this.setIndex(m), this.setAttribute("position", new Ee(u, 3)), this.setAttribute("normal", new Ee(d, 3)), this.setAttribute("uv", new Ee(f, 2));
    function _() {
      for (let y = 0; y < t; y++)
        p(y);
      p(s === !1 ? t : 0), x(), g();
    }
    function p(y) {
      h = e.getPointAt(y / t, h);
      const v = r.normals[y], M = r.binormals[y];
      for (let S = 0; S <= n; S++) {
        const A = S / n * Math.PI * 2, w = Math.sin(A), E = -Math.cos(A);
        l.x = E * v.x + w * M.x, l.y = E * v.y + w * M.y, l.z = E * v.z + w * M.z, l.normalize(), d.push(l.x, l.y, l.z), a.x = h.x + i * l.x, a.y = h.y + i * l.y, a.z = h.z + i * l.z, u.push(a.x, a.y, a.z);
      }
    }
    function g() {
      for (let y = 1; y <= t; y++)
        for (let v = 1; v <= n; v++) {
          const M = (n + 1) * (y - 1) + (v - 1), S = (n + 1) * y + (v - 1), A = (n + 1) * y + v, w = (n + 1) * (y - 1) + v;
          m.push(M, S, w), m.push(S, A, w);
        }
    }
    function x() {
      for (let y = 0; y <= t; y++)
        for (let v = 0; v <= n; v++)
          c.x = y / t, c.y = v / n, f.push(c.x, c.y);
    }
  }
  toJSON() {
    const e = super.toJSON();
    return e.path = this.parameters.path.toJSON(), e;
  }
  static fromJSON(e) {
    return new pc(
      new Ql[e.path.type]().fromJSON(e.path),
      e.tubularSegments,
      e.radius,
      e.radialSegments,
      e.closed
    );
  }
}
class Nd extends Ue {
  constructor(e = null) {
    if (super(), this.type = "WireframeGeometry", this.parameters = {
      geometry: e
    }, e !== null) {
      const t = [], i = /* @__PURE__ */ new Set(), n = new b(), s = new b();
      if (e.index !== null) {
        const r = e.attributes.position, a = e.index;
        let l = e.groups;
        l.length === 0 && (l = [{ start: 0, count: a.count, materialIndex: 0 }]);
        for (let c = 0, h = l.length; c < h; ++c) {
          const u = l[c], d = u.start, f = u.count;
          for (let m = d, _ = d + f; m < _; m += 3)
            for (let p = 0; p < 3; p++) {
              const g = a.getX(m + p), x = a.getX(m + (p + 1) % 3);
              n.fromBufferAttribute(r, g), s.fromBufferAttribute(r, x), su(n, s, i) === !0 && (t.push(n.x, n.y, n.z), t.push(s.x, s.y, s.z));
            }
        }
      } else {
        const r = e.attributes.position;
        for (let a = 0, l = r.count / 3; a < l; a++)
          for (let c = 0; c < 3; c++) {
            const h = 3 * a + c, u = 3 * a + (c + 1) % 3;
            n.fromBufferAttribute(r, h), s.fromBufferAttribute(r, u), su(n, s, i) === !0 && (t.push(n.x, n.y, n.z), t.push(s.x, s.y, s.z));
          }
      }
      this.setAttribute("position", new Ee(t, 3));
    }
  }
}
function su(o, e, t) {
  const i = `${o.x},${o.y},${o.z}-${e.x},${e.y},${e.z}`, n = `${e.x},${e.y},${e.z}-${o.x},${o.y},${o.z}`;
  return t.has(i) === !0 || t.has(n) === !0 ? !1 : (t.add(i), t.add(n), !0);
}
var ru = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  BoxGeometry: zs,
  CapsuleGeometry: ec,
  CircleGeometry: tc,
  ConeGeometry: ic,
  CylinderGeometry: Ir,
  DodecahedronGeometry: nc,
  EdgesGeometry: dy,
  ExtrudeGeometry: rc,
  IcosahedronGeometry: ac,
  LatheGeometry: eo,
  OctahedronGeometry: oc,
  PlaneGeometry: Pr,
  PolyhedronGeometry: Gn,
  RingGeometry: lc,
  ShapeGeometry: cc,
  SphereGeometry: hc,
  TetrahedronGeometry: uc,
  TorusGeometry: dc,
  TorusKnotGeometry: fc,
  TubeGeometry: pc,
  WireframeGeometry: Nd
});
class Dy extends Ct {
  constructor(e) {
    super(), this.isShadowMaterial = !0, this.type = "ShadowMaterial", this.color = new de(0), this.transparent = !0, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.fog = e.fog, this;
  }
}
class Oy extends xt {
  constructor(e) {
    super(e), this.isRawShaderMaterial = !0, this.type = "RawShaderMaterial";
  }
}
class io extends Ct {
  constructor(e) {
    super(), this.isMeshStandardMaterial = !0, this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new de(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new de(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Vn, this.normalScale = new G(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.defines = { STANDARD: "" }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapIntensity = e.envMapIntensity, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class vn extends io {
  constructor(e) {
    super(), this.isMeshPhysicalMaterial = !0, this.defines = {
      STANDARD: "",
      PHYSICAL: ""
    }, this.type = "MeshPhysicalMaterial", this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new G(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
      get: function() {
        return _t(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
      },
      set: function(t) {
        this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
      }
    }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [100, 400], this.iridescenceThicknessMap = null, this.sheenColor = new de(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new de(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new de(1, 1, 1), this.specularColorMap = null, this._sheen = 0, this._clearcoat = 0, this._iridescence = 0, this._transmission = 0, this.setValues(e);
  }
  get sheen() {
    return this._sheen;
  }
  set sheen(e) {
    this._sheen > 0 != e > 0 && this.version++, this._sheen = e;
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(e) {
    this._clearcoat > 0 != e > 0 && this.version++, this._clearcoat = e;
  }
  get iridescence() {
    return this._iridescence;
  }
  set iridescence(e) {
    this._iridescence > 0 != e > 0 && this.version++, this._iridescence = e;
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(e) {
    this._transmission > 0 != e > 0 && this.version++, this._transmission = e;
  }
  copy(e) {
    return super.copy(e), this.defines = {
      STANDARD: "",
      PHYSICAL: ""
    }, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.ior = e.ior, this.iridescence = e.iridescence, this.iridescenceMap = e.iridescenceMap, this.iridescenceIOR = e.iridescenceIOR, this.iridescenceThicknessRange = [...e.iridescenceThicknessRange], this.iridescenceThicknessMap = e.iridescenceThicknessMap, this.sheen = e.sheen, this.sheenColor.copy(e.sheenColor), this.sheenColorMap = e.sheenColorMap, this.sheenRoughness = e.sheenRoughness, this.sheenRoughnessMap = e.sheenRoughnessMap, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationColor.copy(e.attenuationColor), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularColor.copy(e.specularColor), this.specularColorMap = e.specularColorMap, this;
  }
}
class Na extends Ct {
  constructor(e) {
    super(), this.isMeshPhongMaterial = !0, this.type = "MeshPhongMaterial", this.color = new de(16777215), this.specular = new de(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new de(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Vn, this.normalScale = new G(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = Ya, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class Ny extends Ct {
  constructor(e) {
    super(), this.isMeshToonMaterial = !0, this.defines = { TOON: "" }, this.type = "MeshToonMaterial", this.color = new de(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new de(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Vn, this.normalScale = new G(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.gradientMap = e.gradientMap, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
  }
}
class ky extends Ct {
  constructor(e) {
    super(), this.isMeshNormalMaterial = !0, this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Vn, this.normalScale = new G(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.flatShading = !1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.flatShading = e.flatShading, this;
  }
}
class kd extends Ct {
  constructor(e) {
    super(), this.isMeshLambertMaterial = !0, this.type = "MeshLambertMaterial", this.color = new de(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new de(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Vn, this.normalScale = new G(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = Ya, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class zy extends Ct {
  constructor(e) {
    super(), this.isMeshMatcapMaterial = !0, this.defines = { MATCAP: "" }, this.type = "MeshMatcapMaterial", this.color = new de(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Vn, this.normalScale = new G(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.defines = { MATCAP: "" }, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class Fy extends mn {
  constructor(e) {
    super(), this.isLineDashedMaterial = !0, this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this;
  }
}
function Qi(o, e, t) {
  return zd(o) ? new o.constructor(o.subarray(e, t !== void 0 ? t : o.length)) : o.slice(e, t);
}
function _a(o, e, t) {
  return !o || // let 'undefined' and 'null' pass
  !t && o.constructor === e ? o : typeof e.BYTES_PER_ELEMENT == "number" ? new e(o) : Array.prototype.slice.call(o);
}
function zd(o) {
  return ArrayBuffer.isView(o) && !(o instanceof DataView);
}
function By(o) {
  function e(n, s) {
    return o[n] - o[s];
  }
  const t = o.length, i = new Array(t);
  for (let n = 0; n !== t; ++n) i[n] = n;
  return i.sort(e), i;
}
function au(o, e, t) {
  const i = o.length, n = new o.constructor(i);
  for (let s = 0, r = 0; r !== i; ++s) {
    const a = t[s] * e;
    for (let l = 0; l !== e; ++l)
      n[r++] = o[a + l];
  }
  return n;
}
function Fd(o, e, t, i) {
  let n = 1, s = o[0];
  for (; s !== void 0 && s[i] === void 0; )
    s = o[n++];
  if (s === void 0) return;
  let r = s[i];
  if (r !== void 0)
    if (Array.isArray(r))
      do
        r = s[i], r !== void 0 && (e.push(s.time), t.push.apply(t, r)), s = o[n++];
      while (s !== void 0);
    else if (r.toArray !== void 0)
      do
        r = s[i], r !== void 0 && (e.push(s.time), r.toArray(t, t.length)), s = o[n++];
      while (s !== void 0);
    else
      do
        r = s[i], r !== void 0 && (e.push(s.time), t.push(r)), s = o[n++];
      while (s !== void 0);
}
class Dr {
  constructor(e, t, i, n) {
    this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = n !== void 0 ? n : new t.constructor(i), this.sampleValues = t, this.valueSize = i, this.settings = null, this.DefaultSettings_ = {};
  }
  evaluate(e) {
    const t = this.parameterPositions;
    let i = this._cachedIndex, n = t[i], s = t[i - 1];
    e: {
      t: {
        let r;
        i: {
          n: if (!(e < n)) {
            for (let a = i + 2; ; ) {
              if (n === void 0) {
                if (e < s) break n;
                return i = t.length, this._cachedIndex = i, this.copySampleValue_(i - 1);
              }
              if (i === a) break;
              if (s = n, n = t[++i], e < n)
                break t;
            }
            r = t.length;
            break i;
          }
          if (!(e >= s)) {
            const a = t[1];
            e < a && (i = 2, s = a);
            for (let l = i - 2; ; ) {
              if (s === void 0)
                return this._cachedIndex = 0, this.copySampleValue_(0);
              if (i === l) break;
              if (n = s, s = t[--i - 1], e >= s)
                break t;
            }
            r = i, i = 0;
            break i;
          }
          break e;
        }
        for (; i < r; ) {
          const a = i + r >>> 1;
          e < t[a] ? r = a : i = a + 1;
        }
        if (n = t[i], s = t[i - 1], s === void 0)
          return this._cachedIndex = 0, this.copySampleValue_(0);
        if (n === void 0)
          return i = t.length, this._cachedIndex = i, this.copySampleValue_(i - 1);
      }
      this._cachedIndex = i, this.intervalChanged_(i, s, n);
    }
    return this.interpolate_(i, s, e, n);
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  copySampleValue_(e) {
    const t = this.resultBuffer, i = this.sampleValues, n = this.valueSize, s = e * n;
    for (let r = 0; r !== n; ++r)
      t[r] = i[s + r];
    return t;
  }
  // Template methods for derived classes:
  interpolate_() {
    throw new Error("call to abstract method");
  }
  intervalChanged_() {
  }
}
class Uy extends Dr {
  constructor(e, t, i, n) {
    super(e, t, i, n), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
      endingStart: ms,
      endingEnd: ms
    };
  }
  intervalChanged_(e, t, i) {
    const n = this.parameterPositions;
    let s = e - 2, r = e + 1, a = n[s], l = n[r];
    if (a === void 0)
      switch (this.getSettings_().endingStart) {
        case _s:
          s = e, a = 2 * t - i;
          break;
        case Ua:
          s = n.length - 2, a = t + n[s] - n[s + 1];
          break;
        default:
          s = e, a = i;
      }
    if (l === void 0)
      switch (this.getSettings_().endingEnd) {
        case _s:
          r = e, l = 2 * i - t;
          break;
        case Ua:
          r = 1, l = i + n[1] - n[0];
          break;
        default:
          r = e - 1, l = t;
      }
    const c = (i - t) * 0.5, h = this.valueSize;
    this._weightPrev = c / (t - a), this._weightNext = c / (l - i), this._offsetPrev = s * h, this._offsetNext = r * h;
  }
  interpolate_(e, t, i, n) {
    const s = this.resultBuffer, r = this.sampleValues, a = this.valueSize, l = e * a, c = l - a, h = this._offsetPrev, u = this._offsetNext, d = this._weightPrev, f = this._weightNext, m = (i - t) / (n - t), _ = m * m, p = _ * m, g = -d * p + 2 * d * _ - d * m, x = (1 + d) * p + (-1.5 - 2 * d) * _ + (-0.5 + d) * m + 1, y = (-1 - f) * p + (1.5 + f) * _ + 0.5 * m, v = f * p - f * _;
    for (let M = 0; M !== a; ++M)
      s[M] = g * r[h + M] + x * r[c + M] + y * r[l + M] + v * r[u + M];
    return s;
  }
}
class Bd extends Dr {
  constructor(e, t, i, n) {
    super(e, t, i, n);
  }
  interpolate_(e, t, i, n) {
    const s = this.resultBuffer, r = this.sampleValues, a = this.valueSize, l = e * a, c = l - a, h = (i - t) / (n - t), u = 1 - h;
    for (let d = 0; d !== a; ++d)
      s[d] = r[c + d] * u + r[l + d] * h;
    return s;
  }
}
class Vy extends Dr {
  constructor(e, t, i, n) {
    super(e, t, i, n);
  }
  interpolate_(e) {
    return this.copySampleValue_(e - 1);
  }
}
class Li {
  constructor(e, t, i, n) {
    if (e === void 0) throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (t === void 0 || t.length === 0) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
    this.name = e, this.times = _a(t, this.TimeBufferType), this.values = _a(i, this.ValueBufferType), this.setInterpolation(n || this.DefaultInterpolation);
  }
  // Serialization (in static context, because of constructor invocation
  // and automatic invocation of .toJSON):
  static toJSON(e) {
    const t = e.constructor;
    let i;
    if (t.toJSON !== this.toJSON)
      i = t.toJSON(e);
    else {
      i = {
        name: e.name,
        times: _a(e.times, Array),
        values: _a(e.values, Array)
      };
      const n = e.getInterpolation();
      n !== e.DefaultInterpolation && (i.interpolation = n);
    }
    return i.type = e.ValueTypeName, i;
  }
  InterpolantFactoryMethodDiscrete(e) {
    return new Vy(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodLinear(e) {
    return new Bd(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodSmooth(e) {
    return new Uy(this.times, this.values, this.getValueSize(), e);
  }
  setInterpolation(e) {
    let t;
    switch (e) {
      case vr:
        t = this.InterpolantFactoryMethodDiscrete;
        break;
      case Cs:
        t = this.InterpolantFactoryMethodLinear;
        break;
      case fo:
        t = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (t === void 0) {
      const i = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
      if (this.createInterpolant === void 0)
        if (e !== this.DefaultInterpolation)
          this.setInterpolation(this.DefaultInterpolation);
        else
          throw new Error(i);
      return console.warn("THREE.KeyframeTrack:", i), this;
    }
    return this.createInterpolant = t, this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return vr;
      case this.InterpolantFactoryMethodLinear:
        return Cs;
      case this.InterpolantFactoryMethodSmooth:
        return fo;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  // move all keyframes either forwards or backwards in time
  shift(e) {
    if (e !== 0) {
      const t = this.times;
      for (let i = 0, n = t.length; i !== n; ++i)
        t[i] += e;
    }
    return this;
  }
  // scale all keyframe times by a factor (useful for frame <-> seconds conversions)
  scale(e) {
    if (e !== 1) {
      const t = this.times;
      for (let i = 0, n = t.length; i !== n; ++i)
        t[i] *= e;
    }
    return this;
  }
  // removes keyframes before and after animation without changing any values within the range [startTime, endTime].
  // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
  trim(e, t) {
    const i = this.times, n = i.length;
    let s = 0, r = n - 1;
    for (; s !== n && i[s] < e; )
      ++s;
    for (; r !== -1 && i[r] > t; )
      --r;
    if (++r, s !== 0 || r !== n) {
      s >= r && (r = Math.max(r, 1), s = r - 1);
      const a = this.getValueSize();
      this.times = Qi(i, s, r), this.values = Qi(this.values, s * a, r * a);
    }
    return this;
  }
  // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
  validate() {
    let e = !0;
    const t = this.getValueSize();
    t - Math.floor(t) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1);
    const i = this.times, n = this.values, s = i.length;
    s === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1);
    let r = null;
    for (let a = 0; a !== s; a++) {
      const l = i[a];
      if (typeof l == "number" && isNaN(l)) {
        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, a, l), e = !1;
        break;
      }
      if (r !== null && r > l) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, a, l, r), e = !1;
        break;
      }
      r = l;
    }
    if (n !== void 0 && zd(n))
      for (let a = 0, l = n.length; a !== l; ++a) {
        const c = n[a];
        if (isNaN(c)) {
          console.error("THREE.KeyframeTrack: Value is not a valid number.", this, a, c), e = !1;
          break;
        }
      }
    return e;
  }
  // removes equivalent sequential keys as common in morph target sequences
  // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
  optimize() {
    const e = Qi(this.times), t = Qi(this.values), i = this.getValueSize(), n = this.getInterpolation() === fo, s = e.length - 1;
    let r = 1;
    for (let a = 1; a < s; ++a) {
      let l = !1;
      const c = e[a], h = e[a + 1];
      if (c !== h && (a !== 1 || c !== e[0]))
        if (n)
          l = !0;
        else {
          const u = a * i, d = u - i, f = u + i;
          for (let m = 0; m !== i; ++m) {
            const _ = t[u + m];
            if (_ !== t[d + m] || _ !== t[f + m]) {
              l = !0;
              break;
            }
          }
        }
      if (l) {
        if (a !== r) {
          e[r] = e[a];
          const u = a * i, d = r * i;
          for (let f = 0; f !== i; ++f)
            t[d + f] = t[u + f];
        }
        ++r;
      }
    }
    if (s > 0) {
      e[r] = e[s];
      for (let a = s * i, l = r * i, c = 0; c !== i; ++c)
        t[l + c] = t[a + c];
      ++r;
    }
    return r !== e.length ? (this.times = Qi(e, 0, r), this.values = Qi(t, 0, r * i)) : (this.times = e, this.values = t), this;
  }
  clone() {
    const e = Qi(this.times, 0), t = Qi(this.values, 0), i = this.constructor, n = new i(this.name, e, t);
    return n.createInterpolant = this.createInterpolant, n;
  }
}
Li.prototype.TimeBufferType = Float32Array;
Li.prototype.ValueBufferType = Float32Array;
Li.prototype.DefaultInterpolation = Cs;
class Bs extends Li {
}
Bs.prototype.ValueTypeName = "bool";
Bs.prototype.ValueBufferType = Array;
Bs.prototype.DefaultInterpolation = vr;
Bs.prototype.InterpolantFactoryMethodLinear = void 0;
Bs.prototype.InterpolantFactoryMethodSmooth = void 0;
class Ud extends Li {
}
Ud.prototype.ValueTypeName = "color";
class Ps extends Li {
}
Ps.prototype.ValueTypeName = "number";
class Gy extends Dr {
  constructor(e, t, i, n) {
    super(e, t, i, n);
  }
  interpolate_(e, t, i, n) {
    const s = this.resultBuffer, r = this.sampleValues, a = this.valueSize, l = (i - t) / (n - t);
    let c = e * a;
    for (let h = c + a; c !== h; c += 4)
      Et.slerpFlat(s, 0, r, c - a, r, c, l);
    return s;
  }
}
class _n extends Li {
  InterpolantFactoryMethodLinear(e) {
    return new Gy(this.times, this.values, this.getValueSize(), e);
  }
}
_n.prototype.ValueTypeName = "quaternion";
_n.prototype.DefaultInterpolation = Cs;
_n.prototype.InterpolantFactoryMethodSmooth = void 0;
class Us extends Li {
}
Us.prototype.ValueTypeName = "string";
Us.prototype.ValueBufferType = Array;
Us.prototype.DefaultInterpolation = vr;
Us.prototype.InterpolantFactoryMethodLinear = void 0;
Us.prototype.InterpolantFactoryMethodSmooth = void 0;
class Rs extends Li {
}
Rs.prototype.ValueTypeName = "vector";
class Is {
  constructor(e, t = -1, i, n = zl) {
    this.name = e, this.tracks = i, this.duration = t, this.blendMode = n, this.uuid = li(), this.duration < 0 && this.resetDuration();
  }
  static parse(e) {
    const t = [], i = e.tracks, n = 1 / (e.fps || 1);
    for (let r = 0, a = i.length; r !== a; ++r)
      t.push(Wy(i[r]).scale(n));
    const s = new this(e.name, e.duration, t, e.blendMode);
    return s.uuid = e.uuid, s;
  }
  static toJSON(e) {
    const t = [], i = e.tracks, n = {
      name: e.name,
      duration: e.duration,
      tracks: t,
      uuid: e.uuid,
      blendMode: e.blendMode
    };
    for (let s = 0, r = i.length; s !== r; ++s)
      t.push(Li.toJSON(i[s]));
    return n;
  }
  static CreateFromMorphTargetSequence(e, t, i, n) {
    const s = t.length, r = [];
    for (let a = 0; a < s; a++) {
      let l = [], c = [];
      l.push(
        (a + s - 1) % s,
        a,
        (a + 1) % s
      ), c.push(0, 1, 0);
      const h = By(l);
      l = au(l, 1, h), c = au(c, 1, h), !n && l[0] === 0 && (l.push(s), c.push(c[0])), r.push(
        new Ps(
          ".morphTargetInfluences[" + t[a].name + "]",
          l,
          c
        ).scale(1 / i)
      );
    }
    return new this(e, -1, r);
  }
  static findByName(e, t) {
    let i = e;
    if (!Array.isArray(e)) {
      const n = e;
      i = n.geometry && n.geometry.animations || n.animations;
    }
    for (let n = 0; n < i.length; n++)
      if (i[n].name === t)
        return i[n];
    return null;
  }
  static CreateClipsFromMorphTargetSequences(e, t, i) {
    const n = {}, s = /^([\w-]*?)([\d]+)$/;
    for (let a = 0, l = e.length; a < l; a++) {
      const c = e[a], h = c.name.match(s);
      if (h && h.length > 1) {
        const u = h[1];
        let d = n[u];
        d || (n[u] = d = []), d.push(c);
      }
    }
    const r = [];
    for (const a in n)
      r.push(this.CreateFromMorphTargetSequence(a, n[a], t, i));
    return r;
  }
  // parse the animation.hierarchy format
  static parseAnimation(e, t) {
    if (!e)
      return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
    const i = function(u, d, f, m, _) {
      if (f.length !== 0) {
        const p = [], g = [];
        Fd(f, p, g, m), p.length !== 0 && _.push(new u(d, p, g));
      }
    }, n = [], s = e.name || "default", r = e.fps || 30, a = e.blendMode;
    let l = e.length || -1;
    const c = e.hierarchy || [];
    for (let u = 0; u < c.length; u++) {
      const d = c[u].keys;
      if (!(!d || d.length === 0))
        if (d[0].morphTargets) {
          const f = {};
          let m;
          for (m = 0; m < d.length; m++)
            if (d[m].morphTargets)
              for (let _ = 0; _ < d[m].morphTargets.length; _++)
                f[d[m].morphTargets[_]] = -1;
          for (const _ in f) {
            const p = [], g = [];
            for (let x = 0; x !== d[m].morphTargets.length; ++x) {
              const y = d[m];
              p.push(y.time), g.push(y.morphTarget === _ ? 1 : 0);
            }
            n.push(new Ps(".morphTargetInfluence[" + _ + "]", p, g));
          }
          l = f.length * r;
        } else {
          const f = ".bones[" + t[u].name + "]";
          i(
            Rs,
            f + ".position",
            d,
            "pos",
            n
          ), i(
            _n,
            f + ".quaternion",
            d,
            "rot",
            n
          ), i(
            Rs,
            f + ".scale",
            d,
            "scl",
            n
          );
        }
    }
    return n.length === 0 ? null : new this(s, l, n, a);
  }
  resetDuration() {
    const e = this.tracks;
    let t = 0;
    for (let i = 0, n = e.length; i !== n; ++i) {
      const s = this.tracks[i];
      t = Math.max(t, s.times[s.times.length - 1]);
    }
    return this.duration = t, this;
  }
  trim() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].trim(0, this.duration);
    return this;
  }
  validate() {
    let e = !0;
    for (let t = 0; t < this.tracks.length; t++)
      e = e && this.tracks[t].validate();
    return e;
  }
  optimize() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].optimize();
    return this;
  }
  clone() {
    const e = [];
    for (let t = 0; t < this.tracks.length; t++)
      e.push(this.tracks[t].clone());
    return new this.constructor(this.name, this.duration, e, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
}
function Hy(o) {
  switch (o.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return Ps;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return Rs;
    case "color":
      return Ud;
    case "quaternion":
      return _n;
    case "bool":
    case "boolean":
      return Bs;
    case "string":
      return Us;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + o);
}
function Wy(o) {
  if (o.type === void 0)
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  const e = Hy(o.type);
  if (o.times === void 0) {
    const t = [], i = [];
    Fd(o.keys, t, i, "value"), o.times = t, o.values = i;
  }
  return e.parse !== void 0 ? e.parse(o) : new e(o.name, o.times, o.values, o.interpolation);
}
const Ds = {
  enabled: !1,
  files: {},
  add: function(o, e) {
    this.enabled !== !1 && (this.files[o] = e);
  },
  get: function(o) {
    if (this.enabled !== !1)
      return this.files[o];
  },
  remove: function(o) {
    delete this.files[o];
  },
  clear: function() {
    this.files = {};
  }
};
class mc {
  constructor(e, t, i) {
    const n = this;
    let s = !1, r = 0, a = 0, l;
    const c = [];
    this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = i, this.itemStart = function(h) {
      a++, s === !1 && n.onStart !== void 0 && n.onStart(h, r, a), s = !0;
    }, this.itemEnd = function(h) {
      r++, n.onProgress !== void 0 && n.onProgress(h, r, a), r === a && (s = !1, n.onLoad !== void 0 && n.onLoad());
    }, this.itemError = function(h) {
      n.onError !== void 0 && n.onError(h);
    }, this.resolveURL = function(h) {
      return l ? l(h) : h;
    }, this.setURLModifier = function(h) {
      return l = h, this;
    }, this.addHandler = function(h, u) {
      return c.push(h, u), this;
    }, this.removeHandler = function(h) {
      const u = c.indexOf(h);
      return u !== -1 && c.splice(u, 2), this;
    }, this.getHandler = function(h) {
      for (let u = 0, d = c.length; u < d; u += 2) {
        const f = c[u], m = c[u + 1];
        if (f.global && (f.lastIndex = 0), f.test(h))
          return m;
      }
      return null;
    };
  }
}
const Vs = /* @__PURE__ */ new mc();
class xi {
  constructor(e) {
    this.manager = e !== void 0 ? e : Vs, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {};
  }
  load() {
  }
  loadAsync(e, t) {
    const i = this;
    return new Promise(function(n, s) {
      i.load(e, n, t, s);
    });
  }
  parse() {
  }
  setCrossOrigin(e) {
    return this.crossOrigin = e, this;
  }
  setWithCredentials(e) {
    return this.withCredentials = e, this;
  }
  setPath(e) {
    return this.path = e, this;
  }
  setResourcePath(e) {
    return this.resourcePath = e, this;
  }
  setRequestHeader(e) {
    return this.requestHeader = e, this;
  }
}
const zi = {};
class Xy extends Error {
  constructor(e, t) {
    super(e), this.response = t;
  }
}
class Ai extends xi {
  constructor(e) {
    super(e);
  }
  load(e, t, i, n) {
    e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const s = Ds.get(e);
    if (s !== void 0)
      return this.manager.itemStart(e), setTimeout(() => {
        t && t(s), this.manager.itemEnd(e);
      }, 0), s;
    if (zi[e] !== void 0) {
      zi[e].push({
        onLoad: t,
        onProgress: i,
        onError: n
      });
      return;
    }
    zi[e] = [], zi[e].push({
      onLoad: t,
      onProgress: i,
      onError: n
    });
    const r = new Request(e, {
      headers: new Headers(this.requestHeader),
      credentials: this.withCredentials ? "include" : "same-origin"
      // An abort controller could be added within a future PR
    }), a = this.mimeType, l = this.responseType;
    fetch(r).then((c) => {
      if (c.status === 200 || c.status === 0) {
        if (c.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."), typeof ReadableStream > "u" || c.body === void 0 || c.body.getReader === void 0)
          return c;
        const h = zi[e], u = c.body.getReader(), d = c.headers.get("Content-Length") || c.headers.get("X-File-Size"), f = d ? parseInt(d) : 0, m = f !== 0;
        let _ = 0;
        const p = new ReadableStream({
          start(g) {
            x();
            function x() {
              u.read().then(({ done: y, value: v }) => {
                if (y)
                  g.close();
                else {
                  _ += v.byteLength;
                  const M = new ProgressEvent("progress", { lengthComputable: m, loaded: _, total: f });
                  for (let S = 0, A = h.length; S < A; S++) {
                    const w = h[S];
                    w.onProgress && w.onProgress(M);
                  }
                  g.enqueue(v), x();
                }
              });
            }
          }
        });
        return new Response(p);
      } else
        throw new Xy(`fetch for "${c.url}" responded with ${c.status}: ${c.statusText}`, c);
    }).then((c) => {
      switch (l) {
        case "arraybuffer":
          return c.arrayBuffer();
        case "blob":
          return c.blob();
        case "document":
          return c.text().then((h) => new DOMParser().parseFromString(h, a));
        case "json":
          return c.json();
        default:
          if (a === void 0)
            return c.text();
          {
            const u = /charset="?([^;"\s]*)"?/i.exec(a), d = u && u[1] ? u[1].toLowerCase() : void 0, f = new TextDecoder(d);
            return c.arrayBuffer().then((m) => f.decode(m));
          }
      }
    }).then((c) => {
      Ds.add(e, c);
      const h = zi[e];
      delete zi[e];
      for (let u = 0, d = h.length; u < d; u++) {
        const f = h[u];
        f.onLoad && f.onLoad(c);
      }
    }).catch((c) => {
      const h = zi[e];
      if (h === void 0)
        throw this.manager.itemError(e), c;
      delete zi[e];
      for (let u = 0, d = h.length; u < d; u++) {
        const f = h[u];
        f.onError && f.onError(c);
      }
      this.manager.itemError(e);
    }).finally(() => {
      this.manager.itemEnd(e);
    }), this.manager.itemStart(e);
  }
  setResponseType(e) {
    return this.responseType = e, this;
  }
  setMimeType(e) {
    return this.mimeType = e, this;
  }
}
class Ga extends xi {
  constructor(e) {
    super(e);
  }
  load(e, t, i, n) {
    this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const s = this, r = Ds.get(e);
    if (r !== void 0)
      return s.manager.itemStart(e), setTimeout(function() {
        t && t(r), s.manager.itemEnd(e);
      }, 0), r;
    const a = wr("img");
    function l() {
      h(), Ds.add(e, this), t && t(this), s.manager.itemEnd(e);
    }
    function c(u) {
      h(), n && n(u), s.manager.itemError(e), s.manager.itemEnd(e);
    }
    function h() {
      a.removeEventListener("load", l, !1), a.removeEventListener("error", c, !1);
    }
    return a.addEventListener("load", l, !1), a.addEventListener("error", c, !1), e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (a.crossOrigin = this.crossOrigin), s.manager.itemStart(e), a.src = e, a;
  }
}
class qy extends xi {
  constructor(e) {
    super(e);
  }
  load(e, t, i, n) {
    const s = new Za(), r = new Ga(this.manager);
    r.setCrossOrigin(this.crossOrigin), r.setPath(this.path);
    let a = 0;
    function l(c) {
      r.load(e[c], function(h) {
        s.images[c] = h, a++, a === 6 && (s.needsUpdate = !0, t && t(s));
      }, void 0, n);
    }
    for (let c = 0; c < e.length; ++c)
      l(c);
    return s;
  }
}
class fr extends xi {
  constructor(e) {
    super(e);
  }
  load(e, t, i, n) {
    const s = new dt(), r = new Ga(this.manager);
    return r.setCrossOrigin(this.crossOrigin), r.setPath(this.path), r.load(e, function(a) {
      s.image = a, s.needsUpdate = !0, t !== void 0 && t(s);
    }, i, n), s;
  }
}
class vi extends tt {
  constructor(e, t = 1) {
    super(), this.isLight = !0, this.type = "Light", this.color = new de(e), this.intensity = t;
  }
  dispose() {
  }
  copy(e, t) {
    return super.copy(e, t), this.color.copy(e.color), this.intensity = e.intensity, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (t.object.distance = this.distance), this.angle !== void 0 && (t.object.angle = this.angle), this.decay !== void 0 && (t.object.decay = this.decay), this.penumbra !== void 0 && (t.object.penumbra = this.penumbra), this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()), t;
  }
}
class jy extends vi {
  constructor(e, t, i) {
    super(e, i), this.isHemisphereLight = !0, this.type = "HemisphereLight", this.position.copy(tt.DefaultUp), this.updateMatrix(), this.groundColor = new de(t);
  }
  copy(e, t) {
    return super.copy(e, t), this.groundColor.copy(e.groundColor), this;
  }
}
const Xo = /* @__PURE__ */ new ue(), ou = /* @__PURE__ */ new b(), lu = /* @__PURE__ */ new b();
class _c {
  constructor(e) {
    this.camera = e, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new G(512, 512), this.map = null, this.mapPass = null, this.matrix = new ue(), this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new Ja(), this._frameExtents = new G(1, 1), this._viewportCount = 1, this._viewports = [
      new We(0, 0, 1, 1)
    ];
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(e) {
    const t = this.camera, i = this.matrix;
    ou.setFromMatrixPosition(e.matrixWorld), t.position.copy(ou), lu.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(lu), t.updateMatrixWorld(), Xo.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Xo), i.set(
      0.5,
      0,
      0,
      0.5,
      0,
      0.5,
      0,
      0.5,
      0,
      0,
      0.5,
      0.5,
      0,
      0,
      0,
      1
    ), i.multiply(Xo);
  }
  getViewport(e) {
    return this._viewports[e];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(e) {
    return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const e = {};
    return this.bias !== 0 && (e.bias = this.bias), this.normalBias !== 0 && (e.normalBias = this.normalBias), this.radius !== 1 && (e.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e;
  }
}
class Yy extends _c {
  constructor() {
    super(new gt(50, 1, 0.5, 500)), this.isSpotLightShadow = !0, this.focus = 1;
  }
  updateMatrices(e) {
    const t = this.camera, i = xr * 2 * e.angle * this.focus, n = this.mapSize.width / this.mapSize.height, s = e.distance || t.far;
    (i !== t.fov || n !== t.aspect || s !== t.far) && (t.fov = i, t.aspect = n, t.far = s, t.updateProjectionMatrix()), super.updateMatrices(e);
  }
  copy(e) {
    return super.copy(e), this.focus = e.focus, this;
  }
}
class gc extends vi {
  constructor(e, t, i = 0, n = Math.PI / 3, s = 0, r = 2) {
    super(e, t), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(tt.DefaultUp), this.updateMatrix(), this.target = new tt(), this.distance = i, this.angle = n, this.penumbra = s, this.decay = r, this.map = null, this.shadow = new Yy();
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(e) {
    this.intensity = e / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return super.copy(e, t), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
  }
}
const cu = /* @__PURE__ */ new ue(), er = /* @__PURE__ */ new b(), qo = /* @__PURE__ */ new b();
class Zy extends _c {
  constructor() {
    super(new gt(90, 1, 0.5, 500)), this.isPointLightShadow = !0, this._frameExtents = new G(4, 2), this._viewportCount = 6, this._viewports = [
      // These viewports map a cube-map onto a 2D texture with the
      // following orientation:
      //
      //  xzXZ
      //   y Y
      //
      // X - Positive x direction
      // x - Negative x direction
      // Y - Positive y direction
      // y - Negative y direction
      // Z - Positive z direction
      // z - Negative z direction
      // positive X
      new We(2, 1, 1, 1),
      // negative X
      new We(0, 1, 1, 1),
      // positive Z
      new We(3, 1, 1, 1),
      // negative Z
      new We(1, 1, 1, 1),
      // positive Y
      new We(3, 0, 1, 1),
      // negative Y
      new We(1, 0, 1, 1)
    ], this._cubeDirections = [
      new b(1, 0, 0),
      new b(-1, 0, 0),
      new b(0, 0, 1),
      new b(0, 0, -1),
      new b(0, 1, 0),
      new b(0, -1, 0)
    ], this._cubeUps = [
      new b(0, 1, 0),
      new b(0, 1, 0),
      new b(0, 1, 0),
      new b(0, 1, 0),
      new b(0, 0, 1),
      new b(0, 0, -1)
    ];
  }
  updateMatrices(e, t = 0) {
    const i = this.camera, n = this.matrix, s = e.distance || i.far;
    s !== i.far && (i.far = s, i.updateProjectionMatrix()), er.setFromMatrixPosition(e.matrixWorld), i.position.copy(er), qo.copy(i.position), qo.add(this._cubeDirections[t]), i.up.copy(this._cubeUps[t]), i.lookAt(qo), i.updateMatrixWorld(), n.makeTranslation(-er.x, -er.y, -er.z), cu.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse), this._frustum.setFromProjectionMatrix(cu);
  }
}
class Ha extends vi {
  constructor(e, t, i = 0, n = 2) {
    super(e, t), this.isPointLight = !0, this.type = "PointLight", this.distance = i, this.decay = n, this.shadow = new Zy();
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(e) {
    this.intensity = e / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return super.copy(e, t), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this;
  }
}
class Jy extends _c {
  constructor() {
    super(new pn(-5, 5, 5, -5, 0.5, 500)), this.isDirectionalLightShadow = !0;
  }
}
class vc extends vi {
  constructor(e, t) {
    super(e, t), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(tt.DefaultUp), this.updateMatrix(), this.target = new tt(), this.shadow = new Jy();
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e) {
    return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
  }
}
class Vd extends vi {
  constructor(e, t) {
    super(e, t), this.isAmbientLight = !0, this.type = "AmbientLight";
  }
}
class Ky extends vi {
  constructor(e, t, i = 10, n = 10) {
    super(e, t), this.isRectAreaLight = !0, this.type = "RectAreaLight", this.width = i, this.height = n;
  }
  get power() {
    return this.intensity * this.width * this.height * Math.PI;
  }
  set power(e) {
    this.intensity = e / (this.width * this.height * Math.PI);
  }
  copy(e) {
    return super.copy(e), this.width = e.width, this.height = e.height, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.width = this.width, t.object.height = this.height, t;
  }
}
class $y {
  constructor() {
    this.isSphericalHarmonics3 = !0, this.coefficients = [];
    for (let e = 0; e < 9; e++)
      this.coefficients.push(new b());
  }
  set(e) {
    for (let t = 0; t < 9; t++)
      this.coefficients[t].copy(e[t]);
    return this;
  }
  zero() {
    for (let e = 0; e < 9; e++)
      this.coefficients[e].set(0, 0, 0);
    return this;
  }
  // get the radiance in the direction of the normal
  // target is a Vector3
  getAt(e, t) {
    const i = e.x, n = e.y, s = e.z, r = this.coefficients;
    return t.copy(r[0]).multiplyScalar(0.282095), t.addScaledVector(r[1], 0.488603 * n), t.addScaledVector(r[2], 0.488603 * s), t.addScaledVector(r[3], 0.488603 * i), t.addScaledVector(r[4], 1.092548 * (i * n)), t.addScaledVector(r[5], 1.092548 * (n * s)), t.addScaledVector(r[6], 0.315392 * (3 * s * s - 1)), t.addScaledVector(r[7], 1.092548 * (i * s)), t.addScaledVector(r[8], 0.546274 * (i * i - n * n)), t;
  }
  // get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
  // target is a Vector3
  // https://graphics.stanford.edu/papers/envmap/envmap.pdf
  getIrradianceAt(e, t) {
    const i = e.x, n = e.y, s = e.z, r = this.coefficients;
    return t.copy(r[0]).multiplyScalar(0.886227), t.addScaledVector(r[1], 2 * 0.511664 * n), t.addScaledVector(r[2], 2 * 0.511664 * s), t.addScaledVector(r[3], 2 * 0.511664 * i), t.addScaledVector(r[4], 2 * 0.429043 * i * n), t.addScaledVector(r[5], 2 * 0.429043 * n * s), t.addScaledVector(r[6], 0.743125 * s * s - 0.247708), t.addScaledVector(r[7], 2 * 0.429043 * i * s), t.addScaledVector(r[8], 0.429043 * (i * i - n * n)), t;
  }
  add(e) {
    for (let t = 0; t < 9; t++)
      this.coefficients[t].add(e.coefficients[t]);
    return this;
  }
  addScaledSH(e, t) {
    for (let i = 0; i < 9; i++)
      this.coefficients[i].addScaledVector(e.coefficients[i], t);
    return this;
  }
  scale(e) {
    for (let t = 0; t < 9; t++)
      this.coefficients[t].multiplyScalar(e);
    return this;
  }
  lerp(e, t) {
    for (let i = 0; i < 9; i++)
      this.coefficients[i].lerp(e.coefficients[i], t);
    return this;
  }
  equals(e) {
    for (let t = 0; t < 9; t++)
      if (!this.coefficients[t].equals(e.coefficients[t]))
        return !1;
    return !0;
  }
  copy(e) {
    return this.set(e.coefficients);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(e, t = 0) {
    const i = this.coefficients;
    for (let n = 0; n < 9; n++)
      i[n].fromArray(e, t + n * 3);
    return this;
  }
  toArray(e = [], t = 0) {
    const i = this.coefficients;
    for (let n = 0; n < 9; n++)
      i[n].toArray(e, t + n * 3);
    return e;
  }
  // evaluate the basis functions
  // shBasis is an Array[ 9 ]
  static getBasisAt(e, t) {
    const i = e.x, n = e.y, s = e.z;
    t[0] = 0.282095, t[1] = 0.488603 * n, t[2] = 0.488603 * s, t[3] = 0.488603 * i, t[4] = 1.092548 * i * n, t[5] = 1.092548 * n * s, t[6] = 0.315392 * (3 * s * s - 1), t[7] = 1.092548 * i * s, t[8] = 0.546274 * (i * i - n * n);
  }
}
class Qy extends vi {
  constructor(e = new $y(), t = 1) {
    super(void 0, t), this.isLightProbe = !0, this.sh = e;
  }
  copy(e) {
    return super.copy(e), this.sh.copy(e.sh), this;
  }
  fromJSON(e) {
    return this.intensity = e.intensity, this.sh.fromArray(e.sh), this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.sh = this.sh.toArray(), t;
  }
}
class yc extends xi {
  constructor(e) {
    super(e), this.textures = {};
  }
  load(e, t, i, n) {
    const s = this, r = new Ai(s.manager);
    r.setPath(s.path), r.setRequestHeader(s.requestHeader), r.setWithCredentials(s.withCredentials), r.load(e, function(a) {
      try {
        t(s.parse(JSON.parse(a)));
      } catch (l) {
        n ? n(l) : console.error(l), s.manager.itemError(e);
      }
    }, i, n);
  }
  parse(e) {
    const t = this.textures;
    function i(s) {
      return t[s] === void 0 && console.warn("THREE.MaterialLoader: Undefined texture", s), t[s];
    }
    const n = yc.createMaterialFromType(e.type);
    if (e.uuid !== void 0 && (n.uuid = e.uuid), e.name !== void 0 && (n.name = e.name), e.color !== void 0 && n.color !== void 0 && n.color.setHex(e.color), e.roughness !== void 0 && (n.roughness = e.roughness), e.metalness !== void 0 && (n.metalness = e.metalness), e.sheen !== void 0 && (n.sheen = e.sheen), e.sheenColor !== void 0 && (n.sheenColor = new de().setHex(e.sheenColor)), e.sheenRoughness !== void 0 && (n.sheenRoughness = e.sheenRoughness), e.emissive !== void 0 && n.emissive !== void 0 && n.emissive.setHex(e.emissive), e.specular !== void 0 && n.specular !== void 0 && n.specular.setHex(e.specular), e.specularIntensity !== void 0 && (n.specularIntensity = e.specularIntensity), e.specularColor !== void 0 && n.specularColor !== void 0 && n.specularColor.setHex(e.specularColor), e.shininess !== void 0 && (n.shininess = e.shininess), e.clearcoat !== void 0 && (n.clearcoat = e.clearcoat), e.clearcoatRoughness !== void 0 && (n.clearcoatRoughness = e.clearcoatRoughness), e.iridescence !== void 0 && (n.iridescence = e.iridescence), e.iridescenceIOR !== void 0 && (n.iridescenceIOR = e.iridescenceIOR), e.iridescenceThicknessRange !== void 0 && (n.iridescenceThicknessRange = e.iridescenceThicknessRange), e.transmission !== void 0 && (n.transmission = e.transmission), e.thickness !== void 0 && (n.thickness = e.thickness), e.attenuationDistance !== void 0 && (n.attenuationDistance = e.attenuationDistance), e.attenuationColor !== void 0 && n.attenuationColor !== void 0 && n.attenuationColor.setHex(e.attenuationColor), e.fog !== void 0 && (n.fog = e.fog), e.flatShading !== void 0 && (n.flatShading = e.flatShading), e.blending !== void 0 && (n.blending = e.blending), e.combine !== void 0 && (n.combine = e.combine), e.side !== void 0 && (n.side = e.side), e.shadowSide !== void 0 && (n.shadowSide = e.shadowSide), e.opacity !== void 0 && (n.opacity = e.opacity), e.transparent !== void 0 && (n.transparent = e.transparent), e.alphaTest !== void 0 && (n.alphaTest = e.alphaTest), e.depthTest !== void 0 && (n.depthTest = e.depthTest), e.depthWrite !== void 0 && (n.depthWrite = e.depthWrite), e.colorWrite !== void 0 && (n.colorWrite = e.colorWrite), e.stencilWrite !== void 0 && (n.stencilWrite = e.stencilWrite), e.stencilWriteMask !== void 0 && (n.stencilWriteMask = e.stencilWriteMask), e.stencilFunc !== void 0 && (n.stencilFunc = e.stencilFunc), e.stencilRef !== void 0 && (n.stencilRef = e.stencilRef), e.stencilFuncMask !== void 0 && (n.stencilFuncMask = e.stencilFuncMask), e.stencilFail !== void 0 && (n.stencilFail = e.stencilFail), e.stencilZFail !== void 0 && (n.stencilZFail = e.stencilZFail), e.stencilZPass !== void 0 && (n.stencilZPass = e.stencilZPass), e.wireframe !== void 0 && (n.wireframe = e.wireframe), e.wireframeLinewidth !== void 0 && (n.wireframeLinewidth = e.wireframeLinewidth), e.wireframeLinecap !== void 0 && (n.wireframeLinecap = e.wireframeLinecap), e.wireframeLinejoin !== void 0 && (n.wireframeLinejoin = e.wireframeLinejoin), e.rotation !== void 0 && (n.rotation = e.rotation), e.linewidth !== 1 && (n.linewidth = e.linewidth), e.dashSize !== void 0 && (n.dashSize = e.dashSize), e.gapSize !== void 0 && (n.gapSize = e.gapSize), e.scale !== void 0 && (n.scale = e.scale), e.polygonOffset !== void 0 && (n.polygonOffset = e.polygonOffset), e.polygonOffsetFactor !== void 0 && (n.polygonOffsetFactor = e.polygonOffsetFactor), e.polygonOffsetUnits !== void 0 && (n.polygonOffsetUnits = e.polygonOffsetUnits), e.dithering !== void 0 && (n.dithering = e.dithering), e.alphaToCoverage !== void 0 && (n.alphaToCoverage = e.alphaToCoverage), e.premultipliedAlpha !== void 0 && (n.premultipliedAlpha = e.premultipliedAlpha), e.visible !== void 0 && (n.visible = e.visible), e.toneMapped !== void 0 && (n.toneMapped = e.toneMapped), e.userData !== void 0 && (n.userData = e.userData), e.vertexColors !== void 0 && (typeof e.vertexColors == "number" ? n.vertexColors = e.vertexColors > 0 : n.vertexColors = e.vertexColors), e.uniforms !== void 0)
      for (const s in e.uniforms) {
        const r = e.uniforms[s];
        switch (n.uniforms[s] = {}, r.type) {
          case "t":
            n.uniforms[s].value = i(r.value);
            break;
          case "c":
            n.uniforms[s].value = new de().setHex(r.value);
            break;
          case "v2":
            n.uniforms[s].value = new G().fromArray(r.value);
            break;
          case "v3":
            n.uniforms[s].value = new b().fromArray(r.value);
            break;
          case "v4":
            n.uniforms[s].value = new We().fromArray(r.value);
            break;
          case "m3":
            n.uniforms[s].value = new Gt().fromArray(r.value);
            break;
          case "m4":
            n.uniforms[s].value = new ue().fromArray(r.value);
            break;
          default:
            n.uniforms[s].value = r.value;
        }
      }
    if (e.defines !== void 0 && (n.defines = e.defines), e.vertexShader !== void 0 && (n.vertexShader = e.vertexShader), e.fragmentShader !== void 0 && (n.fragmentShader = e.fragmentShader), e.glslVersion !== void 0 && (n.glslVersion = e.glslVersion), e.extensions !== void 0)
      for (const s in e.extensions)
        n.extensions[s] = e.extensions[s];
    if (e.size !== void 0 && (n.size = e.size), e.sizeAttenuation !== void 0 && (n.sizeAttenuation = e.sizeAttenuation), e.map !== void 0 && (n.map = i(e.map)), e.matcap !== void 0 && (n.matcap = i(e.matcap)), e.alphaMap !== void 0 && (n.alphaMap = i(e.alphaMap)), e.bumpMap !== void 0 && (n.bumpMap = i(e.bumpMap)), e.bumpScale !== void 0 && (n.bumpScale = e.bumpScale), e.normalMap !== void 0 && (n.normalMap = i(e.normalMap)), e.normalMapType !== void 0 && (n.normalMapType = e.normalMapType), e.normalScale !== void 0) {
      let s = e.normalScale;
      Array.isArray(s) === !1 && (s = [s, s]), n.normalScale = new G().fromArray(s);
    }
    return e.displacementMap !== void 0 && (n.displacementMap = i(e.displacementMap)), e.displacementScale !== void 0 && (n.displacementScale = e.displacementScale), e.displacementBias !== void 0 && (n.displacementBias = e.displacementBias), e.roughnessMap !== void 0 && (n.roughnessMap = i(e.roughnessMap)), e.metalnessMap !== void 0 && (n.metalnessMap = i(e.metalnessMap)), e.emissiveMap !== void 0 && (n.emissiveMap = i(e.emissiveMap)), e.emissiveIntensity !== void 0 && (n.emissiveIntensity = e.emissiveIntensity), e.specularMap !== void 0 && (n.specularMap = i(e.specularMap)), e.specularIntensityMap !== void 0 && (n.specularIntensityMap = i(e.specularIntensityMap)), e.specularColorMap !== void 0 && (n.specularColorMap = i(e.specularColorMap)), e.envMap !== void 0 && (n.envMap = i(e.envMap)), e.envMapIntensity !== void 0 && (n.envMapIntensity = e.envMapIntensity), e.reflectivity !== void 0 && (n.reflectivity = e.reflectivity), e.refractionRatio !== void 0 && (n.refractionRatio = e.refractionRatio), e.lightMap !== void 0 && (n.lightMap = i(e.lightMap)), e.lightMapIntensity !== void 0 && (n.lightMapIntensity = e.lightMapIntensity), e.aoMap !== void 0 && (n.aoMap = i(e.aoMap)), e.aoMapIntensity !== void 0 && (n.aoMapIntensity = e.aoMapIntensity), e.gradientMap !== void 0 && (n.gradientMap = i(e.gradientMap)), e.clearcoatMap !== void 0 && (n.clearcoatMap = i(e.clearcoatMap)), e.clearcoatRoughnessMap !== void 0 && (n.clearcoatRoughnessMap = i(e.clearcoatRoughnessMap)), e.clearcoatNormalMap !== void 0 && (n.clearcoatNormalMap = i(e.clearcoatNormalMap)), e.clearcoatNormalScale !== void 0 && (n.clearcoatNormalScale = new G().fromArray(e.clearcoatNormalScale)), e.iridescenceMap !== void 0 && (n.iridescenceMap = i(e.iridescenceMap)), e.iridescenceThicknessMap !== void 0 && (n.iridescenceThicknessMap = i(e.iridescenceThicknessMap)), e.transmissionMap !== void 0 && (n.transmissionMap = i(e.transmissionMap)), e.thicknessMap !== void 0 && (n.thicknessMap = i(e.thicknessMap)), e.sheenColorMap !== void 0 && (n.sheenColorMap = i(e.sheenColorMap)), e.sheenRoughnessMap !== void 0 && (n.sheenRoughnessMap = i(e.sheenRoughnessMap)), n;
  }
  setTextures(e) {
    return this.textures = e, this;
  }
  static createMaterialFromType(e) {
    const t = {
      ShadowMaterial: Dy,
      SpriteMaterial: Xl,
      RawShaderMaterial: Oy,
      ShaderMaterial: xt,
      PointsMaterial: Qa,
      MeshPhysicalMaterial: vn,
      MeshStandardMaterial: io,
      MeshPhongMaterial: Na,
      MeshToonMaterial: Ny,
      MeshNormalMaterial: ky,
      MeshLambertMaterial: kd,
      MeshDepthMaterial: Gl,
      MeshDistanceMaterial: Sd,
      MeshBasicMaterial: gi,
      MeshMatcapMaterial: zy,
      LineDashedMaterial: Fy,
      LineBasicMaterial: mn,
      Material: Ct
    };
    return new t[e]();
  }
}
class ci {
  static decodeText(e) {
    if (typeof TextDecoder < "u")
      return new TextDecoder().decode(e);
    let t = "";
    for (let i = 0, n = e.length; i < n; i++)
      t += String.fromCharCode(e[i]);
    try {
      return decodeURIComponent(escape(t));
    } catch {
      return t;
    }
  }
  static extractUrlBase(e) {
    const t = e.lastIndexOf("/");
    return t === -1 ? "./" : e.slice(0, t + 1);
  }
  static resolveURL(e, t) {
    return typeof e != "string" || e === "" ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e);
  }
}
class Gd extends Ue {
  constructor() {
    super(), this.isInstancedBufferGeometry = !0, this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0;
  }
  copy(e) {
    return super.copy(e), this.instanceCount = e.instanceCount, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.instanceCount = this.instanceCount, e.isInstancedBufferGeometry = !0, e;
  }
}
class ex extends xi {
  constructor(e) {
    super(e);
  }
  load(e, t, i, n) {
    const s = this, r = new Ai(s.manager);
    r.setPath(s.path), r.setRequestHeader(s.requestHeader), r.setWithCredentials(s.withCredentials), r.load(e, function(a) {
      try {
        t(s.parse(JSON.parse(a)));
      } catch (l) {
        n ? n(l) : console.error(l), s.manager.itemError(e);
      }
    }, i, n);
  }
  parse(e) {
    const t = {}, i = {};
    function n(f, m) {
      if (t[m] !== void 0) return t[m];
      const p = f.interleavedBuffers[m], g = s(f, p.buffer), x = gs(p.type, g), y = new $a(x, p.stride);
      return y.uuid = p.uuid, t[m] = y, y;
    }
    function s(f, m) {
      if (i[m] !== void 0) return i[m];
      const p = f.arrayBuffers[m], g = new Uint32Array(p).buffer;
      return i[m] = g, g;
    }
    const r = e.isInstancedBufferGeometry ? new Gd() : new Ue(), a = e.data.index;
    if (a !== void 0) {
      const f = gs(a.type, a.array);
      r.setIndex(new $e(f, 1));
    }
    const l = e.data.attributes;
    for (const f in l) {
      const m = l[f];
      let _;
      if (m.isInterleavedBufferAttribute) {
        const p = n(e.data, m.data);
        _ = new $t(p, m.itemSize, m.offset, m.normalized);
      } else {
        const p = gs(m.type, m.array), g = m.isInstancedBufferAttribute ? Mr : $e;
        _ = new g(p, m.itemSize, m.normalized);
      }
      m.name !== void 0 && (_.name = m.name), m.usage !== void 0 && _.setUsage(m.usage), m.updateRange !== void 0 && (_.updateRange.offset = m.updateRange.offset, _.updateRange.count = m.updateRange.count), r.setAttribute(f, _);
    }
    const c = e.data.morphAttributes;
    if (c)
      for (const f in c) {
        const m = c[f], _ = [];
        for (let p = 0, g = m.length; p < g; p++) {
          const x = m[p];
          let y;
          if (x.isInterleavedBufferAttribute) {
            const v = n(e.data, x.data);
            y = new $t(v, x.itemSize, x.offset, x.normalized);
          } else {
            const v = gs(x.type, x.array);
            y = new $e(v, x.itemSize, x.normalized);
          }
          x.name !== void 0 && (y.name = x.name), _.push(y);
        }
        r.morphAttributes[f] = _;
      }
    e.data.morphTargetsRelative && (r.morphTargetsRelative = !0);
    const u = e.data.groups || e.data.drawcalls || e.data.offsets;
    if (u !== void 0)
      for (let f = 0, m = u.length; f !== m; ++f) {
        const _ = u[f];
        r.addGroup(_.start, _.count, _.materialIndex);
      }
    const d = e.data.boundingSphere;
    if (d !== void 0) {
      const f = new b();
      d.center !== void 0 && f.fromArray(d.center), r.boundingSphere = new Ci(f, d.radius);
    }
    return e.name && (r.name = e.name), e.userData && (r.userData = e.userData), r;
  }
}
class Hd extends xi {
  constructor(e) {
    super(e);
  }
  load(e, t, i, n) {
    const s = this, r = this.path === "" ? ci.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || r;
    const a = new Ai(this.manager);
    a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(e, function(l) {
      let c = null;
      try {
        c = JSON.parse(l);
      } catch (u) {
        n !== void 0 && n(u), console.error("THREE:ObjectLoader: Can't parse " + e + ".", u.message);
        return;
      }
      const h = c.metadata;
      if (h === void 0 || h.type === void 0 || h.type.toLowerCase() === "geometry") {
        n !== void 0 && n(new Error("THREE.ObjectLoader: Can't load " + e)), console.error("THREE.ObjectLoader: Can't load " + e);
        return;
      }
      s.parse(c, t);
    }, i, n);
  }
  async loadAsync(e, t) {
    const i = this, n = this.path === "" ? ci.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || n;
    const s = new Ai(this.manager);
    s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials);
    const r = await s.loadAsync(e, t), a = JSON.parse(r), l = a.metadata;
    if (l === void 0 || l.type === void 0 || l.type.toLowerCase() === "geometry")
      throw new Error("THREE.ObjectLoader: Can't load " + e);
    return await i.parseAsync(a);
  }
  parse(e, t) {
    const i = this.parseAnimations(e.animations), n = this.parseShapes(e.shapes), s = this.parseGeometries(e.geometries, n), r = this.parseImages(e.images, function() {
      t !== void 0 && t(c);
    }), a = this.parseTextures(e.textures, r), l = this.parseMaterials(e.materials, a), c = this.parseObject(e.object, s, l, a, i), h = this.parseSkeletons(e.skeletons, c);
    if (this.bindSkeletons(c, h), t !== void 0) {
      let u = !1;
      for (const d in r)
        if (r[d].data instanceof HTMLImageElement) {
          u = !0;
          break;
        }
      u === !1 && t(c);
    }
    return c;
  }
  async parseAsync(e) {
    const t = this.parseAnimations(e.animations), i = this.parseShapes(e.shapes), n = this.parseGeometries(e.geometries, i), s = await this.parseImagesAsync(e.images), r = this.parseTextures(e.textures, s), a = this.parseMaterials(e.materials, r), l = this.parseObject(e.object, n, a, r, t), c = this.parseSkeletons(e.skeletons, l);
    return this.bindSkeletons(l, c), l;
  }
  parseShapes(e) {
    const t = {};
    if (e !== void 0)
      for (let i = 0, n = e.length; i < n; i++) {
        const s = new sc().fromJSON(e[i]);
        t[s.uuid] = s;
      }
    return t;
  }
  parseSkeletons(e, t) {
    const i = {}, n = {};
    if (t.traverse(function(s) {
      s.isBone && (n[s.uuid] = s);
    }), e !== void 0)
      for (let s = 0, r = e.length; s < r; s++) {
        const a = new Rr().fromJSON(e[s], n);
        i[a.uuid] = a;
      }
    return i;
  }
  parseGeometries(e, t) {
    const i = {};
    if (e !== void 0) {
      const n = new ex();
      for (let s = 0, r = e.length; s < r; s++) {
        let a;
        const l = e[s];
        switch (l.type) {
          case "BufferGeometry":
          case "InstancedBufferGeometry":
            a = n.parse(l);
            break;
          default:
            l.type in ru ? a = ru[l.type].fromJSON(l, t) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${l.type}"`);
        }
        a.uuid = l.uuid, l.name !== void 0 && (a.name = l.name), a.isBufferGeometry === !0 && l.userData !== void 0 && (a.userData = l.userData), i[l.uuid] = a;
      }
    }
    return i;
  }
  parseMaterials(e, t) {
    const i = {}, n = {};
    if (e !== void 0) {
      const s = new yc();
      s.setTextures(t);
      for (let r = 0, a = e.length; r < a; r++) {
        const l = e[r];
        i[l.uuid] === void 0 && (i[l.uuid] = s.parse(l)), n[l.uuid] = i[l.uuid];
      }
    }
    return n;
  }
  parseAnimations(e) {
    const t = {};
    if (e !== void 0)
      for (let i = 0; i < e.length; i++) {
        const n = e[i], s = Is.parse(n);
        t[s.uuid] = s;
      }
    return t;
  }
  parseImages(e, t) {
    const i = this, n = {};
    let s;
    function r(l) {
      return i.manager.itemStart(l), s.load(l, function() {
        i.manager.itemEnd(l);
      }, void 0, function() {
        i.manager.itemError(l), i.manager.itemEnd(l);
      });
    }
    function a(l) {
      if (typeof l == "string") {
        const c = l, h = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(c) ? c : i.resourcePath + c;
        return r(h);
      } else
        return l.data ? {
          data: gs(l.type, l.data),
          width: l.width,
          height: l.height
        } : null;
    }
    if (e !== void 0 && e.length > 0) {
      const l = new mc(t);
      s = new Ga(l), s.setCrossOrigin(this.crossOrigin);
      for (let c = 0, h = e.length; c < h; c++) {
        const u = e[c], d = u.url;
        if (Array.isArray(d)) {
          const f = [];
          for (let m = 0, _ = d.length; m < _; m++) {
            const p = d[m], g = a(p);
            g !== null && (g instanceof HTMLImageElement ? f.push(g) : f.push(new Oa(g.data, g.width, g.height)));
          }
          n[u.uuid] = new vs(f);
        } else {
          const f = a(u.url);
          n[u.uuid] = new vs(f);
        }
      }
    }
    return n;
  }
  async parseImagesAsync(e) {
    const t = this, i = {};
    let n;
    async function s(r) {
      if (typeof r == "string") {
        const a = r, l = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(a) ? a : t.resourcePath + a;
        return await n.loadAsync(l);
      } else
        return r.data ? {
          data: gs(r.type, r.data),
          width: r.width,
          height: r.height
        } : null;
    }
    if (e !== void 0 && e.length > 0) {
      n = new Ga(this.manager), n.setCrossOrigin(this.crossOrigin);
      for (let r = 0, a = e.length; r < a; r++) {
        const l = e[r], c = l.url;
        if (Array.isArray(c)) {
          const h = [];
          for (let u = 0, d = c.length; u < d; u++) {
            const f = c[u], m = await s(f);
            m !== null && (m instanceof HTMLImageElement ? h.push(m) : h.push(new Oa(m.data, m.width, m.height)));
          }
          i[l.uuid] = new vs(h);
        } else {
          const h = await s(l.url);
          i[l.uuid] = new vs(h);
        }
      }
    }
    return i;
  }
  parseTextures(e, t) {
    function i(s, r) {
      return typeof s == "number" ? s : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", s), r[s]);
    }
    const n = {};
    if (e !== void 0)
      for (let s = 0, r = e.length; s < r; s++) {
        const a = e[s];
        a.image === void 0 && console.warn('THREE.ObjectLoader: No "image" specified for', a.uuid), t[a.image] === void 0 && console.warn("THREE.ObjectLoader: Undefined image", a.image);
        const l = t[a.image], c = l.data;
        let h;
        Array.isArray(c) ? (h = new Za(), c.length === 6 && (h.needsUpdate = !0)) : (c && c.data ? h = new Oa() : h = new dt(), c && (h.needsUpdate = !0)), h.source = l, h.uuid = a.uuid, a.name !== void 0 && (h.name = a.name), a.mapping !== void 0 && (h.mapping = i(a.mapping, tx)), a.offset !== void 0 && h.offset.fromArray(a.offset), a.repeat !== void 0 && h.repeat.fromArray(a.repeat), a.center !== void 0 && h.center.fromArray(a.center), a.rotation !== void 0 && (h.rotation = a.rotation), a.wrap !== void 0 && (h.wrapS = i(a.wrap[0], hu), h.wrapT = i(a.wrap[1], hu)), a.format !== void 0 && (h.format = a.format), a.type !== void 0 && (h.type = a.type), a.encoding !== void 0 && (h.encoding = a.encoding), a.minFilter !== void 0 && (h.minFilter = i(a.minFilter, uu)), a.magFilter !== void 0 && (h.magFilter = i(a.magFilter, uu)), a.anisotropy !== void 0 && (h.anisotropy = a.anisotropy), a.flipY !== void 0 && (h.flipY = a.flipY), a.generateMipmaps !== void 0 && (h.generateMipmaps = a.generateMipmaps), a.premultiplyAlpha !== void 0 && (h.premultiplyAlpha = a.premultiplyAlpha), a.unpackAlignment !== void 0 && (h.unpackAlignment = a.unpackAlignment), a.userData !== void 0 && (h.userData = a.userData), n[a.uuid] = h;
      }
    return n;
  }
  parseObject(e, t, i, n, s) {
    let r;
    function a(d) {
      return t[d] === void 0 && console.warn("THREE.ObjectLoader: Undefined geometry", d), t[d];
    }
    function l(d) {
      if (d !== void 0) {
        if (Array.isArray(d)) {
          const f = [];
          for (let m = 0, _ = d.length; m < _; m++) {
            const p = d[m];
            i[p] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", p), f.push(i[p]);
          }
          return f;
        }
        return i[d] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", d), i[d];
      }
    }
    function c(d) {
      return n[d] === void 0 && console.warn("THREE.ObjectLoader: Undefined texture", d), n[d];
    }
    let h, u;
    switch (e.type) {
      case "Scene":
        r = new or(), e.background !== void 0 && (Number.isInteger(e.background) ? r.background = new de(e.background) : r.background = c(e.background)), e.environment !== void 0 && (r.environment = c(e.environment)), e.fog !== void 0 && (e.fog.type === "Fog" ? r.fog = new Wl(e.fog.color, e.fog.near, e.fog.far) : e.fog.type === "FogExp2" && (r.fog = new Hl(e.fog.color, e.fog.density))), e.backgroundBlurriness !== void 0 && (r.backgroundBlurriness = e.backgroundBlurriness);
        break;
      case "PerspectiveCamera":
        r = new gt(e.fov, e.aspect, e.near, e.far), e.focus !== void 0 && (r.focus = e.focus), e.zoom !== void 0 && (r.zoom = e.zoom), e.filmGauge !== void 0 && (r.filmGauge = e.filmGauge), e.filmOffset !== void 0 && (r.filmOffset = e.filmOffset), e.view !== void 0 && (r.view = Object.assign({}, e.view));
        break;
      case "OrthographicCamera":
        r = new pn(e.left, e.right, e.top, e.bottom, e.near, e.far), e.zoom !== void 0 && (r.zoom = e.zoom), e.view !== void 0 && (r.view = Object.assign({}, e.view));
        break;
      case "AmbientLight":
        r = new Vd(e.color, e.intensity);
        break;
      case "DirectionalLight":
        r = new vc(e.color, e.intensity);
        break;
      case "PointLight":
        r = new Ha(e.color, e.intensity, e.distance, e.decay);
        break;
      case "RectAreaLight":
        r = new Ky(e.color, e.intensity, e.width, e.height);
        break;
      case "SpotLight":
        r = new gc(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay);
        break;
      case "HemisphereLight":
        r = new jy(e.color, e.groundColor, e.intensity);
        break;
      case "LightProbe":
        r = new Qy().fromJSON(e);
        break;
      case "SkinnedMesh":
        h = a(e.geometry), u = l(e.material), r = new ql(h, u), e.bindMode !== void 0 && (r.bindMode = e.bindMode), e.bindMatrix !== void 0 && r.bindMatrix.fromArray(e.bindMatrix), e.skeleton !== void 0 && (r.skeleton = e.skeleton);
        break;
      case "Mesh":
        h = a(e.geometry), u = l(e.material), r = new st(h, u);
        break;
      case "InstancedMesh":
        h = a(e.geometry), u = l(e.material);
        const d = e.count, f = e.instanceMatrix, m = e.instanceColor;
        r = new jl(h, u, d), r.instanceMatrix = new Mr(new Float32Array(f.array), 16), m !== void 0 && (r.instanceColor = new Mr(new Float32Array(m.array), m.itemSize));
        break;
      case "LOD":
        r = new Jv();
        break;
      case "Line":
        r = new Bn(a(e.geometry), l(e.material));
        break;
      case "LineLoop":
        r = new Ed(a(e.geometry), l(e.material));
        break;
      case "LineSegments":
        r = new Yl(a(e.geometry), l(e.material));
        break;
      case "PointCloud":
      case "Points":
        r = new Zl(a(e.geometry), l(e.material));
        break;
      case "Sprite":
        r = new Ad(l(e.material));
        break;
      case "Group":
        r = new nt();
        break;
      case "Bone":
        r = new br();
        break;
      default:
        r = new tt();
    }
    if (r.uuid = e.uuid, e.name !== void 0 && (r.name = e.name), e.matrix !== void 0 ? (r.matrix.fromArray(e.matrix), e.matrixAutoUpdate !== void 0 && (r.matrixAutoUpdate = e.matrixAutoUpdate), r.matrixAutoUpdate && r.matrix.decompose(r.position, r.quaternion, r.scale)) : (e.position !== void 0 && r.position.fromArray(e.position), e.rotation !== void 0 && r.rotation.fromArray(e.rotation), e.quaternion !== void 0 && r.quaternion.fromArray(e.quaternion), e.scale !== void 0 && r.scale.fromArray(e.scale)), e.castShadow !== void 0 && (r.castShadow = e.castShadow), e.receiveShadow !== void 0 && (r.receiveShadow = e.receiveShadow), e.shadow && (e.shadow.bias !== void 0 && (r.shadow.bias = e.shadow.bias), e.shadow.normalBias !== void 0 && (r.shadow.normalBias = e.shadow.normalBias), e.shadow.radius !== void 0 && (r.shadow.radius = e.shadow.radius), e.shadow.mapSize !== void 0 && r.shadow.mapSize.fromArray(e.shadow.mapSize), e.shadow.camera !== void 0 && (r.shadow.camera = this.parseObject(e.shadow.camera))), e.visible !== void 0 && (r.visible = e.visible), e.frustumCulled !== void 0 && (r.frustumCulled = e.frustumCulled), e.renderOrder !== void 0 && (r.renderOrder = e.renderOrder), e.userData !== void 0 && (r.userData = e.userData), e.layers !== void 0 && (r.layers.mask = e.layers), e.children !== void 0) {
      const d = e.children;
      for (let f = 0; f < d.length; f++)
        r.add(this.parseObject(d[f], t, i, n, s));
    }
    if (e.animations !== void 0) {
      const d = e.animations;
      for (let f = 0; f < d.length; f++) {
        const m = d[f];
        r.animations.push(s[m]);
      }
    }
    if (e.type === "LOD") {
      e.autoUpdate !== void 0 && (r.autoUpdate = e.autoUpdate);
      const d = e.levels;
      for (let f = 0; f < d.length; f++) {
        const m = d[f], _ = r.getObjectByProperty("uuid", m.object);
        _ !== void 0 && r.addLevel(_, m.distance, m.hysteresis);
      }
    }
    return r;
  }
  bindSkeletons(e, t) {
    Object.keys(t).length !== 0 && e.traverse(function(i) {
      if (i.isSkinnedMesh === !0 && i.skeleton !== void 0) {
        const n = t[i.skeleton];
        n === void 0 ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", i.skeleton) : i.bind(n, i.bindMatrix);
      }
    });
  }
}
const tx = {
  UVMapping: Nl,
  CubeReflectionMapping: Nn,
  CubeRefractionMapping: kn,
  EquirectangularReflectionMapping: mr,
  EquirectangularRefractionMapping: Fa,
  CubeUVReflectionMapping: Cr
}, hu = {
  RepeatWrapping: Yi,
  ClampToEdgeWrapping: Vt,
  MirroredRepeatWrapping: _r
}, uu = {
  NearestFilter: yt,
  NearestMipmapNearestFilter: Ba,
  NearestMipmapLinearFilter: cr,
  LinearFilter: Ut,
  LinearMipmapNearestFilter: kl,
  LinearMipmapLinearFilter: fn
};
class ix extends xi {
  constructor(e) {
    super(e), this.isImageBitmapLoader = !0, typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = { premultiplyAlpha: "none" };
  }
  setOptions(e) {
    return this.options = e, this;
  }
  load(e, t, i, n) {
    e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const s = this, r = Ds.get(e);
    if (r !== void 0)
      return s.manager.itemStart(e), setTimeout(function() {
        t && t(r), s.manager.itemEnd(e);
      }, 0), r;
    const a = {};
    a.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include", a.headers = this.requestHeader, fetch(e, a).then(function(l) {
      return l.blob();
    }).then(function(l) {
      return createImageBitmap(l, Object.assign(s.options, { colorSpaceConversion: "none" }));
    }).then(function(l) {
      Ds.add(e, l), t && t(l), s.manager.itemEnd(e);
    }).catch(function(l) {
      n && n(l), s.manager.itemError(e), s.manager.itemEnd(e);
    }), s.manager.itemStart(e);
  }
}
class Ml {
  constructor(e = !0) {
    this.autoStart = e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1;
  }
  start() {
    this.startTime = du(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0;
  }
  stop() {
    this.getElapsedTime(), this.running = !1, this.autoStart = !1;
  }
  getElapsedTime() {
    return this.getDelta(), this.elapsedTime;
  }
  getDelta() {
    let e = 0;
    if (this.autoStart && !this.running)
      return this.start(), 0;
    if (this.running) {
      const t = du();
      e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e;
    }
    return e;
  }
}
function du() {
  return (typeof performance > "u" ? Date : performance).now();
}
class nx {
  constructor(e, t, i) {
    this.binding = e, this.valueSize = i;
    let n, s, r;
    switch (t) {
      case "quaternion":
        n = this._slerp, s = this._slerpAdditive, r = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(i * 6), this._workIndex = 5;
        break;
      case "string":
      case "bool":
        n = this._select, s = this._select, r = this._setAdditiveIdentityOther, this.buffer = new Array(i * 5);
        break;
      default:
        n = this._lerp, s = this._lerpAdditive, r = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(i * 5);
    }
    this._mixBufferRegion = n, this._mixBufferRegionAdditive = s, this._setIdentity = r, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0;
  }
  // accumulate data in the 'incoming' region into 'accu<i>'
  accumulate(e, t) {
    const i = this.buffer, n = this.valueSize, s = e * n + n;
    let r = this.cumulativeWeight;
    if (r === 0) {
      for (let a = 0; a !== n; ++a)
        i[s + a] = i[a];
      r = t;
    } else {
      r += t;
      const a = t / r;
      this._mixBufferRegion(i, s, 0, a, n);
    }
    this.cumulativeWeight = r;
  }
  // accumulate data in the 'incoming' region into 'add'
  accumulateAdditive(e) {
    const t = this.buffer, i = this.valueSize, n = i * this._addIndex;
    this.cumulativeWeightAdditive === 0 && this._setIdentity(), this._mixBufferRegionAdditive(t, n, 0, e, i), this.cumulativeWeightAdditive += e;
  }
  // apply the state of 'accu<i>' to the binding when accus differ
  apply(e) {
    const t = this.valueSize, i = this.buffer, n = e * t + t, s = this.cumulativeWeight, r = this.cumulativeWeightAdditive, a = this.binding;
    if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, s < 1) {
      const l = t * this._origIndex;
      this._mixBufferRegion(
        i,
        n,
        l,
        1 - s,
        t
      );
    }
    r > 0 && this._mixBufferRegionAdditive(i, n, this._addIndex * t, 1, t);
    for (let l = t, c = t + t; l !== c; ++l)
      if (i[l] !== i[l + t]) {
        a.setValue(i, n);
        break;
      }
  }
  // remember the state of the bound property and copy it to both accus
  saveOriginalState() {
    const e = this.binding, t = this.buffer, i = this.valueSize, n = i * this._origIndex;
    e.getValue(t, n);
    for (let s = i, r = n; s !== r; ++s)
      t[s] = t[n + s % i];
    this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0;
  }
  // apply the state previously taken via 'saveOriginalState' to the binding
  restoreOriginalState() {
    const e = this.valueSize * 3;
    this.binding.setValue(this.buffer, e);
  }
  _setAdditiveIdentityNumeric() {
    const e = this._addIndex * this.valueSize, t = e + this.valueSize;
    for (let i = e; i < t; i++)
      this.buffer[i] = 0;
  }
  _setAdditiveIdentityQuaternion() {
    this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1;
  }
  _setAdditiveIdentityOther() {
    const e = this._origIndex * this.valueSize, t = this._addIndex * this.valueSize;
    for (let i = 0; i < this.valueSize; i++)
      this.buffer[t + i] = this.buffer[e + i];
  }
  // mix functions
  _select(e, t, i, n, s) {
    if (n >= 0.5)
      for (let r = 0; r !== s; ++r)
        e[t + r] = e[i + r];
  }
  _slerp(e, t, i, n) {
    Et.slerpFlat(e, t, e, t, e, i, n);
  }
  _slerpAdditive(e, t, i, n, s) {
    const r = this._workIndex * s;
    Et.multiplyQuaternionsFlat(e, r, e, t, e, i), Et.slerpFlat(e, t, e, t, e, r, n);
  }
  _lerp(e, t, i, n, s) {
    const r = 1 - n;
    for (let a = 0; a !== s; ++a) {
      const l = t + a;
      e[l] = e[l] * r + e[i + a] * n;
    }
  }
  _lerpAdditive(e, t, i, n, s) {
    for (let r = 0; r !== s; ++r) {
      const a = t + r;
      e[a] = e[a] + e[i + r] * n;
    }
  }
}
const xc = "\\[\\]\\.:\\/", sx = new RegExp("[" + xc + "]", "g"), wc = "[^" + xc + "]", rx = "[^" + xc.replace("\\.", "") + "]", ax = /* @__PURE__ */ /((?:WC+[\/:])*)/.source.replace("WC", wc), ox = /* @__PURE__ */ /(WCOD+)?/.source.replace("WCOD", rx), lx = /* @__PURE__ */ /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", wc), cx = /* @__PURE__ */ /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", wc), hx = new RegExp(
  "^" + ax + ox + lx + cx + "$"
), ux = ["material", "materials", "bones", "map"];
class dx {
  constructor(e, t, i) {
    const n = i || Je.parseTrackName(t);
    this._targetGroup = e, this._bindings = e.subscribe_(t, n);
  }
  getValue(e, t) {
    this.bind();
    const i = this._targetGroup.nCachedObjects_, n = this._bindings[i];
    n !== void 0 && n.getValue(e, t);
  }
  setValue(e, t) {
    const i = this._bindings;
    for (let n = this._targetGroup.nCachedObjects_, s = i.length; n !== s; ++n)
      i[n].setValue(e, t);
  }
  bind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t)
      e[t].bind();
  }
  unbind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t)
      e[t].unbind();
  }
}
class Je {
  constructor(e, t, i) {
    this.path = t, this.parsedPath = i || Je.parseTrackName(t), this.node = Je.findNode(e, this.parsedPath.nodeName) || e, this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
  }
  static create(e, t, i) {
    return e && e.isAnimationObjectGroup ? new Je.Composite(e, t, i) : new Je(e, t, i);
  }
  /**
   * Replaces spaces with underscores and removes unsupported characters from
   * node names, to ensure compatibility with parseTrackName().
   *
   * @param {string} name Node name to be sanitized.
   * @return {string}
   */
  static sanitizeNodeName(e) {
    return e.replace(/\s/g, "_").replace(sx, "");
  }
  static parseTrackName(e) {
    const t = hx.exec(e);
    if (t === null)
      throw new Error("PropertyBinding: Cannot parse trackName: " + e);
    const i = {
      // directoryName: matches[ 1 ], // (tschw) currently unused
      nodeName: t[2],
      objectName: t[3],
      objectIndex: t[4],
      propertyName: t[5],
      // required
      propertyIndex: t[6]
    }, n = i.nodeName && i.nodeName.lastIndexOf(".");
    if (n !== void 0 && n !== -1) {
      const s = i.nodeName.substring(n + 1);
      ux.indexOf(s) !== -1 && (i.nodeName = i.nodeName.substring(0, n), i.objectName = s);
    }
    if (i.propertyName === null || i.propertyName.length === 0)
      throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
    return i;
  }
  static findNode(e, t) {
    if (t === void 0 || t === "" || t === "." || t === -1 || t === e.name || t === e.uuid)
      return e;
    if (e.skeleton) {
      const i = e.skeleton.getBoneByName(t);
      if (i !== void 0)
        return i;
    }
    if (e.children) {
      const i = function(s) {
        for (let r = 0; r < s.length; r++) {
          const a = s[r];
          if (a.name === t || a.uuid === t)
            return a;
          const l = i(a.children);
          if (l) return l;
        }
        return null;
      }, n = i(e.children);
      if (n)
        return n;
    }
    return null;
  }
  // these are used to "bind" a nonexistent property
  _getValue_unavailable() {
  }
  _setValue_unavailable() {
  }
  // Getters
  _getValue_direct(e, t) {
    e[t] = this.targetObject[this.propertyName];
  }
  _getValue_array(e, t) {
    const i = this.resolvedProperty;
    for (let n = 0, s = i.length; n !== s; ++n)
      e[t++] = i[n];
  }
  _getValue_arrayElement(e, t) {
    e[t] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(e, t) {
    this.resolvedProperty.toArray(e, t);
  }
  // Direct
  _setValue_direct(e, t) {
    this.targetObject[this.propertyName] = e[t];
  }
  _setValue_direct_setNeedsUpdate(e, t) {
    this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0;
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
    this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  // EntireArray
  _setValue_array(e, t) {
    const i = this.resolvedProperty;
    for (let n = 0, s = i.length; n !== s; ++n)
      i[n] = e[t++];
  }
  _setValue_array_setNeedsUpdate(e, t) {
    const i = this.resolvedProperty;
    for (let n = 0, s = i.length; n !== s; ++n)
      i[n] = e[t++];
    this.targetObject.needsUpdate = !0;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
    const i = this.resolvedProperty;
    for (let n = 0, s = i.length; n !== s; ++n)
      i[n] = e[t++];
    this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  // ArrayElement
  _setValue_arrayElement(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t];
  }
  _setValue_arrayElement_setNeedsUpdate(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0;
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  // HasToFromArray
  _setValue_fromArray(e, t) {
    this.resolvedProperty.fromArray(e, t);
  }
  _setValue_fromArray_setNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0;
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  _getValue_unbound(e, t) {
    this.bind(), this.getValue(e, t);
  }
  _setValue_unbound(e, t) {
    this.bind(), this.setValue(e, t);
  }
  // create getter / setter pair for a property in the scene graph
  bind() {
    let e = this.node;
    const t = this.parsedPath, i = t.objectName, n = t.propertyName;
    let s = t.propertyIndex;
    if (e || (e = Je.findNode(this.rootNode, t.nodeName) || this.rootNode, this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) {
      console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
      return;
    }
    if (i) {
      let c = t.objectIndex;
      switch (i) {
        case "materials":
          if (!e.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!e.material.materials) {
            console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
            return;
          }
          e = e.material.materials;
          break;
        case "bones":
          if (!e.skeleton) {
            console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
            return;
          }
          e = e.skeleton.bones;
          for (let h = 0; h < e.length; h++)
            if (e[h].name === c) {
              c = h;
              break;
            }
          break;
        case "map":
          if ("map" in e) {
            e = e.map;
            break;
          }
          if (!e.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!e.material.map) {
            console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
            return;
          }
          e = e.material.map;
          break;
        default:
          if (e[i] === void 0) {
            console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
            return;
          }
          e = e[i];
      }
      if (c !== void 0) {
        if (e[c] === void 0) {
          console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
          return;
        }
        e = e[c];
      }
    }
    const r = e[n];
    if (r === void 0) {
      const c = t.nodeName;
      console.error("THREE.PropertyBinding: Trying to update property for track: " + c + "." + n + " but it wasn't found.", e);
      return;
    }
    let a = this.Versioning.None;
    this.targetObject = e, e.needsUpdate !== void 0 ? a = this.Versioning.NeedsUpdate : e.matrixWorldNeedsUpdate !== void 0 && (a = this.Versioning.MatrixWorldNeedsUpdate);
    let l = this.BindingType.Direct;
    if (s !== void 0) {
      if (n === "morphTargetInfluences") {
        if (!e.geometry) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
          return;
        }
        if (!e.geometry.morphAttributes) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
          return;
        }
        e.morphTargetDictionary[s] !== void 0 && (s = e.morphTargetDictionary[s]);
      }
      l = this.BindingType.ArrayElement, this.resolvedProperty = r, this.propertyIndex = s;
    } else r.fromArray !== void 0 && r.toArray !== void 0 ? (l = this.BindingType.HasFromToArray, this.resolvedProperty = r) : Array.isArray(r) ? (l = this.BindingType.EntireArray, this.resolvedProperty = r) : this.propertyName = n;
    this.getValue = this.GetterByBindingType[l], this.setValue = this.SetterByBindingTypeAndVersioning[l][a];
  }
  unbind() {
    this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
  }
}
Je.Composite = dx;
Je.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3
};
Je.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2
};
Je.prototype.GetterByBindingType = [
  Je.prototype._getValue_direct,
  Je.prototype._getValue_array,
  Je.prototype._getValue_arrayElement,
  Je.prototype._getValue_toArray
];
Je.prototype.SetterByBindingTypeAndVersioning = [
  [
    // Direct
    Je.prototype._setValue_direct,
    Je.prototype._setValue_direct_setNeedsUpdate,
    Je.prototype._setValue_direct_setMatrixWorldNeedsUpdate
  ],
  [
    // EntireArray
    Je.prototype._setValue_array,
    Je.prototype._setValue_array_setNeedsUpdate,
    Je.prototype._setValue_array_setMatrixWorldNeedsUpdate
  ],
  [
    // ArrayElement
    Je.prototype._setValue_arrayElement,
    Je.prototype._setValue_arrayElement_setNeedsUpdate,
    Je.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate
  ],
  [
    // HasToFromArray
    Je.prototype._setValue_fromArray,
    Je.prototype._setValue_fromArray_setNeedsUpdate,
    Je.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate
  ]
];
class fx {
  constructor(e, t, i = null, n = t.blendMode) {
    this._mixer = e, this._clip = t, this._localRoot = i, this.blendMode = n;
    const s = t.tracks, r = s.length, a = new Array(r), l = {
      endingStart: ms,
      endingEnd: ms
    };
    for (let c = 0; c !== r; ++c) {
      const h = s[c].createInterpolant(null);
      a[c] = h, h.settings = l;
    }
    this._interpolantSettings = l, this._interpolants = a, this._propertyBindings = new Array(r), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = Dp, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0;
  }
  // State & Scheduling
  play() {
    return this._mixer._activateAction(this), this;
  }
  stop() {
    return this._mixer._deactivateAction(this), this.reset();
  }
  reset() {
    return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping();
  }
  isRunning() {
    return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
  }
  // return true when play has been called
  isScheduled() {
    return this._mixer._isActiveAction(this);
  }
  startAt(e) {
    return this._startTime = e, this;
  }
  setLoop(e, t) {
    return this.loop = e, this.repetitions = t, this;
  }
  // Weight
  // set the weight stopping any scheduled fading
  // although .enabled = false yields an effective weight of zero, this
  // method does *not* change .enabled, because it would be confusing
  setEffectiveWeight(e) {
    return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading();
  }
  // return the weight considering fading and .enabled
  getEffectiveWeight() {
    return this._effectiveWeight;
  }
  fadeIn(e) {
    return this._scheduleFading(e, 0, 1);
  }
  fadeOut(e) {
    return this._scheduleFading(e, 1, 0);
  }
  crossFadeFrom(e, t, i) {
    if (e.fadeOut(t), this.fadeIn(t), i) {
      const n = this._clip.duration, s = e._clip.duration, r = s / n, a = n / s;
      e.warp(1, r, t), this.warp(a, 1, t);
    }
    return this;
  }
  crossFadeTo(e, t, i) {
    return e.crossFadeFrom(this, t, i);
  }
  stopFading() {
    const e = this._weightInterpolant;
    return e !== null && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this;
  }
  // Time Scale Control
  // set the time scale stopping any scheduled warping
  // although .paused = true yields an effective time scale of zero, this
  // method does *not* change .paused, because it would be confusing
  setEffectiveTimeScale(e) {
    return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping();
  }
  // return the time scale considering warping and .paused
  getEffectiveTimeScale() {
    return this._effectiveTimeScale;
  }
  setDuration(e) {
    return this.timeScale = this._clip.duration / e, this.stopWarping();
  }
  syncWith(e) {
    return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping();
  }
  halt(e) {
    return this.warp(this._effectiveTimeScale, 0, e);
  }
  warp(e, t, i) {
    const n = this._mixer, s = n.time, r = this.timeScale;
    let a = this._timeScaleInterpolant;
    a === null && (a = n._lendControlInterpolant(), this._timeScaleInterpolant = a);
    const l = a.parameterPositions, c = a.sampleValues;
    return l[0] = s, l[1] = s + i, c[0] = e / r, c[1] = t / r, this;
  }
  stopWarping() {
    const e = this._timeScaleInterpolant;
    return e !== null && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this;
  }
  // Object Accessors
  getMixer() {
    return this._mixer;
  }
  getClip() {
    return this._clip;
  }
  getRoot() {
    return this._localRoot || this._mixer._root;
  }
  // Interna
  _update(e, t, i, n) {
    if (!this.enabled) {
      this._updateWeight(e);
      return;
    }
    const s = this._startTime;
    if (s !== null) {
      const l = (e - s) * i;
      l < 0 || i === 0 ? t = 0 : (this._startTime = null, t = i * l);
    }
    t *= this._updateTimeScale(e);
    const r = this._updateTime(t), a = this._updateWeight(e);
    if (a > 0) {
      const l = this._interpolants, c = this._propertyBindings;
      switch (this.blendMode) {
        case Np:
          for (let h = 0, u = l.length; h !== u; ++h)
            l[h].evaluate(r), c[h].accumulateAdditive(a);
          break;
        case zl:
        default:
          for (let h = 0, u = l.length; h !== u; ++h)
            l[h].evaluate(r), c[h].accumulate(n, a);
      }
    }
  }
  _updateWeight(e) {
    let t = 0;
    if (this.enabled) {
      t = this.weight;
      const i = this._weightInterpolant;
      if (i !== null) {
        const n = i.evaluate(e)[0];
        t *= n, e > i.parameterPositions[1] && (this.stopFading(), n === 0 && (this.enabled = !1));
      }
    }
    return this._effectiveWeight = t, t;
  }
  _updateTimeScale(e) {
    let t = 0;
    if (!this.paused) {
      t = this.timeScale;
      const i = this._timeScaleInterpolant;
      if (i !== null) {
        const n = i.evaluate(e)[0];
        t *= n, e > i.parameterPositions[1] && (this.stopWarping(), t === 0 ? this.paused = !0 : this.timeScale = t);
      }
    }
    return this._effectiveTimeScale = t, t;
  }
  _updateTime(e) {
    const t = this._clip.duration, i = this.loop;
    let n = this.time + e, s = this._loopCount;
    const r = i === Op;
    if (e === 0)
      return s === -1 ? n : r && (s & 1) === 1 ? t - n : n;
    if (i === Ip) {
      s === -1 && (this._loopCount = 0, this._setEndings(!0, !0, !1));
      e: {
        if (n >= t)
          n = t;
        else if (n < 0)
          n = 0;
        else {
          this.time = n;
          break e;
        }
        this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = n, this._mixer.dispatchEvent({
          type: "finished",
          action: this,
          direction: e < 0 ? -1 : 1
        });
      }
    } else {
      if (s === -1 && (e >= 0 ? (s = 0, this._setEndings(!0, this.repetitions === 0, r)) : this._setEndings(this.repetitions === 0, !0, r)), n >= t || n < 0) {
        const a = Math.floor(n / t);
        n -= t * a, s += Math.abs(a);
        const l = this.repetitions - s;
        if (l <= 0)
          this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, n = e > 0 ? t : 0, this.time = n, this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: e > 0 ? 1 : -1
          });
        else {
          if (l === 1) {
            const c = e < 0;
            this._setEndings(c, !c, r);
          } else
            this._setEndings(!1, !1, r);
          this._loopCount = s, this.time = n, this._mixer.dispatchEvent({
            type: "loop",
            action: this,
            loopDelta: a
          });
        }
      } else
        this.time = n;
      if (r && (s & 1) === 1)
        return t - n;
    }
    return n;
  }
  _setEndings(e, t, i) {
    const n = this._interpolantSettings;
    i ? (n.endingStart = _s, n.endingEnd = _s) : (e ? n.endingStart = this.zeroSlopeAtStart ? _s : ms : n.endingStart = Ua, t ? n.endingEnd = this.zeroSlopeAtEnd ? _s : ms : n.endingEnd = Ua);
  }
  _scheduleFading(e, t, i) {
    const n = this._mixer, s = n.time;
    let r = this._weightInterpolant;
    r === null && (r = n._lendControlInterpolant(), this._weightInterpolant = r);
    const a = r.parameterPositions, l = r.sampleValues;
    return a[0] = s, l[0] = t, a[1] = s + e, l[1] = i, this;
  }
}
const px = new Float32Array(1);
class fu extends gn {
  constructor(e) {
    super(), this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1;
  }
  _bindAction(e, t) {
    const i = e._localRoot || this._root, n = e._clip.tracks, s = n.length, r = e._propertyBindings, a = e._interpolants, l = i.uuid, c = this._bindingsByRootAndName;
    let h = c[l];
    h === void 0 && (h = {}, c[l] = h);
    for (let u = 0; u !== s; ++u) {
      const d = n[u], f = d.name;
      let m = h[f];
      if (m !== void 0)
        ++m.referenceCount, r[u] = m;
      else {
        if (m = r[u], m !== void 0) {
          m._cacheIndex === null && (++m.referenceCount, this._addInactiveBinding(m, l, f));
          continue;
        }
        const _ = t && t._propertyBindings[u].binding.parsedPath;
        m = new nx(
          Je.create(i, f, _),
          d.ValueTypeName,
          d.getValueSize()
        ), ++m.referenceCount, this._addInactiveBinding(m, l, f), r[u] = m;
      }
      a[u].resultBuffer = m.buffer;
    }
  }
  _activateAction(e) {
    if (!this._isActiveAction(e)) {
      if (e._cacheIndex === null) {
        const i = (e._localRoot || this._root).uuid, n = e._clip.uuid, s = this._actionsByClip[n];
        this._bindAction(
          e,
          s && s.knownActions[0]
        ), this._addInactiveAction(e, n, i);
      }
      const t = e._propertyBindings;
      for (let i = 0, n = t.length; i !== n; ++i) {
        const s = t[i];
        s.useCount++ === 0 && (this._lendBinding(s), s.saveOriginalState());
      }
      this._lendAction(e);
    }
  }
  _deactivateAction(e) {
    if (this._isActiveAction(e)) {
      const t = e._propertyBindings;
      for (let i = 0, n = t.length; i !== n; ++i) {
        const s = t[i];
        --s.useCount === 0 && (s.restoreOriginalState(), this._takeBackBinding(s));
      }
      this._takeBackAction(e);
    }
  }
  // Memory manager
  _initMemoryManager() {
    this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
    const e = this;
    this.stats = {
      actions: {
        get total() {
          return e._actions.length;
        },
        get inUse() {
          return e._nActiveActions;
        }
      },
      bindings: {
        get total() {
          return e._bindings.length;
        },
        get inUse() {
          return e._nActiveBindings;
        }
      },
      controlInterpolants: {
        get total() {
          return e._controlInterpolants.length;
        },
        get inUse() {
          return e._nActiveControlInterpolants;
        }
      }
    };
  }
  // Memory management for AnimationAction objects
  _isActiveAction(e) {
    const t = e._cacheIndex;
    return t !== null && t < this._nActiveActions;
  }
  _addInactiveAction(e, t, i) {
    const n = this._actions, s = this._actionsByClip;
    let r = s[t];
    if (r === void 0)
      r = {
        knownActions: [e],
        actionByRoot: {}
      }, e._byClipCacheIndex = 0, s[t] = r;
    else {
      const a = r.knownActions;
      e._byClipCacheIndex = a.length, a.push(e);
    }
    e._cacheIndex = n.length, n.push(e), r.actionByRoot[i] = e;
  }
  _removeInactiveAction(e) {
    const t = this._actions, i = t[t.length - 1], n = e._cacheIndex;
    i._cacheIndex = n, t[n] = i, t.pop(), e._cacheIndex = null;
    const s = e._clip.uuid, r = this._actionsByClip, a = r[s], l = a.knownActions, c = l[l.length - 1], h = e._byClipCacheIndex;
    c._byClipCacheIndex = h, l[h] = c, l.pop(), e._byClipCacheIndex = null;
    const u = a.actionByRoot, d = (e._localRoot || this._root).uuid;
    delete u[d], l.length === 0 && delete r[s], this._removeInactiveBindingsForAction(e);
  }
  _removeInactiveBindingsForAction(e) {
    const t = e._propertyBindings;
    for (let i = 0, n = t.length; i !== n; ++i) {
      const s = t[i];
      --s.referenceCount === 0 && this._removeInactiveBinding(s);
    }
  }
  _lendAction(e) {
    const t = this._actions, i = e._cacheIndex, n = this._nActiveActions++, s = t[n];
    e._cacheIndex = n, t[n] = e, s._cacheIndex = i, t[i] = s;
  }
  _takeBackAction(e) {
    const t = this._actions, i = e._cacheIndex, n = --this._nActiveActions, s = t[n];
    e._cacheIndex = n, t[n] = e, s._cacheIndex = i, t[i] = s;
  }
  // Memory management for PropertyMixer objects
  _addInactiveBinding(e, t, i) {
    const n = this._bindingsByRootAndName, s = this._bindings;
    let r = n[t];
    r === void 0 && (r = {}, n[t] = r), r[i] = e, e._cacheIndex = s.length, s.push(e);
  }
  _removeInactiveBinding(e) {
    const t = this._bindings, i = e.binding, n = i.rootNode.uuid, s = i.path, r = this._bindingsByRootAndName, a = r[n], l = t[t.length - 1], c = e._cacheIndex;
    l._cacheIndex = c, t[c] = l, t.pop(), delete a[s], Object.keys(a).length === 0 && delete r[n];
  }
  _lendBinding(e) {
    const t = this._bindings, i = e._cacheIndex, n = this._nActiveBindings++, s = t[n];
    e._cacheIndex = n, t[n] = e, s._cacheIndex = i, t[i] = s;
  }
  _takeBackBinding(e) {
    const t = this._bindings, i = e._cacheIndex, n = --this._nActiveBindings, s = t[n];
    e._cacheIndex = n, t[n] = e, s._cacheIndex = i, t[i] = s;
  }
  // Memory management of Interpolants for weight and time scale
  _lendControlInterpolant() {
    const e = this._controlInterpolants, t = this._nActiveControlInterpolants++;
    let i = e[t];
    return i === void 0 && (i = new Bd(
      new Float32Array(2),
      new Float32Array(2),
      1,
      px
    ), i.__cacheIndex = t, e[t] = i), i;
  }
  _takeBackControlInterpolant(e) {
    const t = this._controlInterpolants, i = e.__cacheIndex, n = --this._nActiveControlInterpolants, s = t[n];
    e.__cacheIndex = n, t[n] = e, s.__cacheIndex = i, t[i] = s;
  }
  // return an action for a clip optionally using a custom root target
  // object (this method allocates a lot of dynamic memory in case a
  // previously unknown clip/root combination is specified)
  clipAction(e, t, i) {
    const n = t || this._root, s = n.uuid;
    let r = typeof e == "string" ? Is.findByName(n, e) : e;
    const a = r !== null ? r.uuid : e, l = this._actionsByClip[a];
    let c = null;
    if (i === void 0 && (r !== null ? i = r.blendMode : i = zl), l !== void 0) {
      const u = l.actionByRoot[s];
      if (u !== void 0 && u.blendMode === i)
        return u;
      c = l.knownActions[0], r === null && (r = c._clip);
    }
    if (r === null) return null;
    const h = new fx(this, r, t, i);
    return this._bindAction(h, c), this._addInactiveAction(h, a, s), h;
  }
  // get an existing action
  existingAction(e, t) {
    const i = t || this._root, n = i.uuid, s = typeof e == "string" ? Is.findByName(i, e) : e, r = s ? s.uuid : e, a = this._actionsByClip[r];
    return a !== void 0 && a.actionByRoot[n] || null;
  }
  // deactivates all previously scheduled actions
  stopAllAction() {
    const e = this._actions, t = this._nActiveActions;
    for (let i = t - 1; i >= 0; --i)
      e[i].stop();
    return this;
  }
  // advance the time and update apply the animation
  update(e) {
    e *= this.timeScale;
    const t = this._actions, i = this._nActiveActions, n = this.time += e, s = Math.sign(e), r = this._accuIndex ^= 1;
    for (let c = 0; c !== i; ++c)
      t[c]._update(n, e, s, r);
    const a = this._bindings, l = this._nActiveBindings;
    for (let c = 0; c !== l; ++c)
      a[c].apply(r);
    return this;
  }
  // Allows you to seek to a specific time in an animation.
  setTime(e) {
    this.time = 0;
    for (let t = 0; t < this._actions.length; t++)
      this._actions[t].time = 0;
    return this.update(e);
  }
  // return this mixer's root target object
  getRoot() {
    return this._root;
  }
  // free all resources specific to a particular clip
  uncacheClip(e) {
    const t = this._actions, i = e.uuid, n = this._actionsByClip, s = n[i];
    if (s !== void 0) {
      const r = s.knownActions;
      for (let a = 0, l = r.length; a !== l; ++a) {
        const c = r[a];
        this._deactivateAction(c);
        const h = c._cacheIndex, u = t[t.length - 1];
        c._cacheIndex = null, c._byClipCacheIndex = null, u._cacheIndex = h, t[h] = u, t.pop(), this._removeInactiveBindingsForAction(c);
      }
      delete n[i];
    }
  }
  // free all resources specific to a particular root target object
  uncacheRoot(e) {
    const t = e.uuid, i = this._actionsByClip;
    for (const r in i) {
      const a = i[r].actionByRoot, l = a[t];
      l !== void 0 && (this._deactivateAction(l), this._removeInactiveAction(l));
    }
    const n = this._bindingsByRootAndName, s = n[t];
    if (s !== void 0)
      for (const r in s) {
        const a = s[r];
        a.restoreOriginalState(), this._removeInactiveBinding(a);
      }
  }
  // remove a targeted clip from the cache
  uncacheAction(e, t) {
    const i = this.existingAction(e, t);
    i !== null && (this._deactivateAction(i), this._removeInactiveAction(i));
  }
}
class Sl extends $a {
  constructor(e, t, i = 1) {
    super(e, t), this.isInstancedInterleavedBuffer = !0, this.meshPerAttribute = i;
  }
  copy(e) {
    return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
  }
  clone(e) {
    const t = super.clone(e);
    return t.meshPerAttribute = this.meshPerAttribute, t;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.isInstancedInterleavedBuffer = !0, t.meshPerAttribute = this.meshPerAttribute, t;
  }
}
class mx {
  constructor(e, t, i = 0, n = 1 / 0) {
    this.ray = new ks(e, t), this.near = i, this.far = n, this.camera = null, this.layers = new Bl(), this.params = {
      Mesh: {},
      Line: { threshold: 1 },
      LOD: {},
      Points: { threshold: 1 },
      Sprite: {}
    };
  }
  set(e, t) {
    this.ray.set(e, t);
  }
  setFromCamera(e, t) {
    t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, 0.5).unproject(t).sub(this.ray.origin).normalize(), this.camera = t) : t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type);
  }
  intersectObject(e, t = !0, i = []) {
    return Tl(e, this, i, t), i.sort(pu), i;
  }
  intersectObjects(e, t = !0, i = []) {
    for (let n = 0, s = e.length; n < s; n++)
      Tl(e[n], this, i, t);
    return i.sort(pu), i;
  }
}
function pu(o, e) {
  return o.distance - e.distance;
}
function Tl(o, e, t, i) {
  if (o.layers.test(e.layers) && o.raycast(e, t), i === !0) {
    const n = o.children;
    for (let s = 0, r = n.length; s < r; s++)
      Tl(n[s], e, t, !0);
  }
}
class Al {
  constructor(e = 1, t = 0, i = 0) {
    return this.radius = e, this.phi = t, this.theta = i, this;
  }
  set(e, t, i) {
    return this.radius = e, this.phi = t, this.theta = i, this;
  }
  copy(e) {
    return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this;
  }
  // restrict phi to be between EPS and PI-EPS
  makeSafe() {
    return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this;
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, i) {
    return this.radius = Math.sqrt(e * e + t * t + i * i), this.radius === 0 ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, i), this.phi = Math.acos(_t(t / this.radius, -1, 1))), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const mu = /* @__PURE__ */ new b(), ga = /* @__PURE__ */ new b();
class _x {
  constructor(e = new b(), t = new b()) {
    this.start = e, this.end = t;
  }
  set(e, t) {
    return this.start.copy(e), this.end.copy(t), this;
  }
  copy(e) {
    return this.start.copy(e.start), this.end.copy(e.end), this;
  }
  getCenter(e) {
    return e.addVectors(this.start, this.end).multiplyScalar(0.5);
  }
  delta(e) {
    return e.subVectors(this.end, this.start);
  }
  distanceSq() {
    return this.start.distanceToSquared(this.end);
  }
  distance() {
    return this.start.distanceTo(this.end);
  }
  at(e, t) {
    return this.delta(t).multiplyScalar(e).add(this.start);
  }
  closestPointToPointParameter(e, t) {
    mu.subVectors(e, this.start), ga.subVectors(this.end, this.start);
    const i = ga.dot(ga);
    let s = ga.dot(mu) / i;
    return t && (s = _t(s, 0, 1)), s;
  }
  closestPointToPoint(e, t, i) {
    const n = this.closestPointToPointParameter(e, t);
    return this.delta(i).multiplyScalar(n).add(this.start);
  }
  applyMatrix4(e) {
    return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this;
  }
  equals(e) {
    return e.start.equals(this.start) && e.end.equals(this.end);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const va = /* @__PURE__ */ new Ht();
class os extends Yl {
  constructor(e, t = 16776960) {
    const i = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), n = new Float32Array(8 * 3), s = new Ue();
    s.setIndex(new $e(i, 1)), s.setAttribute("position", new $e(n, 3)), super(s, new mn({ color: t, toneMapped: !1 })), this.object = e, this.type = "BoxHelper", this.matrixAutoUpdate = !1, this.update();
  }
  update(e) {
    if (e !== void 0 && console.warn("THREE.BoxHelper: .update() has no longer arguments."), this.object !== void 0 && va.setFromObject(this.object), va.isEmpty()) return;
    const t = va.min, i = va.max, n = this.geometry.attributes.position, s = n.array;
    s[0] = i.x, s[1] = i.y, s[2] = i.z, s[3] = t.x, s[4] = i.y, s[5] = i.z, s[6] = t.x, s[7] = t.y, s[8] = i.z, s[9] = i.x, s[10] = t.y, s[11] = i.z, s[12] = i.x, s[13] = i.y, s[14] = t.z, s[15] = t.x, s[16] = i.y, s[17] = t.z, s[18] = t.x, s[19] = t.y, s[20] = t.z, s[21] = i.x, s[22] = t.y, s[23] = t.z, n.needsUpdate = !0, this.geometry.computeBoundingSphere();
  }
  setFromObject(e) {
    return this.object = e, this.update(), this;
  }
  copy(e, t) {
    return super.copy(e, t), this.object = e.object, this;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {
  revision: Ol
} }));
typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = Ol);
const _u = { type: "change" }, jo = { type: "start" }, gu = { type: "end" };
class gx extends gn {
  constructor(e, t) {
    super(), this.object = e, this.domElement = t, this.domElement.style.touchAction = "none", this.enabled = !0, this.target = new b(), this.minDistance = 0, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.enableDamping = !1, this.dampingFactor = 0.05, this.enableZoom = !0, this.zoomSpeed = 1, this.enableRotate = !0, this.rotateSpeed = 1, this.enablePan = !0, this.panSpeed = 1, this.screenSpacePanning = !0, this.keyPanSpeed = 7, this.autoRotate = !1, this.autoRotateSpeed = 2, this.keys = { LEFT: "ArrowLeft", UP: "ArrowUp", RIGHT: "ArrowRight", BOTTOM: "ArrowDown" }, this.mouseButtons = { LEFT: an.ROTATE, MIDDLE: an.DOLLY, RIGHT: an.PAN }, this.touches = { ONE: on.ROTATE, TWO: on.DOLLY_PAN }, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this._domElementKeyEvents = null, this.getPolarAngle = function() {
      return a.phi;
    }, this.getAzimuthalAngle = function() {
      return a.theta;
    }, this.getDistance = function() {
      return this.object.position.distanceTo(this.target);
    }, this.listenToKeyEvents = function(R) {
      R.addEventListener("keydown", Qe), this._domElementKeyEvents = R;
    }, this.saveState = function() {
      i.target0.copy(i.target), i.position0.copy(i.object.position), i.zoom0 = i.object.zoom;
    }, this.reset = function() {
      i.target.copy(i.target0), i.object.position.copy(i.position0), i.object.zoom = i.zoom0, i.object.updateProjectionMatrix(), i.dispatchEvent(_u), i.update(), s = n.NONE;
    }, this.update = function() {
      const R = new b(), F = new Et().setFromUnitVectors(e.up, new b(0, 1, 0)), ge = F.clone().invert(), we = new b(), ve = new Et(), Se = 2 * Math.PI;
      return function() {
        const Xe = i.object.position;
        R.copy(Xe).sub(i.target), R.applyQuaternion(F), a.setFromVector3(R), i.autoRotate && s === n.NONE && E(A()), i.enableDamping ? (a.theta += l.theta * i.dampingFactor, a.phi += l.phi * i.dampingFactor) : (a.theta += l.theta, a.phi += l.phi);
        let qe = i.minAzimuthAngle, at = i.maxAzimuthAngle;
        return isFinite(qe) && isFinite(at) && (qe < -Math.PI ? qe += Se : qe > Math.PI && (qe -= Se), at < -Math.PI ? at += Se : at > Math.PI && (at -= Se), qe <= at ? a.theta = Math.max(qe, Math.min(at, a.theta)) : a.theta = a.theta > (qe + at) / 2 ? Math.max(qe, a.theta) : Math.min(at, a.theta)), a.phi = Math.max(i.minPolarAngle, Math.min(i.maxPolarAngle, a.phi)), a.makeSafe(), a.radius *= c, a.radius = Math.max(i.minDistance, Math.min(i.maxDistance, a.radius)), i.enableDamping === !0 ? i.target.addScaledVector(h, i.dampingFactor) : i.target.add(h), R.setFromSpherical(a), R.applyQuaternion(ge), Xe.copy(i.target).add(R), i.object.lookAt(i.target), i.enableDamping === !0 ? (l.theta *= 1 - i.dampingFactor, l.phi *= 1 - i.dampingFactor, h.multiplyScalar(1 - i.dampingFactor)) : (l.set(0, 0, 0), h.set(0, 0, 0)), c = 1, u || we.distanceToSquared(i.object.position) > r || 8 * (1 - ve.dot(i.object.quaternion)) > r ? (i.dispatchEvent(_u), we.copy(i.object.position), ve.copy(i.object.quaternion), u = !1, !0) : !1;
      };
    }(), this.dispose = function() {
      i.domElement.removeEventListener("contextmenu", X), i.domElement.removeEventListener("pointerdown", ce), i.domElement.removeEventListener("pointercancel", Ne), i.domElement.removeEventListener("wheel", rt), i.domElement.removeEventListener("pointermove", be), i.domElement.removeEventListener("pointerup", pe), i._domElementKeyEvents !== null && i._domElementKeyEvents.removeEventListener("keydown", Qe);
    };
    const i = this, n = {
      NONE: -1,
      ROTATE: 0,
      DOLLY: 1,
      PAN: 2,
      TOUCH_ROTATE: 3,
      TOUCH_PAN: 4,
      TOUCH_DOLLY_PAN: 5,
      TOUCH_DOLLY_ROTATE: 6
    };
    let s = n.NONE;
    const r = 1e-6, a = new Al(), l = new Al();
    let c = 1;
    const h = new b();
    let u = !1;
    const d = new G(), f = new G(), m = new G(), _ = new G(), p = new G(), g = new G(), x = new G(), y = new G(), v = new G(), M = [], S = {};
    function A() {
      return 2 * Math.PI / 60 / 60 * i.autoRotateSpeed;
    }
    function w() {
      return Math.pow(0.95, i.zoomSpeed);
    }
    function E(R) {
      l.theta -= R;
    }
    function P(R) {
      l.phi -= R;
    }
    const z = function() {
      const R = new b();
      return function(ge, we) {
        R.setFromMatrixColumn(we, 0), R.multiplyScalar(-ge), h.add(R);
      };
    }(), V = function() {
      const R = new b();
      return function(ge, we) {
        i.screenSpacePanning === !0 ? R.setFromMatrixColumn(we, 1) : (R.setFromMatrixColumn(we, 0), R.crossVectors(i.object.up, R)), R.multiplyScalar(ge), h.add(R);
      };
    }(), O = function() {
      const R = new b();
      return function(ge, we) {
        const ve = i.domElement;
        if (i.object.isPerspectiveCamera) {
          const Se = i.object.position;
          R.copy(Se).sub(i.target);
          let Me = R.length();
          Me *= Math.tan(i.object.fov / 2 * Math.PI / 180), z(2 * ge * Me / ve.clientHeight, i.object.matrix), V(2 * we * Me / ve.clientHeight, i.object.matrix);
        } else i.object.isOrthographicCamera ? (z(ge * (i.object.right - i.object.left) / i.object.zoom / ve.clientWidth, i.object.matrix), V(we * (i.object.top - i.object.bottom) / i.object.zoom / ve.clientHeight, i.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), i.enablePan = !1);
      };
    }();
    function D(R) {
      i.object.isPerspectiveCamera ? c /= R : i.object.isOrthographicCamera ? (i.object.zoom = Math.max(i.minZoom, Math.min(i.maxZoom, i.object.zoom * R)), i.object.updateProjectionMatrix(), u = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), i.enableZoom = !1);
    }
    function H(R) {
      i.object.isPerspectiveCamera ? c *= R : i.object.isOrthographicCamera ? (i.object.zoom = Math.max(i.minZoom, Math.min(i.maxZoom, i.object.zoom / R)), i.object.updateProjectionMatrix(), u = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), i.enableZoom = !1);
    }
    function Z(R) {
      d.set(R.clientX, R.clientY);
    }
    function ie(R) {
      x.set(R.clientX, R.clientY);
    }
    function K(R) {
      _.set(R.clientX, R.clientY);
    }
    function ne(R) {
      f.set(R.clientX, R.clientY), m.subVectors(f, d).multiplyScalar(i.rotateSpeed);
      const F = i.domElement;
      E(2 * Math.PI * m.x / F.clientHeight), P(2 * Math.PI * m.y / F.clientHeight), d.copy(f), i.update();
    }
    function te(R) {
      y.set(R.clientX, R.clientY), v.subVectors(y, x), v.y > 0 ? D(w()) : v.y < 0 && H(w()), x.copy(y), i.update();
    }
    function q(R) {
      p.set(R.clientX, R.clientY), g.subVectors(p, _).multiplyScalar(i.panSpeed), O(g.x, g.y), _.copy(p), i.update();
    }
    function W(R) {
      R.deltaY < 0 ? H(w()) : R.deltaY > 0 && D(w()), i.update();
    }
    function le(R) {
      let F = !1;
      switch (R.code) {
        case i.keys.UP:
          R.ctrlKey || R.metaKey || R.shiftKey ? P(2 * Math.PI * i.rotateSpeed / i.domElement.clientHeight) : O(0, i.keyPanSpeed), F = !0;
          break;
        case i.keys.BOTTOM:
          R.ctrlKey || R.metaKey || R.shiftKey ? P(-2 * Math.PI * i.rotateSpeed / i.domElement.clientHeight) : O(0, -i.keyPanSpeed), F = !0;
          break;
        case i.keys.LEFT:
          R.ctrlKey || R.metaKey || R.shiftKey ? E(2 * Math.PI * i.rotateSpeed / i.domElement.clientHeight) : O(i.keyPanSpeed, 0), F = !0;
          break;
        case i.keys.RIGHT:
          R.ctrlKey || R.metaKey || R.shiftKey ? E(-2 * Math.PI * i.rotateSpeed / i.domElement.clientHeight) : O(-i.keyPanSpeed, 0), F = !0;
          break;
      }
      F && (R.preventDefault(), i.update());
    }
    function ae() {
      if (M.length === 1)
        d.set(M[0].pageX, M[0].pageY);
      else {
        const R = 0.5 * (M[0].pageX + M[1].pageX), F = 0.5 * (M[0].pageY + M[1].pageY);
        d.set(R, F);
      }
    }
    function fe() {
      if (M.length === 1)
        _.set(M[0].pageX, M[0].pageY);
      else {
        const R = 0.5 * (M[0].pageX + M[1].pageX), F = 0.5 * (M[0].pageY + M[1].pageY);
        _.set(R, F);
      }
    }
    function j() {
      const R = M[0].pageX - M[1].pageX, F = M[0].pageY - M[1].pageY, ge = Math.sqrt(R * R + F * F);
      x.set(0, ge);
    }
    function De() {
      i.enableZoom && j(), i.enablePan && fe();
    }
    function ye() {
      i.enableZoom && j(), i.enableRotate && ae();
    }
    function Re(R) {
      if (M.length == 1)
        f.set(R.pageX, R.pageY);
      else {
        const ge = Ie(R), we = 0.5 * (R.pageX + ge.x), ve = 0.5 * (R.pageY + ge.y);
        f.set(we, ve);
      }
      m.subVectors(f, d).multiplyScalar(i.rotateSpeed);
      const F = i.domElement;
      E(2 * Math.PI * m.x / F.clientHeight), P(2 * Math.PI * m.y / F.clientHeight), d.copy(f);
    }
    function me(R) {
      if (M.length === 1)
        p.set(R.pageX, R.pageY);
      else {
        const F = Ie(R), ge = 0.5 * (R.pageX + F.x), we = 0.5 * (R.pageY + F.y);
        p.set(ge, we);
      }
      g.subVectors(p, _).multiplyScalar(i.panSpeed), O(g.x, g.y), _.copy(p);
    }
    function ze(R) {
      const F = Ie(R), ge = R.pageX - F.x, we = R.pageY - F.y, ve = Math.sqrt(ge * ge + we * we);
      y.set(0, ve), v.set(0, Math.pow(y.y / x.y, i.zoomSpeed)), D(v.y), x.copy(y);
    }
    function ee(R) {
      i.enableZoom && ze(R), i.enablePan && me(R);
    }
    function Q(R) {
      i.enableZoom && ze(R), i.enableRotate && Re(R);
    }
    function ce(R) {
      i.enabled !== !1 && (M.length === 0 && (i.domElement.setPointerCapture(R.pointerId), i.domElement.addEventListener("pointermove", be), i.domElement.addEventListener("pointerup", pe)), se(R), R.pointerType === "touch" ? L(R) : Le(R));
    }
    function be(R) {
      i.enabled !== !1 && (R.pointerType === "touch" ? T(R) : Ce(R));
    }
    function pe(R) {
      oe(R), M.length === 0 && (i.domElement.releasePointerCapture(R.pointerId), i.domElement.removeEventListener("pointermove", be), i.domElement.removeEventListener("pointerup", pe)), i.dispatchEvent(gu), s = n.NONE;
    }
    function Ne(R) {
      oe(R);
    }
    function Le(R) {
      let F;
      switch (R.button) {
        case 0:
          F = i.mouseButtons.LEFT;
          break;
        case 1:
          F = i.mouseButtons.MIDDLE;
          break;
        case 2:
          F = i.mouseButtons.RIGHT;
          break;
        default:
          F = -1;
      }
      switch (F) {
        case an.DOLLY:
          if (i.enableZoom === !1) return;
          ie(R), s = n.DOLLY;
          break;
        case an.ROTATE:
          if (R.ctrlKey || R.metaKey || R.shiftKey) {
            if (i.enablePan === !1) return;
            K(R), s = n.PAN;
          } else {
            if (i.enableRotate === !1) return;
            Z(R), s = n.ROTATE;
          }
          break;
        case an.PAN:
          if (R.ctrlKey || R.metaKey || R.shiftKey) {
            if (i.enableRotate === !1) return;
            Z(R), s = n.ROTATE;
          } else {
            if (i.enablePan === !1) return;
            K(R), s = n.PAN;
          }
          break;
        default:
          s = n.NONE;
      }
      s !== n.NONE && i.dispatchEvent(jo);
    }
    function Ce(R) {
      switch (s) {
        case n.ROTATE:
          if (i.enableRotate === !1) return;
          ne(R);
          break;
        case n.DOLLY:
          if (i.enableZoom === !1) return;
          te(R);
          break;
        case n.PAN:
          if (i.enablePan === !1) return;
          q(R);
          break;
      }
    }
    function rt(R) {
      i.enabled === !1 || i.enableZoom === !1 || s !== n.NONE || (R.preventDefault(), i.dispatchEvent(jo), W(R), i.dispatchEvent(gu));
    }
    function Qe(R) {
      i.enabled === !1 || i.enablePan === !1 || le(R);
    }
    function L(R) {
      switch (_e(R), M.length) {
        case 1:
          switch (i.touches.ONE) {
            case on.ROTATE:
              if (i.enableRotate === !1) return;
              ae(), s = n.TOUCH_ROTATE;
              break;
            case on.PAN:
              if (i.enablePan === !1) return;
              fe(), s = n.TOUCH_PAN;
              break;
            default:
              s = n.NONE;
          }
          break;
        case 2:
          switch (i.touches.TWO) {
            case on.DOLLY_PAN:
              if (i.enableZoom === !1 && i.enablePan === !1) return;
              De(), s = n.TOUCH_DOLLY_PAN;
              break;
            case on.DOLLY_ROTATE:
              if (i.enableZoom === !1 && i.enableRotate === !1) return;
              ye(), s = n.TOUCH_DOLLY_ROTATE;
              break;
            default:
              s = n.NONE;
          }
          break;
        default:
          s = n.NONE;
      }
      s !== n.NONE && i.dispatchEvent(jo);
    }
    function T(R) {
      switch (_e(R), s) {
        case n.TOUCH_ROTATE:
          if (i.enableRotate === !1) return;
          Re(R), i.update();
          break;
        case n.TOUCH_PAN:
          if (i.enablePan === !1) return;
          me(R), i.update();
          break;
        case n.TOUCH_DOLLY_PAN:
          if (i.enableZoom === !1 && i.enablePan === !1) return;
          ee(R), i.update();
          break;
        case n.TOUCH_DOLLY_ROTATE:
          if (i.enableZoom === !1 && i.enableRotate === !1) return;
          Q(R), i.update();
          break;
        default:
          s = n.NONE;
      }
    }
    function X(R) {
      i.enabled !== !1 && R.preventDefault();
    }
    function se(R) {
      M.push(R);
    }
    function oe(R) {
      delete S[R.pointerId];
      for (let F = 0; F < M.length; F++)
        if (M[F].pointerId == R.pointerId) {
          M.splice(F, 1);
          return;
        }
    }
    function _e(R) {
      let F = S[R.pointerId];
      F === void 0 && (F = new G(), S[R.pointerId] = F), F.set(R.pageX, R.pageY);
    }
    function Ie(R) {
      const F = R.pointerId === M[0].pointerId ? M[1] : M[0];
      return S[F.pointerId];
    }
    i.domElement.addEventListener("contextmenu", X), i.domElement.addEventListener("pointerdown", ce), i.domElement.addEventListener("pointercancel", Ne), i.domElement.addEventListener("wheel", rt, { passive: !1 }), this.update();
  }
}
class vx extends gx {
  constructor(e, t) {
    super(e, t), this.screenSpacePanning = !1, this.mouseButtons.LEFT = an.PAN, this.mouseButtons.RIGHT = an.ROTATE, this.touches.ONE = on.PAN, this.touches.TWO = on.DOLLY_ROTATE;
  }
}
var qi = Object.freeze({
  Linear: Object.freeze({
    None: function(o) {
      return o;
    },
    In: function(o) {
      return this.None(o);
    },
    Out: function(o) {
      return this.None(o);
    },
    InOut: function(o) {
      return this.None(o);
    }
  }),
  Quadratic: Object.freeze({
    In: function(o) {
      return o * o;
    },
    Out: function(o) {
      return o * (2 - o);
    },
    InOut: function(o) {
      return (o *= 2) < 1 ? 0.5 * o * o : -0.5 * (--o * (o - 2) - 1);
    }
  }),
  Cubic: Object.freeze({
    In: function(o) {
      return o * o * o;
    },
    Out: function(o) {
      return --o * o * o + 1;
    },
    InOut: function(o) {
      return (o *= 2) < 1 ? 0.5 * o * o * o : 0.5 * ((o -= 2) * o * o + 2);
    }
  }),
  Quartic: Object.freeze({
    In: function(o) {
      return o * o * o * o;
    },
    Out: function(o) {
      return 1 - --o * o * o * o;
    },
    InOut: function(o) {
      return (o *= 2) < 1 ? 0.5 * o * o * o * o : -0.5 * ((o -= 2) * o * o * o - 2);
    }
  }),
  Quintic: Object.freeze({
    In: function(o) {
      return o * o * o * o * o;
    },
    Out: function(o) {
      return --o * o * o * o * o + 1;
    },
    InOut: function(o) {
      return (o *= 2) < 1 ? 0.5 * o * o * o * o * o : 0.5 * ((o -= 2) * o * o * o * o + 2);
    }
  }),
  Sinusoidal: Object.freeze({
    In: function(o) {
      return 1 - Math.sin((1 - o) * Math.PI / 2);
    },
    Out: function(o) {
      return Math.sin(o * Math.PI / 2);
    },
    InOut: function(o) {
      return 0.5 * (1 - Math.sin(Math.PI * (0.5 - o)));
    }
  }),
  Exponential: Object.freeze({
    In: function(o) {
      return o === 0 ? 0 : Math.pow(1024, o - 1);
    },
    Out: function(o) {
      return o === 1 ? 1 : 1 - Math.pow(2, -10 * o);
    },
    InOut: function(o) {
      return o === 0 ? 0 : o === 1 ? 1 : (o *= 2) < 1 ? 0.5 * Math.pow(1024, o - 1) : 0.5 * (-Math.pow(2, -10 * (o - 1)) + 2);
    }
  }),
  Circular: Object.freeze({
    In: function(o) {
      return 1 - Math.sqrt(1 - o * o);
    },
    Out: function(o) {
      return Math.sqrt(1 - --o * o);
    },
    InOut: function(o) {
      return (o *= 2) < 1 ? -0.5 * (Math.sqrt(1 - o * o) - 1) : 0.5 * (Math.sqrt(1 - (o -= 2) * o) + 1);
    }
  }),
  Elastic: Object.freeze({
    In: function(o) {
      return o === 0 ? 0 : o === 1 ? 1 : -Math.pow(2, 10 * (o - 1)) * Math.sin((o - 1.1) * 5 * Math.PI);
    },
    Out: function(o) {
      return o === 0 ? 0 : o === 1 ? 1 : Math.pow(2, -10 * o) * Math.sin((o - 0.1) * 5 * Math.PI) + 1;
    },
    InOut: function(o) {
      return o === 0 ? 0 : o === 1 ? 1 : (o *= 2, o < 1 ? -0.5 * Math.pow(2, 10 * (o - 1)) * Math.sin((o - 1.1) * 5 * Math.PI) : 0.5 * Math.pow(2, -10 * (o - 1)) * Math.sin((o - 1.1) * 5 * Math.PI) + 1);
    }
  }),
  Back: Object.freeze({
    In: function(o) {
      var e = 1.70158;
      return o === 1 ? 1 : o * o * ((e + 1) * o - e);
    },
    Out: function(o) {
      var e = 1.70158;
      return o === 0 ? 0 : --o * o * ((e + 1) * o + e) + 1;
    },
    InOut: function(o) {
      var e = 2.5949095;
      return (o *= 2) < 1 ? 0.5 * (o * o * ((e + 1) * o - e)) : 0.5 * ((o -= 2) * o * ((e + 1) * o + e) + 2);
    }
  }),
  Bounce: Object.freeze({
    In: function(o) {
      return 1 - qi.Bounce.Out(1 - o);
    },
    Out: function(o) {
      return o < 1 / 2.75 ? 7.5625 * o * o : o < 2 / 2.75 ? 7.5625 * (o -= 1.5 / 2.75) * o + 0.75 : o < 2.5 / 2.75 ? 7.5625 * (o -= 2.25 / 2.75) * o + 0.9375 : 7.5625 * (o -= 2.625 / 2.75) * o + 0.984375;
    },
    InOut: function(o) {
      return o < 0.5 ? qi.Bounce.In(o * 2) * 0.5 : qi.Bounce.Out(o * 2 - 1) * 0.5 + 0.5;
    }
  }),
  generatePow: function(o) {
    return o === void 0 && (o = 4), o = o < Number.EPSILON ? Number.EPSILON : o, o = o > 1e4 ? 1e4 : o, {
      In: function(e) {
        return Math.pow(e, o);
      },
      Out: function(e) {
        return 1 - Math.pow(1 - e, o);
      },
      InOut: function(e) {
        return e < 0.5 ? Math.pow(e * 2, o) / 2 : (1 - Math.pow(2 - e * 2, o)) / 2 + 0.5;
      }
    };
  }
}), ws = function() {
  return performance.now();
}, bc = (
  /** @class */
  function() {
    function o() {
      this._tweens = {}, this._tweensAddedDuringUpdate = {};
    }
    return o.prototype.getAll = function() {
      var e = this;
      return Object.keys(this._tweens).map(function(t) {
        return e._tweens[t];
      });
    }, o.prototype.removeAll = function() {
      this._tweens = {};
    }, o.prototype.add = function(e) {
      this._tweens[e.getId()] = e, this._tweensAddedDuringUpdate[e.getId()] = e;
    }, o.prototype.remove = function(e) {
      delete this._tweens[e.getId()], delete this._tweensAddedDuringUpdate[e.getId()];
    }, o.prototype.update = function(e, t) {
      e === void 0 && (e = ws()), t === void 0 && (t = !1);
      var i = Object.keys(this._tweens);
      if (i.length === 0)
        return !1;
      for (; i.length > 0; ) {
        this._tweensAddedDuringUpdate = {};
        for (var n = 0; n < i.length; n++) {
          var s = this._tweens[i[n]], r = !t;
          s && s.update(e, r) === !1 && !t && delete this._tweens[i[n]];
        }
        i = Object.keys(this._tweensAddedDuringUpdate);
      }
      return !0;
    }, o;
  }()
), Pn = {
  Linear: function(o, e) {
    var t = o.length - 1, i = t * e, n = Math.floor(i), s = Pn.Utils.Linear;
    return e < 0 ? s(o[0], o[1], i) : e > 1 ? s(o[t], o[t - 1], t - i) : s(o[n], o[n + 1 > t ? t : n + 1], i - n);
  },
  Bezier: function(o, e) {
    for (var t = 0, i = o.length - 1, n = Math.pow, s = Pn.Utils.Bernstein, r = 0; r <= i; r++)
      t += n(1 - e, i - r) * n(e, r) * o[r] * s(i, r);
    return t;
  },
  CatmullRom: function(o, e) {
    var t = o.length - 1, i = t * e, n = Math.floor(i), s = Pn.Utils.CatmullRom;
    return o[0] === o[t] ? (e < 0 && (n = Math.floor(i = t * (1 + e))), s(o[(n - 1 + t) % t], o[n], o[(n + 1) % t], o[(n + 2) % t], i - n)) : e < 0 ? o[0] - (s(o[0], o[0], o[1], o[1], -i) - o[0]) : e > 1 ? o[t] - (s(o[t], o[t], o[t - 1], o[t - 1], i - t) - o[t]) : s(o[n ? n - 1 : 0], o[n], o[t < n + 1 ? t : n + 1], o[t < n + 2 ? t : n + 2], i - n);
  },
  Utils: {
    Linear: function(o, e, t) {
      return (e - o) * t + o;
    },
    Bernstein: function(o, e) {
      var t = Pn.Utils.Factorial;
      return t(o) / t(e) / t(o - e);
    },
    Factorial: /* @__PURE__ */ function() {
      var o = [1];
      return function(e) {
        var t = 1;
        if (o[e])
          return o[e];
        for (var i = e; i > 1; i--)
          t *= i;
        return o[e] = t, t;
      };
    }(),
    CatmullRom: function(o, e, t, i, n) {
      var s = (t - o) * 0.5, r = (i - e) * 0.5, a = n * n, l = n * a;
      return (2 * e - 2 * t + s + r) * l + (-3 * e + 3 * t - 2 * s - r) * a + s * n + e;
    }
  }
}, Mc = (
  /** @class */
  function() {
    function o() {
    }
    return o.nextId = function() {
      return o._nextId++;
    }, o._nextId = 0, o;
  }()
), El = new bc(), Bt = (
  /** @class */
  function() {
    function o(e, t) {
      t === void 0 && (t = El), this._object = e, this._group = t, this._isPaused = !1, this._pauseStart = 0, this._valuesStart = {}, this._valuesEnd = {}, this._valuesStartRepeat = {}, this._duration = 1e3, this._isDynamic = !1, this._initialRepeat = 0, this._repeat = 0, this._yoyo = !1, this._isPlaying = !1, this._reversed = !1, this._delayTime = 0, this._startTime = 0, this._easingFunction = qi.Linear.None, this._interpolationFunction = Pn.Linear, this._chainedTweens = [], this._onStartCallbackFired = !1, this._onEveryStartCallbackFired = !1, this._id = Mc.nextId(), this._isChainStopped = !1, this._propertiesAreSetUp = !1, this._goToEnd = !1;
    }
    return o.prototype.getId = function() {
      return this._id;
    }, o.prototype.isPlaying = function() {
      return this._isPlaying;
    }, o.prototype.isPaused = function() {
      return this._isPaused;
    }, o.prototype.to = function(e, t) {
      if (t === void 0 && (t = 1e3), this._isPlaying)
        throw new Error("Can not call Tween.to() while Tween is already started or paused. Stop the Tween first.");
      return this._valuesEnd = e, this._propertiesAreSetUp = !1, this._duration = t, this;
    }, o.prototype.duration = function(e) {
      return e === void 0 && (e = 1e3), this._duration = e, this;
    }, o.prototype.dynamic = function(e) {
      return e === void 0 && (e = !1), this._isDynamic = e, this;
    }, o.prototype.start = function(e, t) {
      if (e === void 0 && (e = ws()), t === void 0 && (t = !1), this._isPlaying)
        return this;
      if (this._group && this._group.add(this), this._repeat = this._initialRepeat, this._reversed) {
        this._reversed = !1;
        for (var i in this._valuesStartRepeat)
          this._swapEndStartRepeatValues(i), this._valuesStart[i] = this._valuesStartRepeat[i];
      }
      if (this._isPlaying = !0, this._isPaused = !1, this._onStartCallbackFired = !1, this._onEveryStartCallbackFired = !1, this._isChainStopped = !1, this._startTime = e, this._startTime += this._delayTime, !this._propertiesAreSetUp || t) {
        if (this._propertiesAreSetUp = !0, !this._isDynamic) {
          var n = {};
          for (var s in this._valuesEnd)
            n[s] = this._valuesEnd[s];
          this._valuesEnd = n;
        }
        this._setupProperties(this._object, this._valuesStart, this._valuesEnd, this._valuesStartRepeat, t);
      }
      return this;
    }, o.prototype.startFromCurrentValues = function(e) {
      return this.start(e, !0);
    }, o.prototype._setupProperties = function(e, t, i, n, s) {
      for (var r in i) {
        var a = e[r], l = Array.isArray(a), c = l ? "array" : typeof a, h = !l && Array.isArray(i[r]);
        if (!(c === "undefined" || c === "function")) {
          if (h) {
            var u = i[r];
            if (u.length === 0)
              continue;
            for (var d = [a], f = 0, m = u.length; f < m; f += 1) {
              var _ = this._handleRelativeValue(a, u[f]);
              if (isNaN(_)) {
                h = !1, console.warn("Found invalid interpolation list. Skipping.");
                break;
              }
              d.push(_);
            }
            h && (i[r] = d);
          }
          if ((c === "object" || l) && a && !h) {
            t[r] = l ? [] : {};
            var p = a;
            for (var g in p)
              t[r][g] = p[g];
            n[r] = l ? [] : {};
            var u = i[r];
            if (!this._isDynamic) {
              var x = {};
              for (var g in u)
                x[g] = u[g];
              i[r] = u = x;
            }
            this._setupProperties(p, t[r], u, n[r], s);
          } else
            (typeof t[r] > "u" || s) && (t[r] = a), l || (t[r] *= 1), h ? n[r] = i[r].slice().reverse() : n[r] = t[r] || 0;
        }
      }
    }, o.prototype.stop = function() {
      return this._isChainStopped || (this._isChainStopped = !0, this.stopChainedTweens()), this._isPlaying ? (this._group && this._group.remove(this), this._isPlaying = !1, this._isPaused = !1, this._onStopCallback && this._onStopCallback(this._object), this) : this;
    }, o.prototype.end = function() {
      return this._goToEnd = !0, this.update(1 / 0), this;
    }, o.prototype.pause = function(e) {
      return e === void 0 && (e = ws()), this._isPaused || !this._isPlaying ? this : (this._isPaused = !0, this._pauseStart = e, this._group && this._group.remove(this), this);
    }, o.prototype.resume = function(e) {
      return e === void 0 && (e = ws()), !this._isPaused || !this._isPlaying ? this : (this._isPaused = !1, this._startTime += e - this._pauseStart, this._pauseStart = 0, this._group && this._group.add(this), this);
    }, o.prototype.stopChainedTweens = function() {
      for (var e = 0, t = this._chainedTweens.length; e < t; e++)
        this._chainedTweens[e].stop();
      return this;
    }, o.prototype.group = function(e) {
      return e === void 0 && (e = El), this._group = e, this;
    }, o.prototype.delay = function(e) {
      return e === void 0 && (e = 0), this._delayTime = e, this;
    }, o.prototype.repeat = function(e) {
      return e === void 0 && (e = 0), this._initialRepeat = e, this._repeat = e, this;
    }, o.prototype.repeatDelay = function(e) {
      return this._repeatDelayTime = e, this;
    }, o.prototype.yoyo = function(e) {
      return e === void 0 && (e = !1), this._yoyo = e, this;
    }, o.prototype.easing = function(e) {
      return e === void 0 && (e = qi.Linear.None), this._easingFunction = e, this;
    }, o.prototype.interpolation = function(e) {
      return e === void 0 && (e = Pn.Linear), this._interpolationFunction = e, this;
    }, o.prototype.chain = function() {
      for (var e = [], t = 0; t < arguments.length; t++)
        e[t] = arguments[t];
      return this._chainedTweens = e, this;
    }, o.prototype.onStart = function(e) {
      return this._onStartCallback = e, this;
    }, o.prototype.onEveryStart = function(e) {
      return this._onEveryStartCallback = e, this;
    }, o.prototype.onUpdate = function(e) {
      return this._onUpdateCallback = e, this;
    }, o.prototype.onRepeat = function(e) {
      return this._onRepeatCallback = e, this;
    }, o.prototype.onComplete = function(e) {
      return this._onCompleteCallback = e, this;
    }, o.prototype.onStop = function(e) {
      return this._onStopCallback = e, this;
    }, o.prototype.update = function(e, t) {
      if (e === void 0 && (e = ws()), t === void 0 && (t = !0), this._isPaused)
        return !0;
      var i, n, s = this._startTime + this._duration;
      if (!this._goToEnd && !this._isPlaying) {
        if (e > s)
          return !1;
        t && this.start(e, !0);
      }
      if (this._goToEnd = !1, e < this._startTime)
        return !0;
      this._onStartCallbackFired === !1 && (this._onStartCallback && this._onStartCallback(this._object), this._onStartCallbackFired = !0), this._onEveryStartCallbackFired === !1 && (this._onEveryStartCallback && this._onEveryStartCallback(this._object), this._onEveryStartCallbackFired = !0), n = (e - this._startTime) / this._duration, n = this._duration === 0 || n > 1 ? 1 : n;
      var r = this._easingFunction(n);
      if (this._updateProperties(this._object, this._valuesStart, this._valuesEnd, r), this._onUpdateCallback && this._onUpdateCallback(this._object, n), n === 1)
        if (this._repeat > 0) {
          isFinite(this._repeat) && this._repeat--;
          for (i in this._valuesStartRepeat)
            !this._yoyo && typeof this._valuesEnd[i] == "string" && (this._valuesStartRepeat[i] = // eslint-disable-next-line
            // @ts-ignore FIXME?
            this._valuesStartRepeat[i] + parseFloat(this._valuesEnd[i])), this._yoyo && this._swapEndStartRepeatValues(i), this._valuesStart[i] = this._valuesStartRepeat[i];
          return this._yoyo && (this._reversed = !this._reversed), this._repeatDelayTime !== void 0 ? this._startTime = e + this._repeatDelayTime : this._startTime = e + this._delayTime, this._onRepeatCallback && this._onRepeatCallback(this._object), this._onEveryStartCallbackFired = !1, !0;
        } else {
          this._onCompleteCallback && this._onCompleteCallback(this._object);
          for (var a = 0, l = this._chainedTweens.length; a < l; a++)
            this._chainedTweens[a].start(this._startTime + this._duration, !1);
          return this._isPlaying = !1, !1;
        }
      return !0;
    }, o.prototype._updateProperties = function(e, t, i, n) {
      for (var s in i)
        if (t[s] !== void 0) {
          var r = t[s] || 0, a = i[s], l = Array.isArray(e[s]), c = Array.isArray(a), h = !l && c;
          h ? e[s] = this._interpolationFunction(a, n) : typeof a == "object" && a ? this._updateProperties(e[s], r, a, n) : (a = this._handleRelativeValue(r, a), typeof a == "number" && (e[s] = r + (a - r) * n));
        }
    }, o.prototype._handleRelativeValue = function(e, t) {
      return typeof t != "string" ? t : t.charAt(0) === "+" || t.charAt(0) === "-" ? e + parseFloat(t) : parseFloat(t);
    }, o.prototype._swapEndStartRepeatValues = function(e) {
      var t = this._valuesStartRepeat[e], i = this._valuesEnd[e];
      typeof i == "string" ? this._valuesStartRepeat[e] = this._valuesStartRepeat[e] + parseFloat(i) : this._valuesStartRepeat[e] = this._valuesEnd[e], this._valuesEnd[e] = t;
    }, o;
  }()
), yx = "21.0.0", xx = Mc.nextId, Ei = El, wx = Ei.getAll.bind(Ei), bx = Ei.removeAll.bind(Ei), Mx = Ei.add.bind(Ei), mi = Ei.remove.bind(Ei), Wd = Ei.update.bind(Ei), Sx = {
  Easing: qi,
  Group: bc,
  Interpolation: Pn,
  now: ws,
  Sequence: Mc,
  nextId: xx,
  Tween: Bt,
  VERSION: yx,
  getAll: wx,
  removeAll: bx,
  add: Mx,
  remove: mi,
  update: Wd
};
function vu(o) {
  let e;
  try {
    e = new URL(o, "http://fakehost.com/");
  } catch {
    return null;
  }
  const t = e.pathname.split("/").pop(), i = t.lastIndexOf(".");
  return i === -1 || i === t.length - 1 ? null : t.substring(i + 1);
}
function Tx(o) {
  Promise.resolve().then(o);
}
class Ax {
  constructor() {
    this.maxSize = 800, this.minSize = 600, this.unloadPercent = 0.05, this.itemSet = /* @__PURE__ */ new Map(), this.itemList = [], this.usedSet = /* @__PURE__ */ new Set(), this.callbacks = /* @__PURE__ */ new Map(), this.unloadPriorityCallback = null;
    const e = this.itemSet;
    this.defaultPriorityCallback = (t) => e.get(t);
  }
  // Returns whether or not the cache has reached the maximum size
  isFull() {
    return this.itemSet.size >= this.maxSize;
  }
  add(e, t) {
    const i = this.itemSet;
    if (i.has(e) || this.isFull())
      return !1;
    const n = this.usedSet, s = this.itemList, r = this.callbacks;
    return s.push(e), n.add(e), i.set(e, Date.now()), r.set(e, t), !0;
  }
  remove(e) {
    const t = this.usedSet, i = this.itemSet, n = this.itemList, s = this.callbacks;
    if (i.has(e)) {
      s.get(e)(e);
      const r = n.indexOf(e);
      return n.splice(r, 1), t.delete(e), i.delete(e), s.delete(e), !0;
    }
    return !1;
  }
  markUsed(e) {
    const t = this.itemSet, i = this.usedSet;
    t.has(e) && !i.has(e) && (t.set(e, Date.now()), i.add(e));
  }
  markAllUnused() {
    this.usedSet.clear();
  }
  // TODO: this should be renamed because it's not necessarily unloading all unused content
  // Maybe call it "cleanup" or "unloadToMinSize"
  unloadUnusedContent() {
    const e = this.unloadPercent, t = this.minSize, i = this.itemList, n = this.itemSet, s = this.usedSet, r = this.callbacks, a = i.length - s.size, l = i.length - t, c = this.unloadPriorityCallback || this.defaultPriorityCallback;
    if (l > 0 && a > 0) {
      i.sort((m, _) => {
        const p = s.has(m), g = s.has(_);
        return p && g ? 0 : !p && !g ? c(_) - c(m) : p ? 1 : -1;
      });
      const h = Math.min(l, a), u = Math.max(t * e, h * e);
      let d = Math.min(u, a);
      d = Math.ceil(d);
      const f = i.splice(0, d);
      for (let m = 0, _ = f.length; m < _; m++) {
        const p = f[m];
        r.get(p)(p), n.delete(p), r.delete(p);
      }
    }
  }
  scheduleUnload(e = !0) {
    this.scheduled || (this.scheduled = !0, Tx(() => {
      this.scheduled = !1, this.unloadUnusedContent(), e && this.markAllUnused();
    }));
  }
}
class yu {
  constructor() {
    this.maxJobs = 6, this.items = [], this.callbacks = /* @__PURE__ */ new Map(), this.currJobs = 0, this.scheduled = !1, this.autoUpdate = !0, this.priorityCallback = () => {
      throw new Error("PriorityQueue: PriorityCallback function not defined.");
    }, this.schedulingCallback = (e) => {
      requestAnimationFrame(e);
    }, this._runjobs = () => {
      this.tryRunJobs(), this.scheduled = !1;
    };
  }
  sort() {
    const e = this.priorityCallback;
    this.items.sort(e);
  }
  add(e, t) {
    return new Promise((i, n) => {
      const s = (...l) => t(...l).then(i).catch(n), r = this.items, a = this.callbacks;
      r.push(e), a.set(e, s), this.autoUpdate && this.scheduleJobRun();
    });
  }
  remove(e) {
    const t = this.items, i = this.callbacks, n = t.indexOf(e);
    n !== -1 && (t.splice(n, 1), i.delete(e));
  }
  tryRunJobs() {
    this.sort();
    const e = this.items, t = this.callbacks, i = this.maxJobs;
    let n = this.currJobs;
    for (; i > n && e.length > 0; ) {
      n++;
      const s = e.pop(), r = t.get(s);
      t.delete(s), r(s).then(() => {
        this.currJobs--, this.autoUpdate && this.scheduleJobRun();
      }).catch(() => {
        this.currJobs--, this.autoUpdate && this.scheduleJobRun();
      });
    }
    this.currJobs = n;
  }
  scheduleJobRun() {
    this.scheduled || (this.schedulingCallback(this._runjobs), this.scheduled = !0);
  }
}
const ya = 0, xa = 1, Yo = 2, Er = 3, Wa = 4, Xa = 6378137, Ex = 1 / 298.257223563, Cx = -(Ex * Xa - Xa);
function Sc(o) {
  return o === Er || o === Wa;
}
function On(o, e) {
  return o.__lastFrameVisited === e && o.__used;
}
function Xd(o, e) {
  o.__lastFrameVisited !== e && (o.__lastFrameVisited = e, o.__used = !1, o.__inFrustum = !1, o.__isLeaf = !1, o.__visible = !1, o.__active = !1, o.__error = 1 / 0, o.__distanceFromCamera = 1 / 0, o.__childrenWereVisible = !1, o.__allChildrenLoaded = !1);
}
function qd(o, e, t, i) {
  if (i.ensureChildrenArePreprocessed(o), Xd(o, e), o.__used = !0, t.markUsed(o), o.__contentEmpty) {
    const n = o.children;
    for (let s = 0, r = n.length; s < r; s++)
      qd(n[s], e, t, i);
  }
}
function jd(o, e, t) {
  if (t.ensureChildrenArePreprocessed(o), o.__contentEmpty && (!o.__externalTileSet || Sc(o.__loadingState))) {
    const n = o.children;
    for (let s = 0, r = n.length; s < r; s++) {
      const a = n[s];
      a.__depthFromRenderedParent = e, jd(a, e, t);
    }
  } else
    t.requestTileContents(o);
}
function Yd(o, e = null, t = null, i = null, n = 0) {
  if (e && e(o, i, n)) {
    t && t(o, i, n);
    return;
  }
  const s = o.children;
  for (let r = 0, a = s.length; r < a; r++)
    Yd(s[r], e, t, o, n + 1);
  t && t(o, i, n);
}
function Zd(o, e) {
  e.ensureChildrenArePreprocessed(o);
  const t = e.stats, i = e.frameCount, n = e.errorTarget, s = e.maxDepth, r = e.loadSiblings, a = e.lruCache, l = e.stopAtEmptyTiles;
  if (Xd(o, i), e.tileInView(o) === !1)
    return !1;
  if (o.__used = !0, a.markUsed(o), o.__inFrustum = !0, t.inFrustum++, (l || !o.__contentEmpty) && !o.__externalTileSet && (e.calculateError(o), o.__error <= n || e.maxDepth > 0 && o.__depth + 1 >= s))
    return !0;
  let h = !1;
  const u = o.children;
  for (let d = 0, f = u.length; d < f; d++) {
    const m = u[d], _ = Zd(m, e);
    h = h || _;
  }
  if (h && r)
    for (let d = 0, f = u.length; d < f; d++) {
      const m = u[d];
      qd(m, i, a, e);
    }
  return !0;
}
function Jd(o, e) {
  const t = e.stats, i = e.frameCount;
  if (!On(o, i))
    return;
  t.used++;
  const n = o.children;
  let s = !1;
  for (let r = 0, a = n.length; r < a; r++) {
    const l = n[r];
    s = s || On(l, i);
  }
  if (!s)
    o.__isLeaf = !0;
  else {
    let r = !1, a = !0;
    for (let l = 0, c = n.length; l < c; l++) {
      const h = n[l];
      if (Jd(h, e), r = r || h.__wasSetVisible || h.__childrenWereVisible, On(h, i)) {
        const u = h.__allChildrenLoaded || !h.__contentEmpty && Sc(h.__loadingState) || h.__externalTileSet && h.__loadingState === Wa;
        a = a && u;
      }
    }
    o.__childrenWereVisible = r, o.__allChildrenLoaded = a;
  }
}
function Kd(o, e) {
  const t = e.stats, i = e.frameCount;
  if (!On(o, i))
    return;
  const n = o.parent, s = n ? n.__depthFromRenderedParent : -1;
  o.__depthFromRenderedParent = s;
  const r = e.lruCache;
  if (o.__isLeaf) {
    o.__depthFromRenderedParent++, o.__loadingState === Er ? (o.__inFrustum && (o.__visible = !0, t.visible++), o.__active = !0, t.active++) : !r.isFull() && (!o.__contentEmpty || o.__externalTileSet) && e.requestTileContents(o);
    return;
  }
  const a = (e.errorTarget + 1) * e.errorThreshold, l = o.__error <= a, c = l || o.refine === "ADD", h = !o.__contentEmpty, u = h || o.__externalTileSet, d = Sc(o.__loadingState) && u, f = o.__childrenWereVisible, m = o.children, _ = o.__allChildrenLoaded;
  if (c && h && o.__depthFromRenderedParent++, c && !d && !r.isFull() && u && e.requestTileContents(o), (l && !_ && !f && d || o.refine === "ADD" && d) && (o.__inFrustum && (o.__visible = !0, t.visible++), o.__active = !0, t.active++), o.refine !== "ADD" && l && !_ && d)
    for (let p = 0, g = m.length; p < g; p++) {
      const x = m[p];
      On(x, i) && !r.isFull() && (x.__depthFromRenderedParent = o.__depthFromRenderedParent + 1, jd(x, x.__depthFromRenderedParent, e));
    }
  else
    for (let p = 0, g = m.length; p < g; p++) {
      const x = m[p];
      On(x, i) && Kd(x, e);
    }
}
function $d(o, e) {
  const t = e.frameCount, i = On(o, t);
  if (i || o.__usedLastFrame) {
    let n = !1, s = !1;
    i && (n = o.__active, e.displayActiveTiles ? s = o.__active || o.__visible : s = o.__visible), !o.__contentEmpty && o.__loadingState === Er && (o.__wasSetActive !== n && e.setTileActive(o, n), o.__wasSetVisible !== s && e.setTileVisible(o, s)), o.__wasSetActive = n, o.__wasSetVisible = s, o.__usedLastFrame = i;
    const r = o.children;
    for (let a = 0, l = r.length; a < l; a++) {
      const c = r[a];
      $d(c, e);
    }
  }
}
const xu = (o, e) => o.__depth !== e.__depth ? o.__depth > e.__depth ? -1 : 1 : o.__inFrustum !== e.__inFrustum ? o.__inFrustum ? 1 : -1 : o.__used !== e.__used ? o.__used ? 1 : -1 : o.__error !== e.__error ? o.__error > e.__error ? 1 : -1 : o.__distanceFromCamera !== e.__distanceFromCamera ? o.__distanceFromCamera > e.__distanceFromCamera ? -1 : 1 : 0, Lx = (o) => 1 / (o.__depthFromRenderedParent + 1);
class Px {
  get rootTileSet() {
    const e = this.tileSets[this.rootURL];
    return !e || e instanceof Promise ? null : e;
  }
  get root() {
    const e = this.rootTileSet;
    return e ? e.root : null;
  }
  constructor(e) {
    this.tileSets = {}, this.rootURL = e, this.fetchOptions = {}, this.preprocessURL = null;
    const t = new Ax();
    t.unloadPriorityCallback = Lx;
    const i = new yu();
    i.maxJobs = 4, i.priorityCallback = xu;
    const n = new yu();
    n.maxJobs = 1, n.priorityCallback = xu, this.lruCache = t, this.downloadQueue = i, this.parseQueue = n, this.stats = {
      parsing: 0,
      downloading: 0,
      failed: 0,
      inFrustum: 0,
      used: 0,
      active: 0,
      visible: 0
    }, this.frameCount = 0, this.errorTarget = 6, this.errorThreshold = 1 / 0, this.loadSiblings = !0, this.displayActiveTiles = !1, this.maxDepth = 1 / 0, this.stopAtEmptyTiles = !0;
  }
  traverse(e, t) {
    const n = this.tileSets[this.rootURL];
    !n || !n.root || Yd(n.root, (s, ...r) => (this.ensureChildrenArePreprocessed(s), e ? e(s, ...r) : !1), t);
  }
  // Public API
  update() {
    const e = this.stats, t = this.lruCache, i = this.tileSets, n = i[this.rootURL];
    if (this.rootURL in i) {
      if (!n || !n.root)
        return;
    } else {
      this.loadRootTileSet(this.rootURL);
      return;
    }
    const s = n.root;
    e.inFrustum = 0, e.used = 0, e.active = 0, e.visible = 0, this.frameCount++, Zd(s, this), Jd(s, this), Kd(s, this), $d(s, this), t.scheduleUnload();
  }
  // Overrideable
  parseTile(e, t, i) {
    return null;
  }
  disposeTile(e) {
  }
  preprocessNode(e, t, i = null) {
    if (e.content && (!("uri" in e.content) && "url" in e.content && (e.content.uri = e.content.url, delete e.content.url), e.content.uri && (e.content.uri = new URL(e.content.uri, t + "/").toString()), e.content.boundingVolume && !("box" in e.content.boundingVolume || "sphere" in e.content.boundingVolume || "region" in e.content.boundingVolume) && delete e.content.boundingVolume), e.parent = i, e.children = e.children || [], e.content && e.content.uri) {
      const s = vu(e.content.uri), r = !!(s && s.toLowerCase() === "json");
      e.__externalTileSet = r, e.__contentEmpty = r;
    } else
      e.__externalTileSet = !1, e.__contentEmpty = !0;
    e.__distanceFromCamera = 1 / 0, e.__error = 1 / 0, e.__inFrustum = !1, e.__isLeaf = !1, e.__usedLastFrame = !1, e.__used = !1, e.__wasSetVisible = !1, e.__visible = !1, e.__childrenWereVisible = !1, e.__allChildrenLoaded = !1, e.__wasSetActive = !1, e.__active = !1, e.__loadingState = ya, e.__loadIndex = 0, e.__loadAbort = null, e.__depthFromRenderedParent = -1, i === null ? (e.__depth = 0, e.refine = e.refine || "REPLACE") : (e.__depth = i.__depth + 1, e.refine = e.refine || i.refine), e.__basePath = t;
  }
  setTileActive(e, t) {
  }
  setTileVisible(e, t) {
  }
  calculateError(e) {
    return 0;
  }
  tileInView(e) {
    return !0;
  }
  ensureChildrenArePreprocessed(e) {
    const t = e.children;
    for (let i = 0, n = t.length; i < n; i++) {
      const s = t[i];
      if ("__depth" in s)
        break;
      this.preprocessNode(s, e.__basePath, e);
    }
  }
  resetFailedTiles() {
    const e = this.stats;
    e.failed !== 0 && (this.traverse((t) => {
      t.__loadingState === Wa && (t.__loadingState = ya);
    }), e.failed = 0);
  }
  // Private Functions
  fetchTileSet(e, t, i = null) {
    return fetch(e, t).then((n) => {
      if (n.ok)
        return n.json();
      throw new Error(`TilesRenderer: Failed to load tileset "${e}" with status ${n.status} : ${n.statusText}`);
    }).then((n) => {
      const s = n.asset.version, [r, a] = s.split(".").map((c) => parseInt(c));
      console.assert(
        r <= 1,
        "TilesRenderer: asset.version is expected to be a 1.x or a compatible version."
      ), r === 1 && a > 0 && console.warn("TilesRenderer: tiles versions at 1.1 or higher have limited support. Some new extensions and features may not be supported.");
      let l = e.replace(/\/[^\/]*\/?$/, "");
      return l = new URL(l, window.location.href).toString(), this.preprocessNode(n.root, l, i), n;
    });
  }
  loadRootTileSet(e) {
    const t = this.tileSets;
    if (e in t)
      return t[e] instanceof Error ? Promise.reject(t[e]) : Promise.resolve(t[e]);
    {
      const i = this.fetchTileSet(this.preprocessURL ? this.preprocessURL(e) : e, this.fetchOptions).then((n) => {
        t[e] = n;
      });
      return i.catch((n) => {
        console.error(n), t[e] = n;
      }), t[e] = i, i;
    }
  }
  requestTileContents(e) {
    if (e.__loadingState !== ya)
      return;
    const t = this.stats, i = this.lruCache, n = this.downloadQueue, s = this.parseQueue, r = e.__externalTileSet;
    i.add(e, (u) => {
      u.__loadingState === xa ? (u.__loadAbort.abort(), u.__loadAbort = null) : r ? u.children.length = 0 : this.disposeTile(u), u.__loadingState === xa ? t.downloading-- : u.__loadingState === Yo && t.parsing--, u.__loadingState = ya, u.__loadIndex++, s.remove(u), n.remove(u);
    }), e.__loadIndex++;
    const a = e.__loadIndex, l = new AbortController(), c = l.signal;
    t.downloading++, e.__loadAbort = l, e.__loadingState = xa;
    const h = (u) => {
      e.__loadIndex === a && (u.name !== "AbortError" ? (s.remove(e), n.remove(e), e.__loadingState === Yo ? t.parsing-- : e.__loadingState === xa && t.downloading--, t.failed++, console.error(`TilesRenderer : Failed to load tile at url "${e.content.uri}".`), console.error(u), e.__loadingState = Wa) : i.remove(e));
    };
    r ? n.add(e, (u) => {
      if (u.__loadIndex !== a)
        return Promise.resolve();
      const d = this.preprocessURL ? this.preprocessURL(u.content.uri) : u.content.uri;
      return this.fetchTileSet(d, Object.assign({ signal: c }, this.fetchOptions), u);
    }).then((u) => {
      e.__loadIndex === a && (t.downloading--, e.__loadAbort = null, e.__loadingState = Er, e.children.push(u.root));
    }).catch(h) : n.add(e, (u) => {
      if (u.__loadIndex !== a)
        return Promise.resolve();
      const d = this.preprocessURL ? this.preprocessURL(u.content.uri) : u.content.uri;
      return fetch(d, Object.assign({ signal: c }, this.fetchOptions));
    }).then((u) => {
      if (e.__loadIndex === a) {
        if (u.ok)
          return u.arrayBuffer();
        throw new Error(`Failed to load model with error code ${u.status}`);
      }
    }).then((u) => {
      if (e.__loadIndex === a)
        return t.downloading--, t.parsing++, e.__loadAbort = null, e.__loadingState = Yo, s.add(e, (d) => {
          if (d.__loadIndex !== a)
            return Promise.resolve();
          const f = d.content.uri, m = vu(f);
          return this.parseTile(u, d, m);
        });
    }).then(() => {
      e.__loadIndex === a && (t.parsing--, e.__loadingState = Er, e.__wasSetVisible && this.setTileVisible(e, !0), e.__wasSetActive && this.setTileActive(e, !0));
    }).catch(h);
  }
  dispose() {
    const e = this.lruCache, t = [];
    this.traverse((i) => (t.push(i), !1));
    for (let i = 0, n = t.length; i < n; i++)
      e.remove(t[i]);
    this.stats = {
      parsing: 0,
      downloading: 0,
      failed: 0,
      inFrustum: 0,
      used: 0,
      active: 0,
      visible: 0
    }, this.frameCount = 0;
  }
}
function Qd(o) {
  return new TextDecoder().decode(o);
}
class no {
  constructor(e, t, i, n) {
    this.buffer = e, this.binOffset = t + i, this.binLength = n;
    let s = null;
    if (i !== 0) {
      const r = new Uint8Array(e, t, i);
      s = JSON.parse(Qd(r));
    } else
      s = {};
    this.header = s;
  }
  getKeys() {
    return Object.keys(this.header);
  }
  getData(e, t, i = null, n = null) {
    const s = this.header;
    if (!(e in s))
      return null;
    const r = s[e];
    if (r instanceof Object) {
      if (Array.isArray(r))
        return r;
      {
        const { buffer: a, binOffset: l, binLength: c } = this, h = r.byteOffset || 0, u = r.type || n, d = r.componentType || i;
        if ("type" in r && n && r.type !== n)
          throw new Error("FeatureTable: Specified type does not match expected type.");
        let f;
        switch (u) {
          case "SCALAR":
            f = 1;
            break;
          case "VEC2":
            f = 2;
            break;
          case "VEC3":
            f = 3;
            break;
          case "VEC4":
            f = 4;
            break;
          default:
            throw new Error(`FeatureTable : Feature type not provided for "${e}".`);
        }
        let m;
        const _ = l + h, p = t * f;
        switch (d) {
          case "BYTE":
            m = new Int8Array(a, _, p);
            break;
          case "UNSIGNED_BYTE":
            m = new Uint8Array(a, _, p);
            break;
          case "SHORT":
            m = new Int16Array(a, _, p);
            break;
          case "UNSIGNED_SHORT":
            m = new Uint16Array(a, _, p);
            break;
          case "INT":
            m = new Int32Array(a, _, p);
            break;
          case "UNSIGNED_INT":
            m = new Uint32Array(a, _, p);
            break;
          case "FLOAT":
            m = new Float32Array(a, _, p);
            break;
          case "DOUBLE":
            m = new Float64Array(a, _, p);
            break;
          default:
            throw new Error(`FeatureTable : Feature component type not provided for "${e}".`);
        }
        if (_ + p * m.BYTES_PER_ELEMENT > l + c)
          throw new Error("FeatureTable: Feature data read outside binary body length.");
        return m;
      }
    } else return r;
  }
  getBuffer(e, t) {
    const { buffer: i, binOffset: n } = this;
    return i.slice(n + e, n + e + t);
  }
}
class Tc extends no {
  constructor(e, t, i, n, s) {
    super(e, i, n, s), this.batchSize = t;
  }
  getData(e, t = null, i = null) {
    return super.getData(e, this.batchSize, t, i);
  }
}
class Or {
  constructor() {
    this.fetchOptions = {}, this.workingPath = "";
  }
  load(e) {
    return fetch(e, this.fetchOptions).then((t) => {
      if (!t.ok)
        throw new Error(`Failed to load file "${e}" with status ${t.status} : ${t.statusText}`);
      return t.arrayBuffer();
    }).then((t) => (this.workingPath === "" && (this.workingPath = this.workingPathForURL(e)), this.parse(t)));
  }
  resolveExternalURL(e) {
    return /^[^\\/]/.test(e) ? this.workingPath + "/" + e : e;
  }
  workingPathForURL(e) {
    const t = e.split(/[\\/]/g);
    return t.pop(), t.join("/") + "/";
  }
  parse(e) {
    throw new Error("LoaderBase: Parse not implemented.");
  }
}
function Os(o) {
  let e;
  if (o instanceof DataView ? e = o : e = new DataView(o), String.fromCharCode(e.getUint8(0)) === "{")
    return null;
  let t = "";
  for (let i = 0; i < 4; i++)
    t += String.fromCharCode(e.getUint8(i));
  return t;
}
class Rx extends Or {
  parse(e) {
    const t = new DataView(e), i = Os(t);
    console.assert(i === "b3dm");
    const n = t.getUint32(4, !0);
    console.assert(n === 1);
    const s = t.getUint32(8, !0);
    console.assert(s === e.byteLength);
    const r = t.getUint32(12, !0), a = t.getUint32(16, !0), l = t.getUint32(20, !0), c = t.getUint32(24, !0), h = 28, u = e.slice(
      h,
      h + r + a
    ), d = new no(
      u,
      0,
      r,
      a
    ), f = h + r + a, m = e.slice(
      f,
      f + l + c
    ), _ = new Tc(
      m,
      d.getData("BATCH_LENGTH"),
      0,
      l,
      c
    ), p = f + l + c, g = new Uint8Array(e, p, s - p);
    return {
      version: n,
      featureTable: d,
      batchTable: _,
      glbBytes: g
    };
  }
}
class Ns extends xi {
  constructor(e) {
    super(e), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register(function(t) {
      return new kx(t);
    }), this.register(function(t) {
      return new Hx(t);
    }), this.register(function(t) {
      return new Wx(t);
    }), this.register(function(t) {
      return new Fx(t);
    }), this.register(function(t) {
      return new Bx(t);
    }), this.register(function(t) {
      return new Ux(t);
    }), this.register(function(t) {
      return new Vx(t);
    }), this.register(function(t) {
      return new Nx(t);
    }), this.register(function(t) {
      return new Gx(t);
    }), this.register(function(t) {
      return new zx(t);
    }), this.register(function(t) {
      return new Dx(t);
    }), this.register(function(t) {
      return new Xx(t);
    }), this.register(function(t) {
      return new qx(t);
    });
  }
  load(e, t, i, n) {
    const s = this;
    let r;
    this.resourcePath !== "" ? r = this.resourcePath : this.path !== "" ? r = this.path : r = ci.extractUrlBase(e), this.manager.itemStart(e);
    const a = function(c) {
      n ? n(c) : console.error(c), s.manager.itemError(e), s.manager.itemEnd(e);
    }, l = new Ai(this.manager);
    l.setPath(this.path), l.setResponseType("arraybuffer"), l.setRequestHeader(this.requestHeader), l.setWithCredentials(this.withCredentials), l.load(e, function(c) {
      try {
        s.parse(c, r, function(h) {
          t(h), s.manager.itemEnd(e);
        }, a);
      } catch (h) {
        a(h);
      }
    }, i, a);
  }
  setDRACOLoader(e) {
    return this.dracoLoader = e, this;
  }
  setDDSLoader() {
    throw new Error(
      'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".'
    );
  }
  setKTX2Loader(e) {
    return this.ktx2Loader = e, this;
  }
  setMeshoptDecoder(e) {
    return this.meshoptDecoder = e, this;
  }
  register(e) {
    return this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e), this;
  }
  unregister(e) {
    return this.pluginCallbacks.indexOf(e) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this;
  }
  parse(e, t, i, n) {
    let s;
    const r = {}, a = {};
    if (typeof e == "string")
      s = JSON.parse(e);
    else if (e instanceof ArrayBuffer)
      if (ci.decodeText(new Uint8Array(e, 0, 4)) === ef) {
        try {
          r[Ke.KHR_BINARY_GLTF] = new jx(e);
        } catch (h) {
          n && n(h);
          return;
        }
        s = JSON.parse(r[Ke.KHR_BINARY_GLTF].content);
      } else
        s = JSON.parse(ci.decodeText(new Uint8Array(e)));
    else
      s = e;
    if (s.asset === void 0 || s.asset.version[0] < 2) {
      n && n(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
      return;
    }
    const l = new aw(s, {
      path: t || this.resourcePath || "",
      crossOrigin: this.crossOrigin,
      requestHeader: this.requestHeader,
      manager: this.manager,
      ktx2Loader: this.ktx2Loader,
      meshoptDecoder: this.meshoptDecoder
    });
    l.fileLoader.setRequestHeader(this.requestHeader);
    for (let c = 0; c < this.pluginCallbacks.length; c++) {
      const h = this.pluginCallbacks[c](l);
      a[h.name] = h, r[h.name] = !0;
    }
    if (s.extensionsUsed)
      for (let c = 0; c < s.extensionsUsed.length; ++c) {
        const h = s.extensionsUsed[c], u = s.extensionsRequired || [];
        switch (h) {
          case Ke.KHR_MATERIALS_UNLIT:
            r[h] = new Ox();
            break;
          case Ke.KHR_DRACO_MESH_COMPRESSION:
            r[h] = new Yx(s, this.dracoLoader);
            break;
          case Ke.KHR_TEXTURE_TRANSFORM:
            r[h] = new Zx();
            break;
          case Ke.KHR_MESH_QUANTIZATION:
            r[h] = new Jx();
            break;
          default:
            u.indexOf(h) >= 0 && a[h] === void 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + h + '".');
        }
      }
    l.setExtensions(r), l.setPlugins(a), l.parse(i, n);
  }
  parseAsync(e, t) {
    const i = this;
    return new Promise(function(n, s) {
      i.parse(e, t, n, s);
    });
  }
}
function Ix() {
  let o = {};
  return {
    get: function(e) {
      return o[e];
    },
    add: function(e, t) {
      o[e] = t;
    },
    remove: function(e) {
      delete o[e];
    },
    removeAll: function() {
      o = {};
    }
  };
}
const Ke = {
  KHR_BINARY_GLTF: "KHR_binary_glTF",
  KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
  KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
  KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
  KHR_MATERIALS_IOR: "KHR_materials_ior",
  KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
  KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
  KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
  KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
  KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
  KHR_MATERIALS_VOLUME: "KHR_materials_volume",
  KHR_TEXTURE_BASISU: "KHR_texture_basisu",
  KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
  KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
  KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
  EXT_TEXTURE_WEBP: "EXT_texture_webp",
  EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
  EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
};
class Dx {
  constructor(e) {
    this.parser = e, this.name = Ke.KHR_LIGHTS_PUNCTUAL, this.cache = { refs: {}, uses: {} };
  }
  _markDefs() {
    const e = this.parser, t = this.parser.json.nodes || [];
    for (let i = 0, n = t.length; i < n; i++) {
      const s = t[i];
      s.extensions && s.extensions[this.name] && s.extensions[this.name].light !== void 0 && e._addNodeRef(this.cache, s.extensions[this.name].light);
    }
  }
  _loadLight(e) {
    const t = this.parser, i = "light:" + e;
    let n = t.cache.get(i);
    if (n) return n;
    const s = t.json, l = ((s.extensions && s.extensions[this.name] || {}).lights || [])[e];
    let c;
    const h = new de(16777215);
    l.color !== void 0 && h.fromArray(l.color);
    const u = l.range !== void 0 ? l.range : 0;
    switch (l.type) {
      case "directional":
        c = new vc(h), c.target.position.set(0, 0, -1), c.add(c.target);
        break;
      case "point":
        c = new Ha(h), c.distance = u;
        break;
      case "spot":
        c = new gc(h), c.distance = u, l.spot = l.spot || {}, l.spot.innerConeAngle = l.spot.innerConeAngle !== void 0 ? l.spot.innerConeAngle : 0, l.spot.outerConeAngle = l.spot.outerConeAngle !== void 0 ? l.spot.outerConeAngle : Math.PI / 4, c.angle = l.spot.outerConeAngle, c.penumbra = 1 - l.spot.innerConeAngle / l.spot.outerConeAngle, c.target.position.set(0, 0, -1), c.add(c.target);
        break;
      default:
        throw new Error("THREE.GLTFLoader: Unexpected light type: " + l.type);
    }
    return c.position.set(0, 0, 0), c.decay = 2, ln(c, l), l.intensity !== void 0 && (c.intensity = l.intensity), c.name = t.createUniqueName(l.name || "light_" + e), n = Promise.resolve(c), t.cache.add(i, n), n;
  }
  getDependency(e, t) {
    if (e === "light")
      return this._loadLight(t);
  }
  createNodeAttachment(e) {
    const t = this, i = this.parser, s = i.json.nodes[e], a = (s.extensions && s.extensions[this.name] || {}).light;
    return a === void 0 ? null : this._loadLight(a).then(function(l) {
      return i._getNodeRef(t.cache, a, l);
    });
  }
}
class Ox {
  constructor() {
    this.name = Ke.KHR_MATERIALS_UNLIT;
  }
  getMaterialType() {
    return gi;
  }
  extendParams(e, t, i) {
    const n = [];
    e.color = new de(1, 1, 1), e.opacity = 1;
    const s = t.pbrMetallicRoughness;
    if (s) {
      if (Array.isArray(s.baseColorFactor)) {
        const r = s.baseColorFactor;
        e.color.fromArray(r), e.opacity = r[3];
      }
      s.baseColorTexture !== void 0 && n.push(i.assignTexture(e, "map", s.baseColorTexture, He));
    }
    return Promise.all(n);
  }
}
class Nx {
  constructor(e) {
    this.parser = e, this.name = Ke.KHR_MATERIALS_EMISSIVE_STRENGTH;
  }
  extendMaterialParams(e, t) {
    const n = this.parser.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const s = n.extensions[this.name].emissiveStrength;
    return s !== void 0 && (t.emissiveIntensity = s), Promise.resolve();
  }
}
class kx {
  constructor(e) {
    this.parser = e, this.name = Ke.KHR_MATERIALS_CLEARCOAT;
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : vn;
  }
  extendMaterialParams(e, t) {
    const i = this.parser, n = i.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const s = [], r = n.extensions[this.name];
    if (r.clearcoatFactor !== void 0 && (t.clearcoat = r.clearcoatFactor), r.clearcoatTexture !== void 0 && s.push(i.assignTexture(t, "clearcoatMap", r.clearcoatTexture)), r.clearcoatRoughnessFactor !== void 0 && (t.clearcoatRoughness = r.clearcoatRoughnessFactor), r.clearcoatRoughnessTexture !== void 0 && s.push(i.assignTexture(t, "clearcoatRoughnessMap", r.clearcoatRoughnessTexture)), r.clearcoatNormalTexture !== void 0 && (s.push(i.assignTexture(t, "clearcoatNormalMap", r.clearcoatNormalTexture)), r.clearcoatNormalTexture.scale !== void 0)) {
      const a = r.clearcoatNormalTexture.scale;
      t.clearcoatNormalScale = new G(a, a);
    }
    return Promise.all(s);
  }
}
class zx {
  constructor(e) {
    this.parser = e, this.name = Ke.KHR_MATERIALS_IRIDESCENCE;
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : vn;
  }
  extendMaterialParams(e, t) {
    const i = this.parser, n = i.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const s = [], r = n.extensions[this.name];
    return r.iridescenceFactor !== void 0 && (t.iridescence = r.iridescenceFactor), r.iridescenceTexture !== void 0 && s.push(i.assignTexture(t, "iridescenceMap", r.iridescenceTexture)), r.iridescenceIor !== void 0 && (t.iridescenceIOR = r.iridescenceIor), t.iridescenceThicknessRange === void 0 && (t.iridescenceThicknessRange = [100, 400]), r.iridescenceThicknessMinimum !== void 0 && (t.iridescenceThicknessRange[0] = r.iridescenceThicknessMinimum), r.iridescenceThicknessMaximum !== void 0 && (t.iridescenceThicknessRange[1] = r.iridescenceThicknessMaximum), r.iridescenceThicknessTexture !== void 0 && s.push(i.assignTexture(t, "iridescenceThicknessMap", r.iridescenceThicknessTexture)), Promise.all(s);
  }
}
class Fx {
  constructor(e) {
    this.parser = e, this.name = Ke.KHR_MATERIALS_SHEEN;
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : vn;
  }
  extendMaterialParams(e, t) {
    const i = this.parser, n = i.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const s = [];
    t.sheenColor = new de(0, 0, 0), t.sheenRoughness = 0, t.sheen = 1;
    const r = n.extensions[this.name];
    return r.sheenColorFactor !== void 0 && t.sheenColor.fromArray(r.sheenColorFactor), r.sheenRoughnessFactor !== void 0 && (t.sheenRoughness = r.sheenRoughnessFactor), r.sheenColorTexture !== void 0 && s.push(i.assignTexture(t, "sheenColorMap", r.sheenColorTexture, He)), r.sheenRoughnessTexture !== void 0 && s.push(i.assignTexture(t, "sheenRoughnessMap", r.sheenRoughnessTexture)), Promise.all(s);
  }
}
class Bx {
  constructor(e) {
    this.parser = e, this.name = Ke.KHR_MATERIALS_TRANSMISSION;
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : vn;
  }
  extendMaterialParams(e, t) {
    const i = this.parser, n = i.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const s = [], r = n.extensions[this.name];
    return r.transmissionFactor !== void 0 && (t.transmission = r.transmissionFactor), r.transmissionTexture !== void 0 && s.push(i.assignTexture(t, "transmissionMap", r.transmissionTexture)), Promise.all(s);
  }
}
class Ux {
  constructor(e) {
    this.parser = e, this.name = Ke.KHR_MATERIALS_VOLUME;
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : vn;
  }
  extendMaterialParams(e, t) {
    const i = this.parser, n = i.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const s = [], r = n.extensions[this.name];
    t.thickness = r.thicknessFactor !== void 0 ? r.thicknessFactor : 0, r.thicknessTexture !== void 0 && s.push(i.assignTexture(t, "thicknessMap", r.thicknessTexture)), t.attenuationDistance = r.attenuationDistance || 1 / 0;
    const a = r.attenuationColor || [1, 1, 1];
    return t.attenuationColor = new de(a[0], a[1], a[2]), Promise.all(s);
  }
}
class Vx {
  constructor(e) {
    this.parser = e, this.name = Ke.KHR_MATERIALS_IOR;
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : vn;
  }
  extendMaterialParams(e, t) {
    const n = this.parser.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const s = n.extensions[this.name];
    return t.ior = s.ior !== void 0 ? s.ior : 1.5, Promise.resolve();
  }
}
class Gx {
  constructor(e) {
    this.parser = e, this.name = Ke.KHR_MATERIALS_SPECULAR;
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : vn;
  }
  extendMaterialParams(e, t) {
    const i = this.parser, n = i.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const s = [], r = n.extensions[this.name];
    t.specularIntensity = r.specularFactor !== void 0 ? r.specularFactor : 1, r.specularTexture !== void 0 && s.push(i.assignTexture(t, "specularIntensityMap", r.specularTexture));
    const a = r.specularColorFactor || [1, 1, 1];
    return t.specularColor = new de(a[0], a[1], a[2]), r.specularColorTexture !== void 0 && s.push(i.assignTexture(t, "specularColorMap", r.specularColorTexture, He)), Promise.all(s);
  }
}
class Hx {
  constructor(e) {
    this.parser = e, this.name = Ke.KHR_TEXTURE_BASISU;
  }
  loadTexture(e) {
    const t = this.parser, i = t.json, n = i.textures[e];
    if (!n.extensions || !n.extensions[this.name])
      return null;
    const s = n.extensions[this.name], r = t.options.ktx2Loader;
    if (!r) {
      if (i.extensionsRequired && i.extensionsRequired.indexOf(this.name) >= 0)
        throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
      return null;
    }
    return t.loadTextureImage(e, s.source, r);
  }
}
class Wx {
  constructor(e) {
    this.parser = e, this.name = Ke.EXT_TEXTURE_WEBP, this.isSupported = null;
  }
  loadTexture(e) {
    const t = this.name, i = this.parser, n = i.json, s = n.textures[e];
    if (!s.extensions || !s.extensions[t])
      return null;
    const r = s.extensions[t], a = n.images[r.source];
    let l = i.textureLoader;
    if (a.uri) {
      const c = i.options.manager.getHandler(a.uri);
      c !== null && (l = c);
    }
    return this.detectSupport().then(function(c) {
      if (c) return i.loadTextureImage(e, r.source, l);
      if (n.extensionsRequired && n.extensionsRequired.indexOf(t) >= 0)
        throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
      return i.loadTexture(e);
    });
  }
  detectSupport() {
    return this.isSupported || (this.isSupported = new Promise(function(e) {
      const t = new Image();
      t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", t.onload = t.onerror = function() {
        e(t.height === 1);
      };
    })), this.isSupported;
  }
}
class Xx {
  constructor(e) {
    this.name = Ke.EXT_MESHOPT_COMPRESSION, this.parser = e;
  }
  loadBufferView(e) {
    const t = this.parser.json, i = t.bufferViews[e];
    if (i.extensions && i.extensions[this.name]) {
      const n = i.extensions[this.name], s = this.parser.getDependency("buffer", n.buffer), r = this.parser.options.meshoptDecoder;
      if (!r || !r.supported) {
        if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0)
          throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
        return null;
      }
      return s.then(function(a) {
        const l = n.byteOffset || 0, c = n.byteLength || 0, h = n.count, u = n.byteStride, d = new Uint8Array(a, l, c);
        return r.decodeGltfBufferAsync ? r.decodeGltfBufferAsync(h, u, d, n.mode, n.filter).then(function(f) {
          return f.buffer;
        }) : r.ready.then(function() {
          const f = new ArrayBuffer(h * u);
          return r.decodeGltfBuffer(new Uint8Array(f), h, u, d, n.mode, n.filter), f;
        });
      });
    } else
      return null;
  }
}
class qx {
  constructor(e) {
    this.name = Ke.EXT_MESH_GPU_INSTANCING, this.parser = e;
  }
  createNodeMesh(e) {
    const t = this.parser.json, i = t.nodes[e];
    if (!i.extensions || !i.extensions[this.name] || i.mesh === void 0)
      return null;
    const n = t.meshes[i.mesh];
    for (const c of n.primitives)
      if (c.mode !== si.TRIANGLES && c.mode !== si.TRIANGLE_STRIP && c.mode !== si.TRIANGLE_FAN && c.mode !== void 0)
        return null;
    const r = i.extensions[this.name].attributes, a = [], l = {};
    for (const c in r)
      a.push(this.parser.getDependency("accessor", r[c]).then((h) => (l[c] = h, l[c])));
    return a.length < 1 ? null : (a.push(this.parser.createNodeMesh(e)), Promise.all(a).then((c) => {
      const h = c.pop(), u = h.isGroup ? h.children : [h], d = c[0].count, f = [];
      for (const m of u) {
        const _ = new ue(), p = new b(), g = new Et(), x = new b(1, 1, 1), y = new jl(m.geometry, m.material, d);
        for (let v = 0; v < d; v++)
          l.TRANSLATION && p.fromBufferAttribute(l.TRANSLATION, v), l.ROTATION && g.fromBufferAttribute(l.ROTATION, v), l.SCALE && x.fromBufferAttribute(l.SCALE, v), y.setMatrixAt(v, _.compose(p, g, x));
        for (const v in l)
          v !== "TRANSLATION" && v !== "ROTATION" && v !== "SCALE" && m.geometry.setAttribute(v, l[v]);
        tt.prototype.copy.call(y, m), y.frustumCulled = !1, this.parser.assignFinalMaterial(y), f.push(y);
      }
      return h.isGroup ? (h.clear(), h.add(...f), h) : f[0];
    }));
  }
}
const ef = "glTF", tr = 12, wu = { JSON: 1313821514, BIN: 5130562 };
class jx {
  constructor(e) {
    this.name = Ke.KHR_BINARY_GLTF, this.content = null, this.body = null;
    const t = new DataView(e, 0, tr);
    if (this.header = {
      magic: ci.decodeText(new Uint8Array(e.slice(0, 4))),
      version: t.getUint32(4, !0),
      length: t.getUint32(8, !0)
    }, this.header.magic !== ef)
      throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
    if (this.header.version < 2)
      throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
    const i = this.header.length - tr, n = new DataView(e, tr);
    let s = 0;
    for (; s < i; ) {
      const r = n.getUint32(s, !0);
      s += 4;
      const a = n.getUint32(s, !0);
      if (s += 4, a === wu.JSON) {
        const l = new Uint8Array(e, tr + s, r);
        this.content = ci.decodeText(l);
      } else if (a === wu.BIN) {
        const l = tr + s;
        this.body = e.slice(l, l + r);
      }
      s += r;
    }
    if (this.content === null)
      throw new Error("THREE.GLTFLoader: JSON content not found.");
  }
}
class Yx {
  constructor(e, t) {
    if (!t)
      throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
    this.name = Ke.KHR_DRACO_MESH_COMPRESSION, this.json = e, this.dracoLoader = t, this.dracoLoader.preload();
  }
  decodePrimitive(e, t) {
    const i = this.json, n = this.dracoLoader, s = e.extensions[this.name].bufferView, r = e.extensions[this.name].attributes, a = {}, l = {}, c = {};
    for (const h in r) {
      const u = Cl[h] || h.toLowerCase();
      a[u] = r[h];
    }
    for (const h in e.attributes) {
      const u = Cl[h] || h.toLowerCase();
      if (r[h] !== void 0) {
        const d = i.accessors[e.attributes[h]], f = Ts[d.componentType];
        c[u] = f.name, l[u] = d.normalized === !0;
      }
    }
    return t.getDependency("bufferView", s).then(function(h) {
      return new Promise(function(u) {
        n.decodeDracoFile(h, function(d) {
          for (const f in d.attributes) {
            const m = d.attributes[f], _ = l[f];
            _ !== void 0 && (m.normalized = _);
          }
          u(d);
        }, a, c);
      });
    });
  }
}
class Zx {
  constructor() {
    this.name = Ke.KHR_TEXTURE_TRANSFORM;
  }
  extendTexture(e, t) {
    return t.texCoord !== void 0 && console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.'), t.offset === void 0 && t.rotation === void 0 && t.scale === void 0 || (e = e.clone(), t.offset !== void 0 && e.offset.fromArray(t.offset), t.rotation !== void 0 && (e.rotation = t.rotation), t.scale !== void 0 && e.repeat.fromArray(t.scale), e.needsUpdate = !0), e;
  }
}
class Jx {
  constructor() {
    this.name = Ke.KHR_MESH_QUANTIZATION;
  }
}
class tf extends Dr {
  constructor(e, t, i, n) {
    super(e, t, i, n);
  }
  copySampleValue_(e) {
    const t = this.resultBuffer, i = this.sampleValues, n = this.valueSize, s = e * n * 3 + n;
    for (let r = 0; r !== n; r++)
      t[r] = i[s + r];
    return t;
  }
  interpolate_(e, t, i, n) {
    const s = this.resultBuffer, r = this.sampleValues, a = this.valueSize, l = a * 2, c = a * 3, h = n - t, u = (i - t) / h, d = u * u, f = d * u, m = e * c, _ = m - c, p = -2 * f + 3 * d, g = f - d, x = 1 - p, y = g - d + u;
    for (let v = 0; v !== a; v++) {
      const M = r[_ + v + a], S = r[_ + v + l] * h, A = r[m + v + a], w = r[m + v] * h;
      s[v] = x * M + y * S + p * A + g * w;
    }
    return s;
  }
}
const Kx = new Et();
class $x extends tf {
  interpolate_(e, t, i, n) {
    const s = super.interpolate_(e, t, i, n);
    return Kx.fromArray(s).normalize().toArray(s), s;
  }
}
const si = {
  FLOAT: 5126,
  //FLOAT_MAT2: 35674,
  FLOAT_MAT3: 35675,
  FLOAT_MAT4: 35676,
  FLOAT_VEC2: 35664,
  FLOAT_VEC3: 35665,
  FLOAT_VEC4: 35666,
  LINEAR: 9729,
  REPEAT: 10497,
  SAMPLER_2D: 35678,
  POINTS: 0,
  LINES: 1,
  LINE_LOOP: 2,
  LINE_STRIP: 3,
  TRIANGLES: 4,
  TRIANGLE_STRIP: 5,
  TRIANGLE_FAN: 6,
  UNSIGNED_BYTE: 5121,
  UNSIGNED_SHORT: 5123
}, Ts = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
}, bu = {
  9728: yt,
  9729: Ut,
  9984: Ba,
  9985: kl,
  9986: cr,
  9987: fn
}, Mu = {
  33071: Vt,
  33648: _r,
  10497: Yi
}, Zo = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
}, Cl = {
  POSITION: "position",
  NORMAL: "normal",
  TANGENT: "tangent",
  TEXCOORD_0: "uv",
  TEXCOORD_1: "uv2",
  COLOR_0: "color",
  WEIGHTS_0: "skinWeight",
  JOINTS_0: "skinIndex"
}, en = {
  scale: "scale",
  translation: "position",
  rotation: "quaternion",
  weights: "morphTargetInfluences"
}, Qx = {
  CUBICSPLINE: void 0,
  // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each
  // keyframe track will be initialized with a default interpolation type, then modified.
  LINEAR: Cs,
  STEP: vr
}, Jo = {
  OPAQUE: "OPAQUE",
  MASK: "MASK",
  BLEND: "BLEND"
};
function ew(o) {
  return o.DefaultMaterial === void 0 && (o.DefaultMaterial = new io({
    color: 16777215,
    emissive: 0,
    metalness: 1,
    roughness: 1,
    transparent: !1,
    depthTest: !0,
    side: dn
  })), o.DefaultMaterial;
}
function ir(o, e, t) {
  for (const i in t.extensions)
    o[i] === void 0 && (e.userData.gltfExtensions = e.userData.gltfExtensions || {}, e.userData.gltfExtensions[i] = t.extensions[i]);
}
function ln(o, e) {
  e.extras !== void 0 && (typeof e.extras == "object" ? Object.assign(o.userData, e.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras));
}
function tw(o, e, t) {
  let i = !1, n = !1, s = !1;
  for (let c = 0, h = e.length; c < h; c++) {
    const u = e[c];
    if (u.POSITION !== void 0 && (i = !0), u.NORMAL !== void 0 && (n = !0), u.COLOR_0 !== void 0 && (s = !0), i && n && s) break;
  }
  if (!i && !n && !s) return Promise.resolve(o);
  const r = [], a = [], l = [];
  for (let c = 0, h = e.length; c < h; c++) {
    const u = e[c];
    if (i) {
      const d = u.POSITION !== void 0 ? t.getDependency("accessor", u.POSITION) : o.attributes.position;
      r.push(d);
    }
    if (n) {
      const d = u.NORMAL !== void 0 ? t.getDependency("accessor", u.NORMAL) : o.attributes.normal;
      a.push(d);
    }
    if (s) {
      const d = u.COLOR_0 !== void 0 ? t.getDependency("accessor", u.COLOR_0) : o.attributes.color;
      l.push(d);
    }
  }
  return Promise.all([
    Promise.all(r),
    Promise.all(a),
    Promise.all(l)
  ]).then(function(c) {
    const h = c[0], u = c[1], d = c[2];
    return i && (o.morphAttributes.position = h), n && (o.morphAttributes.normal = u), s && (o.morphAttributes.color = d), o.morphTargetsRelative = !0, o;
  });
}
function iw(o, e) {
  if (o.updateMorphTargets(), e.weights !== void 0)
    for (let t = 0, i = e.weights.length; t < i; t++)
      o.morphTargetInfluences[t] = e.weights[t];
  if (e.extras && Array.isArray(e.extras.targetNames)) {
    const t = e.extras.targetNames;
    if (o.morphTargetInfluences.length === t.length) {
      o.morphTargetDictionary = {};
      for (let i = 0, n = t.length; i < n; i++)
        o.morphTargetDictionary[t[i]] = i;
    } else
      console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
  }
}
function nw(o) {
  const e = o.extensions && o.extensions[Ke.KHR_DRACO_MESH_COMPRESSION];
  let t;
  return e ? t = "draco:" + e.bufferView + ":" + e.indices + ":" + Su(e.attributes) : t = o.indices + ":" + Su(o.attributes) + ":" + o.mode, t;
}
function Su(o) {
  let e = "";
  const t = Object.keys(o).sort();
  for (let i = 0, n = t.length; i < n; i++)
    e += t[i] + ":" + o[t[i]] + ";";
  return e;
}
function Ll(o) {
  switch (o) {
    case Int8Array:
      return 1 / 127;
    case Uint8Array:
      return 1 / 255;
    case Int16Array:
      return 1 / 32767;
    case Uint16Array:
      return 1 / 65535;
    default:
      throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.");
  }
}
function sw(o) {
  return o.search(/\.jpe?g($|\?)/i) > 0 || o.search(/^data\:image\/jpeg/) === 0 ? "image/jpeg" : o.search(/\.webp($|\?)/i) > 0 || o.search(/^data\:image\/webp/) === 0 ? "image/webp" : "image/png";
}
const rw = new ue();
class aw {
  constructor(e = {}, t = {}) {
    this.json = e, this.extensions = {}, this.plugins = {}, this.options = t, this.cache = new Ix(), this.associations = /* @__PURE__ */ new Map(), this.primitiveCache = {}, this.meshCache = { refs: {}, uses: {} }, this.cameraCache = { refs: {}, uses: {} }, this.lightCache = { refs: {}, uses: {} }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {};
    let i = !1, n = !1, s = -1;
    typeof navigator < "u" && (i = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === !0, n = navigator.userAgent.indexOf("Firefox") > -1, s = n ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1), typeof createImageBitmap > "u" || i || n && s < 98 ? this.textureLoader = new fr(this.options.manager) : this.textureLoader = new ix(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new Ai(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), this.options.crossOrigin === "use-credentials" && this.fileLoader.setWithCredentials(!0);
  }
  setExtensions(e) {
    this.extensions = e;
  }
  setPlugins(e) {
    this.plugins = e;
  }
  parse(e, t) {
    const i = this, n = this.json, s = this.extensions;
    this.cache.removeAll(), this._invokeAll(function(r) {
      return r._markDefs && r._markDefs();
    }), Promise.all(this._invokeAll(function(r) {
      return r.beforeRoot && r.beforeRoot();
    })).then(function() {
      return Promise.all([
        i.getDependencies("scene"),
        i.getDependencies("animation"),
        i.getDependencies("camera")
      ]);
    }).then(function(r) {
      const a = {
        scene: r[0][n.scene || 0],
        scenes: r[0],
        animations: r[1],
        cameras: r[2],
        asset: n.asset,
        parser: i,
        userData: {}
      };
      ir(s, a, n), ln(a, n), Promise.all(i._invokeAll(function(l) {
        return l.afterRoot && l.afterRoot(a);
      })).then(function() {
        e(a);
      });
    }).catch(t);
  }
  /**
   * Marks the special nodes/meshes in json for efficient parse.
   */
  _markDefs() {
    const e = this.json.nodes || [], t = this.json.skins || [], i = this.json.meshes || [];
    for (let n = 0, s = t.length; n < s; n++) {
      const r = t[n].joints;
      for (let a = 0, l = r.length; a < l; a++)
        e[r[a]].isBone = !0;
    }
    for (let n = 0, s = e.length; n < s; n++) {
      const r = e[n];
      r.mesh !== void 0 && (this._addNodeRef(this.meshCache, r.mesh), r.skin !== void 0 && (i[r.mesh].isSkinnedMesh = !0)), r.camera !== void 0 && this._addNodeRef(this.cameraCache, r.camera);
    }
  }
  /**
   * Counts references to shared node / Object3D resources. These resources
   * can be reused, or "instantiated", at multiple nodes in the scene
   * hierarchy. Mesh, Camera, and Light instances are instantiated and must
   * be marked. Non-scenegraph resources (like Materials, Geometries, and
   * Textures) can be reused directly and are not marked here.
   *
   * Example: CesiumMilkTruck sample model reuses "Wheel" meshes.
   */
  _addNodeRef(e, t) {
    t !== void 0 && (e.refs[t] === void 0 && (e.refs[t] = e.uses[t] = 0), e.refs[t]++);
  }
  /** Returns a reference to a shared resource, cloning it if necessary. */
  _getNodeRef(e, t, i) {
    if (e.refs[t] <= 1) return i;
    const n = i.clone(), s = (r, a) => {
      const l = this.associations.get(r);
      l != null && this.associations.set(a, l);
      for (const [c, h] of r.children.entries())
        s(h, a.children[c]);
    };
    return s(i, n), n.name += "_instance_" + e.uses[t]++, n;
  }
  _invokeOne(e) {
    const t = Object.values(this.plugins);
    t.push(this);
    for (let i = 0; i < t.length; i++) {
      const n = e(t[i]);
      if (n) return n;
    }
    return null;
  }
  _invokeAll(e) {
    const t = Object.values(this.plugins);
    t.unshift(this);
    const i = [];
    for (let n = 0; n < t.length; n++) {
      const s = e(t[n]);
      s && i.push(s);
    }
    return i;
  }
  /**
   * Requests the specified dependency asynchronously, with caching.
   * @param {string} type
   * @param {number} index
   * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}
   */
  getDependency(e, t) {
    const i = e + ":" + t;
    let n = this.cache.get(i);
    if (!n) {
      switch (e) {
        case "scene":
          n = this.loadScene(t);
          break;
        case "node":
          n = this._invokeOne(function(s) {
            return s.loadNode && s.loadNode(t);
          });
          break;
        case "mesh":
          n = this._invokeOne(function(s) {
            return s.loadMesh && s.loadMesh(t);
          });
          break;
        case "accessor":
          n = this.loadAccessor(t);
          break;
        case "bufferView":
          n = this._invokeOne(function(s) {
            return s.loadBufferView && s.loadBufferView(t);
          });
          break;
        case "buffer":
          n = this.loadBuffer(t);
          break;
        case "material":
          n = this._invokeOne(function(s) {
            return s.loadMaterial && s.loadMaterial(t);
          });
          break;
        case "texture":
          n = this._invokeOne(function(s) {
            return s.loadTexture && s.loadTexture(t);
          });
          break;
        case "skin":
          n = this.loadSkin(t);
          break;
        case "animation":
          n = this._invokeOne(function(s) {
            return s.loadAnimation && s.loadAnimation(t);
          });
          break;
        case "camera":
          n = this.loadCamera(t);
          break;
        default:
          if (n = this._invokeOne(function(s) {
            return s != this && s.getDependency && s.getDependency(e, t);
          }), !n)
            throw new Error("Unknown type: " + e);
          break;
      }
      this.cache.add(i, n);
    }
    return n;
  }
  /**
   * Requests all dependencies of the specified type asynchronously, with caching.
   * @param {string} type
   * @return {Promise<Array<Object>>}
   */
  getDependencies(e) {
    let t = this.cache.get(e);
    if (!t) {
      const i = this, n = this.json[e + (e === "mesh" ? "es" : "s")] || [];
      t = Promise.all(n.map(function(s, r) {
        return i.getDependency(e, r);
      })), this.cache.add(e, t);
    }
    return t;
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {number} bufferIndex
   * @return {Promise<ArrayBuffer>}
   */
  loadBuffer(e) {
    const t = this.json.buffers[e], i = this.fileLoader;
    if (t.type && t.type !== "arraybuffer")
      throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported.");
    if (t.uri === void 0 && e === 0)
      return Promise.resolve(this.extensions[Ke.KHR_BINARY_GLTF].body);
    const n = this.options;
    return new Promise(function(s, r) {
      i.load(ci.resolveURL(t.uri, n.path), s, void 0, function() {
        r(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'));
      });
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {number} bufferViewIndex
   * @return {Promise<ArrayBuffer>}
   */
  loadBufferView(e) {
    const t = this.json.bufferViews[e];
    return this.getDependency("buffer", t.buffer).then(function(i) {
      const n = t.byteLength || 0, s = t.byteOffset || 0;
      return i.slice(s, s + n);
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors
   * @param {number} accessorIndex
   * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}
   */
  loadAccessor(e) {
    const t = this, i = this.json, n = this.json.accessors[e];
    if (n.bufferView === void 0 && n.sparse === void 0) {
      const r = Zo[n.type], a = Ts[n.componentType], l = n.normalized === !0, c = new a(n.count * r);
      return Promise.resolve(new $e(c, r, l));
    }
    const s = [];
    return n.bufferView !== void 0 ? s.push(this.getDependency("bufferView", n.bufferView)) : s.push(null), n.sparse !== void 0 && (s.push(this.getDependency("bufferView", n.sparse.indices.bufferView)), s.push(this.getDependency("bufferView", n.sparse.values.bufferView))), Promise.all(s).then(function(r) {
      const a = r[0], l = Zo[n.type], c = Ts[n.componentType], h = c.BYTES_PER_ELEMENT, u = h * l, d = n.byteOffset || 0, f = n.bufferView !== void 0 ? i.bufferViews[n.bufferView].byteStride : void 0, m = n.normalized === !0;
      let _, p;
      if (f && f !== u) {
        const g = Math.floor(d / f), x = "InterleavedBuffer:" + n.bufferView + ":" + n.componentType + ":" + g + ":" + n.count;
        let y = t.cache.get(x);
        y || (_ = new c(a, g * f, n.count * f / h), y = new $a(_, f / h), t.cache.add(x, y)), p = new $t(y, l, d % f / h, m);
      } else
        a === null ? _ = new c(n.count * l) : _ = new c(a, d, n.count * l), p = new $e(_, l, m);
      if (n.sparse !== void 0) {
        const g = Zo.SCALAR, x = Ts[n.sparse.indices.componentType], y = n.sparse.indices.byteOffset || 0, v = n.sparse.values.byteOffset || 0, M = new x(r[1], y, n.sparse.count * g), S = new c(r[2], v, n.sparse.count * l);
        a !== null && (p = new $e(p.array.slice(), p.itemSize, p.normalized));
        for (let A = 0, w = M.length; A < w; A++) {
          const E = M[A];
          if (p.setX(E, S[A * l]), l >= 2 && p.setY(E, S[A * l + 1]), l >= 3 && p.setZ(E, S[A * l + 2]), l >= 4 && p.setW(E, S[A * l + 3]), l >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
        }
      }
      return p;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures
   * @param {number} textureIndex
   * @return {Promise<THREE.Texture|null>}
   */
  loadTexture(e) {
    const t = this.json, i = this.options, s = t.textures[e].source, r = t.images[s];
    let a = this.textureLoader;
    if (r.uri) {
      const l = i.manager.getHandler(r.uri);
      l !== null && (a = l);
    }
    return this.loadTextureImage(e, s, a);
  }
  loadTextureImage(e, t, i) {
    const n = this, s = this.json, r = s.textures[e], a = s.images[t], l = (a.uri || a.bufferView) + ":" + r.sampler;
    if (this.textureCache[l])
      return this.textureCache[l];
    const c = this.loadImageSource(t, i).then(function(h) {
      h.flipY = !1, h.name = r.name || a.name || "";
      const d = (s.samplers || {})[r.sampler] || {};
      return h.magFilter = bu[d.magFilter] || Ut, h.minFilter = bu[d.minFilter] || fn, h.wrapS = Mu[d.wrapS] || Yi, h.wrapT = Mu[d.wrapT] || Yi, n.associations.set(h, { textures: e }), h;
    }).catch(function() {
      return null;
    });
    return this.textureCache[l] = c, c;
  }
  loadImageSource(e, t) {
    const i = this, n = this.json, s = this.options;
    if (this.sourceCache[e] !== void 0)
      return this.sourceCache[e].then((u) => u.clone());
    const r = n.images[e], a = self.URL || self.webkitURL;
    let l = r.uri || "", c = !1;
    if (r.bufferView !== void 0)
      l = i.getDependency("bufferView", r.bufferView).then(function(u) {
        c = !0;
        const d = new Blob([u], { type: r.mimeType });
        return l = a.createObjectURL(d), l;
      });
    else if (r.uri === void 0)
      throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView");
    const h = Promise.resolve(l).then(function(u) {
      return new Promise(function(d, f) {
        let m = d;
        t.isImageBitmapLoader === !0 && (m = function(_) {
          const p = new dt(_);
          p.needsUpdate = !0, d(p);
        }), t.load(ci.resolveURL(u, s.path), m, void 0, f);
      });
    }).then(function(u) {
      return c === !0 && a.revokeObjectURL(l), u.userData.mimeType = r.mimeType || sw(r.uri), u;
    }).catch(function(u) {
      throw console.error("THREE.GLTFLoader: Couldn't load texture", l), u;
    });
    return this.sourceCache[e] = h, h;
  }
  /**
   * Asynchronously assigns a texture to the given material parameters.
   * @param {Object} materialParams
   * @param {string} mapName
   * @param {Object} mapDef
   * @return {Promise<Texture>}
   */
  assignTexture(e, t, i, n) {
    const s = this;
    return this.getDependency("texture", i.index).then(function(r) {
      if (!r) return null;
      if (i.texCoord !== void 0 && i.texCoord != 0 && !(t === "aoMap" && i.texCoord == 1) && console.warn("THREE.GLTFLoader: Custom UV set " + i.texCoord + " for texture " + t + " not yet supported."), s.extensions[Ke.KHR_TEXTURE_TRANSFORM]) {
        const a = i.extensions !== void 0 ? i.extensions[Ke.KHR_TEXTURE_TRANSFORM] : void 0;
        if (a) {
          const l = s.associations.get(r);
          r = s.extensions[Ke.KHR_TEXTURE_TRANSFORM].extendTexture(r, a), s.associations.set(r, l);
        }
      }
      return n !== void 0 && (r.encoding = n), e[t] = r, r;
    });
  }
  /**
   * Assigns final material to a Mesh, Line, or Points instance. The instance
   * already has a material (generated from the glTF material options alone)
   * but reuse of the same glTF material may require multiple threejs materials
   * to accommodate different primitive types, defines, etc. New materials will
   * be created if necessary, and reused from a cache.
   * @param  {Object3D} mesh Mesh, Line, or Points instance.
   */
  assignFinalMaterial(e) {
    const t = e.geometry;
    let i = e.material;
    const n = t.attributes.tangent === void 0, s = t.attributes.color !== void 0, r = t.attributes.normal === void 0;
    if (e.isPoints) {
      const a = "PointsMaterial:" + i.uuid;
      let l = this.cache.get(a);
      l || (l = new Qa(), Ct.prototype.copy.call(l, i), l.color.copy(i.color), l.map = i.map, l.sizeAttenuation = !1, this.cache.add(a, l)), i = l;
    } else if (e.isLine) {
      const a = "LineBasicMaterial:" + i.uuid;
      let l = this.cache.get(a);
      l || (l = new mn(), Ct.prototype.copy.call(l, i), l.color.copy(i.color), this.cache.add(a, l)), i = l;
    }
    if (n || s || r) {
      let a = "ClonedMaterial:" + i.uuid + ":";
      n && (a += "derivative-tangents:"), s && (a += "vertex-colors:"), r && (a += "flat-shading:");
      let l = this.cache.get(a);
      l || (l = i.clone(), s && (l.vertexColors = !0), r && (l.flatShading = !0), n && (l.normalScale && (l.normalScale.y *= -1), l.clearcoatNormalScale && (l.clearcoatNormalScale.y *= -1)), this.cache.add(a, l), this.associations.set(l, this.associations.get(i))), i = l;
    }
    i.aoMap && t.attributes.uv2 === void 0 && t.attributes.uv !== void 0 && t.setAttribute("uv2", t.attributes.uv), e.material = i;
  }
  getMaterialType() {
    return io;
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials
   * @param {number} materialIndex
   * @return {Promise<Material>}
   */
  loadMaterial(e) {
    const t = this, i = this.json, n = this.extensions, s = i.materials[e];
    let r;
    const a = {}, l = s.extensions || {}, c = [];
    if (l[Ke.KHR_MATERIALS_UNLIT]) {
      const u = n[Ke.KHR_MATERIALS_UNLIT];
      r = u.getMaterialType(), c.push(u.extendParams(a, s, t));
    } else {
      const u = s.pbrMetallicRoughness || {};
      if (a.color = new de(1, 1, 1), a.opacity = 1, Array.isArray(u.baseColorFactor)) {
        const d = u.baseColorFactor;
        a.color.fromArray(d), a.opacity = d[3];
      }
      u.baseColorTexture !== void 0 && c.push(t.assignTexture(a, "map", u.baseColorTexture, He)), a.metalness = u.metallicFactor !== void 0 ? u.metallicFactor : 1, a.roughness = u.roughnessFactor !== void 0 ? u.roughnessFactor : 1, u.metallicRoughnessTexture !== void 0 && (c.push(t.assignTexture(a, "metalnessMap", u.metallicRoughnessTexture)), c.push(t.assignTexture(a, "roughnessMap", u.metallicRoughnessTexture))), r = this._invokeOne(function(d) {
        return d.getMaterialType && d.getMaterialType(e);
      }), c.push(Promise.all(this._invokeAll(function(d) {
        return d.extendMaterialParams && d.extendMaterialParams(e, a);
      })));
    }
    s.doubleSided === !0 && (a.side = ji);
    const h = s.alphaMode || Jo.OPAQUE;
    if (h === Jo.BLEND ? (a.transparent = !0, a.depthWrite = !1) : (a.transparent = !1, h === Jo.MASK && (a.alphaTest = s.alphaCutoff !== void 0 ? s.alphaCutoff : 0.5)), s.normalTexture !== void 0 && r !== gi && (c.push(t.assignTexture(a, "normalMap", s.normalTexture)), a.normalScale = new G(1, 1), s.normalTexture.scale !== void 0)) {
      const u = s.normalTexture.scale;
      a.normalScale.set(u, u);
    }
    return s.occlusionTexture !== void 0 && r !== gi && (c.push(t.assignTexture(a, "aoMap", s.occlusionTexture)), s.occlusionTexture.strength !== void 0 && (a.aoMapIntensity = s.occlusionTexture.strength)), s.emissiveFactor !== void 0 && r !== gi && (a.emissive = new de().fromArray(s.emissiveFactor)), s.emissiveTexture !== void 0 && r !== gi && c.push(t.assignTexture(a, "emissiveMap", s.emissiveTexture, He)), Promise.all(c).then(function() {
      const u = new r(a);
      return s.name && (u.name = s.name), ln(u, s), t.associations.set(u, { materials: e }), s.extensions && ir(n, u, s), u;
    });
  }
  /** When Object3D instances are targeted by animation, they need unique names. */
  createUniqueName(e) {
    const t = Je.sanitizeNodeName(e || "");
    let i = t;
    for (let n = 1; this.nodeNamesUsed[i]; ++n)
      i = t + "_" + n;
    return this.nodeNamesUsed[i] = !0, i;
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry
   *
   * Creates BufferGeometries from primitives.
   *
   * @param {Array<GLTF.Primitive>} primitives
   * @return {Promise<Array<BufferGeometry>>}
   */
  loadGeometries(e) {
    const t = this, i = this.extensions, n = this.primitiveCache;
    function s(a) {
      return i[Ke.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(a, t).then(function(l) {
        return Tu(l, a, t);
      });
    }
    const r = [];
    for (let a = 0, l = e.length; a < l; a++) {
      const c = e[a], h = nw(c), u = n[h];
      if (u)
        r.push(u.promise);
      else {
        let d;
        c.extensions && c.extensions[Ke.KHR_DRACO_MESH_COMPRESSION] ? d = s(c) : d = Tu(new Ue(), c, t), n[h] = { primitive: c, promise: d }, r.push(d);
      }
    }
    return Promise.all(r);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes
   * @param {number} meshIndex
   * @return {Promise<Group|Mesh|SkinnedMesh>}
   */
  loadMesh(e) {
    const t = this, i = this.json, n = this.extensions, s = i.meshes[e], r = s.primitives, a = [];
    for (let l = 0, c = r.length; l < c; l++) {
      const h = r[l].material === void 0 ? ew(this.cache) : this.getDependency("material", r[l].material);
      a.push(h);
    }
    return a.push(t.loadGeometries(r)), Promise.all(a).then(function(l) {
      const c = l.slice(0, l.length - 1), h = l[l.length - 1], u = [];
      for (let f = 0, m = h.length; f < m; f++) {
        const _ = h[f], p = r[f];
        let g;
        const x = c[f];
        if (p.mode === si.TRIANGLES || p.mode === si.TRIANGLE_STRIP || p.mode === si.TRIANGLE_FAN || p.mode === void 0)
          g = s.isSkinnedMesh === !0 ? new ql(_, x) : new st(_, x), g.isSkinnedMesh === !0 && !g.geometry.attributes.skinWeight.normalized && g.normalizeSkinWeights(), p.mode === si.TRIANGLE_STRIP ? g.geometry = Au(g.geometry, kp) : p.mode === si.TRIANGLE_FAN && (g.geometry = Au(g.geometry, cd));
        else if (p.mode === si.LINES)
          g = new Yl(_, x);
        else if (p.mode === si.LINE_STRIP)
          g = new Bn(_, x);
        else if (p.mode === si.LINE_LOOP)
          g = new Ed(_, x);
        else if (p.mode === si.POINTS)
          g = new Zl(_, x);
        else
          throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + p.mode);
        Object.keys(g.geometry.morphAttributes).length > 0 && iw(g, s), g.name = t.createUniqueName(s.name || "mesh_" + e), ln(g, s), p.extensions && ir(n, g, p), t.assignFinalMaterial(g), u.push(g);
      }
      for (let f = 0, m = u.length; f < m; f++)
        t.associations.set(u[f], {
          meshes: e,
          primitives: f
        });
      if (u.length === 1)
        return u[0];
      const d = new nt();
      t.associations.set(d, { meshes: e });
      for (let f = 0, m = u.length; f < m; f++)
        d.add(u[f]);
      return d;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras
   * @param {number} cameraIndex
   * @return {Promise<THREE.Camera>}
   */
  loadCamera(e) {
    let t;
    const i = this.json.cameras[e], n = i[i.type];
    if (!n) {
      console.warn("THREE.GLTFLoader: Missing camera parameters.");
      return;
    }
    return i.type === "perspective" ? t = new gt(Rt.radToDeg(n.yfov), n.aspectRatio || 1, n.znear || 1, n.zfar || 2e6) : i.type === "orthographic" && (t = new pn(-n.xmag, n.xmag, n.ymag, -n.ymag, n.znear, n.zfar)), i.name && (t.name = this.createUniqueName(i.name)), ln(t, i), Promise.resolve(t);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins
   * @param {number} skinIndex
   * @return {Promise<Skeleton>}
   */
  loadSkin(e) {
    const t = this.json.skins[e], i = [];
    for (let n = 0, s = t.joints.length; n < s; n++)
      i.push(this.getDependency("node", t.joints[n]));
    return t.inverseBindMatrices !== void 0 ? i.push(this.getDependency("accessor", t.inverseBindMatrices)) : i.push(null), Promise.all(i).then(function(n) {
      const s = n.pop(), r = n, a = [], l = [];
      for (let c = 0, h = r.length; c < h; c++) {
        const u = r[c];
        if (u) {
          a.push(u);
          const d = new ue();
          s !== null && d.fromArray(s.array, c * 16), l.push(d);
        } else
          console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[c]);
      }
      return new Rr(a, l);
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
   * @param {number} animationIndex
   * @return {Promise<AnimationClip>}
   */
  loadAnimation(e) {
    const i = this.json.animations[e], n = [], s = [], r = [], a = [], l = [];
    for (let c = 0, h = i.channels.length; c < h; c++) {
      const u = i.channels[c], d = i.samplers[u.sampler], f = u.target, m = f.node, _ = i.parameters !== void 0 ? i.parameters[d.input] : d.input, p = i.parameters !== void 0 ? i.parameters[d.output] : d.output;
      n.push(this.getDependency("node", m)), s.push(this.getDependency("accessor", _)), r.push(this.getDependency("accessor", p)), a.push(d), l.push(f);
    }
    return Promise.all([
      Promise.all(n),
      Promise.all(s),
      Promise.all(r),
      Promise.all(a),
      Promise.all(l)
    ]).then(function(c) {
      const h = c[0], u = c[1], d = c[2], f = c[3], m = c[4], _ = [];
      for (let g = 0, x = h.length; g < x; g++) {
        const y = h[g], v = u[g], M = d[g], S = f[g], A = m[g];
        if (y === void 0) continue;
        y.updateMatrix();
        let w;
        switch (en[A.path]) {
          case en.weights:
            w = Ps;
            break;
          case en.rotation:
            w = _n;
            break;
          case en.position:
          case en.scale:
          default:
            w = Rs;
            break;
        }
        const E = y.name ? y.name : y.uuid, P = S.interpolation !== void 0 ? Qx[S.interpolation] : Cs, z = [];
        en[A.path] === en.weights ? y.traverse(function(O) {
          O.morphTargetInfluences && z.push(O.name ? O.name : O.uuid);
        }) : z.push(E);
        let V = M.array;
        if (M.normalized) {
          const O = Ll(V.constructor), D = new Float32Array(V.length);
          for (let H = 0, Z = V.length; H < Z; H++)
            D[H] = V[H] * O;
          V = D;
        }
        for (let O = 0, D = z.length; O < D; O++) {
          const H = new w(
            z[O] + "." + en[A.path],
            v.array,
            V,
            P
          );
          S.interpolation === "CUBICSPLINE" && (H.createInterpolant = function(ie) {
            const K = this instanceof _n ? $x : tf;
            return new K(this.times, this.values, this.getValueSize() / 3, ie);
          }, H.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0), _.push(H);
        }
      }
      const p = i.name ? i.name : "animation_" + e;
      return new Is(p, void 0, _);
    });
  }
  createNodeMesh(e) {
    const t = this.json, i = this, n = t.nodes[e];
    return n.mesh === void 0 ? null : i.getDependency("mesh", n.mesh).then(function(s) {
      const r = i._getNodeRef(i.meshCache, n.mesh, s);
      return n.weights !== void 0 && r.traverse(function(a) {
        if (a.isMesh)
          for (let l = 0, c = n.weights.length; l < c; l++)
            a.morphTargetInfluences[l] = n.weights[l];
      }), r;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy
   * @param {number} nodeIndex
   * @return {Promise<Object3D>}
   */
  loadNode(e) {
    const t = this.json, i = this.extensions, n = this, s = t.nodes[e], r = s.name ? n.createUniqueName(s.name) : "";
    return function() {
      const a = [], l = n._invokeOne(function(d) {
        return d.createNodeMesh && d.createNodeMesh(e);
      });
      l && a.push(l), s.camera !== void 0 && a.push(n.getDependency("camera", s.camera).then(function(d) {
        return n._getNodeRef(n.cameraCache, s.camera, d);
      })), n._invokeAll(function(d) {
        return d.createNodeAttachment && d.createNodeAttachment(e);
      }).forEach(function(d) {
        a.push(d);
      });
      const c = [], h = s.children || [];
      for (let d = 0, f = h.length; d < f; d++)
        c.push(n.getDependency("node", h[d]));
      const u = s.skin === void 0 ? Promise.resolve(null) : n.getDependency("skin", s.skin);
      return Promise.all([
        Promise.all(a),
        Promise.all(c),
        u
      ]);
    }().then(function(a) {
      const l = a[0], c = a[1], h = a[2];
      let u;
      if (s.isBone === !0 ? u = new br() : l.length > 1 ? u = new nt() : l.length === 1 ? u = l[0] : u = new tt(), u !== l[0])
        for (let d = 0, f = l.length; d < f; d++)
          u.add(l[d]);
      if (s.name && (u.userData.name = s.name, u.name = r), ln(u, s), s.extensions && ir(i, u, s), s.matrix !== void 0) {
        const d = new ue();
        d.fromArray(s.matrix), u.applyMatrix4(d);
      } else
        s.translation !== void 0 && u.position.fromArray(s.translation), s.rotation !== void 0 && u.quaternion.fromArray(s.rotation), s.scale !== void 0 && u.scale.fromArray(s.scale);
      n.associations.has(u) || n.associations.set(u, {}), n.associations.get(u).nodes = e, h !== null && u.traverse(function(d) {
        d.isSkinnedMesh && d.bind(h, rw);
      });
      for (let d = 0, f = c.length; d < f; d++)
        u.add(c[d]);
      return u;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes
   * @param {number} sceneIndex
   * @return {Promise<Group>}
   */
  loadScene(e) {
    const t = this.extensions, i = this.json.scenes[e], n = this, s = new nt();
    i.name && (s.name = n.createUniqueName(i.name)), ln(s, i), i.extensions && ir(t, s, i);
    const r = i.nodes || [], a = [];
    for (let l = 0, c = r.length; l < c; l++)
      a.push(n.getDependency("node", r[l]));
    return Promise.all(a).then(function(l) {
      for (let h = 0, u = l.length; h < u; h++)
        s.add(l[h]);
      const c = (h) => {
        const u = /* @__PURE__ */ new Map();
        for (const [d, f] of n.associations)
          (d instanceof Ct || d instanceof dt) && u.set(d, f);
        return h.traverse((d) => {
          const f = n.associations.get(d);
          f != null && u.set(d, f);
        }), u;
      };
      return n.associations = c(s), s;
    });
  }
}
function ow(o, e, t) {
  const i = e.attributes, n = new Ht();
  if (i.POSITION !== void 0) {
    const a = t.json.accessors[i.POSITION], l = a.min, c = a.max;
    if (l !== void 0 && c !== void 0) {
      if (n.set(
        new b(l[0], l[1], l[2]),
        new b(c[0], c[1], c[2])
      ), a.normalized) {
        const h = Ll(Ts[a.componentType]);
        n.min.multiplyScalar(h), n.max.multiplyScalar(h);
      }
    } else {
      console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
      return;
    }
  } else
    return;
  const s = e.targets;
  if (s !== void 0) {
    const a = new b(), l = new b();
    for (let c = 0, h = s.length; c < h; c++) {
      const u = s[c];
      if (u.POSITION !== void 0) {
        const d = t.json.accessors[u.POSITION], f = d.min, m = d.max;
        if (f !== void 0 && m !== void 0) {
          if (l.setX(Math.max(Math.abs(f[0]), Math.abs(m[0]))), l.setY(Math.max(Math.abs(f[1]), Math.abs(m[1]))), l.setZ(Math.max(Math.abs(f[2]), Math.abs(m[2]))), d.normalized) {
            const _ = Ll(Ts[d.componentType]);
            l.multiplyScalar(_);
          }
          a.max(l);
        } else
          console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
      }
    }
    n.expandByVector(a);
  }
  o.boundingBox = n;
  const r = new Ci();
  n.getCenter(r.center), r.radius = n.min.distanceTo(n.max) / 2, o.boundingSphere = r;
}
function Tu(o, e, t) {
  const i = e.attributes, n = [];
  function s(r, a) {
    return t.getDependency("accessor", r).then(function(l) {
      o.setAttribute(a, l);
    });
  }
  for (const r in i) {
    const a = Cl[r] || r.toLowerCase();
    a in o.attributes || n.push(s(i[r], a));
  }
  if (e.indices !== void 0 && !o.index) {
    const r = t.getDependency("accessor", e.indices).then(function(a) {
      o.setIndex(a);
    });
    n.push(r);
  }
  return ln(o, e), ow(o, e, t), Promise.all(n).then(function() {
    return e.targets !== void 0 ? tw(o, e.targets, t) : o;
  });
}
function Au(o, e) {
  let t = o.getIndex();
  if (t === null) {
    const r = [], a = o.getAttribute("position");
    if (a !== void 0) {
      for (let l = 0; l < a.count; l++)
        r.push(l);
      o.setIndex(r), t = o.getIndex();
    } else
      return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), o;
  }
  const i = t.count - 2, n = [];
  if (e === cd)
    for (let r = 1; r <= i; r++)
      n.push(t.getX(0)), n.push(t.getX(r)), n.push(t.getX(r + 1));
  else
    for (let r = 0; r < i; r++)
      r % 2 === 0 ? (n.push(t.getX(r)), n.push(t.getX(r + 1)), n.push(t.getX(r + 2))) : (n.push(t.getX(r + 2)), n.push(t.getX(r + 1)), n.push(t.getX(r)));
  n.length / 3 !== i && console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
  const s = o.clone();
  return s.setIndex(n), s;
}
class nf extends Rx {
  constructor(e = Vs) {
    super(), this.manager = e, this.adjustmentTransform = new ue();
  }
  parse(e) {
    const t = super.parse(e), i = t.glbBytes.slice().buffer;
    return new Promise((n, s) => {
      const r = this.manager, a = this.fetchOptions, l = r.getHandler("path.gltf") || new Ns(r);
      a.credentials === "include" && a.mode === "cors" && l.setCrossOrigin("use-credentials"), "credentials" in a && l.setWithCredentials(a.credentials === "include"), a.headers && l.setRequestHeader(a.headers);
      let c = this.workingPath;
      !/[\\/]$/.test(c) && c.length && (c += "/");
      const h = this.adjustmentTransform;
      l.parse(i, c, (u) => {
        const { batchTable: d, featureTable: f } = t, { scene: m } = u, _ = f.getData("RTC_CENTER");
        _ && (m.position.x += _[0], m.position.y += _[1], m.position.z += _[2]), u.scene.updateMatrix(), u.scene.matrix.multiply(h), u.scene.matrix.decompose(u.scene.position, u.scene.quaternion, u.scene.scale), u.batchTable = d, u.featureTable = f, m.batchTable = d, m.featureTable = f, n(u);
      }, s);
    });
  }
}
class lw extends Or {
  parse(e) {
    const t = new DataView(e), i = Os(t);
    console.assert(i === "pnts");
    const n = t.getUint32(4, !0);
    console.assert(n === 1);
    const s = t.getUint32(8, !0);
    console.assert(s === e.byteLength);
    const r = t.getUint32(12, !0), a = t.getUint32(16, !0), l = t.getUint32(20, !0), c = t.getUint32(24, !0), h = 28, u = e.slice(
      h,
      h + r + a
    ), d = new no(
      u,
      0,
      r,
      a
    ), f = h + r + a, m = e.slice(
      f,
      f + l + c
    ), _ = new Tc(
      m,
      d.getData("BATCH_LENGTH") || d.getData("POINTS_LENGTH"),
      0,
      l,
      c
    );
    return Promise.resolve({
      version: n,
      featureTable: d,
      batchTable: _
    });
  }
}
function cw(o) {
  const e = o >> 11, t = o >> 5 & 63, i = o & 31, n = Math.round(e / 31 * 255), s = Math.round(t / 63 * 255), r = Math.round(i / 31 * 255);
  return [n, s, r];
}
const Eu = {
  RGB: "color",
  POSITION: "position"
};
class sf extends lw {
  constructor(e = Vs) {
    super(), this.manager = e;
  }
  parse(e) {
    return super.parse(e).then(async (t) => {
      const { featureTable: i } = t, n = new Qa(), s = i.header.extensions, r = new b();
      let a;
      if (s && s["3DTILES_draco_point_compression"]) {
        const { byteOffset: h, byteLength: u, properties: d } = s["3DTILES_draco_point_compression"], f = this.manager.getHandler("draco.drc");
        if (f == null)
          throw new Error("PNTSLoader: dracoLoader not available.");
        const m = {};
        for (const g in d)
          if (g in Eu && g in d) {
            const x = Eu[g];
            m[x] = d[g];
          }
        const _ = {
          attributeIDs: m,
          attributeTypes: {
            position: "Float32Array",
            color: "Uint8Array"
          },
          useUniqueIDs: !0
        }, p = i.getBuffer(h, u);
        a = await f.decodeGeometry(p, _), a.attributes.color && (n.vertexColors = !0);
      } else {
        const h = i.getData("POINTS_LENGTH"), u = i.getData("POSITION", h, "FLOAT", "VEC3"), d = i.getData("RGB", h, "UNSIGNED_BYTE", "VEC3"), f = i.getData("RGBA", h, "UNSIGNED_BYTE", "VEC4"), m = i.getData("RGB565", h, "UNSIGNED_SHORT", "SCALAR"), _ = i.getData("CONSTANT_RGBA", h, "UNSIGNED_BYTE", "VEC4"), p = i.getData("POSITION_QUANTIZED", h, "UNSIGNED_SHORT", "VEC3"), g = i.getData("QUANTIZED_VOLUME_SCALE", h, "FLOAT", "VEC3"), x = i.getData("QUANTIZED_VOLUME_OFFSET", h, "FLOAT", "VEC3");
        if (a = new Ue(), p) {
          const y = new Float32Array(h * 3);
          for (let v = 0; v < h; v++)
            for (let M = 0; M < 3; M++) {
              const S = 3 * v + M;
              y[S] = p[S] / 65535 * g[M];
            }
          r.x = x[0], r.y = x[1], r.z = x[2], a.setAttribute("position", new $e(y, 3, !1));
        } else
          a.setAttribute("position", new $e(u, 3, !1));
        if (f !== null)
          a.setAttribute("color", new $e(f, 4, !0)), n.vertexColors = !0, n.transparent = !0, n.depthWrite = !1;
        else if (d !== null)
          a.setAttribute("color", new $e(d, 3, !0)), n.vertexColors = !0;
        else if (m !== null) {
          const y = new Uint8Array(h * 3);
          for (let v = 0; v < h; v++) {
            const M = cw(m[v]);
            for (let S = 0; S < 3; S++) {
              const A = 3 * v + S;
              y[A] = M[S];
            }
          }
          a.setAttribute("color", new $e(y, 3, !0)), n.vertexColors = !0;
        } else if (_ !== null) {
          const y = new de(_[0], _[1], _[2]);
          n.color = y;
          const v = _[3] / 255;
          v < 1 && (n.opacity = v, n.transparent = !0, n.depthWrite = !1);
        }
      }
      [
        "BATCH_LENGTH",
        "NORMAL",
        "NORMAL_OCT16P"
      ].forEach((h) => {
        h in i.header && console.warn(
          `PNTSLoader: Unsupported FeatureTable feature "${h}" detected.`
        );
      });
      const l = new Zl(a, n);
      l.position.copy(r), t.scene = l, t.scene.featureTable = i;
      const c = i.getData("RTC_CENTER");
      return c && (t.scene.position.x += c[0], t.scene.position.y += c[1], t.scene.position.z += c[2]), t;
    });
  }
}
class hw extends Or {
  parse(e) {
    const t = new DataView(e), i = Os(t);
    console.assert(i === "i3dm");
    const n = t.getUint32(4, !0);
    console.assert(n === 1);
    const s = t.getUint32(8, !0);
    console.assert(s === e.byteLength);
    const r = t.getUint32(12, !0), a = t.getUint32(16, !0), l = t.getUint32(20, !0), c = t.getUint32(24, !0), h = t.getUint32(28, !0), u = 32, d = e.slice(
      u,
      u + r + a
    ), f = new no(
      d,
      0,
      r,
      a
    ), m = u + r + a, _ = e.slice(
      m,
      m + l + c
    ), p = new Tc(
      _,
      f.getData("INSTANCES_LENGTH"),
      0,
      l,
      c
    ), g = m + l + c, x = new Uint8Array(e, g, s - g);
    let y = null, v = null;
    if (h)
      y = x, v = Promise.resolve();
    else {
      const M = this.resolveExternalURL(Qd(x));
      v = fetch(M, this.fetchOptions).then((S) => {
        if (!S.ok)
          throw new Error(`I3DMLoaderBase : Failed to load file "${M}" with status ${S.status} : ${S.statusText}`);
        return S.arrayBuffer();
      }).then((S) => {
        y = new Uint8Array(S);
      });
    }
    return v.then(() => ({
      version: n,
      featureTable: f,
      batchTable: p,
      glbBytes: y
    }));
  }
}
const Cu = new b(), Ko = new b(), $o = new b(), Lu = new b(), Qo = new Et(), wa = new b(), ba = new ue();
class rf extends hw {
  constructor(e = Vs) {
    super(), this.manager = e, this.adjustmentTransform = new ue();
  }
  resolveExternalURL(e) {
    return this.manager.resolveURL(super.resolveExternalURL(e));
  }
  parse(e) {
    return super.parse(e).then((t) => {
      const { featureTable: i, batchTable: n } = t, s = t.glbBytes.slice().buffer;
      return new Promise((r, a) => {
        const l = this.fetchOptions, c = this.manager, h = c.getHandler("path.gltf") || new Ns(c);
        l.credentials === "include" && l.mode === "cors" && h.setCrossOrigin("use-credentials"), "credentials" in l && h.setWithCredentials(l.credentials === "include"), l.headers && h.setRequestHeader(l.headers);
        let u = this.workingPath;
        /[\\/]$/.test(u) || (u += "/");
        const d = this.adjustmentTransform;
        h.parse(s, u, (f) => {
          const m = i.getData("INSTANCES_LENGTH"), _ = i.getData("POSITION", m, "FLOAT", "VEC3"), p = i.getData("NORMAL_UP", m, "FLOAT", "VEC3"), g = i.getData("NORMAL_RIGHT", m, "FLOAT", "VEC3"), x = i.getData("SCALE_NON_UNIFORM", m, "FLOAT", "VEC3"), y = i.getData("SCALE", m, "FLOAT", "SCALAR");
          [
            "RTC_CENTER",
            "QUANTIZED_VOLUME_OFFSET",
            "QUANTIZED_VOLUME_SCALE",
            "EAST_NORTH_UP",
            "POSITION_QUANTIZED",
            "NORMAL_UP_OCT32P",
            "NORMAL_RIGHT_OCT32P"
          ].forEach((A) => {
            A in i.header && console.warn(`I3DMLoader: Unsupported FeatureTable feature "${A}" detected.`);
          });
          const v = /* @__PURE__ */ new Map(), M = [];
          f.scene.traverse((A) => {
            if (A.isMesh) {
              const { geometry: w, material: E } = A, P = new jl(w, E, m);
              P.position.copy(A.position), P.rotation.copy(A.rotation), P.scale.copy(A.scale), M.push(P), v.set(A, P);
            }
          });
          const S = new b();
          for (let A = 0; A < m; A++)
            S.x += _[A * 3 + 0] / m, S.y += _[A * 3 + 1] / m, S.z += _[A * 3 + 2] / m;
          v.forEach((A, w) => {
            const E = w.parent;
            E && (E.remove(w), E.add(A), A.updateMatrixWorld(), A.position.copy(S).applyMatrix4(A.matrixWorld));
          });
          for (let A = 0; A < m; A++) {
            Lu.set(
              _[A * 3 + 0] - S.x,
              _[A * 3 + 1] - S.y,
              _[A * 3 + 2] - S.z
            ), p ? (Ko.set(
              p[A * 3 + 0],
              p[A * 3 + 1],
              p[A * 3 + 2]
            ), $o.set(
              g[A * 3 + 0],
              g[A * 3 + 1],
              g[A * 3 + 2]
            ), Cu.crossVectors($o, Ko).normalize(), ba.makeBasis(
              $o,
              Ko,
              Cu
            ), Qo.setFromRotationMatrix(ba)) : Qo.set(0, 0, 0, 1), y ? wa.setScalar(y[A]) : x ? wa.set(
              x[A * 3 + 0],
              x[A * 3 + 1],
              x[A * 3 + 2]
            ) : wa.set(1, 1, 1), ba.compose(Lu, Qo, wa).multiply(d);
            for (let w = 0, E = M.length; w < E; w++)
              M[w].setMatrixAt(A, ba);
          }
          f.batchTable = n, f.featureTable = i, f.scene.batchTable = n, f.scene.featureTable = i, r(f);
        }, a);
      });
    });
  }
}
class uw extends Or {
  parse(e) {
    const t = new DataView(e), i = Os(t);
    console.assert(i === "cmpt", 'CMPTLoader: The magic bytes equal "cmpt".');
    const n = t.getUint32(4, !0);
    console.assert(n === 1, 'CMPTLoader: The version listed in the header is "1".');
    const s = t.getUint32(8, !0);
    console.assert(s === e.byteLength, "CMPTLoader: The contents buffer length listed in the header matches the file.");
    const r = t.getUint32(12, !0), a = [];
    let l = 16;
    for (let c = 0; c < r; c++) {
      const h = new DataView(e, l, 12), u = Os(h), d = h.getUint32(4, !0), f = h.getUint32(8, !0), m = new Uint8Array(e, l, f);
      a.push({
        type: u,
        buffer: m,
        version: d
      }), l += f;
    }
    return {
      version: n,
      tiles: a
    };
  }
}
class dw extends uw {
  constructor(e = Vs) {
    super(), this.manager = e, this.adjustmentTransform = new ue();
  }
  parse(e) {
    const t = super.parse(e), i = this.manager, n = this.adjustmentTransform, s = [];
    for (const r in t.tiles) {
      const { type: a, buffer: l } = t.tiles[r];
      switch (a) {
        case "b3dm": {
          const c = l.slice(), h = new nf(i);
          h.workingPath = this.workingPath, h.fetchOptions = this.fetchOptions, h.adjustmentTransform.copy(n);
          const u = h.parse(c.buffer);
          s.push(u);
          break;
        }
        case "pnts": {
          const c = l.slice(), h = new sf(i);
          h.workingPath = this.workingPath, h.fetchOptions = this.fetchOptions;
          const u = h.parse(c.buffer);
          s.push(u);
          break;
        }
        case "i3dm": {
          const c = l.slice(), h = new rf(i);
          h.workingPath = this.workingPath, h.fetchOptions = this.fetchOptions, h.adjustmentTransform.copy(n);
          const u = h.parse(c.buffer);
          s.push(u);
          break;
        }
      }
    }
    return Promise.all(s).then((r) => {
      const a = new nt();
      return r.forEach((l) => {
        a.add(l.scene);
      }), {
        tiles: r,
        scene: a
      };
    });
  }
}
class fw {
  constructor() {
    this.name = "CESIUM_RTC";
  }
  afterRoot(e) {
    if (e.parser.json.extensions && e.parser.json.extensions.CESIUM_RTC) {
      const { center: t } = e.parser.json.extensions.CESIUM_RTC;
      t && (e.scene.position.x += t[0], e.scene.position.y += t[1], e.scene.position.z += t[2]);
    }
  }
}
class pw extends Or {
  constructor(e = Vs) {
    super(), this.manager = e;
  }
  parse(e) {
    return new Promise((t, i) => {
      const n = this.manager, s = this.fetchOptions;
      let r = n.getHandler("path.gltf") || n.getHandler("path.glb");
      r || (r = new Ns(n), r.register(() => new fw()), s.credentials === "include" && s.mode === "cors" && r.setCrossOrigin("use-credentials"), "credentials" in s && r.setWithCredentials(s.credentials === "include"), s.headers && r.setRequestHeader(s.headers));
      let a = r.resourcePath || r.path || this.workingPath;
      !/[\\/]$/.test(a) && a.length && (a += "/"), r.parse(e, a, (l) => {
        t(l);
      }, i);
    });
  }
}
const Ma = new ue();
class mw extends nt {
  constructor(e) {
    super(), this.name = "TilesRenderer.TilesGroup", this.tilesRenderer = e;
  }
  raycast(e, t) {
    this.tilesRenderer.optimizeRaycast && this.tilesRenderer.raycast(e, t);
  }
  updateMatrixWorld(e) {
    if (this.matrixAutoUpdate && this.updateMatrix(), this.matrixWorldNeedsUpdate || e) {
      this.parent === null ? Ma.copy(this.matrix) : Ma.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1;
      const t = Ma.elements, i = this.matrixWorld.elements;
      let n = !1;
      for (let s = 0; s < 16; s++) {
        const r = t[s], a = i[s];
        if (Math.abs(r - a) > Number.EPSILON) {
          n = !0;
          break;
        }
      }
      if (n) {
        this.matrixWorld.copy(Ma);
        const s = this.children;
        for (let r = 0, a = s.length; r < a; r++)
          s[r].updateMatrixWorld();
      }
    }
  }
}
const qa = new ue(), af = new ks(), el = new b(), Sa = [];
function of(o, e) {
  return o.distance - e.distance;
}
function lf(o, e, t) {
  o.traverse((i) => {
    Object.getPrototypeOf(i).raycast.call(i, e, t);
  });
}
function _w(o, e) {
  lf(o, e, Sa), Sa.sort(of);
  const t = Sa[0] || null;
  return Sa.length = 0, t;
}
function cf(o, e, t, i = null) {
  const { group: n, activeTiles: s } = o;
  o.ensureChildrenArePreprocessed(e), i === null && (i = af, qa.copy(n.matrixWorld).invert(), i.copy(t.ray).applyMatrix4(qa));
  const r = [], a = e.children;
  for (let h = 0, u = a.length; h < u; h++) {
    const d = a[h];
    if (!d.__used)
      continue;
    d.cached.boundingVolume.intersectRay(i, el) !== null && (el.applyMatrix4(n.matrixWorld), r.push({
      distance: el.distanceToSquared(t.ray.origin),
      tile: d
    }));
  }
  r.sort(of);
  let l = null, c = 1 / 0;
  if (s.has(e)) {
    const h = _w(e.cached.scene, t);
    h && (l = h, c = h.distance * h.distance);
  }
  for (let h = 0, u = r.length; h < u; h++) {
    const d = r[h], f = d.distance, m = d.tile;
    if (f > c)
      break;
    const _ = cf(o, m, t, i);
    if (_) {
      const p = _.distance * _.distance;
      p < c && (l = _, c = p);
    }
  }
  return l;
}
function hf(o, e, t, i, n = null) {
  const { group: s, activeTiles: r } = o, { scene: a, boundingVolume: l } = e.cached;
  if (o.ensureChildrenArePreprocessed(e), n === null && (n = af, qa.copy(s.matrixWorld).invert(), n.copy(t.ray).applyMatrix4(qa)), !e.__used || !l.intersectsRay(n))
    return;
  r.has(e) && lf(a, t, i);
  const c = e.children;
  for (let h = 0, u = c.length; h < u; h++)
    hf(o, c[h], t, i, n);
}
class Pu {
  constructor(e = new Ht(), t = new ue()) {
    this.box = e.clone(), this.transform = t.clone(), this.inverseTransform = new ue(), this.points = new Array(8).fill().map(() => new b());
  }
  update() {
    const { points: e, inverseTransform: t, transform: i, box: n } = this;
    t.copy(i).invert();
    const { min: s, max: r } = n;
    let a = 0;
    for (let l = -1; l <= 1; l += 2)
      for (let c = -1; c <= 1; c += 2)
        for (let h = -1; h <= 1; h += 2)
          e[a].set(
            l < 0 ? s.x : r.x,
            c < 0 ? s.y : r.y,
            h < 0 ? s.z : r.z
          ).applyMatrix4(i), a++;
  }
  // based on three.js' Box3 "intersects frustum" function
  intersectsFrustum(e) {
    const { points: t } = this, { planes: i } = e;
    for (let n = 0; n < 6; n++) {
      const s = i[n];
      let r = -1 / 0;
      for (let a = 0; a < 8; a++) {
        const l = t[a], c = s.distanceToPoint(l);
        r = r < c ? c : r;
      }
      if (r < 0)
        return !1;
    }
    return !0;
  }
}
new b();
function gw(o) {
  const { x: e, y: t, z: i } = o;
  o.x = i, o.y = e, o.z = t;
}
function vw(o) {
  return -o + Math.PI / 2;
}
const Ru = new Al(), tn = new b(), fi = new b(), tl = new b(), yw = new b(), Iu = new b(), il = new b(), nl = new b(), Du = new b(), xw = 1e-12, ww = 0.1;
class bw {
  constructor(e = 1, t = 1, i = 1) {
    this.radius = new b(e, t, i);
  }
  // returns a frame with Z indicating altitude
  // Y pointing north
  // X pointing east
  constructLatLonFrame(e, t, i) {
    return this.getCartographicToPosition(e, t, 0, Du), this.getCartographicToNormal(e, t, nl), this.getNorthernTangent(e, t, il), Iu.crossVectors(il, nl), i.makeBasis(Iu, il, nl).setPosition(Du);
  }
  getNorthernTangent(e, t, i, n = yw) {
    let s = 1, r = e + 1e-7;
    e > Math.PI / 4 && (s = -1, r = e - 1e-7);
    const a = this.getCartographicToNormal(e, t, fi).normalize(), l = this.getCartographicToNormal(r, t, tl).normalize();
    return n.crossVectors(a, l).normalize().multiplyScalar(s), i.crossVectors(n, a).normalize();
  }
  getCartographicToPosition(e, t, i, n) {
    this.getCartographicToNormal(e, t, tn);
    const s = this.radius;
    fi.copy(tn), fi.x *= s.x ** 2, fi.y *= s.y ** 2, fi.z *= s.z ** 2;
    const r = Math.sqrt(tn.dot(fi));
    return fi.divideScalar(r), n.copy(fi).addScaledVector(tn, i);
  }
  getPositionToCartographic(e, t) {
    this.getPositionToSurfacePoint(e, fi), this.getPositionToNormal(e, tn);
    const i = tl.subVectors(e, fi);
    return t.lon = Math.atan2(tn.y, tn.x), t.lat = Math.asin(tn.z), t.height = Math.sign(i.dot(e)) * i.length(), t;
  }
  getCartographicToNormal(e, t, i) {
    return Ru.set(1, vw(e), t), i.setFromSpherical(Ru).normalize(), gw(i), i;
  }
  getPositionToNormal(e, t) {
    const i = this.radius;
    return t.copy(e), t.x /= i.x ** 2, t.y /= i.y ** 2, t.z /= i.z ** 2, t.normalize(), t;
  }
  getPositionToSurfacePoint(e, t) {
    const i = this.radius, n = 1 / i.x ** 2, s = 1 / i.y ** 2, r = 1 / i.z ** 2, a = e.x * e.x * n, l = e.y * e.y * s, c = e.z * e.z * r, h = a + l + c, u = Math.sqrt(1 / h), d = fi.copy(e).multiplyScalar(u);
    if (h < ww)
      return isFinite(u) ? t.copy(d) : null;
    const f = tl.set(
      d.x * n * 2,
      d.y * s * 2,
      d.z * r * 2
    );
    let m = (1 - u) * e.length() / (0.5 * f.length()), _ = 0, p, g, x, y, v, M, S, A, w, E, P;
    do {
      m -= _, x = 1 / (1 + m * n), y = 1 / (1 + m * s), v = 1 / (1 + m * r), M = x * x, S = y * y, A = v * v, w = M * x, E = S * y, P = A * v, p = a * M + l * S + c * A - 1, g = a * w * n + l * E * s + c * P * r;
      const z = -2 * g;
      _ = p / z;
    } while (Math.abs(p) > xw);
    return t.set(
      e.x * x,
      e.y * y,
      e.z * v
    );
  }
}
const rn = Math.PI, Ta = rn / 2, nr = new b(), ls = new b(), cs = new b(), Ou = new ue();
let lr = 0;
const sl = [];
function Mw(o = !1) {
  return o ? (sl[lr] || (sl[lr] = new b()), lr++, sl[lr - 1]) : new b();
}
function Nu() {
  lr = 0;
}
class Sw extends bw {
  constructor(e, t, i, n = -Ta, s = Ta, r = 0, a = 2 * rn, l = 0, c = 0) {
    super(e, t, i), this.latStart = n, this.latEnd = s, this.lonStart = r, this.lonEnd = a, this.heightStart = l, this.heightEnd = c;
  }
  _getPoints(e = !1) {
    const {
      latStart: t,
      latEnd: i,
      lonStart: n,
      lonEnd: s,
      heightStart: r,
      heightEnd: a
    } = this, l = Rt.mapLinear(0.5, 0, 1, t, i), c = Rt.mapLinear(0.5, 0, 1, n, s), h = Math.floor(n / Ta) * Ta, u = [
      [-rn / 2, 0],
      [rn / 2, 0],
      [0, h],
      [0, h + rn / 2],
      [0, h + rn],
      [0, h + 3 * rn / 2],
      [t, s],
      [i, s],
      [t, n],
      [i, n],
      [0, n],
      [0, s],
      [l, c],
      [t, c],
      [i, c],
      [l, n],
      [l, s]
    ], d = [], f = u.length;
    for (let m = 0; m <= 1; m++) {
      const _ = Rt.mapLinear(m, 0, 1, r, a);
      for (let p = 0, g = f; p < g; p++) {
        const [x, y] = u[p];
        if (x >= t && x <= i && y >= n && y <= s) {
          const v = Mw(e);
          d.push(v), this.getCartographicToPosition(x, y, _, v);
        }
      }
    }
    return d;
  }
  getBoundingBox(e, t) {
    Nu();
    const {
      latStart: i,
      latEnd: n,
      lonStart: s,
      lonEnd: r
    } = this;
    if (n - i < rn / 2) {
      const c = Rt.mapLinear(0.5, 0, 1, i, n), h = Rt.mapLinear(0.5, 0, 1, s, r);
      this.getCartographicToNormal(c, h, cs), ls.set(0, 0, 1), nr.crossVectors(ls, cs), ls.crossVectors(nr, cs), t.makeBasis(nr, ls, cs);
    } else
      nr.set(1, 0, 0), ls.set(0, 1, 0), cs.set(0, 0, 1), t.makeBasis(nr, ls, cs);
    Ou.copy(t).invert();
    const l = this._getPoints(!0);
    for (let c = 0, h = l.length; c < h; c++)
      l[c].applyMatrix4(Ou);
    e.makeEmpty(), e.setFromPoints(l);
  }
  getBoundingSphere(e, t) {
    Nu();
    const i = this._getPoints(!0);
    e.makeEmpty(), e.setFromPoints(i, t);
  }
}
const Fi = new b(), Bi = new b(), Ui = new b(), ku = new b(), zu = new b(), Fu = new b(), hs = new ks();
class Tw {
  constructor() {
    this.sphere = null, this.obb = null, this.region = null, this.regionObb = null;
  }
  intersectsRay(e) {
    const t = this.sphere, i = this.obb || this.regionObb;
    return !(t && !e.intersectsSphere(t) || i && (hs.copy(e).applyMatrix4(i.inverseTransform), !hs.intersectsBox(i.box)));
  }
  intersectRay(e, t = null) {
    const i = this.sphere, n = this.obb || this.regionObb;
    let s = -1 / 0, r = -1 / 0;
    i && e.intersectSphere(i, zu) && (s = i.containsPoint(e.origin) ? 0 : e.origin.distanceToSquared(zu)), n && (hs.copy(e).applyMatrix4(n.inverseTransform), hs.intersectBox(n.box, Fu) && (r = n.box.containsPoint(hs.origin) ? 0 : hs.origin.distanceToSquared(Fu)));
    const a = Math.max(s, r);
    return a === -1 / 0 ? null : (e.at(Math.sqrt(a), t), t);
  }
  distanceToPoint(e) {
    const t = this.sphere, i = this.obb || this.regionObb;
    let n = -1 / 0, s = -1 / 0;
    return t && (n = Math.max(t.distanceToPoint(e), 0)), i && (ku.copy(e).applyMatrix4(i.inverseTransform), s = i.box.distanceToPoint(ku)), n > s ? n : s;
  }
  intersectsFrustum(e) {
    const t = this.obb || this.regionObb, i = this.sphere;
    return i && !e.intersectsSphere(i) || t && !t.intersectsFrustum(e) ? !1 : !!(i || t);
  }
  getOBB(e, t) {
    const i = this.obb || this.regionObb;
    i ? (e.copy(i.box), t.copy(i.transform)) : (this.getAABB(e), t.identity());
  }
  getAABB(e) {
    if (this.sphere)
      this.sphere.getBoundingBox(e);
    else {
      const t = this.obb || this.regionObb;
      e.copy(t.box).applyMatrix4(t.transform);
    }
  }
  getSphere(e) {
    if (this.sphere)
      e.copy(this.sphere);
    else if (this.region)
      this.region.getBoundingSphere(e);
    else {
      const t = this.obb || this.regionObb;
      t.box.getBoundingSphere(e), e.applyMatrix4(t.transform);
    }
  }
  setObbData(e, t) {
    const i = new Pu();
    Fi.set(e[3], e[4], e[5]), Bi.set(e[6], e[7], e[8]), Ui.set(e[9], e[10], e[11]);
    const n = Fi.length(), s = Bi.length(), r = Ui.length();
    Fi.normalize(), Bi.normalize(), Ui.normalize(), n === 0 && Fi.crossVectors(Bi, Ui), s === 0 && Bi.crossVectors(Fi, Ui), r === 0 && Ui.crossVectors(Fi, Bi), i.transform.set(
      Fi.x,
      Bi.x,
      Ui.x,
      e[0],
      Fi.y,
      Bi.y,
      Ui.y,
      e[1],
      Fi.z,
      Bi.z,
      Ui.z,
      e[2],
      0,
      0,
      0,
      1
    ).premultiply(t), i.box.min.set(-n, -s, -r), i.box.max.set(n, s, r), i.update(), this.obb = i;
  }
  setSphereData(e, t, i, n, s) {
    const r = new Ci();
    r.center.set(e, t, i), r.radius = n, r.applyMatrix4(s), this.sphere = r;
  }
  setRegionData(e, t, i, n, s, r) {
    const a = new Sw(
      Xa,
      Xa,
      Cx,
      t,
      n,
      e,
      i,
      s,
      r
    ), l = new Pu();
    a.getBoundingBox(l.box, l.transform), l.update(), this.region = a, this.regionObb = l;
  }
}
const uf = Symbol("INITIAL_FRUSTUM_CULLED"), Aa = new ue(), rl = new ue(), us = new b(), Aw = new b(1, 0, 0), Ew = new b(0, 1, 0);
function Bu(o, e) {
  o.traverse((t) => {
    t.frustumCulled = t[uf] && e;
  });
}
class df extends Px {
  get autoDisableRendererCulling() {
    return this._autoDisableRendererCulling;
  }
  set autoDisableRendererCulling(e) {
    this._autoDisableRendererCulling !== e && (super._autoDisableRendererCulling = e, this.forEachLoadedModel((t) => {
      Bu(t, !e);
    }));
  }
  constructor(...e) {
    super(...e), this.group = new mw(this), this.cameras = [], this.cameraMap = /* @__PURE__ */ new Map(), this.cameraInfo = [], this.activeTiles = /* @__PURE__ */ new Set(), this.visibleTiles = /* @__PURE__ */ new Set(), this._autoDisableRendererCulling = !0, this.optimizeRaycast = !0, this.onLoadTileSet = null, this.onLoadModel = null, this.onDisposeModel = null, this.onTileVisibilityChange = null;
    const t = new mc();
    t.setURLModifier((n) => this.preprocessURL ? this.preprocessURL(n) : n), this.manager = t;
    const i = this;
    this._overridenRaycast = function(n, s) {
      i.optimizeRaycast || Object.getPrototypeOf(this).raycast.call(this, n, s);
    };
  }
  /* Public API */
  getBounds(e) {
    if (!this.root)
      return !1;
    const t = this.root.cached.boundingVolume;
    return t && t.getAABB(e), !0;
  }
  getOrientedBounds(e, t) {
    if (!this.root)
      return !1;
    const i = this.root.cached.boundingVolume;
    return i && i.getOBB(e, t), !0;
  }
  getBoundingSphere(e) {
    if (!this.root)
      return !1;
    const t = this.root.cached.boundingVolume;
    return t ? (t.getSphere(e), !0) : !1;
  }
  forEachLoadedModel(e) {
    this.traverse((t) => {
      const i = t.cached.scene;
      i && e(i, t);
    });
  }
  raycast(e, t) {
    if (this.root)
      if (e.firstHitOnly) {
        const i = cf(this, this.root, e);
        i && t.push(i);
      } else
        hf(this, this.root, e, t);
  }
  hasCamera(e) {
    return this.cameraMap.has(e);
  }
  setCamera(e) {
    const t = this.cameras, i = this.cameraMap;
    return i.has(e) ? !1 : (i.set(e, new G()), t.push(e), !0);
  }
  setResolution(e, t, i) {
    const n = this.cameraMap;
    return n.has(e) ? (t instanceof G ? n.get(e).copy(t) : n.get(e).set(t, i), !0) : !1;
  }
  setResolutionFromRenderer(e, t) {
    const i = this.cameraMap;
    if (!i.has(e))
      return !1;
    const n = i.get(e);
    return t.getSize(n), n.multiplyScalar(t.getPixelRatio()), !0;
  }
  deleteCamera(e) {
    const t = this.cameras, i = this.cameraMap;
    if (i.has(e)) {
      const n = t.indexOf(e);
      return t.splice(n, 1), i.delete(e), !0;
    }
    return !1;
  }
  /* Overriden */
  fetchTileSet(e, ...t) {
    const i = super.fetchTileSet(e, ...t);
    return i.then((n) => {
      this.onLoadTileSet && Promise.resolve().then(() => {
        this.onLoadTileSet(n, e);
      });
    }), i;
  }
  update() {
    const e = this.group, t = this.cameras, i = this.cameraMap, n = this.cameraInfo;
    if (t.length === 0) {
      console.warn("TilesRenderer: no cameras defined. Cannot update 3d tiles.");
      return;
    }
    for (; n.length > t.length; )
      n.pop();
    for (; n.length < t.length; )
      n.push({
        frustum: new Ja(),
        isOrthographic: !1,
        sseDenominator: -1,
        // used if isOrthographic:false
        position: new b(),
        invScale: -1,
        pixelSize: 0
        // used if isOrthographic:true
      });
    rl.copy(e.matrixWorld).invert(), us.setFromMatrixScale(rl);
    const s = us.x;
    Math.abs(Math.max(us.x - us.y, us.x - us.z)) > 1e-6 && console.warn("ThreeTilesRenderer : Non uniform scale used for tile which may cause issues when calculating screen space error.");
    for (let r = 0, a = n.length; r < a; r++) {
      const l = t[r], c = n[r], h = c.frustum, u = c.position, d = i.get(l);
      (d.width === 0 || d.height === 0) && console.warn("TilesRenderer: resolution for camera error calculation is not set.");
      const f = l.projectionMatrix.elements;
      if (c.isOrthographic = f[15] === 1, c.isOrthographic) {
        const m = 2 / f[0], _ = 2 / f[5];
        c.pixelSize = Math.max(_ / d.height, m / d.width);
      } else
        c.sseDenominator = 2 / f[5] / d.height;
      c.invScale = s, Aa.copy(e.matrixWorld), Aa.premultiply(l.matrixWorldInverse), Aa.premultiply(l.projectionMatrix), h.setFromProjectionMatrix(Aa), u.set(0, 0, 0), u.applyMatrix4(l.matrixWorld), u.applyMatrix4(rl);
    }
    super.update();
  }
  preprocessNode(e, t, i = null) {
    super.preprocessNode(e, t, i);
    const n = new ue();
    if (e.transform) {
      const a = e.transform;
      for (let l = 0; l < 16; l++)
        n.elements[l] = a[l];
    } else
      n.identity();
    i && n.premultiply(i.cached.transform);
    const s = new ue().copy(n).invert(), r = new Tw();
    "sphere" in e.boundingVolume && r.setSphereData(...e.boundingVolume.sphere, n), "box" in e.boundingVolume && r.setObbData(e.boundingVolume.box, n), "region" in e.boundingVolume && r.setRegionData(...e.boundingVolume.region), e.cached = {
      loadIndex: 0,
      transform: n,
      transformInverse: s,
      active: !1,
      inFrustum: [],
      boundingVolume: r,
      scene: null,
      geometry: null,
      material: null
    };
  }
  parseTile(e, t, i) {
    t._loadIndex = t._loadIndex || 0, t._loadIndex++;
    const s = t.content.uri.split(/[\\\/]/g);
    s.pop();
    const r = s.join("/"), a = this.fetchOptions, l = this.manager, c = t._loadIndex;
    let h = null;
    const u = this.rootTileSet.asset && this.rootTileSet.asset.gltfUpAxis || "y", d = t.cached, f = d.transform, m = new ue();
    switch (u.toLowerCase()) {
      case "x":
        m.makeRotationAxis(Ew, -Math.PI / 2);
        break;
      case "y":
        m.makeRotationAxis(Aw, Math.PI / 2);
        break;
      case "z":
        m.identity();
        break;
    }
    const _ = (Os(e) || i).toLowerCase();
    switch (_) {
      case "b3dm": {
        const g = new nf(l);
        g.workingPath = r, g.fetchOptions = a, g.adjustmentTransform.copy(m), h = g.parse(e);
        break;
      }
      case "pnts": {
        const g = new sf(l);
        g.workingPath = r, g.fetchOptions = a, h = g.parse(e);
        break;
      }
      case "i3dm": {
        const g = new rf(l);
        g.workingPath = r, g.fetchOptions = a, g.adjustmentTransform.copy(m), h = g.parse(e);
        break;
      }
      case "cmpt": {
        const g = new dw(l);
        g.workingPath = r, g.fetchOptions = a, g.adjustmentTransform.copy(m), h = g.parse(e).then((x) => x.scene);
        break;
      }
      case "gltf":
      case "glb":
        const p = new pw(l);
        p.workingPath = r, p.fetchOptions = a, h = p.parse(e);
        break;
      default:
        console.warn(`TilesRenderer: Content type "${_}" not supported.`), h = Promise.resolve(null);
        break;
    }
    return h.then((p) => {
      let g, x;
      if (p.isObject3D ? (g = p, x = null) : (g = p.scene, x = p), t._loadIndex !== c)
        return;
      g.updateMatrix(), (_ === "glb" || _ === "gltf") && g.matrix.multiply(m), g.matrix.premultiply(f), g.matrix.decompose(g.position, g.quaternion, g.scale), g.traverse((S) => {
        S[uf] = S.frustumCulled;
      }), Bu(g, !this.autoDisableRendererCulling), g.traverse((S) => {
        S.raycast = this._overridenRaycast;
      });
      const y = [], v = [], M = [];
      g.traverse((S) => {
        if (S.geometry && v.push(S.geometry), S.material) {
          const A = S.material;
          y.push(S.material);
          for (const w in A) {
            const E = A[w];
            E && E.isTexture && M.push(E);
          }
        }
      }), d.materials = y, d.geometry = v, d.textures = M, d.scene = g, d.metadata = x, this.onLoadModel && this.onLoadModel(g, t);
    });
  }
  disposeTile(e) {
    const t = e.cached;
    if (t.scene) {
      const i = t.materials, n = t.geometry, s = t.textures, r = t.scene.parent;
      for (let a = 0, l = n.length; a < l; a++)
        n[a].dispose();
      for (let a = 0, l = i.length; a < l; a++)
        i[a].dispose();
      for (let a = 0, l = s.length; a < l; a++)
        s[a].dispose();
      r && r.remove(t.scene), this.onDisposeModel && this.onDisposeModel(t.scene, e), t.scene = null, t.materials = null, t.textures = null, t.geometry = null, t.metadata = null;
    }
    this.activeTiles.delete(e), this.visibleTiles.delete(e), e._loadIndex++;
  }
  setTileVisible(e, t) {
    const i = e.cached.scene, n = this.visibleTiles, s = this.group;
    t ? (s.add(i), n.add(e), i.updateMatrixWorld(!0)) : (s.remove(i), n.delete(e)), this.onTileVisibilityChange && this.onTileVisibilityChange(i, e, t);
  }
  setTileActive(e, t) {
    const i = this.activeTiles;
    t ? i.add(e) : i.delete(e);
  }
  calculateError(e) {
    const t = e.cached, i = t.inFrustum, n = this.cameras, s = this.cameraInfo, r = t.boundingVolume;
    let a = -1 / 0, l = 1 / 0;
    for (let c = 0, h = n.length; c < h; c++) {
      if (!i[c])
        continue;
      const u = s[c], d = u.invScale;
      let f;
      if (u.isOrthographic) {
        const m = u.pixelSize;
        f = e.geometricError / (m * d);
      } else {
        const _ = r.distanceToPoint(u.position) * d, p = u.sseDenominator;
        f = e.geometricError / (_ * p), l = Math.min(l, _);
      }
      a = Math.max(a, f);
    }
    e.__distanceFromCamera = l, e.__error = a;
  }
  tileInView(e) {
    const t = e.cached, i = t.boundingVolume, n = t.inFrustum, s = this.cameraInfo;
    let r = !1;
    for (let a = 0, l = s.length; a < l; a++) {
      const c = s[a].frustum;
      i.intersectsFrustum(c) ? (r = !0, n[a] = !0) : n[a] = !1;
    }
    return r;
  }
}
const al = /* @__PURE__ */ new WeakMap();
class ff extends xi {
  constructor(e) {
    super(e), this.decoderPath = "", this.decoderConfig = {}, this.decoderBinary = null, this.decoderPending = null, this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.defaultAttributeIDs = {
      position: "POSITION",
      normal: "NORMAL",
      color: "COLOR",
      uv: "TEX_COORD"
    }, this.defaultAttributeTypes = {
      position: "Float32Array",
      normal: "Float32Array",
      color: "Float32Array",
      uv: "Float32Array"
    };
  }
  setDecoderPath(e) {
    return this.decoderPath = e, this;
  }
  setDecoderConfig(e) {
    return this.decoderConfig = e, this;
  }
  setWorkerLimit(e) {
    return this.workerLimit = e, this;
  }
  load(e, t, i, n) {
    const s = new Ai(this.manager);
    s.setPath(this.path), s.setResponseType("arraybuffer"), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(e, (r) => {
      this.decodeDracoFile(r, t).catch(n);
    }, i, n);
  }
  decodeDracoFile(e, t, i, n) {
    const s = {
      attributeIDs: i || this.defaultAttributeIDs,
      attributeTypes: n || this.defaultAttributeTypes,
      useUniqueIDs: !!i
    };
    return this.decodeGeometry(e, s).then(t);
  }
  decodeGeometry(e, t) {
    const i = JSON.stringify(t);
    if (al.has(e)) {
      const l = al.get(e);
      if (l.key === i)
        return l.promise;
      if (e.byteLength === 0)
        throw new Error(
          "THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred."
        );
    }
    let n;
    const s = this.workerNextTaskID++, r = e.byteLength, a = this._getWorker(s, r).then((l) => (n = l, new Promise((c, h) => {
      n._callbacks[s] = { resolve: c, reject: h }, n.postMessage({ type: "decode", id: s, taskConfig: t, buffer: e }, [e]);
    }))).then((l) => this._createGeometry(l.geometry));
    return a.catch(() => !0).then(() => {
      n && s && this._releaseTask(n, s);
    }), al.set(e, {
      key: i,
      promise: a
    }), a;
  }
  _createGeometry(e) {
    const t = new Ue();
    e.index && t.setIndex(new $e(e.index.array, 1));
    for (let i = 0; i < e.attributes.length; i++) {
      const n = e.attributes[i], s = n.name, r = n.array, a = n.itemSize;
      t.setAttribute(s, new $e(r, a));
    }
    return t;
  }
  _loadLibrary(e, t) {
    const i = new Ai(this.manager);
    return i.setPath(this.decoderPath), i.setResponseType(t), i.setWithCredentials(this.withCredentials), new Promise((n, s) => {
      i.load(e, n, void 0, s);
    });
  }
  preload() {
    return this._initDecoder(), this;
  }
  _initDecoder() {
    if (this.decoderPending) return this.decoderPending;
    const e = typeof WebAssembly != "object" || this.decoderConfig.type === "js", t = [];
    return e ? t.push(this._loadLibrary("draco_decoder.js", "text")) : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), t.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(t).then((i) => {
      const n = i[0];
      e || (this.decoderConfig.wasmBinary = i[1]);
      const s = Cw.toString(), r = [
        "/* draco decoder */",
        n,
        "",
        "/* worker */",
        s.substring(s.indexOf("{") + 1, s.lastIndexOf("}"))
      ].join(`
`);
      this.workerSourceURL = URL.createObjectURL(new Blob([r]));
    }), this.decoderPending;
  }
  _getWorker(e, t) {
    return this._initDecoder().then(() => {
      if (this.workerPool.length < this.workerLimit) {
        const n = new Worker(this.workerSourceURL);
        n._callbacks = {}, n._taskCosts = {}, n._taskLoad = 0, n.postMessage({ type: "init", decoderConfig: this.decoderConfig }), n.onmessage = function(s) {
          const r = s.data;
          switch (r.type) {
            case "decode":
              n._callbacks[r.id].resolve(r);
              break;
            case "error":
              n._callbacks[r.id].reject(r);
              break;
            default:
              console.error('THREE.DRACOLoader: Unexpected message, "' + r.type + '"');
          }
        }, this.workerPool.push(n);
      } else
        this.workerPool.sort(function(n, s) {
          return n._taskLoad > s._taskLoad ? -1 : 1;
        });
      const i = this.workerPool[this.workerPool.length - 1];
      return i._taskCosts[e] = t, i._taskLoad += t, i;
    });
  }
  _releaseTask(e, t) {
    e._taskLoad -= e._taskCosts[t], delete e._callbacks[t], delete e._taskCosts[t];
  }
  debug() {
    console.log("Task load: ", this.workerPool.map((e) => e._taskLoad));
  }
  dispose() {
    for (let e = 0; e < this.workerPool.length; ++e)
      this.workerPool[e].terminate();
    return this.workerPool.length = 0, this;
  }
}
function Cw() {
  let o, e;
  onmessage = function(r) {
    const a = r.data;
    switch (a.type) {
      case "init":
        o = a.decoderConfig, e = new Promise(function(h) {
          o.onModuleLoaded = function(u) {
            h({ draco: u });
          }, DracoDecoderModule(o);
        });
        break;
      case "decode":
        const l = a.buffer, c = a.taskConfig;
        e.then((h) => {
          const u = h.draco, d = new u.Decoder(), f = new u.DecoderBuffer();
          f.Init(new Int8Array(l), l.byteLength);
          try {
            const m = t(u, d, f, c), _ = m.attributes.map((p) => p.array.buffer);
            m.index && _.push(m.index.array.buffer), self.postMessage({ type: "decode", id: a.id, geometry: m }, _);
          } catch (m) {
            console.error(m), self.postMessage({ type: "error", id: a.id, error: m.message });
          } finally {
            u.destroy(f), u.destroy(d);
          }
        });
        break;
    }
  };
  function t(r, a, l, c) {
    const h = c.attributeIDs, u = c.attributeTypes;
    let d, f;
    const m = a.GetEncodedGeometryType(l);
    if (m === r.TRIANGULAR_MESH)
      d = new r.Mesh(), f = a.DecodeBufferToMesh(l, d);
    else if (m === r.POINT_CLOUD)
      d = new r.PointCloud(), f = a.DecodeBufferToPointCloud(l, d);
    else
      throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
    if (!f.ok() || d.ptr === 0)
      throw new Error("THREE.DRACOLoader: Decoding failed: " + f.error_msg());
    const _ = { index: null, attributes: [] };
    for (const p in h) {
      const g = self[u[p]];
      let x, y;
      if (c.useUniqueIDs)
        y = h[p], x = a.GetAttributeByUniqueId(d, y);
      else {
        if (y = a.GetAttributeId(d, r[h[p]]), y === -1) continue;
        x = a.GetAttribute(d, y);
      }
      _.attributes.push(n(r, a, d, p, g, x));
    }
    return m === r.TRIANGULAR_MESH && (_.index = i(r, a, d)), r.destroy(d), _;
  }
  function i(r, a, l) {
    const h = l.num_faces() * 3, u = h * 4, d = r._malloc(u);
    a.GetTrianglesUInt32Array(l, u, d);
    const f = new Uint32Array(r.HEAPF32.buffer, d, h).slice();
    return r._free(d), { array: f, itemSize: 1 };
  }
  function n(r, a, l, c, h, u) {
    const d = u.num_components(), m = l.num_points() * d, _ = m * h.BYTES_PER_ELEMENT, p = s(r, h), g = r._malloc(_);
    a.GetAttributeDataArrayForAllPoints(l, u, p, _, g);
    const x = new h(r.HEAPF32.buffer, g, m).slice();
    return r._free(g), {
      name: c,
      array: x,
      itemSize: d
    };
  }
  function s(r, a) {
    switch (a) {
      case Float32Array:
        return r.DT_FLOAT32;
      case Int8Array:
        return r.DT_INT8;
      case Int16Array:
        return r.DT_INT16;
      case Int32Array:
        return r.DT_INT32;
      case Uint8Array:
        return r.DT_UINT8;
      case Uint16Array:
        return r.DT_UINT16;
      case Uint32Array:
        return r.DT_UINT32;
    }
  }
}
class Lw {
  constructor(e, t) {
    k(this, "camera");
    k(this, "control");
    k(this, "target_animation");
    k(this, "position_animation");
    this.camera = e, this.control = t;
  }
  lookDownToBox(e, t, i = 120) {
    const n = new b(), s = new b();
    if (e.getCenter(n), s.copy(n), n.y += e.max.y - e.min.y + i, n.y += (e.max.x - e.min.x) / 2, t) {
      const r = t.length();
      n.z -= t.z / r, n.x -= t.x / r;
    }
    this.lookAt(s), this.moveTo(n);
  }
  lookAt(e, t) {
    return new Promise((i) => {
      this.target_animation && (this.target_animation.stop(), Sx.remove(this.target_animation)), this.control.enabled = !1, this.target_animation = new Bt(this.control.target), this.target_animation.to(e, t).start(), this.target_animation.onComplete(() => {
        this.target_animation = void 0, this.position_animation === void 0 && (this.control.enabled = !0), i();
      });
    });
  }
  moveTo(e, t) {
    return new Promise((i) => {
      this.control.enabled = !1, this.position_animation = new Bt(this.camera.position), this.position_animation.to(e, t).start(), this.position_animation.onComplete(() => {
        this.position_animation = void 0, this.target_animation === void 0 && (this.control.enabled = !0), i();
      });
    });
  }
}
class Pw extends tt {
  constructor(e = document.createElement("div")) {
    super(), this.isCSS2DObject = !0, this.element = e, this.element.style.position = "absolute", this.element.style.userSelect = "none", this.element.setAttribute("draggable", !1), this.addEventListener("removed", function() {
      this.traverse(function(t) {
        t.element instanceof Element && t.element.parentNode !== null && t.element.parentNode.removeChild(t.element);
      });
    });
  }
  copy(e, t) {
    return super.copy(e, t), this.element = e.element.cloneNode(!0), this;
  }
}
const ds = new b(), Uu = new ue(), Vu = new ue(), Gu = new b(), Hu = new b();
class Rw {
  constructor(e = {}) {
    const t = this;
    let i, n, s, r;
    const a = {
      objects: /* @__PURE__ */ new WeakMap()
    }, l = e.element !== void 0 ? e.element : document.createElement("div");
    l.style.overflow = "hidden", this.domElement = l, this.getSize = function() {
      return {
        width: i,
        height: n
      };
    }, this.render = function(f, m) {
      f.matrixWorldAutoUpdate === !0 && f.updateMatrixWorld(), m.parent === null && m.matrixWorldAutoUpdate === !0 && m.updateMatrixWorld(), Uu.copy(m.matrixWorldInverse), Vu.multiplyMatrices(m.projectionMatrix, Uu), c(f, f, m), d(f);
    }, this.setSize = function(f, m) {
      i = f, n = m, s = i / 2, r = n / 2, l.style.width = f + "px", l.style.height = m + "px";
    };
    function c(f, m, _) {
      if (f.isCSS2DObject) {
        ds.setFromMatrixPosition(f.matrixWorld), ds.applyMatrix4(Vu);
        const p = f.visible === !0 && ds.z >= -1 && ds.z <= 1 && f.layers.test(_.layers) === !0;
        if (f.element.style.display = p === !0 ? "" : "none", p === !0) {
          f.onBeforeRender(t, m, _);
          const x = f.element;
          x.style.transform = "translate(-50%,-50%) translate(" + (ds.x * s + s) + "px," + (-ds.y * r + r) + "px)", x.parentNode !== l && l.appendChild(x), f.onAfterRender(t, m, _);
        }
        const g = {
          distanceToCameraSquared: h(_, f)
        };
        a.objects.set(f, g);
      }
      for (let p = 0, g = f.children.length; p < g; p++)
        c(f.children[p], m, _);
    }
    function h(f, m) {
      return Gu.setFromMatrixPosition(f.matrixWorld), Hu.setFromMatrixPosition(m.matrixWorld), Gu.distanceToSquared(Hu);
    }
    function u(f) {
      const m = [];
      return f.traverse(function(_) {
        _.isCSS2DObject && m.push(_);
      }), m;
    }
    function d(f) {
      const m = u(f).sort(function(p, g) {
        if (p.renderOrder !== g.renderOrder)
          return g.renderOrder - p.renderOrder;
        const x = a.objects.get(p).distanceToCameraSquared, y = a.objects.get(g).distanceToCameraSquared;
        return x - y;
      }), _ = m.length;
      for (let p = 0, g = m.length; p < g; p++)
        m[p].element.style.zIndex = _ - p;
    }
  }
}
/*!
fflate - fast JavaScript compression/decompression
<https://101arrowz.github.io/fflate>
Licensed under MIT. https://github.com/101arrowz/fflate/blob/master/LICENSE
version 0.6.9
*/
var Wu = function(o) {
  return URL.createObjectURL(new Blob([o], { type: "text/javascript" }));
};
try {
  URL.revokeObjectURL(Wu(""));
} catch {
  Wu = function(e) {
    return "data:application/javascript;charset=UTF-8," + encodeURI(e);
  };
}
var ai = Uint8Array, hn = Uint16Array, Pl = Uint32Array, pf = new ai([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]), mf = new ai([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]), Iw = new ai([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), _f = function(o, e) {
  for (var t = new hn(31), i = 0; i < 31; ++i)
    t[i] = e += 1 << o[i - 1];
  for (var n = new Pl(t[30]), i = 1; i < 30; ++i)
    for (var s = t[i]; s < t[i + 1]; ++s)
      n[s] = s - t[i] << 5 | i;
  return [t, n];
}, gf = _f(pf, 2), vf = gf[0], Dw = gf[1];
vf[28] = 258, Dw[258] = 28;
var Ow = _f(mf, 0), Nw = Ow[0], Rl = new hn(32768);
for (var lt = 0; lt < 32768; ++lt) {
  var nn = (lt & 43690) >>> 1 | (lt & 21845) << 1;
  nn = (nn & 52428) >>> 2 | (nn & 13107) << 2, nn = (nn & 61680) >>> 4 | (nn & 3855) << 4, Rl[lt] = ((nn & 65280) >>> 8 | (nn & 255) << 8) >>> 1;
}
var pr = function(o, e, t) {
  for (var i = o.length, n = 0, s = new hn(e); n < i; ++n)
    ++s[o[n] - 1];
  var r = new hn(e);
  for (n = 0; n < e; ++n)
    r[n] = r[n - 1] + s[n - 1] << 1;
  var a;
  if (t) {
    a = new hn(1 << e);
    var l = 15 - e;
    for (n = 0; n < i; ++n)
      if (o[n])
        for (var c = n << 4 | o[n], h = e - o[n], u = r[o[n] - 1]++ << h, d = u | (1 << h) - 1; u <= d; ++u)
          a[Rl[u] >>> l] = c;
  } else
    for (a = new hn(i), n = 0; n < i; ++n)
      o[n] && (a[n] = Rl[r[o[n] - 1]++] >>> 15 - o[n]);
  return a;
}, Nr = new ai(288);
for (var lt = 0; lt < 144; ++lt)
  Nr[lt] = 8;
for (var lt = 144; lt < 256; ++lt)
  Nr[lt] = 9;
for (var lt = 256; lt < 280; ++lt)
  Nr[lt] = 7;
for (var lt = 280; lt < 288; ++lt)
  Nr[lt] = 8;
var yf = new ai(32);
for (var lt = 0; lt < 32; ++lt)
  yf[lt] = 5;
var kw = /* @__PURE__ */ pr(Nr, 9, 1), zw = /* @__PURE__ */ pr(yf, 5, 1), ol = function(o) {
  for (var e = o[0], t = 1; t < o.length; ++t)
    o[t] > e && (e = o[t]);
  return e;
}, pi = function(o, e, t) {
  var i = e / 8 | 0;
  return (o[i] | o[i + 1] << 8) >> (e & 7) & t;
}, ll = function(o, e) {
  var t = e / 8 | 0;
  return (o[t] | o[t + 1] << 8 | o[t + 2] << 16) >> (e & 7);
}, Fw = function(o) {
  return (o / 8 | 0) + (o & 7 && 1);
}, Bw = function(o, e, t) {
  (t == null || t > o.length) && (t = o.length);
  var i = new (o instanceof hn ? hn : o instanceof Pl ? Pl : ai)(t - e);
  return i.set(o.subarray(e, t)), i;
}, Uw = function(o, e, t) {
  var i = o.length;
  if (!i || t && !t.l && i < 5)
    return e || new ai(0);
  var n = !e || t, s = !t || t.i;
  t || (t = {}), e || (e = new ai(i * 3));
  var r = function(j) {
    var De = e.length;
    if (j > De) {
      var ye = new ai(Math.max(De * 2, j));
      ye.set(e), e = ye;
    }
  }, a = t.f || 0, l = t.p || 0, c = t.b || 0, h = t.l, u = t.d, d = t.m, f = t.n, m = i * 8;
  do {
    if (!h) {
      t.f = a = pi(o, l, 1);
      var _ = pi(o, l + 1, 3);
      if (l += 3, _)
        if (_ == 1)
          h = kw, u = zw, d = 9, f = 5;
        else if (_ == 2) {
          var y = pi(o, l, 31) + 257, v = pi(o, l + 10, 15) + 4, M = y + pi(o, l + 5, 31) + 1;
          l += 14;
          for (var S = new ai(M), A = new ai(19), w = 0; w < v; ++w)
            A[Iw[w]] = pi(o, l + w * 3, 7);
          l += v * 3;
          for (var E = ol(A), P = (1 << E) - 1, z = pr(A, E, 1), w = 0; w < M; ) {
            var V = z[pi(o, l, P)];
            l += V & 15;
            var p = V >>> 4;
            if (p < 16)
              S[w++] = p;
            else {
              var O = 0, D = 0;
              for (p == 16 ? (D = 3 + pi(o, l, 3), l += 2, O = S[w - 1]) : p == 17 ? (D = 3 + pi(o, l, 7), l += 3) : p == 18 && (D = 11 + pi(o, l, 127), l += 7); D--; )
                S[w++] = O;
            }
          }
          var H = S.subarray(0, y), Z = S.subarray(y);
          d = ol(H), f = ol(Z), h = pr(H, d, 1), u = pr(Z, f, 1);
        } else
          throw "invalid block type";
      else {
        var p = Fw(l) + 4, g = o[p - 4] | o[p - 3] << 8, x = p + g;
        if (x > i) {
          if (s)
            throw "unexpected EOF";
          break;
        }
        n && r(c + g), e.set(o.subarray(p, x), c), t.b = c += g, t.p = l = x * 8;
        continue;
      }
      if (l > m) {
        if (s)
          throw "unexpected EOF";
        break;
      }
    }
    n && r(c + 131072);
    for (var ie = (1 << d) - 1, K = (1 << f) - 1, ne = l; ; ne = l) {
      var O = h[ll(o, l) & ie], te = O >>> 4;
      if (l += O & 15, l > m) {
        if (s)
          throw "unexpected EOF";
        break;
      }
      if (!O)
        throw "invalid length/literal";
      if (te < 256)
        e[c++] = te;
      else if (te == 256) {
        ne = l, h = null;
        break;
      } else {
        var q = te - 254;
        if (te > 264) {
          var w = te - 257, W = pf[w];
          q = pi(o, l, (1 << W) - 1) + vf[w], l += W;
        }
        var le = u[ll(o, l) & K], ae = le >>> 4;
        if (!le)
          throw "invalid distance";
        l += le & 15;
        var Z = Nw[ae];
        if (ae > 3) {
          var W = mf[ae];
          Z += ll(o, l) & (1 << W) - 1, l += W;
        }
        if (l > m) {
          if (s)
            throw "unexpected EOF";
          break;
        }
        n && r(c + 131072);
        for (var fe = c + q; c < fe; c += 4)
          e[c] = e[c - Z], e[c + 1] = e[c + 1 - Z], e[c + 2] = e[c + 2 - Z], e[c + 3] = e[c + 3 - Z];
        c = fe;
      }
    }
    t.l = h, t.p = ne, t.b = c, h && (a = 1, t.m = d, t.d = u, t.n = f);
  } while (!a);
  return c == e.length ? e : Bw(e, 0, c);
}, Vw = /* @__PURE__ */ new ai(0), Gw = function(o) {
  if ((o[0] & 15) != 8 || o[0] >>> 4 > 7 || (o[0] << 8 | o[1]) % 31)
    throw "invalid zlib data";
  if (o[1] & 32)
    throw "invalid zlib data: preset dictionaries not supported";
};
function Hw(o, e) {
  return Uw((Gw(o), o.subarray(2, -4)), e);
}
var Ww = typeof TextDecoder < "u" && /* @__PURE__ */ new TextDecoder(), Xw = 0;
try {
  Ww.decode(Vw, { stream: !0 }), Xw = 1;
} catch {
}
function xf(o, e, t) {
  const i = t.length - o - 1;
  if (e >= t[i])
    return i - 1;
  if (e <= t[o])
    return o;
  let n = o, s = i, r = Math.floor((n + s) / 2);
  for (; e < t[r] || e >= t[r + 1]; )
    e < t[r] ? s = r : n = r, r = Math.floor((n + s) / 2);
  return r;
}
function qw(o, e, t, i) {
  const n = [], s = [], r = [];
  n[0] = 1;
  for (let a = 1; a <= t; ++a) {
    s[a] = e - i[o + 1 - a], r[a] = i[o + a] - e;
    let l = 0;
    for (let c = 0; c < a; ++c) {
      const h = r[c + 1], u = s[a - c], d = n[c] / (h + u);
      n[c] = l + h * d, l = u * d;
    }
    n[a] = l;
  }
  return n;
}
function jw(o, e, t, i) {
  const n = xf(o, i, e), s = qw(n, i, o, e), r = new We(0, 0, 0, 0);
  for (let a = 0; a <= o; ++a) {
    const l = t[n - o + a], c = s[a], h = l.w * c;
    r.x += l.x * h, r.y += l.y * h, r.z += l.z * h, r.w += l.w * c;
  }
  return r;
}
function Yw(o, e, t, i, n) {
  const s = [];
  for (let u = 0; u <= t; ++u)
    s[u] = 0;
  const r = [];
  for (let u = 0; u <= i; ++u)
    r[u] = s.slice(0);
  const a = [];
  for (let u = 0; u <= t; ++u)
    a[u] = s.slice(0);
  a[0][0] = 1;
  const l = s.slice(0), c = s.slice(0);
  for (let u = 1; u <= t; ++u) {
    l[u] = e - n[o + 1 - u], c[u] = n[o + u] - e;
    let d = 0;
    for (let f = 0; f < u; ++f) {
      const m = c[f + 1], _ = l[u - f];
      a[u][f] = m + _;
      const p = a[f][u - 1] / a[u][f];
      a[f][u] = d + m * p, d = _ * p;
    }
    a[u][u] = d;
  }
  for (let u = 0; u <= t; ++u)
    r[0][u] = a[u][t];
  for (let u = 0; u <= t; ++u) {
    let d = 0, f = 1;
    const m = [];
    for (let _ = 0; _ <= t; ++_)
      m[_] = s.slice(0);
    m[0][0] = 1;
    for (let _ = 1; _ <= i; ++_) {
      let p = 0;
      const g = u - _, x = t - _;
      u >= _ && (m[f][0] = m[d][0] / a[x + 1][g], p = m[f][0] * a[g][x]);
      const y = g >= -1 ? 1 : -g, v = u - 1 <= x ? _ - 1 : t - u;
      for (let S = y; S <= v; ++S)
        m[f][S] = (m[d][S] - m[d][S - 1]) / a[x + 1][g + S], p += m[f][S] * a[g + S][x];
      u <= x && (m[f][_] = -m[d][_ - 1] / a[x + 1][u], p += m[f][_] * a[u][x]), r[_][u] = p;
      const M = d;
      d = f, f = M;
    }
  }
  let h = t;
  for (let u = 1; u <= i; ++u) {
    for (let d = 0; d <= t; ++d)
      r[u][d] *= h;
    h *= t - u;
  }
  return r;
}
function Zw(o, e, t, i, n) {
  const s = n < o ? n : o, r = [], a = xf(o, i, e), l = Yw(a, i, o, s, e), c = [];
  for (let h = 0; h < t.length; ++h) {
    const u = t[h].clone(), d = u.w;
    u.x *= d, u.y *= d, u.z *= d, c[h] = u;
  }
  for (let h = 0; h <= s; ++h) {
    const u = c[a - o].clone().multiplyScalar(l[h][0]);
    for (let d = 1; d <= o; ++d)
      u.add(c[a - o + d].clone().multiplyScalar(l[h][d]));
    r[h] = u;
  }
  for (let h = s + 1; h <= n + 1; ++h)
    r[h] = new We(0, 0, 0);
  return r;
}
function Jw(o, e) {
  let t = 1;
  for (let n = 2; n <= o; ++n)
    t *= n;
  let i = 1;
  for (let n = 2; n <= e; ++n)
    i *= n;
  for (let n = 2; n <= o - e; ++n)
    i *= n;
  return t / i;
}
function Kw(o) {
  const e = o.length, t = [], i = [];
  for (let s = 0; s < e; ++s) {
    const r = o[s];
    t[s] = new b(r.x, r.y, r.z), i[s] = r.w;
  }
  const n = [];
  for (let s = 0; s < e; ++s) {
    const r = t[s].clone();
    for (let a = 1; a <= s; ++a)
      r.sub(n[s - a].clone().multiplyScalar(Jw(s, a) * i[a]));
    n[s] = r.divideScalar(i[0]);
  }
  return n;
}
function $w(o, e, t, i, n) {
  const s = Zw(o, e, t, i, n);
  return Kw(s);
}
class Qw extends yi {
  constructor(e, t, i, n, s) {
    super(), this.degree = e, this.knots = t, this.controlPoints = [], this.startKnot = n || 0, this.endKnot = s || this.knots.length - 1;
    for (let r = 0; r < i.length; ++r) {
      const a = i[r];
      this.controlPoints[r] = new We(a.x, a.y, a.z, a.w);
    }
  }
  getPoint(e, t = new b()) {
    const i = t, n = this.knots[this.startKnot] + e * (this.knots[this.endKnot] - this.knots[this.startKnot]), s = jw(this.degree, this.knots, this.controlPoints, n);
    return s.w !== 1 && s.divideScalar(s.w), i.set(s.x, s.y, s.z);
  }
  getTangent(e, t = new b()) {
    const i = t, n = this.knots[0] + e * (this.knots[this.knots.length - 1] - this.knots[0]), s = $w(this.degree, this.knots, this.controlPoints, n, 1);
    return i.copy(s[1]).normalize(), i;
  }
}
let Ge, ut, Xt;
class eb extends xi {
  constructor(e) {
    super(e);
  }
  load(e, t, i, n) {
    const s = this, r = s.path === "" ? ci.extractUrlBase(e) : s.path, a = new Ai(this.manager);
    a.setPath(s.path), a.setResponseType("arraybuffer"), a.setRequestHeader(s.requestHeader), a.setWithCredentials(s.withCredentials), a.load(e, function(l) {
      try {
        t(s.parse(l, r));
      } catch (c) {
        n ? n(c) : console.error(c), s.manager.itemError(e);
      }
    }, i, n);
  }
  parse(e, t) {
    if (ab(e))
      Ge = new rb().parse(e);
    else {
      const n = Sf(e);
      if (!ob(n))
        throw new Error("THREE.FBXLoader: Unknown format.");
      if (qu(n) < 7e3)
        throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + qu(n));
      Ge = new sb().parse(n);
    }
    const i = new fr(this.manager).setPath(this.resourcePath || t).setCrossOrigin(this.crossOrigin);
    return new tb(i, this.manager).parse(Ge);
  }
}
class tb {
  constructor(e, t) {
    this.textureLoader = e, this.manager = t;
  }
  parse() {
    ut = this.parseConnections();
    const e = this.parseImages(), t = this.parseTextures(e), i = this.parseMaterials(t), n = this.parseDeformers(), s = new ib().parse(n);
    return this.parseScene(n, s, i), Xt;
  }
  // Parses FBXTree.Connections which holds parent-child connections between objects (e.g. material -> texture, model->geometry )
  // and details the connection type
  parseConnections() {
    const e = /* @__PURE__ */ new Map();
    return "Connections" in Ge && Ge.Connections.connections.forEach(function(i) {
      const n = i[0], s = i[1], r = i[2];
      e.has(n) || e.set(n, {
        parents: [],
        children: []
      });
      const a = { ID: s, relationship: r };
      e.get(n).parents.push(a), e.has(s) || e.set(s, {
        parents: [],
        children: []
      });
      const l = { ID: n, relationship: r };
      e.get(s).children.push(l);
    }), e;
  }
  // Parse FBXTree.Objects.Video for embedded image data
  // These images are connected to textures in FBXTree.Objects.Textures
  // via FBXTree.Connections.
  parseImages() {
    const e = {}, t = {};
    if ("Video" in Ge.Objects) {
      const i = Ge.Objects.Video;
      for (const n in i) {
        const s = i[n], r = parseInt(n);
        if (e[r] = s.RelativeFilename || s.Filename, "Content" in s) {
          const a = s.Content instanceof ArrayBuffer && s.Content.byteLength > 0, l = typeof s.Content == "string" && s.Content !== "";
          if (a || l) {
            const c = this.parseImage(i[n]);
            t[s.RelativeFilename || s.Filename] = c;
          }
        }
      }
    }
    for (const i in e) {
      const n = e[i];
      t[n] !== void 0 ? e[i] = t[n] : e[i] = e[i].split("\\").pop();
    }
    return e;
  }
  // Parse embedded image data in FBXTree.Video.Content
  parseImage(e) {
    const t = e.Content, i = e.RelativeFilename || e.Filename, n = i.slice(i.lastIndexOf(".") + 1).toLowerCase();
    let s;
    switch (n) {
      case "bmp":
        s = "image/bmp";
        break;
      case "jpg":
      case "jpeg":
        s = "image/jpeg";
        break;
      case "png":
        s = "image/png";
        break;
      case "tif":
        s = "image/tiff";
        break;
      case "tga":
        this.manager.getHandler(".tga") === null && console.warn("FBXLoader: TGA loader not found, skipping ", i), s = "image/tga";
        break;
      default:
        console.warn('FBXLoader: Image type "' + n + '" is not supported.');
        return;
    }
    if (typeof t == "string")
      return "data:" + s + ";base64," + t;
    {
      const r = new Uint8Array(t);
      return window.URL.createObjectURL(new Blob([r], { type: s }));
    }
  }
  // Parse nodes in FBXTree.Objects.Texture
  // These contain details such as UV scaling, cropping, rotation etc and are connected
  // to images in FBXTree.Objects.Video
  parseTextures(e) {
    const t = /* @__PURE__ */ new Map();
    if ("Texture" in Ge.Objects) {
      const i = Ge.Objects.Texture;
      for (const n in i) {
        const s = this.parseTexture(i[n], e);
        t.set(parseInt(n), s);
      }
    }
    return t;
  }
  // Parse individual node in FBXTree.Objects.Texture
  parseTexture(e, t) {
    const i = this.loadTexture(e, t);
    i.ID = e.id, i.name = e.attrName;
    const n = e.WrapModeU, s = e.WrapModeV, r = n !== void 0 ? n.value : 0, a = s !== void 0 ? s.value : 0;
    if (i.wrapS = r === 0 ? Yi : Vt, i.wrapT = a === 0 ? Yi : Vt, "Scaling" in e) {
      const l = e.Scaling.value;
      i.repeat.x = l[0], i.repeat.y = l[1];
    }
    if ("Translation" in e) {
      const l = e.Translation.value;
      i.offset.x = l[0], i.offset.y = l[1];
    }
    return i;
  }
  // load a texture specified as a blob or data URI, or via an external URL using TextureLoader
  loadTexture(e, t) {
    let i;
    const n = this.textureLoader.path, s = ut.get(e.id).children;
    s !== void 0 && s.length > 0 && t[s[0].ID] !== void 0 && (i = t[s[0].ID], (i.indexOf("blob:") === 0 || i.indexOf("data:") === 0) && this.textureLoader.setPath(void 0));
    let r;
    const a = e.FileName.slice(-3).toLowerCase();
    if (a === "tga") {
      const l = this.manager.getHandler(".tga");
      l === null ? (console.warn("FBXLoader: TGA loader not found, creating placeholder texture for", e.RelativeFilename), r = new dt()) : (l.setPath(this.textureLoader.path), r = l.load(i));
    } else a === "psd" ? (console.warn("FBXLoader: PSD textures are not supported, creating placeholder texture for", e.RelativeFilename), r = new dt()) : r = this.textureLoader.load(i);
    return this.textureLoader.setPath(n), r;
  }
  // Parse nodes in FBXTree.Objects.Material
  parseMaterials(e) {
    const t = /* @__PURE__ */ new Map();
    if ("Material" in Ge.Objects) {
      const i = Ge.Objects.Material;
      for (const n in i) {
        const s = this.parseMaterial(i[n], e);
        s !== null && t.set(parseInt(n), s);
      }
    }
    return t;
  }
  // Parse single node in FBXTree.Objects.Material
  // Materials are connected to texture maps in FBXTree.Objects.Textures
  // FBX format currently only supports Lambert and Phong shading models
  parseMaterial(e, t) {
    const i = e.id, n = e.attrName;
    let s = e.ShadingModel;
    if (typeof s == "object" && (s = s.value), !ut.has(i)) return null;
    const r = this.parseParameters(e, t, i);
    let a;
    switch (s.toLowerCase()) {
      case "phong":
        a = new Na();
        break;
      case "lambert":
        a = new kd();
        break;
      default:
        console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.', s), a = new Na();
        break;
    }
    return a.setValues(r), a.name = n, a;
  }
  // Parse FBX material and return parameters suitable for a three.js material
  // Also parse the texture map and return any textures associated with the material
  parseParameters(e, t, i) {
    const n = {};
    e.BumpFactor && (n.bumpScale = e.BumpFactor.value), e.Diffuse ? n.color = new de().fromArray(e.Diffuse.value) : e.DiffuseColor && (e.DiffuseColor.type === "Color" || e.DiffuseColor.type === "ColorRGB") && (n.color = new de().fromArray(e.DiffuseColor.value)), e.DisplacementFactor && (n.displacementScale = e.DisplacementFactor.value), e.Emissive ? n.emissive = new de().fromArray(e.Emissive.value) : e.EmissiveColor && (e.EmissiveColor.type === "Color" || e.EmissiveColor.type === "ColorRGB") && (n.emissive = new de().fromArray(e.EmissiveColor.value)), e.EmissiveFactor && (n.emissiveIntensity = parseFloat(e.EmissiveFactor.value)), e.Opacity && (n.opacity = parseFloat(e.Opacity.value)), n.opacity < 1 && (n.transparent = !0), e.ReflectionFactor && (n.reflectivity = e.ReflectionFactor.value), e.Shininess && (n.shininess = e.Shininess.value), e.Specular ? n.specular = new de().fromArray(e.Specular.value) : e.SpecularColor && e.SpecularColor.type === "Color" && (n.specular = new de().fromArray(e.SpecularColor.value));
    const s = this;
    return ut.get(i).children.forEach(function(r) {
      const a = r.relationship;
      switch (a) {
        case "Bump":
          n.bumpMap = s.getTexture(t, r.ID);
          break;
        case "Maya|TEX_ao_map":
          n.aoMap = s.getTexture(t, r.ID);
          break;
        case "DiffuseColor":
        case "Maya|TEX_color_map":
          n.map = s.getTexture(t, r.ID), n.map !== void 0 && (n.map.encoding = He);
          break;
        case "DisplacementColor":
          n.displacementMap = s.getTexture(t, r.ID);
          break;
        case "EmissiveColor":
          n.emissiveMap = s.getTexture(t, r.ID), n.emissiveMap !== void 0 && (n.emissiveMap.encoding = He);
          break;
        case "NormalMap":
        case "Maya|TEX_normal_map":
          n.normalMap = s.getTexture(t, r.ID);
          break;
        case "ReflectionColor":
          n.envMap = s.getTexture(t, r.ID), n.envMap !== void 0 && (n.envMap.mapping = mr, n.envMap.encoding = He);
          break;
        case "SpecularColor":
          n.specularMap = s.getTexture(t, r.ID), n.specularMap !== void 0 && (n.specularMap.encoding = He);
          break;
        case "TransparentColor":
        case "TransparencyFactor":
          n.alphaMap = s.getTexture(t, r.ID), n.transparent = !0;
          break;
        case "AmbientColor":
        case "ShininessExponent":
        case "SpecularFactor":
        case "VectorDisplacementColor":
        default:
          console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.", a);
          break;
      }
    }), n;
  }
  // get a texture from the textureMap for use by a material.
  getTexture(e, t) {
    return "LayeredTexture" in Ge.Objects && t in Ge.Objects.LayeredTexture && (console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer."), t = ut.get(t).children[0].ID), e.get(t);
  }
  // Parse nodes in FBXTree.Objects.Deformer
  // Deformer node can contain skinning or Vertex Cache animation data, however only skinning is supported here
  // Generates map of Skeleton-like objects for use later when generating and binding skeletons.
  parseDeformers() {
    const e = {}, t = {};
    if ("Deformer" in Ge.Objects) {
      const i = Ge.Objects.Deformer;
      for (const n in i) {
        const s = i[n], r = ut.get(parseInt(n));
        if (s.attrType === "Skin") {
          const a = this.parseSkeleton(r, i);
          a.ID = n, r.parents.length > 1 && console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported."), a.geometryID = r.parents[0].ID, e[n] = a;
        } else if (s.attrType === "BlendShape") {
          const a = {
            id: n
          };
          a.rawTargets = this.parseMorphTargets(r, i), a.id = n, r.parents.length > 1 && console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported."), t[n] = a;
        }
      }
    }
    return {
      skeletons: e,
      morphTargets: t
    };
  }
  // Parse single nodes in FBXTree.Objects.Deformer
  // The top level skeleton node has type 'Skin' and sub nodes have type 'Cluster'
  // Each skin node represents a skeleton and each cluster node represents a bone
  parseSkeleton(e, t) {
    const i = [];
    return e.children.forEach(function(n) {
      const s = t[n.ID];
      if (s.attrType !== "Cluster") return;
      const r = {
        ID: n.ID,
        indices: [],
        weights: [],
        transformLink: new ue().fromArray(s.TransformLink.a)
        // transform: new Matrix4().fromArray( boneNode.Transform.a ),
        // linkMode: boneNode.Mode,
      };
      "Indexes" in s && (r.indices = s.Indexes.a, r.weights = s.Weights.a), i.push(r);
    }), {
      rawBones: i,
      bones: []
    };
  }
  // The top level morph deformer node has type "BlendShape" and sub nodes have type "BlendShapeChannel"
  parseMorphTargets(e, t) {
    const i = [];
    for (let n = 0; n < e.children.length; n++) {
      const s = e.children[n], r = t[s.ID], a = {
        name: r.attrName,
        initialWeight: r.DeformPercent,
        id: r.id,
        fullWeights: r.FullWeights.a
      };
      if (r.attrType !== "BlendShapeChannel") return;
      a.geoID = ut.get(parseInt(s.ID)).children.filter(function(l) {
        return l.relationship === void 0;
      })[0].ID, i.push(a);
    }
    return i;
  }
  // create the main Group() to be returned by the loader
  parseScene(e, t, i) {
    Xt = new nt();
    const n = this.parseModels(e.skeletons, t, i), s = Ge.Objects.Model, r = this;
    n.forEach(function(l) {
      const c = s[l.ID];
      r.setLookAtProperties(l, c), ut.get(l.ID).parents.forEach(function(u) {
        const d = n.get(u.ID);
        d !== void 0 && d.add(l);
      }), l.parent === null && Xt.add(l);
    }), this.bindSkeleton(e.skeletons, t, n), this.createAmbientLight(), Xt.traverse(function(l) {
      if (l.userData.transformData) {
        l.parent && (l.userData.transformData.parentMatrix = l.parent.matrix, l.userData.transformData.parentMatrixWorld = l.parent.matrixWorld);
        const c = bf(l.userData.transformData);
        l.applyMatrix4(c), l.updateWorldMatrix();
      }
    });
    const a = new nb().parse();
    Xt.children.length === 1 && Xt.children[0].isGroup && (Xt.children[0].animations = a, Xt = Xt.children[0]), Xt.animations = a;
  }
  // parse nodes in FBXTree.Objects.Model
  parseModels(e, t, i) {
    const n = /* @__PURE__ */ new Map(), s = Ge.Objects.Model;
    for (const r in s) {
      const a = parseInt(r), l = s[r], c = ut.get(a);
      let h = this.buildSkeleton(c, e, a, l.attrName);
      if (!h) {
        switch (l.attrType) {
          case "Camera":
            h = this.createCamera(c);
            break;
          case "Light":
            h = this.createLight(c);
            break;
          case "Mesh":
            h = this.createMesh(c, t, i);
            break;
          case "NurbsCurve":
            h = this.createCurve(c, t);
            break;
          case "LimbNode":
          case "Root":
            h = new br();
            break;
          case "Null":
          default:
            h = new nt();
            break;
        }
        h.name = l.attrName ? Je.sanitizeNodeName(l.attrName) : "", h.ID = a;
      }
      this.getTransformData(h, l), n.set(a, h);
    }
    return n;
  }
  buildSkeleton(e, t, i, n) {
    let s = null;
    return e.parents.forEach(function(r) {
      for (const a in t) {
        const l = t[a];
        l.rawBones.forEach(function(c, h) {
          if (c.ID === r.ID) {
            const u = s;
            s = new br(), s.matrixWorld.copy(c.transformLink), s.name = n ? Je.sanitizeNodeName(n) : "", s.ID = i, l.bones[h] = s, u !== null && s.add(u);
          }
        });
      }
    }), s;
  }
  // create a PerspectiveCamera or OrthographicCamera
  createCamera(e) {
    let t, i;
    if (e.children.forEach(function(n) {
      const s = Ge.Objects.NodeAttribute[n.ID];
      s !== void 0 && (i = s);
    }), i === void 0)
      t = new tt();
    else {
      let n = 0;
      i.CameraProjectionType !== void 0 && i.CameraProjectionType.value === 1 && (n = 1);
      let s = 1;
      i.NearPlane !== void 0 && (s = i.NearPlane.value / 1e3);
      let r = 1e3;
      i.FarPlane !== void 0 && (r = i.FarPlane.value / 1e3);
      let a = window.innerWidth, l = window.innerHeight;
      i.AspectWidth !== void 0 && i.AspectHeight !== void 0 && (a = i.AspectWidth.value, l = i.AspectHeight.value);
      const c = a / l;
      let h = 45;
      i.FieldOfView !== void 0 && (h = i.FieldOfView.value);
      const u = i.FocalLength ? i.FocalLength.value : null;
      switch (n) {
        case 0:
          t = new gt(h, c, s, r), u !== null && t.setFocalLength(u);
          break;
        case 1:
          t = new pn(-a / 2, a / 2, l / 2, -l / 2, s, r);
          break;
        default:
          console.warn("THREE.FBXLoader: Unknown camera type " + n + "."), t = new tt();
          break;
      }
    }
    return t;
  }
  // Create a DirectionalLight, PointLight or SpotLight
  createLight(e) {
    let t, i;
    if (e.children.forEach(function(n) {
      const s = Ge.Objects.NodeAttribute[n.ID];
      s !== void 0 && (i = s);
    }), i === void 0)
      t = new tt();
    else {
      let n;
      i.LightType === void 0 ? n = 0 : n = i.LightType.value;
      let s = 16777215;
      i.Color !== void 0 && (s = new de().fromArray(i.Color.value));
      let r = i.Intensity === void 0 ? 1 : i.Intensity.value / 100;
      i.CastLightOnObject !== void 0 && i.CastLightOnObject.value === 0 && (r = 0);
      let a = 0;
      i.FarAttenuationEnd !== void 0 && (i.EnableFarAttenuation !== void 0 && i.EnableFarAttenuation.value === 0 ? a = 0 : a = i.FarAttenuationEnd.value);
      const l = 1;
      switch (n) {
        case 0:
          t = new Ha(s, r, a, l);
          break;
        case 1:
          t = new vc(s, r);
          break;
        case 2:
          let c = Math.PI / 3;
          i.InnerAngle !== void 0 && (c = Rt.degToRad(i.InnerAngle.value));
          let h = 0;
          i.OuterAngle !== void 0 && (h = Rt.degToRad(i.OuterAngle.value), h = Math.max(h, 1)), t = new gc(s, r, a, c, h, l);
          break;
        default:
          console.warn("THREE.FBXLoader: Unknown light type " + i.LightType.value + ", defaulting to a PointLight."), t = new Ha(s, r);
          break;
      }
      i.CastShadows !== void 0 && i.CastShadows.value === 1 && (t.castShadow = !0);
    }
    return t;
  }
  createMesh(e, t, i) {
    let n, s = null, r = null;
    const a = [];
    return e.children.forEach(function(l) {
      t.has(l.ID) && (s = t.get(l.ID)), i.has(l.ID) && a.push(i.get(l.ID));
    }), a.length > 1 ? r = a : a.length > 0 ? r = a[0] : (r = new Na({ color: 13421772 }), a.push(r)), "color" in s.attributes && a.forEach(function(l) {
      l.vertexColors = !0;
    }), s.FBX_Deformer ? (n = new ql(s, r), n.normalizeSkinWeights()) : n = new st(s, r), n;
  }
  createCurve(e, t) {
    const i = e.children.reduce(function(s, r) {
      return t.has(r.ID) && (s = t.get(r.ID)), s;
    }, null), n = new mn({ color: 3342591, linewidth: 1 });
    return new Bn(i, n);
  }
  // parse the model node for transform data
  getTransformData(e, t) {
    const i = {};
    "InheritType" in t && (i.inheritType = parseInt(t.InheritType.value)), "RotationOrder" in t ? i.eulerOrder = Mf(t.RotationOrder.value) : i.eulerOrder = "ZYX", "Lcl_Translation" in t && (i.translation = t.Lcl_Translation.value), "PreRotation" in t && (i.preRotation = t.PreRotation.value), "Lcl_Rotation" in t && (i.rotation = t.Lcl_Rotation.value), "PostRotation" in t && (i.postRotation = t.PostRotation.value), "Lcl_Scaling" in t && (i.scale = t.Lcl_Scaling.value), "ScalingOffset" in t && (i.scalingOffset = t.ScalingOffset.value), "ScalingPivot" in t && (i.scalingPivot = t.ScalingPivot.value), "RotationOffset" in t && (i.rotationOffset = t.RotationOffset.value), "RotationPivot" in t && (i.rotationPivot = t.RotationPivot.value), e.userData.transformData = i;
  }
  setLookAtProperties(e, t) {
    "LookAtProperty" in t && ut.get(e.ID).children.forEach(function(n) {
      if (n.relationship === "LookAtProperty") {
        const s = Ge.Objects.Model[n.ID];
        if ("Lcl_Translation" in s) {
          const r = s.Lcl_Translation.value;
          e.target !== void 0 ? (e.target.position.fromArray(r), Xt.add(e.target)) : e.lookAt(new b().fromArray(r));
        }
      }
    });
  }
  bindSkeleton(e, t, i) {
    const n = this.parsePoseNodes();
    for (const s in e) {
      const r = e[s];
      ut.get(parseInt(r.ID)).parents.forEach(function(l) {
        if (t.has(l.ID)) {
          const c = l.ID;
          ut.get(c).parents.forEach(function(u) {
            i.has(u.ID) && i.get(u.ID).bind(new Rr(r.bones), n[u.ID]);
          });
        }
      });
    }
  }
  parsePoseNodes() {
    const e = {};
    if ("Pose" in Ge.Objects) {
      const t = Ge.Objects.Pose;
      for (const i in t)
        if (t[i].attrType === "BindPose" && t[i].NbPoseNodes > 0) {
          const n = t[i].PoseNode;
          Array.isArray(n) ? n.forEach(function(s) {
            e[s.Node] = new ue().fromArray(s.Matrix.a);
          }) : e[n.Node] = new ue().fromArray(n.Matrix.a);
        }
    }
    return e;
  }
  // Parse ambient color in FBXTree.GlobalSettings - if it's not set to black (default), create an ambient light
  createAmbientLight() {
    if ("GlobalSettings" in Ge && "AmbientColor" in Ge.GlobalSettings) {
      const e = Ge.GlobalSettings.AmbientColor.value, t = e[0], i = e[1], n = e[2];
      if (t !== 0 || i !== 0 || n !== 0) {
        const s = new de(t, i, n);
        Xt.add(new Vd(s, 1));
      }
    }
  }
}
class ib {
  constructor() {
    this.negativeMaterialIndices = !1;
  }
  // Parse nodes in FBXTree.Objects.Geometry
  parse(e) {
    const t = /* @__PURE__ */ new Map();
    if ("Geometry" in Ge.Objects) {
      const i = Ge.Objects.Geometry;
      for (const n in i) {
        const s = ut.get(parseInt(n)), r = this.parseGeometry(s, i[n], e);
        t.set(parseInt(n), r);
      }
    }
    return this.negativeMaterialIndices === !0 && console.warn("THREE.FBXLoader: The FBX file contains invalid (negative) material indices. The asset might not render as expected."), t;
  }
  // Parse single node in FBXTree.Objects.Geometry
  parseGeometry(e, t, i) {
    switch (t.attrType) {
      case "Mesh":
        return this.parseMeshGeometry(e, t, i);
      case "NurbsCurve":
        return this.parseNurbsGeometry(t);
    }
  }
  // Parse single node mesh geometry in FBXTree.Objects.Geometry
  parseMeshGeometry(e, t, i) {
    const n = i.skeletons, s = [], r = e.parents.map(function(u) {
      return Ge.Objects.Model[u.ID];
    });
    if (r.length === 0) return;
    const a = e.children.reduce(function(u, d) {
      return n[d.ID] !== void 0 && (u = n[d.ID]), u;
    }, null);
    e.children.forEach(function(u) {
      i.morphTargets[u.ID] !== void 0 && s.push(i.morphTargets[u.ID]);
    });
    const l = r[0], c = {};
    "RotationOrder" in l && (c.eulerOrder = Mf(l.RotationOrder.value)), "InheritType" in l && (c.inheritType = parseInt(l.InheritType.value)), "GeometricTranslation" in l && (c.translation = l.GeometricTranslation.value), "GeometricRotation" in l && (c.rotation = l.GeometricRotation.value), "GeometricScaling" in l && (c.scale = l.GeometricScaling.value);
    const h = bf(c);
    return this.genGeometry(t, a, s, h);
  }
  // Generate a BufferGeometry from a node in FBXTree.Objects.Geometry
  genGeometry(e, t, i, n) {
    const s = new Ue();
    e.attrName && (s.name = e.attrName);
    const r = this.parseGeoNode(e, t), a = this.genBuffers(r), l = new Ee(a.vertex, 3);
    if (l.applyMatrix4(n), s.setAttribute("position", l), a.colors.length > 0 && s.setAttribute("color", new Ee(a.colors, 3)), t && (s.setAttribute("skinIndex", new Ul(a.weightsIndices, 4)), s.setAttribute("skinWeight", new Ee(a.vertexWeights, 4)), s.FBX_Deformer = t), a.normal.length > 0) {
      const c = new Gt().getNormalMatrix(n), h = new Ee(a.normal, 3);
      h.applyNormalMatrix(c), s.setAttribute("normal", h);
    }
    if (a.uvs.forEach(function(c, h) {
      let u = "uv" + (h + 1).toString();
      h === 0 && (u = "uv"), s.setAttribute(u, new Ee(a.uvs[h], 2));
    }), r.material && r.material.mappingType !== "AllSame") {
      let c = a.materialIndex[0], h = 0;
      if (a.materialIndex.forEach(function(u, d) {
        u !== c && (s.addGroup(h, d - h, c), c = u, h = d);
      }), s.groups.length > 0) {
        const u = s.groups[s.groups.length - 1], d = u.start + u.count;
        d !== a.materialIndex.length && s.addGroup(d, a.materialIndex.length - d, c);
      }
      s.groups.length === 0 && s.addGroup(0, a.materialIndex.length, a.materialIndex[0]);
    }
    return this.addMorphTargets(s, e, i, n), s;
  }
  parseGeoNode(e, t) {
    const i = {};
    if (i.vertexPositions = e.Vertices !== void 0 ? e.Vertices.a : [], i.vertexIndices = e.PolygonVertexIndex !== void 0 ? e.PolygonVertexIndex.a : [], e.LayerElementColor && (i.color = this.parseVertexColors(e.LayerElementColor[0])), e.LayerElementMaterial && (i.material = this.parseMaterialIndices(e.LayerElementMaterial[0])), e.LayerElementNormal && (i.normal = this.parseNormals(e.LayerElementNormal[0])), e.LayerElementUV) {
      i.uv = [];
      let n = 0;
      for (; e.LayerElementUV[n]; )
        e.LayerElementUV[n].UV && i.uv.push(this.parseUVs(e.LayerElementUV[n])), n++;
    }
    return i.weightTable = {}, t !== null && (i.skeleton = t, t.rawBones.forEach(function(n, s) {
      n.indices.forEach(function(r, a) {
        i.weightTable[r] === void 0 && (i.weightTable[r] = []), i.weightTable[r].push({
          id: s,
          weight: n.weights[a]
        });
      });
    })), i;
  }
  genBuffers(e) {
    const t = {
      vertex: [],
      normal: [],
      colors: [],
      uvs: [],
      materialIndex: [],
      vertexWeights: [],
      weightsIndices: []
    };
    let i = 0, n = 0, s = !1, r = [], a = [], l = [], c = [], h = [], u = [];
    const d = this;
    return e.vertexIndices.forEach(function(f, m) {
      let _, p = !1;
      f < 0 && (f = f ^ -1, p = !0);
      let g = [], x = [];
      if (r.push(f * 3, f * 3 + 1, f * 3 + 2), e.color) {
        const y = Ea(m, i, f, e.color);
        l.push(y[0], y[1], y[2]);
      }
      if (e.skeleton) {
        if (e.weightTable[f] !== void 0 && e.weightTable[f].forEach(function(y) {
          x.push(y.weight), g.push(y.id);
        }), x.length > 4) {
          s || (console.warn("THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."), s = !0);
          const y = [0, 0, 0, 0], v = [0, 0, 0, 0];
          x.forEach(function(M, S) {
            let A = M, w = g[S];
            v.forEach(function(E, P, z) {
              if (A > E) {
                z[P] = A, A = E;
                const V = y[P];
                y[P] = w, w = V;
              }
            });
          }), g = y, x = v;
        }
        for (; x.length < 4; )
          x.push(0), g.push(0);
        for (let y = 0; y < 4; ++y)
          h.push(x[y]), u.push(g[y]);
      }
      if (e.normal) {
        const y = Ea(m, i, f, e.normal);
        a.push(y[0], y[1], y[2]);
      }
      e.material && e.material.mappingType !== "AllSame" && (_ = Ea(m, i, f, e.material)[0], _ < 0 && (d.negativeMaterialIndices = !0, _ = 0)), e.uv && e.uv.forEach(function(y, v) {
        const M = Ea(m, i, f, y);
        c[v] === void 0 && (c[v] = []), c[v].push(M[0]), c[v].push(M[1]);
      }), n++, p && (n > 4 && console.warn("THREE.FBXLoader: Polygons with more than four sides are not supported. Make sure to triangulate the geometry during export."), d.genFace(t, e, r, _, a, l, c, h, u, n), i++, n = 0, r = [], a = [], l = [], c = [], h = [], u = []);
    }), t;
  }
  // Generate data for a single face in a geometry. If the face is a quad then split it into 2 tris
  genFace(e, t, i, n, s, r, a, l, c, h) {
    for (let u = 2; u < h; u++)
      e.vertex.push(t.vertexPositions[i[0]]), e.vertex.push(t.vertexPositions[i[1]]), e.vertex.push(t.vertexPositions[i[2]]), e.vertex.push(t.vertexPositions[i[(u - 1) * 3]]), e.vertex.push(t.vertexPositions[i[(u - 1) * 3 + 1]]), e.vertex.push(t.vertexPositions[i[(u - 1) * 3 + 2]]), e.vertex.push(t.vertexPositions[i[u * 3]]), e.vertex.push(t.vertexPositions[i[u * 3 + 1]]), e.vertex.push(t.vertexPositions[i[u * 3 + 2]]), t.skeleton && (e.vertexWeights.push(l[0]), e.vertexWeights.push(l[1]), e.vertexWeights.push(l[2]), e.vertexWeights.push(l[3]), e.vertexWeights.push(l[(u - 1) * 4]), e.vertexWeights.push(l[(u - 1) * 4 + 1]), e.vertexWeights.push(l[(u - 1) * 4 + 2]), e.vertexWeights.push(l[(u - 1) * 4 + 3]), e.vertexWeights.push(l[u * 4]), e.vertexWeights.push(l[u * 4 + 1]), e.vertexWeights.push(l[u * 4 + 2]), e.vertexWeights.push(l[u * 4 + 3]), e.weightsIndices.push(c[0]), e.weightsIndices.push(c[1]), e.weightsIndices.push(c[2]), e.weightsIndices.push(c[3]), e.weightsIndices.push(c[(u - 1) * 4]), e.weightsIndices.push(c[(u - 1) * 4 + 1]), e.weightsIndices.push(c[(u - 1) * 4 + 2]), e.weightsIndices.push(c[(u - 1) * 4 + 3]), e.weightsIndices.push(c[u * 4]), e.weightsIndices.push(c[u * 4 + 1]), e.weightsIndices.push(c[u * 4 + 2]), e.weightsIndices.push(c[u * 4 + 3])), t.color && (e.colors.push(r[0]), e.colors.push(r[1]), e.colors.push(r[2]), e.colors.push(r[(u - 1) * 3]), e.colors.push(r[(u - 1) * 3 + 1]), e.colors.push(r[(u - 1) * 3 + 2]), e.colors.push(r[u * 3]), e.colors.push(r[u * 3 + 1]), e.colors.push(r[u * 3 + 2])), t.material && t.material.mappingType !== "AllSame" && (e.materialIndex.push(n), e.materialIndex.push(n), e.materialIndex.push(n)), t.normal && (e.normal.push(s[0]), e.normal.push(s[1]), e.normal.push(s[2]), e.normal.push(s[(u - 1) * 3]), e.normal.push(s[(u - 1) * 3 + 1]), e.normal.push(s[(u - 1) * 3 + 2]), e.normal.push(s[u * 3]), e.normal.push(s[u * 3 + 1]), e.normal.push(s[u * 3 + 2])), t.uv && t.uv.forEach(function(d, f) {
        e.uvs[f] === void 0 && (e.uvs[f] = []), e.uvs[f].push(a[f][0]), e.uvs[f].push(a[f][1]), e.uvs[f].push(a[f][(u - 1) * 2]), e.uvs[f].push(a[f][(u - 1) * 2 + 1]), e.uvs[f].push(a[f][u * 2]), e.uvs[f].push(a[f][u * 2 + 1]);
      });
  }
  addMorphTargets(e, t, i, n) {
    if (i.length === 0) return;
    e.morphTargetsRelative = !0, e.morphAttributes.position = [];
    const s = this;
    i.forEach(function(r) {
      r.rawTargets.forEach(function(a) {
        const l = Ge.Objects.Geometry[a.geoID];
        l !== void 0 && s.genMorphGeometry(e, t, l, n, a.name);
      });
    });
  }
  // a morph geometry node is similar to a standard  node, and the node is also contained
  // in FBXTree.Objects.Geometry, however it can only have attributes for position, normal
  // and a special attribute Index defining which vertices of the original geometry are affected
  // Normal and position attributes only have data for the vertices that are affected by the morph
  genMorphGeometry(e, t, i, n, s) {
    const r = t.PolygonVertexIndex !== void 0 ? t.PolygonVertexIndex.a : [], a = i.Vertices !== void 0 ? i.Vertices.a : [], l = i.Indexes !== void 0 ? i.Indexes.a : [], c = e.attributes.position.count * 3, h = new Float32Array(c);
    for (let m = 0; m < l.length; m++) {
      const _ = l[m] * 3;
      h[_] = a[m * 3], h[_ + 1] = a[m * 3 + 1], h[_ + 2] = a[m * 3 + 2];
    }
    const u = {
      vertexIndices: r,
      vertexPositions: h
    }, d = this.genBuffers(u), f = new Ee(d.vertex, 3);
    f.name = s || i.attrName, f.applyMatrix4(n), e.morphAttributes.position.push(f);
  }
  // Parse normal from FBXTree.Objects.Geometry.LayerElementNormal if it exists
  parseNormals(e) {
    const t = e.MappingInformationType, i = e.ReferenceInformationType, n = e.Normals.a;
    let s = [];
    return i === "IndexToDirect" && ("NormalIndex" in e ? s = e.NormalIndex.a : "NormalsIndex" in e && (s = e.NormalsIndex.a)), {
      dataSize: 3,
      buffer: n,
      indices: s,
      mappingType: t,
      referenceType: i
    };
  }
  // Parse UVs from FBXTree.Objects.Geometry.LayerElementUV if it exists
  parseUVs(e) {
    const t = e.MappingInformationType, i = e.ReferenceInformationType, n = e.UV.a;
    let s = [];
    return i === "IndexToDirect" && (s = e.UVIndex.a), {
      dataSize: 2,
      buffer: n,
      indices: s,
      mappingType: t,
      referenceType: i
    };
  }
  // Parse Vertex Colors from FBXTree.Objects.Geometry.LayerElementColor if it exists
  parseVertexColors(e) {
    const t = e.MappingInformationType, i = e.ReferenceInformationType, n = e.Colors.a;
    let s = [];
    return i === "IndexToDirect" && (s = e.ColorIndex.a), {
      dataSize: 4,
      buffer: n,
      indices: s,
      mappingType: t,
      referenceType: i
    };
  }
  // Parse mapping and material data in FBXTree.Objects.Geometry.LayerElementMaterial if it exists
  parseMaterialIndices(e) {
    const t = e.MappingInformationType, i = e.ReferenceInformationType;
    if (t === "NoMappingInformation")
      return {
        dataSize: 1,
        buffer: [0],
        indices: [0],
        mappingType: "AllSame",
        referenceType: i
      };
    const n = e.Materials.a, s = [];
    for (let r = 0; r < n.length; ++r)
      s.push(r);
    return {
      dataSize: 1,
      buffer: n,
      indices: s,
      mappingType: t,
      referenceType: i
    };
  }
  // Generate a NurbGeometry from a node in FBXTree.Objects.Geometry
  parseNurbsGeometry(e) {
    const t = parseInt(e.Order);
    if (isNaN(t))
      return console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s", e.Order, e.id), new Ue();
    const i = t - 1, n = e.KnotVector.a, s = [], r = e.Points.a;
    for (let u = 0, d = r.length; u < d; u += 4)
      s.push(new We().fromArray(r, u));
    let a, l;
    if (e.Form === "Closed")
      s.push(s[0]);
    else if (e.Form === "Periodic") {
      a = i, l = n.length - 1 - a;
      for (let u = 0; u < i; ++u)
        s.push(s[u]);
    }
    const h = new Qw(i, n, s, a, l).getPoints(s.length * 12);
    return new Ue().setFromPoints(h);
  }
}
class nb {
  // take raw animation clips and turn them into three.js animation clips
  parse() {
    const e = [], t = this.parseClips();
    if (t !== void 0)
      for (const i in t) {
        const n = t[i], s = this.addClip(n);
        e.push(s);
      }
    return e;
  }
  parseClips() {
    if (Ge.Objects.AnimationCurve === void 0) return;
    const e = this.parseAnimationCurveNodes();
    this.parseAnimationCurves(e);
    const t = this.parseAnimationLayers(e);
    return this.parseAnimStacks(t);
  }
  // parse nodes in FBXTree.Objects.AnimationCurveNode
  // each AnimationCurveNode holds data for an animation transform for a model (e.g. left arm rotation )
  // and is referenced by an AnimationLayer
  parseAnimationCurveNodes() {
    const e = Ge.Objects.AnimationCurveNode, t = /* @__PURE__ */ new Map();
    for (const i in e) {
      const n = e[i];
      if (n.attrName.match(/S|R|T|DeformPercent/) !== null) {
        const s = {
          id: n.id,
          attr: n.attrName,
          curves: {}
        };
        t.set(s.id, s);
      }
    }
    return t;
  }
  // parse nodes in FBXTree.Objects.AnimationCurve and connect them up to
  // previously parsed AnimationCurveNodes. Each AnimationCurve holds data for a single animated
  // axis ( e.g. times and values of x rotation)
  parseAnimationCurves(e) {
    const t = Ge.Objects.AnimationCurve;
    for (const i in t) {
      const n = {
        id: t[i].id,
        times: t[i].KeyTime.a.map(lb),
        values: t[i].KeyValueFloat.a
      }, s = ut.get(n.id);
      if (s !== void 0) {
        const r = s.parents[0].ID, a = s.parents[0].relationship;
        a.match(/X/) ? e.get(r).curves.x = n : a.match(/Y/) ? e.get(r).curves.y = n : a.match(/Z/) ? e.get(r).curves.z = n : a.match(/d|DeformPercent/) && e.has(r) && (e.get(r).curves.morph = n);
      }
    }
  }
  // parse nodes in FBXTree.Objects.AnimationLayer. Each layers holds references
  // to various AnimationCurveNodes and is referenced by an AnimationStack node
  // note: theoretically a stack can have multiple layers, however in practice there always seems to be one per stack
  parseAnimationLayers(e) {
    const t = Ge.Objects.AnimationLayer, i = /* @__PURE__ */ new Map();
    for (const n in t) {
      const s = [], r = ut.get(parseInt(n));
      r !== void 0 && (r.children.forEach(function(l, c) {
        if (e.has(l.ID)) {
          const h = e.get(l.ID);
          if (h.curves.x !== void 0 || h.curves.y !== void 0 || h.curves.z !== void 0) {
            if (s[c] === void 0) {
              const u = ut.get(l.ID).parents.filter(function(d) {
                return d.relationship !== void 0;
              })[0].ID;
              if (u !== void 0) {
                const d = Ge.Objects.Model[u.toString()];
                if (d === void 0) {
                  console.warn("THREE.FBXLoader: Encountered a unused curve.", l);
                  return;
                }
                const f = {
                  modelName: d.attrName ? Je.sanitizeNodeName(d.attrName) : "",
                  ID: d.id,
                  initialPosition: [0, 0, 0],
                  initialRotation: [0, 0, 0],
                  initialScale: [1, 1, 1]
                };
                Xt.traverse(function(m) {
                  m.ID === d.id && (f.transform = m.matrix, m.userData.transformData && (f.eulerOrder = m.userData.transformData.eulerOrder));
                }), f.transform || (f.transform = new ue()), "PreRotation" in d && (f.preRotation = d.PreRotation.value), "PostRotation" in d && (f.postRotation = d.PostRotation.value), s[c] = f;
              }
            }
            s[c] && (s[c][h.attr] = h);
          } else if (h.curves.morph !== void 0) {
            if (s[c] === void 0) {
              const u = ut.get(l.ID).parents.filter(function(g) {
                return g.relationship !== void 0;
              })[0].ID, d = ut.get(u).parents[0].ID, f = ut.get(d).parents[0].ID, m = ut.get(f).parents[0].ID, _ = Ge.Objects.Model[m], p = {
                modelName: _.attrName ? Je.sanitizeNodeName(_.attrName) : "",
                morphName: Ge.Objects.Deformer[u].attrName
              };
              s[c] = p;
            }
            s[c][h.attr] = h;
          }
        }
      }), i.set(parseInt(n), s));
    }
    return i;
  }
  // parse nodes in FBXTree.Objects.AnimationStack. These are the top level node in the animation
  // hierarchy. Each Stack node will be used to create a AnimationClip
  parseAnimStacks(e) {
    const t = Ge.Objects.AnimationStack, i = {};
    for (const n in t) {
      const s = ut.get(parseInt(n)).children;
      s.length > 1 && console.warn("THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.");
      const r = e.get(s[0].ID);
      i[n] = {
        name: t[n].attrName,
        layer: r
      };
    }
    return i;
  }
  addClip(e) {
    let t = [];
    const i = this;
    return e.layer.forEach(function(n) {
      t = t.concat(i.generateTracks(n));
    }), new Is(e.name, -1, t);
  }
  generateTracks(e) {
    const t = [];
    let i = new b(), n = new Et(), s = new b();
    if (e.transform && e.transform.decompose(i, n, s), i = i.toArray(), n = new Kt().setFromQuaternion(n, e.eulerOrder).toArray(), s = s.toArray(), e.T !== void 0 && Object.keys(e.T.curves).length > 0) {
      const r = this.generateVectorTrack(e.modelName, e.T.curves, i, "position");
      r !== void 0 && t.push(r);
    }
    if (e.R !== void 0 && Object.keys(e.R.curves).length > 0) {
      const r = this.generateRotationTrack(e.modelName, e.R.curves, n, e.preRotation, e.postRotation, e.eulerOrder);
      r !== void 0 && t.push(r);
    }
    if (e.S !== void 0 && Object.keys(e.S.curves).length > 0) {
      const r = this.generateVectorTrack(e.modelName, e.S.curves, s, "scale");
      r !== void 0 && t.push(r);
    }
    if (e.DeformPercent !== void 0) {
      const r = this.generateMorphTrack(e);
      r !== void 0 && t.push(r);
    }
    return t;
  }
  generateVectorTrack(e, t, i, n) {
    const s = this.getTimesForAllAxes(t), r = this.getKeyframeTrackValues(s, t, i);
    return new Rs(e + "." + n, s, r);
  }
  generateRotationTrack(e, t, i, n, s, r) {
    t.x !== void 0 && (this.interpolateRotations(t.x), t.x.values = t.x.values.map(Rt.degToRad)), t.y !== void 0 && (this.interpolateRotations(t.y), t.y.values = t.y.values.map(Rt.degToRad)), t.z !== void 0 && (this.interpolateRotations(t.z), t.z.values = t.z.values.map(Rt.degToRad));
    const a = this.getTimesForAllAxes(t), l = this.getKeyframeTrackValues(a, t, i);
    n !== void 0 && (n = n.map(Rt.degToRad), n.push(r), n = new Kt().fromArray(n), n = new Et().setFromEuler(n)), s !== void 0 && (s = s.map(Rt.degToRad), s.push(r), s = new Kt().fromArray(s), s = new Et().setFromEuler(s).invert());
    const c = new Et(), h = new Kt(), u = [];
    for (let d = 0; d < l.length; d += 3)
      h.set(l[d], l[d + 1], l[d + 2], r), c.setFromEuler(h), n !== void 0 && c.premultiply(n), s !== void 0 && c.multiply(s), c.toArray(u, d / 3 * 4);
    return new _n(e + ".quaternion", a, u);
  }
  generateMorphTrack(e) {
    const t = e.DeformPercent.curves.morph, i = t.values.map(function(s) {
      return s / 100;
    }), n = Xt.getObjectByName(e.modelName).morphTargetDictionary[e.morphName];
    return new Ps(e.modelName + ".morphTargetInfluences[" + n + "]", t.times, i);
  }
  // For all animated objects, times are defined separately for each axis
  // Here we'll combine the times into one sorted array without duplicates
  getTimesForAllAxes(e) {
    let t = [];
    if (e.x !== void 0 && (t = t.concat(e.x.times)), e.y !== void 0 && (t = t.concat(e.y.times)), e.z !== void 0 && (t = t.concat(e.z.times)), t = t.sort(function(i, n) {
      return i - n;
    }), t.length > 1) {
      let i = 1, n = t[0];
      for (let s = 1; s < t.length; s++) {
        const r = t[s];
        r !== n && (t[i] = r, n = r, i++);
      }
      t = t.slice(0, i);
    }
    return t;
  }
  getKeyframeTrackValues(e, t, i) {
    const n = i, s = [];
    let r = -1, a = -1, l = -1;
    return e.forEach(function(c) {
      if (t.x && (r = t.x.times.indexOf(c)), t.y && (a = t.y.times.indexOf(c)), t.z && (l = t.z.times.indexOf(c)), r !== -1) {
        const h = t.x.values[r];
        s.push(h), n[0] = h;
      } else
        s.push(n[0]);
      if (a !== -1) {
        const h = t.y.values[a];
        s.push(h), n[1] = h;
      } else
        s.push(n[1]);
      if (l !== -1) {
        const h = t.z.values[l];
        s.push(h), n[2] = h;
      } else
        s.push(n[2]);
    }), s;
  }
  // Rotations are defined as Euler angles which can have values  of any size
  // These will be converted to quaternions which don't support values greater than
  // PI, so we'll interpolate large rotations
  interpolateRotations(e) {
    for (let t = 1; t < e.values.length; t++) {
      const i = e.values[t - 1], n = e.values[t] - i, s = Math.abs(n);
      if (s >= 180) {
        const r = s / 180, a = n / r;
        let l = i + a;
        const c = e.times[t - 1], u = (e.times[t] - c) / r;
        let d = c + u;
        const f = [], m = [];
        for (; d < e.times[t]; )
          f.push(d), d += u, m.push(l), l += a;
        e.times = ju(e.times, t, f), e.values = ju(e.values, t, m);
      }
    }
  }
}
class sb {
  getPrevNode() {
    return this.nodeStack[this.currentIndent - 2];
  }
  getCurrentNode() {
    return this.nodeStack[this.currentIndent - 1];
  }
  getCurrentProp() {
    return this.currentProp;
  }
  pushStack(e) {
    this.nodeStack.push(e), this.currentIndent += 1;
  }
  popStack() {
    this.nodeStack.pop(), this.currentIndent -= 1;
  }
  setCurrentProp(e, t) {
    this.currentProp = e, this.currentPropName = t;
  }
  parse(e) {
    this.currentIndent = 0, this.allNodes = new wf(), this.nodeStack = [], this.currentProp = [], this.currentPropName = "";
    const t = this, i = e.split(/[\r\n]+/);
    return i.forEach(function(n, s) {
      const r = n.match(/^[\s\t]*;/), a = n.match(/^[\s\t]*$/);
      if (r || a) return;
      const l = n.match("^\\t{" + t.currentIndent + "}(\\w+):(.*){", ""), c = n.match("^\\t{" + t.currentIndent + "}(\\w+):[\\s\\t\\r\\n](.*)"), h = n.match("^\\t{" + (t.currentIndent - 1) + "}}");
      l ? t.parseNodeBegin(n, l) : c ? t.parseNodeProperty(n, c, i[++s]) : h ? t.popStack() : n.match(/^[^\s\t}]/) && t.parseNodePropertyContinued(n);
    }), this.allNodes;
  }
  parseNodeBegin(e, t) {
    const i = t[1].trim().replace(/^"/, "").replace(/"$/, ""), n = t[2].split(",").map(function(l) {
      return l.trim().replace(/^"/, "").replace(/"$/, "");
    }), s = { name: i }, r = this.parseNodeAttr(n), a = this.getCurrentNode();
    this.currentIndent === 0 ? this.allNodes.add(i, s) : i in a ? (i === "PoseNode" ? a.PoseNode.push(s) : a[i].id !== void 0 && (a[i] = {}, a[i][a[i].id] = a[i]), r.id !== "" && (a[i][r.id] = s)) : typeof r.id == "number" ? (a[i] = {}, a[i][r.id] = s) : i !== "Properties70" && (i === "PoseNode" ? a[i] = [s] : a[i] = s), typeof r.id == "number" && (s.id = r.id), r.name !== "" && (s.attrName = r.name), r.type !== "" && (s.attrType = r.type), this.pushStack(s);
  }
  parseNodeAttr(e) {
    let t = e[0];
    e[0] !== "" && (t = parseInt(e[0]), isNaN(t) && (t = e[0]));
    let i = "", n = "";
    return e.length > 1 && (i = e[1].replace(/^(\w+)::/, ""), n = e[2]), { id: t, name: i, type: n };
  }
  parseNodeProperty(e, t, i) {
    let n = t[1].replace(/^"/, "").replace(/"$/, "").trim(), s = t[2].replace(/^"/, "").replace(/"$/, "").trim();
    n === "Content" && s === "," && (s = i.replace(/"/g, "").replace(/,$/, "").trim());
    const r = this.getCurrentNode();
    if (r.name === "Properties70") {
      this.parseNodeSpecialProperty(e, n, s);
      return;
    }
    if (n === "C") {
      const l = s.split(",").slice(1), c = parseInt(l[0]), h = parseInt(l[1]);
      let u = s.split(",").slice(3);
      u = u.map(function(d) {
        return d.trim().replace(/^"/, "");
      }), n = "connections", s = [c, h], hb(s, u), r[n] === void 0 && (r[n] = []);
    }
    n === "Node" && (r.id = s), n in r && Array.isArray(r[n]) ? r[n].push(s) : n !== "a" ? r[n] = s : r.a = s, this.setCurrentProp(r, n), n === "a" && s.slice(-1) !== "," && (r.a = hl(s));
  }
  parseNodePropertyContinued(e) {
    const t = this.getCurrentNode();
    t.a += e, e.slice(-1) !== "," && (t.a = hl(t.a));
  }
  // parse "Property70"
  parseNodeSpecialProperty(e, t, i) {
    const n = i.split('",').map(function(h) {
      return h.trim().replace(/^\"/, "").replace(/\s/, "_");
    }), s = n[0], r = n[1], a = n[2], l = n[3];
    let c = n[4];
    switch (r) {
      case "int":
      case "enum":
      case "bool":
      case "ULongLong":
      case "double":
      case "Number":
      case "FieldOfView":
        c = parseFloat(c);
        break;
      case "Color":
      case "ColorRGB":
      case "Vector3D":
      case "Lcl_Translation":
      case "Lcl_Rotation":
      case "Lcl_Scaling":
        c = hl(c);
        break;
    }
    this.getPrevNode()[s] = {
      type: r,
      type2: a,
      flag: l,
      value: c
    }, this.setCurrentProp(this.getPrevNode(), s);
  }
}
class rb {
  parse(e) {
    const t = new Xu(e);
    t.skip(23);
    const i = t.getUint32();
    if (i < 6400)
      throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + i);
    const n = new wf();
    for (; !this.endOfContent(t); ) {
      const s = this.parseNode(t, i);
      s !== null && n.add(s.name, s);
    }
    return n;
  }
  // Check if reader has reached the end of content.
  endOfContent(e) {
    return e.size() % 16 === 0 ? (e.getOffset() + 160 + 16 & -16) >= e.size() : e.getOffset() + 160 + 16 >= e.size();
  }
  // recursively parse nodes until the end of the file is reached
  parseNode(e, t) {
    const i = {}, n = t >= 7500 ? e.getUint64() : e.getUint32(), s = t >= 7500 ? e.getUint64() : e.getUint32();
    t >= 7500 ? e.getUint64() : e.getUint32();
    const r = e.getUint8(), a = e.getString(r);
    if (n === 0) return null;
    const l = [];
    for (let d = 0; d < s; d++)
      l.push(this.parseProperty(e));
    const c = l.length > 0 ? l[0] : "", h = l.length > 1 ? l[1] : "", u = l.length > 2 ? l[2] : "";
    for (i.singleProperty = s === 1 && e.getOffset() === n; n > e.getOffset(); ) {
      const d = this.parseNode(e, t);
      d !== null && this.parseSubNode(a, i, d);
    }
    return i.propertyList = l, typeof c == "number" && (i.id = c), h !== "" && (i.attrName = h), u !== "" && (i.attrType = u), a !== "" && (i.name = a), i;
  }
  parseSubNode(e, t, i) {
    if (i.singleProperty === !0) {
      const n = i.propertyList[0];
      Array.isArray(n) ? (t[i.name] = i, i.a = n) : t[i.name] = n;
    } else if (e === "Connections" && i.name === "C") {
      const n = [];
      i.propertyList.forEach(function(s, r) {
        r !== 0 && n.push(s);
      }), t.connections === void 0 && (t.connections = []), t.connections.push(n);
    } else if (i.name === "Properties70")
      Object.keys(i).forEach(function(s) {
        t[s] = i[s];
      });
    else if (e === "Properties70" && i.name === "P") {
      let n = i.propertyList[0], s = i.propertyList[1];
      const r = i.propertyList[2], a = i.propertyList[3];
      let l;
      n.indexOf("Lcl ") === 0 && (n = n.replace("Lcl ", "Lcl_")), s.indexOf("Lcl ") === 0 && (s = s.replace("Lcl ", "Lcl_")), s === "Color" || s === "ColorRGB" || s === "Vector" || s === "Vector3D" || s.indexOf("Lcl_") === 0 ? l = [
        i.propertyList[4],
        i.propertyList[5],
        i.propertyList[6]
      ] : l = i.propertyList[4], t[n] = {
        type: s,
        type2: r,
        flag: a,
        value: l
      };
    } else t[i.name] === void 0 ? typeof i.id == "number" ? (t[i.name] = {}, t[i.name][i.id] = i) : t[i.name] = i : i.name === "PoseNode" ? (Array.isArray(t[i.name]) || (t[i.name] = [t[i.name]]), t[i.name].push(i)) : t[i.name][i.id] === void 0 && (t[i.name][i.id] = i);
  }
  parseProperty(e) {
    const t = e.getString(1);
    let i;
    switch (t) {
      case "C":
        return e.getBoolean();
      case "D":
        return e.getFloat64();
      case "F":
        return e.getFloat32();
      case "I":
        return e.getInt32();
      case "L":
        return e.getInt64();
      case "R":
        return i = e.getUint32(), e.getArrayBuffer(i);
      case "S":
        return i = e.getUint32(), e.getString(i);
      case "Y":
        return e.getInt16();
      case "b":
      case "c":
      case "d":
      case "f":
      case "i":
      case "l":
        const n = e.getUint32(), s = e.getUint32(), r = e.getUint32();
        if (s === 0)
          switch (t) {
            case "b":
            case "c":
              return e.getBooleanArray(n);
            case "d":
              return e.getFloat64Array(n);
            case "f":
              return e.getFloat32Array(n);
            case "i":
              return e.getInt32Array(n);
            case "l":
              return e.getInt64Array(n);
          }
        const a = Hw(new Uint8Array(e.getArrayBuffer(r))), l = new Xu(a.buffer);
        switch (t) {
          case "b":
          case "c":
            return l.getBooleanArray(n);
          case "d":
            return l.getFloat64Array(n);
          case "f":
            return l.getFloat32Array(n);
          case "i":
            return l.getInt32Array(n);
          case "l":
            return l.getInt64Array(n);
        }
        break;
      default:
        throw new Error("THREE.FBXLoader: Unknown property type " + t);
    }
  }
}
class Xu {
  constructor(e, t) {
    this.dv = new DataView(e), this.offset = 0, this.littleEndian = t !== void 0 ? t : !0;
  }
  getOffset() {
    return this.offset;
  }
  size() {
    return this.dv.buffer.byteLength;
  }
  skip(e) {
    this.offset += e;
  }
  // seems like true/false representation depends on exporter.
  // true: 1 or 'Y'(=0x59), false: 0 or 'T'(=0x54)
  // then sees LSB.
  getBoolean() {
    return (this.getUint8() & 1) === 1;
  }
  getBooleanArray(e) {
    const t = [];
    for (let i = 0; i < e; i++)
      t.push(this.getBoolean());
    return t;
  }
  getUint8() {
    const e = this.dv.getUint8(this.offset);
    return this.offset += 1, e;
  }
  getInt16() {
    const e = this.dv.getInt16(this.offset, this.littleEndian);
    return this.offset += 2, e;
  }
  getInt32() {
    const e = this.dv.getInt32(this.offset, this.littleEndian);
    return this.offset += 4, e;
  }
  getInt32Array(e) {
    const t = [];
    for (let i = 0; i < e; i++)
      t.push(this.getInt32());
    return t;
  }
  getUint32() {
    const e = this.dv.getUint32(this.offset, this.littleEndian);
    return this.offset += 4, e;
  }
  // JavaScript doesn't support 64-bit integer so calculate this here
  // 1 << 32 will return 1 so using multiply operation instead here.
  // There's a possibility that this method returns wrong value if the value
  // is out of the range between Number.MAX_SAFE_INTEGER and Number.MIN_SAFE_INTEGER.
  // TODO: safely handle 64-bit integer
  getInt64() {
    let e, t;
    return this.littleEndian ? (e = this.getUint32(), t = this.getUint32()) : (t = this.getUint32(), e = this.getUint32()), t & 2147483648 ? (t = ~t & 4294967295, e = ~e & 4294967295, e === 4294967295 && (t = t + 1 & 4294967295), e = e + 1 & 4294967295, -(t * 4294967296 + e)) : t * 4294967296 + e;
  }
  getInt64Array(e) {
    const t = [];
    for (let i = 0; i < e; i++)
      t.push(this.getInt64());
    return t;
  }
  // Note: see getInt64() comment
  getUint64() {
    let e, t;
    return this.littleEndian ? (e = this.getUint32(), t = this.getUint32()) : (t = this.getUint32(), e = this.getUint32()), t * 4294967296 + e;
  }
  getFloat32() {
    const e = this.dv.getFloat32(this.offset, this.littleEndian);
    return this.offset += 4, e;
  }
  getFloat32Array(e) {
    const t = [];
    for (let i = 0; i < e; i++)
      t.push(this.getFloat32());
    return t;
  }
  getFloat64() {
    const e = this.dv.getFloat64(this.offset, this.littleEndian);
    return this.offset += 8, e;
  }
  getFloat64Array(e) {
    const t = [];
    for (let i = 0; i < e; i++)
      t.push(this.getFloat64());
    return t;
  }
  getArrayBuffer(e) {
    const t = this.dv.buffer.slice(this.offset, this.offset + e);
    return this.offset += e, t;
  }
  getString(e) {
    let t = [];
    for (let n = 0; n < e; n++)
      t[n] = this.getUint8();
    const i = t.indexOf(0);
    return i >= 0 && (t = t.slice(0, i)), ci.decodeText(new Uint8Array(t));
  }
}
class wf {
  add(e, t) {
    this[e] = t;
  }
}
function ab(o) {
  const e = "Kaydara FBX Binary  \0";
  return o.byteLength >= e.length && e === Sf(o, 0, e.length);
}
function ob(o) {
  const e = ["K", "a", "y", "d", "a", "r", "a", "\\", "F", "B", "X", "\\", "B", "i", "n", "a", "r", "y", "\\", "\\"];
  let t = 0;
  function i(n) {
    const s = o[n - 1];
    return o = o.slice(t + n), t++, s;
  }
  for (let n = 0; n < e.length; ++n)
    if (i(1) === e[n])
      return !1;
  return !0;
}
function qu(o) {
  const e = /FBXVersion: (\d+)/, t = o.match(e);
  if (t)
    return parseInt(t[1]);
  throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.");
}
function lb(o) {
  return o / 46186158e3;
}
const cb = [];
function Ea(o, e, t, i) {
  let n;
  switch (i.mappingType) {
    case "ByPolygonVertex":
      n = o;
      break;
    case "ByPolygon":
      n = e;
      break;
    case "ByVertice":
      n = t;
      break;
    case "AllSame":
      n = i.indices[0];
      break;
    default:
      console.warn("THREE.FBXLoader: unknown attribute mapping type " + i.mappingType);
  }
  i.referenceType === "IndexToDirect" && (n = i.indices[n]);
  const s = n * i.dataSize, r = s + i.dataSize;
  return ub(cb, i.buffer, s, r);
}
const cl = new Kt(), fs = new b();
function bf(o) {
  const e = new ue(), t = new ue(), i = new ue(), n = new ue(), s = new ue(), r = new ue(), a = new ue(), l = new ue(), c = new ue(), h = new ue(), u = new ue(), d = new ue(), f = o.inheritType ? o.inheritType : 0;
  if (o.translation && e.setPosition(fs.fromArray(o.translation)), o.preRotation) {
    const P = o.preRotation.map(Rt.degToRad);
    P.push(o.eulerOrder || Kt.DefaultOrder), t.makeRotationFromEuler(cl.fromArray(P));
  }
  if (o.rotation) {
    const P = o.rotation.map(Rt.degToRad);
    P.push(o.eulerOrder || Kt.DefaultOrder), i.makeRotationFromEuler(cl.fromArray(P));
  }
  if (o.postRotation) {
    const P = o.postRotation.map(Rt.degToRad);
    P.push(o.eulerOrder || Kt.DefaultOrder), n.makeRotationFromEuler(cl.fromArray(P)), n.invert();
  }
  o.scale && s.scale(fs.fromArray(o.scale)), o.scalingOffset && a.setPosition(fs.fromArray(o.scalingOffset)), o.scalingPivot && r.setPosition(fs.fromArray(o.scalingPivot)), o.rotationOffset && l.setPosition(fs.fromArray(o.rotationOffset)), o.rotationPivot && c.setPosition(fs.fromArray(o.rotationPivot)), o.parentMatrixWorld && (u.copy(o.parentMatrix), h.copy(o.parentMatrixWorld));
  const m = t.clone().multiply(i).multiply(n), _ = new ue();
  _.extractRotation(h);
  const p = new ue();
  p.copyPosition(h);
  const g = p.clone().invert().multiply(h), x = _.clone().invert().multiply(g), y = s, v = new ue();
  if (f === 0)
    v.copy(_).multiply(m).multiply(x).multiply(y);
  else if (f === 1)
    v.copy(_).multiply(x).multiply(m).multiply(y);
  else {
    const z = new ue().scale(new b().setFromMatrixScale(u)).clone().invert(), V = x.clone().multiply(z);
    v.copy(_).multiply(m).multiply(V).multiply(y);
  }
  const M = c.clone().invert(), S = r.clone().invert();
  let A = e.clone().multiply(l).multiply(c).multiply(t).multiply(i).multiply(n).multiply(M).multiply(a).multiply(r).multiply(s).multiply(S);
  const w = new ue().copyPosition(A), E = h.clone().multiply(w);
  return d.copyPosition(E), A = d.clone().multiply(v), A.premultiply(h.invert()), A;
}
function Mf(o) {
  o = o || 0;
  const e = [
    "ZYX",
    // -> XYZ extrinsic
    "YZX",
    // -> XZY extrinsic
    "XZY",
    // -> YZX extrinsic
    "ZXY",
    // -> YXZ extrinsic
    "YXZ",
    // -> ZXY extrinsic
    "XYZ"
    // -> ZYX extrinsic
    //'SphericXYZ', // not possible to support
  ];
  return o === 6 ? (console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect."), e[0]) : e[o];
}
function hl(o) {
  return o.split(",").map(function(t) {
    return parseFloat(t);
  });
}
function Sf(o, e, t) {
  return e === void 0 && (e = 0), t === void 0 && (t = o.byteLength), ci.decodeText(new Uint8Array(o, e, t));
}
function hb(o, e) {
  for (let t = 0, i = o.length, n = e.length; t < n; t++, i++)
    o[i] = e[t];
}
function ub(o, e, t, i) {
  for (let n = t, s = 0; n < i; n++, s++)
    o[s] = e[n];
  return o;
}
function ju(o, e, t) {
  return o.slice(0, e).concat(t).concat(o.slice(e));
}
class db extends eb {
  constructor(e) {
    super(e);
  }
  addClip(e) {
    let t = [];
    const i = this;
    return e.layer.forEach(function(n) {
      t = t.concat(i.generateTracks(n));
    }), t.forEach(function(n) {
      n.times = n.times.map((s) => s - n.times[0]);
    }), new Is(e.name, -1, t);
  }
}
const fb = !1, pb = "map_small", mb = 2, _b = !1, gb = 2, vb = 0, yb = 0, xb = 0.7, wb = 1e5, bb = 500, Mb = 16777215, Sb = 0.2, Tb = 16777215, Ab = 16711680, Eb = 16763904, Cb = 100, Lb = 2, Pb = !1, Rb = !0, Ib = 1, Db = 1, Ob = 1, Nb = 1, kb = 10, zb = 20, Fb = 1.8, Bb = 10, Ub = 3, Vb = 1e3, sr = 1, Gb = 1, Hb = 1, Wb = 5, Xb = 10, Yu = new Ht(), Ca = new b();
class Ac extends Gd {
  constructor() {
    super(), this.type = "LineSegmentsGeometry";
    const e = [-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0], t = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2], i = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5];
    this.setIndex(i), this.setAttribute("position", new Ee(e, 3)), this.setAttribute("uv", new Ee(t, 2));
  }
  applyMatrix4(e) {
    const t = this.attributes.instanceStart, i = this.attributes.instanceEnd;
    return t !== void 0 && (t.applyMatrix4(e), i.applyMatrix4(e), t.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  setPositions(e) {
    let t;
    e instanceof Float32Array ? t = e : Array.isArray(e) && (t = new Float32Array(e));
    const i = new Sl(t, 6, 1);
    return this.setAttribute("instanceStart", new $t(i, 3, 0)), this.setAttribute("instanceEnd", new $t(i, 3, 3)), this.computeBoundingBox(), this.computeBoundingSphere(), this;
  }
  setColors(e) {
    let t;
    e instanceof Float32Array ? t = e : Array.isArray(e) && (t = new Float32Array(e));
    const i = new Sl(t, 6, 1);
    return this.setAttribute("instanceColorStart", new $t(i, 3, 0)), this.setAttribute("instanceColorEnd", new $t(i, 3, 3)), this;
  }
  fromWireframeGeometry(e) {
    return this.setPositions(e.attributes.position.array), this;
  }
  fromEdgesGeometry(e) {
    return this.setPositions(e.attributes.position.array), this;
  }
  fromMesh(e) {
    return this.fromWireframeGeometry(new Nd(e.geometry)), this;
  }
  fromLineSegments(e) {
    const t = e.geometry;
    if (t.isGeometry) {
      console.error("THREE.LineSegmentsGeometry no longer supports Geometry. Use THREE.BufferGeometry instead.");
      return;
    } else t.isBufferGeometry && this.setPositions(t.attributes.position.array);
    return this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new Ht());
    const e = this.attributes.instanceStart, t = this.attributes.instanceEnd;
    e !== void 0 && t !== void 0 && (this.boundingBox.setFromBufferAttribute(e), Yu.setFromBufferAttribute(t), this.boundingBox.union(Yu));
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new Ci()), this.boundingBox === null && this.computeBoundingBox();
    const e = this.attributes.instanceStart, t = this.attributes.instanceEnd;
    if (e !== void 0 && t !== void 0) {
      const i = this.boundingSphere.center;
      this.boundingBox.getCenter(i);
      let n = 0;
      for (let s = 0, r = e.count; s < r; s++)
        Ca.fromBufferAttribute(e, s), n = Math.max(n, i.distanceToSquared(Ca)), Ca.fromBufferAttribute(t, s), n = Math.max(n, i.distanceToSquared(Ca));
      this.boundingSphere.radius = Math.sqrt(n), isNaN(this.boundingSphere.radius) && console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.", this);
    }
  }
  toJSON() {
  }
  applyMatrix(e) {
    return console.warn("THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4()."), this.applyMatrix4(e);
  }
}
Ac.prototype.isLineSegmentsGeometry = !0;
class ja extends Ac {
  constructor() {
    super(), this.type = "LineGeometry";
  }
  setPositions(e) {
    for (var t = [], i = 0; i < e.length; i++) {
      for (var n = e[i].length - 3, s = [], r = 0; r < n; r += 3)
        s[2 * r] = e[i][r], s[2 * r + 1] = e[i][r + 1], s[2 * r + 2] = e[i][r + 2], s[2 * r + 3] = e[i][r + 3], s[2 * r + 4] = e[i][r + 4], s[2 * r + 5] = e[i][r + 5];
      for (const a of s)
        t.push(a);
    }
    return super.setPositions(new Float32Array(t)), this;
  }
  setColors(e) {
    for (var t = [], i = 0; i < e.length; i++) {
      for (var n = e[i].length - 3, s = [], r = 0; r < n; r += 3)
        s[2 * r] = e[i][r], s[2 * r + 1] = e[i][r + 1], s[2 * r + 2] = e[i][r + 2], s[2 * r + 3] = e[i][r + 3], s[2 * r + 4] = e[i][r + 4], s[2 * r + 5] = e[i][r + 5];
      for (const a of s)
        t.push(a);
    }
    return super.setColors(new Float32Array(t)), this;
  }
  fromLine(e) {
    var t = e.geometry;
    if (t.isGeometry) {
      console.error("THREE.LineGeometry no longer supports Geometry. Use THREE.BufferGeometry instead.");
      return;
    } else t.isBufferGeometry && this.setPositions(t.attributes.position.array);
    return this;
  }
}
ja.prototype.isLineGeometry = !0;
he.line = {
  linewidth: { value: 1 },
  resolution: { value: new G(1, 1) },
  dashScale: { value: 1 },
  dashSize: { value: 1 },
  dashOffset: { value: 0 },
  gapSize: { value: 1 },
  // todo FIX - maybe change to totalSize
  opacity: { value: 1 }
};
qt.line = {
  uniforms: Lr.merge([
    he.common,
    he.fog,
    he.line
  ]),
  vertexShader: `
		#include <common>
		#include <color_pars_vertex>
		#include <fog_pars_vertex>
		#include <logdepthbuf_pars_vertex>
		#include <clipping_planes_pars_vertex>

		uniform float linewidth;
		uniform vec2 resolution;

		attribute vec3 instanceStart;
		attribute vec3 instanceEnd;

		attribute vec3 instanceColorStart;
		attribute vec3 instanceColorEnd;

		varying vec2 vUv;

		#ifdef USE_DASH

			uniform float dashScale;
			attribute float instanceDistanceStart;
			attribute float instanceDistanceEnd;
			varying float vLineDistance;

		#endif

		void trimSegment( const in vec4 start, inout vec4 end ) {

			// trim end segment so it terminates between the camera plane and the near plane

			// conservative estimate of the near plane
			float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
			float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
			float nearEstimate = - 0.5 * b / a;

			float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );

			end.xyz = mix( start.xyz, end.xyz, alpha );

		}

		void main() {

			#ifdef USE_COLOR

				vColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;

			#endif

			#ifdef USE_DASH

				vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;

			#endif

			float aspect = resolution.x / resolution.y;

			vUv = uv;

			// camera space
			vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );
			vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );

			// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
			// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
			// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
			// perhaps there is a more elegant solution -- WestLangley

			bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column

			if ( perspective ) {

				if ( start.z < 0.0 && end.z >= 0.0 ) {

					trimSegment( start, end );

				} else if ( end.z < 0.0 && start.z >= 0.0 ) {

					trimSegment( end, start );

				}

			}

			// clip space
			vec4 clipStart = projectionMatrix * start;
			vec4 clipEnd = projectionMatrix * end;

			// ndc space
			vec2 ndcStart = clipStart.xy / clipStart.w;
			vec2 ndcEnd = clipEnd.xy / clipEnd.w;

			// direction
			vec2 dir = ndcEnd - ndcStart;

			// account for clip-space aspect ratio
			dir.x *= aspect;
			dir = normalize( dir );

			// perpendicular to dir
			vec2 offset = vec2( dir.y, - dir.x );

			// undo aspect ratio adjustment
			dir.x /= aspect;
			offset.x /= aspect;

			// sign flip
			if ( position.x < 0.0 ) offset *= - 1.0;

			// endcaps
			if ( position.y < 0.0 ) {

				offset += - dir;

			} else if ( position.y > 1.0 ) {

				offset += dir;

			}

			// adjust for linewidth
			offset *= linewidth;

			// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
			offset /= resolution.y;

			// select end
			vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;

			// back to clip space
			offset *= clip.w;

			clip.xy += offset;

			gl_Position = clip;

			vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation

			#include <logdepthbuf_vertex>
			#include <clipping_planes_vertex>
			#include <fog_vertex>

		}
		`,
  fragmentShader: `
		uniform vec3 diffuse;
		uniform float opacity;

		#ifdef USE_DASH

			uniform float dashSize;
			uniform float dashOffset;
			uniform float gapSize;

		#endif

		varying float vLineDistance;

		#include <common>
		#include <color_pars_fragment>
		#include <fog_pars_fragment>
		#include <logdepthbuf_pars_fragment>
		#include <clipping_planes_pars_fragment>

		varying vec2 vUv;

		void main() {

			#include <clipping_planes_fragment>

			#ifdef USE_DASH

				if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps

				if ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX

			#endif

			float alpha = opacity;

			#ifdef ALPHA_TO_COVERAGE

			// artifacts appear on some hardware if a derivative is taken within a conditional
			float a = vUv.x;
			float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
			float len2 = a * a + b * b;
			float dlen = fwidth( len2 );

			if ( abs( vUv.y ) > 1.0 ) {

				alpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );

			}

			#else

			if ( abs( vUv.y ) > 1.0 ) {

				float a = vUv.x;
				float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
				float len2 = a * a + b * b;

				if ( len2 > 1.0 ) discard;

			}

			#endif

			vec4 diffuseColor = vec4( diffuse, alpha );

			#include <logdepthbuf_fragment>
			#include <color_fragment>

			gl_FragColor = vec4( diffuseColor.rgb, alpha );

			#include <tonemapping_fragment>
			#include <encodings_fragment>
			#include <fog_fragment>
			#include <premultiplied_alpha_fragment>

		}
		`
};
class As extends xt {
  constructor(e) {
    super({
      type: "LineMaterial",
      uniforms: Lr.clone(qt.line.uniforms),
      vertexShader: qt.line.vertexShader,
      fragmentShader: qt.line.fragmentShader,
      clipping: !0
      // required for clipping support
    }), Object.defineProperties(this, {
      color: {
        enumerable: !0,
        get: function() {
          return this.uniforms.diffuse.value;
        },
        set: function(t) {
          this.uniforms.diffuse.value = t;
        }
      },
      linewidth: {
        enumerable: !0,
        get: function() {
          return this.uniforms.linewidth.value;
        },
        set: function(t) {
          this.uniforms.linewidth.value = t;
        }
      },
      dashed: {
        enumerable: !0,
        get: function() {
          return "USE_DASH" in this.defines;
        },
        set(t) {
          !!t != "USE_DASH" in this.defines && (this.needsUpdate = !0), t === !0 ? this.defines.USE_DASH = "" : delete this.defines.USE_DASH;
        }
      },
      dashScale: {
        enumerable: !0,
        get: function() {
          return this.uniforms.dashScale.value;
        },
        set: function(t) {
          this.uniforms.dashScale.value = t;
        }
      },
      dashSize: {
        enumerable: !0,
        get: function() {
          return this.uniforms.dashSize.value;
        },
        set: function(t) {
          this.uniforms.dashSize.value = t;
        }
      },
      dashOffset: {
        enumerable: !0,
        get: function() {
          return this.uniforms.dashOffset.value;
        },
        set: function(t) {
          this.uniforms.dashOffset.value = t;
        }
      },
      gapSize: {
        enumerable: !0,
        get: function() {
          return this.uniforms.gapSize.value;
        },
        set: function(t) {
          this.uniforms.gapSize.value = t;
        }
      },
      opacity: {
        enumerable: !0,
        get: function() {
          return this.uniforms.opacity.value;
        },
        set: function(t) {
          this.uniforms.opacity.value = t;
        }
      },
      resolution: {
        enumerable: !0,
        get: function() {
          return this.uniforms.resolution.value;
        },
        set: function(t) {
          this.uniforms.resolution.value.copy(t);
        }
      },
      alphaToCoverage: {
        enumerable: !0,
        get: function() {
          return "ALPHA_TO_COVERAGE" in this.defines;
        },
        set: function(t) {
          !!t != "ALPHA_TO_COVERAGE" in this.defines && (this.needsUpdate = !0), t === !0 ? (this.defines.ALPHA_TO_COVERAGE = "", this.extensions.derivatives = !0) : (delete this.defines.ALPHA_TO_COVERAGE, this.extensions.derivatives = !1);
        }
      }
    }), this.setValues(e);
  }
}
As.prototype.isLineMaterial = !0;
const Zu = new b(), Ju = new b(), Lt = new We(), Pt = new We(), wi = new We(), ul = new b(), dl = new ue(), ti = new _x(), Ku = new b(), Vi = new Ht(), La = new Ci(), bi = new We();
class Tf extends st {
  constructor(e = new Ac(), t = new As({ color: Math.random() * 16777215 })) {
    super(e, t), this.type = "LineSegments2";
  }
  // for backwards-compatability, but could be a method of LineSegmentsGeometry...
  computeLineDistances() {
    const e = this.geometry, t = e.attributes.instanceStart, i = e.attributes.instanceEnd, n = new Float32Array(2 * t.count);
    for (let r = 0, a = 0, l = t.count; r < l; r++, a += 2)
      Zu.fromBufferAttribute(t, r), Ju.fromBufferAttribute(i, r), n[a] = a === 0 ? 0 : n[a - 1], n[a + 1] = n[a] + Zu.distanceTo(Ju);
    const s = new Sl(n, 2, 1);
    return e.setAttribute("instanceDistanceStart", new $t(s, 1, 0)), e.setAttribute("instanceDistanceEnd", new $t(s, 1, 1)), this;
  }
  raycast(e, t) {
    e.camera === null && console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2.');
    const i = e.params.Line2 !== void 0 && e.params.Line2.threshold || 0, n = e.ray, s = e.camera, r = s.projectionMatrix, a = this.matrixWorld, l = this.geometry, c = this.material, h = c.resolution, u = c.linewidth + i, d = l.attributes.instanceStart, f = l.attributes.instanceEnd, m = -s.near, _ = 2 * Math.max(u / h.width, u / h.height);
    l.boundingSphere === null && l.computeBoundingSphere(), La.copy(l.boundingSphere).applyMatrix4(a);
    const p = Math.max(s.near, La.distanceToPoint(n.origin));
    bi.set(0, 0, -p, 1).applyMatrix4(s.projectionMatrix), bi.multiplyScalar(1 / bi.w), bi.applyMatrix4(s.projectionMatrixInverse);
    const g = Math.abs(_ / bi.w) * 0.5;
    if (La.radius += g, e.ray.intersectsSphere(La) === !1)
      return;
    l.boundingBox === null && l.computeBoundingBox(), Vi.copy(l.boundingBox).applyMatrix4(a);
    const x = Math.max(s.near, Vi.distanceToPoint(n.origin));
    bi.set(0, 0, -x, 1).applyMatrix4(s.projectionMatrix), bi.multiplyScalar(1 / bi.w), bi.applyMatrix4(s.projectionMatrixInverse);
    const y = Math.abs(_ / bi.w) * 0.5;
    if (Vi.max.x += y, Vi.max.y += y, Vi.max.z += y, Vi.min.x -= y, Vi.min.y -= y, Vi.min.z -= y, e.ray.intersectsBox(Vi) !== !1) {
      n.at(1, wi), wi.w = 1, wi.applyMatrix4(s.matrixWorldInverse), wi.applyMatrix4(r), wi.multiplyScalar(1 / wi.w), wi.x *= h.x / 2, wi.y *= h.y / 2, wi.z = 0, ul.copy(wi), dl.multiplyMatrices(s.matrixWorldInverse, a);
      for (let M = 0, S = d.count; M < S; M++) {
        Lt.fromBufferAttribute(d, M), Pt.fromBufferAttribute(f, M), Lt.w = 1, Pt.w = 1, Lt.applyMatrix4(dl), Pt.applyMatrix4(dl);
        var v = Lt.z > m && Pt.z > m;
        if (v)
          continue;
        if (Lt.z > m) {
          const z = Lt.z - Pt.z, V = (Lt.z - m) / z;
          Lt.lerp(Pt, V);
        } else if (Pt.z > m) {
          const z = Pt.z - Lt.z, V = (Pt.z - m) / z;
          Pt.lerp(Lt, V);
        }
        Lt.applyMatrix4(r), Pt.applyMatrix4(r), Lt.multiplyScalar(1 / Lt.w), Pt.multiplyScalar(1 / Pt.w), Lt.x *= h.x / 2, Lt.y *= h.y / 2, Pt.x *= h.x / 2, Pt.y *= h.y / 2, ti.start.copy(Lt), ti.start.z = 0, ti.end.copy(Pt), ti.end.z = 0;
        const A = ti.closestPointToPointParameter(ul, !0);
        ti.at(A, Ku);
        const w = Rt.lerp(Lt.z, Pt.z, A), E = w >= -1 && w <= 1, P = ul.distanceTo(Ku) < u * 0.5;
        if (E && P) {
          ti.start.fromBufferAttribute(d, M), ti.end.fromBufferAttribute(f, M), ti.start.applyMatrix4(a), ti.end.applyMatrix4(a);
          const z = new b(), V = new b();
          n.distanceSqToSegment(ti.start, ti.end, V, z), t.push({
            point: V,
            pointOnLine: z,
            distance: n.origin.distanceTo(V),
            object: this,
            face: null,
            faceIndex: M,
            uv: null,
            uv2: null
          });
        }
      }
    }
  }
}
Tf.prototype.LineSegments2 = !0;
class Il extends Tf {
  constructor(e = new ja(), t = new As({ color: Math.random() * 16777215 })) {
    super(e, t), this.type = "Line2";
  }
}
Il.prototype.isLine2 = !0;
var Wt = /* @__PURE__ */ ((o) => (o[o.Scene = 10] = "Scene", o[o.Building = 11] = "Building", o[o.Floor = 12] = "Floor", o))(Wt || {}), Gi = /* @__PURE__ */ ((o) => (o[o.Json = 0] = "Json", o[o.Tiles = 1] = "Tiles", o))(Gi || {}), ii = /* @__PURE__ */ ((o) => (o[o.In = 0] = "In", o[o.Out = 1] = "Out", o[o.Null = 2] = "Null", o))(ii || {}), Dl = /* @__PURE__ */ ((o) => (o[o.Normal = 0] = "Normal", o[o.Removed = 1] = "Removed", o))(Dl || {});
class Af extends sd {
  constructor(t, i, n, s, r) {
    super();
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    k(this, "id");
    k(this, "model_url");
    k(this, "matrix");
    k(this, "model_loader", new Hd());
    k(this, "init_mesh_group_position");
    k(this, "mesh_group", new nt());
    k(this, "light_group", new nt());
    k(this, "alpha", { alpha: 1 });
    k(this, "alpha_animation", []);
    k(this, "translation_animation", []);
    k(this, "animation_time");
    k(this, "tag_group", new nt());
    k(this, "area_group", new nt());
    k(this, "options");
    k(this, "user_data", {});
    k(this, "last_userdata_translation");
    k(this, "model_file_type");
    k(this, "tile_render");
    k(this, "dracoLoader", new ff());
    k(this, "loader", new Ns());
    k(this, "status", 0);
    k(this, "_is_show", !0);
    this.id = t, this.model_url = i, this.model_file_type = s, this.matrix = new ue().set(...n).transpose(), this.last_userdata_translation = { x: n[12], y: n[13], z: n[14] }, this.options = r, this.animation_time = this.options.animation_time, this.light_group.applyMatrix4(this.matrix), this.mesh_group.applyMatrix4(this.matrix), this.area_group.applyMatrix4(this.matrix), this.tag_group.applyMatrix4(this.matrix), this.init_mesh_group_position = this.mesh_group.position.clone(), this.dracoLoader.setDecoderPath("/three/libs/draco/gltf/"), this.loader.setDRACOLoader(this.dracoLoader), this._init().then(() => {
      this.dispatchEvent(Ae.MODELLOADEDFINISH, this);
    });
  }
  async _init() {
    if (this.model_file_type === Gi.Json) {
      const t = await this.model_loader.loadAsync(this.model_url);
      if (this.status === 1) return;
      this.user_data = t.userData, this._moveMeshAndLightToGroup(t);
    } else if (this.model_file_type === Gi.Tiles) {
      this.tile_render = new df(this.model_url), this.tile_render.onTileVisibilityChange = (n) => {
        n.parent && n.parent.layers.mask === 1 && n.layers.mask === 2 && this.setMeshLayers(!0);
      }, this.tile_render.manager.addHandler(/\.gltf$/, this.loader), this.tile_render.group.rotateX(-Math.PI / 2);
      const t = this.model_url.replace("tileset.json", "scene.json"), i = await this.model_loader.loadAsync(t);
      if (this.status === 1) return;
      i.children.forEach(
        (n) => {
          n instanceof vi ? this.light_group.add(n) : n instanceof gt && (this.user_data.camera = n);
        }
      );
    }
  }
  _moveMeshAndLightToGroup(t) {
    t.traverse((i) => {
      i instanceof vi ? this.light_group.add(i.clone()) : i instanceof st && this.mesh_group.add(i.clone());
    });
  }
  setMeshMaterialOpacity(t) {
    this.mesh_group.traverse((i) => {
      if (i instanceof st) {
        const n = i.material;
        n instanceof Array ? n.forEach((s) => {
          s.opacity = t;
        }) : n.opacity = t;
      }
    }), this.alpha.alpha = t;
  }
  setMeshMaterialTransparent(t) {
    this.mesh_group.traverse((i) => {
      if (i instanceof st) {
        const n = i.material;
        n instanceof Array ? n.forEach((s) => {
          s.transparent = t, s.needsUpdate = !0;
        }) : (n.transparent = t, n.needsUpdate = !0);
      }
    });
  }
  _setMeshLayers(t, i) {
    t.traverse(
      (n) => {
        n.layers.set(+!i);
      }
    );
  }
  setMeshLayers(t) {
    this._is_show = t, this._setMeshLayers(this.mesh_group, t), this._setMeshLayers(this.area_group, t), this.tile_render && this.tile_render.group && (this.tile_render.group.visible = t, this._setMeshLayers(this.tile_render.group, t));
  }
  setTagGroupVisible(t) {
    this._setMeshLayers(this.tag_group, t);
  }
  createTranslationAnimation(t) {
    const i = new Bt(this.mesh_group.position), n = new Bt(this.area_group.position), s = new Bt(this.tag_group.position);
    this.translation_animation.push(i, n, s);
    const r = [];
    return [i, n, s].forEach(
      (a) => {
        r.push(
          new Promise(
            (l) => {
              a.to(t, this.animation_time).easing(qi.Quartic.Out).onComplete(
                () => {
                  const c = this.translation_animation.indexOf(a);
                  c > -1 && this.translation_animation.splice(c, 1), l();
                }
              ).start();
            }
          )
        );
      }
    ), r;
  }
  createAlphaAnimation(t) {
    const i = new Bt(this.alpha);
    return this.alpha_animation.push(i), new Promise(
      (n) => {
        i.to(t, this.animation_time).easing(qi.Quartic.Out).onUpdate((s) => {
          this.setMeshMaterialOpacity(s.alpha);
        }).onComplete(
          () => {
            const s = this.alpha_animation.indexOf(i);
            s > -1 && this.alpha_animation.splice(s, 1), n();
          }
        ).start();
      }
    );
  }
  clearAlphaAnimation() {
    this.alpha_animation.forEach(
      (t) => {
        t.stop();
      }
    ), this.alpha_animation = [];
  }
  clearTranslationAnimation() {
    this.translation_animation.forEach(
      (t) => {
        t.stop();
      }
    ), this.translation_animation = [];
  }
  // todo 修改命名
  setUserDataTranslation(t) {
    this.mesh_group.translateX(t.x - this.last_userdata_translation.x), this.mesh_group.translateY(t.y - this.last_userdata_translation.y), this.mesh_group.translateZ(t.z - this.last_userdata_translation.z), this.light_group.translateX(t.x - this.last_userdata_translation.x), this.light_group.translateY(t.y - this.last_userdata_translation.y), this.light_group.translateZ(t.z - this.last_userdata_translation.z), this.init_mesh_group_position = this.mesh_group.position.clone(), this.last_userdata_translation = t;
  }
  getUserDataTranslation() {
    return this.user_data.translation;
  }
  getUserData() {
    return this.user_data;
  }
  setPosition(t) {
    this.mesh_group.position.set(t.x, t.y, t.z), this.area_group.position.set(t.x, t.y, t.z), this.tag_group.position.set(t.x, t.y, t.z);
  }
  get is_show() {
    return this._is_show;
  }
}
var ka = /* @__PURE__ */ ((o) => (o[o.forward = 0] = "forward", o[o.reverse = 1] = "reverse", o))(ka || {});
class qb extends Af {
  constructor(t, i, n, s, r, a) {
    super(t, n, s, r, a);
    k(this, "floor_order");
    k(this, "unfold_position");
    k(this, "fold_position");
    k(this, "forward_fly_out_position");
    k(this, "reverse_fly_out_position");
    k(this, "floor_distance", 5);
    k(this, "is_always_show_floor_data", !1);
    k(this, "_status", 0);
    this.floor_order = i, this.is_always_show_floor_data = !!a.is_always_show_floor_data, this.floor_distance = a.floor_distance ?? 5, this._initPosition();
  }
  _initPosition() {
    this.unfold_position = this.mesh_group.position.clone().add(new b(0, this.floor_distance, 0).multiplyScalar(this.floor_order)), this.fold_position = this.init_mesh_group_position.clone(), this.forward_fly_out_position = this.unfold_position.clone().add(new b(0, 5, 0)), this.reverse_fly_out_position = this.unfold_position.clone().add(new b(0, -5, 0));
  }
  _getPositionByDirection(t) {
    return t === 0 ? this.forward_fly_out_position : this.reverse_fly_out_position;
  }
  unfold() {
    if (this.clearAlphaAnimation(), this.clearTranslationAnimation(), this.setMeshLayers(!0), this.setTagGroupVisible(!0), this._status = 1, this.mesh_group.children.length !== 0)
      return this.createTranslationAnimation(this.unfold_position);
  }
  async flyOut(t) {
    this.clearAlphaAnimation(), this.clearTranslationAnimation(), this.setTagGroupVisible(!1), this.setMeshMaterialTransparent(!0), this.createTranslationAnimation(this._getPositionByDirection(t)), await this.createAlphaAnimation({ alpha: 0 }), this.setMeshMaterialTransparent(!1), this.setMeshLayers(!1);
  }
  fold() {
    return this.clearAlphaAnimation(), this.clearTranslationAnimation(), this.is_always_show_floor_data ? this.setTagGroupVisible(!0) : this.setTagGroupVisible(!1), this._status = 0, this.createTranslationAnimation(this.fold_position);
  }
  setAlpha(t) {
    return this.clearAlphaAnimation(), this.createAlphaAnimation({ alpha: t });
  }
  setHeight(t) {
    this.unfold_position = this.init_mesh_group_position.clone().add(new b(0, t, 0)), this._status === 1 && this.setPosition(this.unfold_position);
  }
  setIsAlwaysShowFloorData(t) {
    this.is_always_show_floor_data = t;
  }
  beenSelect() {
    this._status = 2, this.leaveHover();
  }
  onHover() {
    this._status !== 2 && (this.setMeshMaterialTransparent(!0), this.setAlpha(0.8));
  }
  leaveHover() {
    this.setAlpha(1).then(() => {
      this.setMeshMaterialTransparent(!1);
    });
  }
  get isNormal() {
    return this._status === 1;
  }
  get isSelect() {
    return this._status === 2;
  }
  get unfoldPosition() {
    return this.unfold_position;
  }
}
class jb extends Af {
  constructor(t, i, n, s, r) {
    super(t, i, n, s, r);
    k(this, "floor_list", {});
    k(this, "_status", 0);
    k(this, "wall_ring_mesh");
  }
  addFloor(t, i) {
    this.floor_list[t] = i;
  }
  async show() {
    this.is_show && this.alpha_animation.length === 0 || (this.clearAlphaAnimation(), this.setMeshMaterialTransparent(!0), this.setMeshLayers(!0), await this.createAlphaAnimation({ alpha: 1 }), this.setMeshMaterialTransparent(!1));
  }
  async hide() {
    !this.is_show && this.alpha_animation.length === 0 || (this.clearAlphaAnimation(), this.setMeshMaterialTransparent(!0), await this.createAlphaAnimation({ alpha: 0 }), this.setMeshLayers(!1), this.setMeshMaterialTransparent(!1));
  }
  unfoldBuildingFloors() {
    var i;
    let t = [];
    return Object.values(this.floor_list).forEach((n) => {
      t = [t, n.unfold()].flat();
    }), this._status = 1, (i = this.wall_ring_mesh) == null || i.layers.set(0), t;
  }
  foldBuildingFloors() {
    var i;
    let t = [];
    return Object.values(this.floor_list).forEach((n) => {
      t = [t, n.fold()].flat();
    }), Promise.all(t).then(() => {
      Object.values(this.floor_list).forEach((n) => {
        n.setMeshLayers(!1), n.setMeshMaterialOpacity(1), n.setMeshMaterialTransparent(!1);
      });
    }), this._status = 0, (i = this.wall_ring_mesh) == null || i.layers.set(1), t;
  }
  selectFloor(t) {
    var n;
    let i = [];
    if (this._status === 2)
      return Object.values(this.floor_list).forEach(
        (s) => {
          s.isSelect && i.push(s.flyOut(ka.reverse)), s.id === t && (s.unfold(), s.beenSelect());
        }
      ), i;
    if (this._status === 1) {
      (n = this.wall_ring_mesh) == null || n.layers.set(1);
      const s = this.floor_list[t].floor_order;
      return Object.values(this.floor_list).forEach(
        (r) => {
          t !== r.id ? r.floor_order > s ? i = [i, r.flyOut(ka.forward)].flat() : i = [i, r.flyOut(ka.reverse)].flat() : r.beenSelect();
        }
      ), this._status = 2, i;
    }
    return this.unfoldBuildingFloors(), this.hide(), this.selectFloor(t), i;
  }
  setAllFloorAlpha(t) {
    const i = [];
    return Object.values(this.floor_list).forEach(
      (n) => i.push(n.setAlpha(t))
    ), i;
  }
  setFloorDistance(t) {
    const i = Object.values(this.floor_list).sort((s, r) => s.floor_order - r.floor_order);
    let n = 0;
    for (let s = 0; s < i.length; s++)
      i[s].setHeight(n), n += t;
  }
  setWallRingMesh(t) {
    this.wall_ring_mesh = t;
  }
  onHover() {
    var t;
    this._status === 0 && Object.entries(this.floor_list).length && ((t = this.wall_ring_mesh) == null || t.layers.set(0));
  }
  leaveHover() {
    var t;
    this._status === 0 && ((t = this.wall_ring_mesh) == null || t.layers.set(1));
  }
  get isNormal() {
    return this._status === 0;
  }
  get isUnfold() {
    return this._status === 1;
  }
  get isSelectFloor() {
    return this._status === 2;
  }
}
var Oe = /* @__PURE__ */ ((o) => (o[o.Card = 1] = "Card", o[o.BaseStation = 2] = "BaseStation", o[o.Custom = 5] = "Custom", o[o.Zone = 20] = "Zone", o[o.Cylinder = 30] = "Cylinder", o[o.WallMesh = 31] = "WallMesh", o))(Oe || {}), At = /* @__PURE__ */ ((o) => (o[o.JSON = 0] = "JSON", o[o.FBX = 1] = "FBX", o[o.GLTF = 2] = "GLTF", o[o.Texture = 3] = "Texture", o))(At || {});
function Yb(o) {
  return {
    type: 0,
    content: o
  };
}
function Zb(o) {
  return {
    type: 1,
    content: o
  };
}
function Jb(o) {
  return {
    type: 3,
    content: o
  };
}
const Kb = `
uniform float time;
varying vec2 vUv;
uniform vec3 uWall;
uniform vec3 uRing;

void main() {
	  float line = vUv.y*2.0 - time;
      line = fract(line * 3.5);
      line = smoothstep(0.8,1.0,line);
      
      float t = vUv.y;
      float wall = 1.0 - t;
      wall = pow(wall, 2.0);
      t = pow(t, 8.0);
      line = line*(1.-t);
      gl_FragColor = vec4(uWall*wall,wall) + vec4(uRing*line,line);
}
`, $b = `
varying vec2 vUv;

void main() {
    vUv = uv;
    gl_Position = projectionMatrix*viewMatrix*modelMatrix*vec4( position, 1.0 );
}
`;
class Qb extends xt {
  constructor(e) {
    super({
      uniforms: {
        time: e.time,
        uWall: e.uWall,
        uRing: e.uRing
      },
      vertexShader: $b,
      fragmentShader: Kb,
      blending: za,
      transparent: !0,
      side: ji,
      depthWrite: !1
    });
  }
}
const I = (o) => {
  if (o == null)
    throw new Error("参数类型为undefined或null");
  return o;
};
function $u(o, e) {
  const t = new Qb(e), i = new Ue(), n = o.min.y + (o.max.y - o.min.y) / 2, s = new Float32Array([
    // front
    o.min.x - 1,
    o.min.y,
    o.max.z + 1,
    o.max.x + 1,
    n,
    o.max.z + 1,
    o.min.x - 1,
    n,
    o.max.z + 1,
    o.min.x - 1,
    o.min.y,
    o.max.z + 1,
    o.max.x + 1,
    o.min.y,
    o.max.z + 1,
    o.max.x + 1,
    n,
    o.max.z + 1,
    // back
    o.min.x - 1,
    o.min.y,
    o.min.z - 1,
    o.max.x + 1,
    n,
    o.min.z - 1,
    o.min.x - 1,
    n,
    o.min.z - 1,
    o.min.x - 1,
    o.min.y,
    o.min.z - 1,
    o.max.x + 1,
    o.min.y,
    o.min.z - 1,
    o.max.x + 1,
    n,
    o.min.z - 1,
    // left
    o.min.x - 1,
    o.min.y,
    o.max.z + 1,
    o.min.x - 1,
    n,
    o.min.z - 1,
    o.min.x - 1,
    o.min.y,
    o.min.z - 1,
    o.min.x - 1,
    o.min.y,
    o.max.z + 1,
    o.min.x - 1,
    n,
    o.max.z + 1,
    o.min.x - 1,
    n,
    o.min.z - 1,
    // right
    o.max.x + 1,
    o.min.y,
    o.max.z + 1,
    o.max.x + 1,
    o.min.y,
    o.min.z - 1,
    o.max.x + 1,
    n,
    o.min.z - 1,
    o.max.x + 1,
    o.min.y,
    o.max.z + 1,
    o.max.x + 1,
    n,
    o.min.z - 1,
    o.max.x + 1,
    n,
    o.max.z + 1
  ]), r = new Float32Array([
    // front
    0,
    0,
    1,
    1,
    0,
    1,
    0,
    0,
    1,
    0,
    1,
    1,
    // back
    0,
    0,
    1,
    1,
    0,
    1,
    0,
    0,
    1,
    0,
    1,
    1,
    // // left
    1,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    1,
    1,
    0,
    1,
    // // right
    0,
    0,
    1,
    0,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1
  ]);
  i.setAttribute("position", new $e(s, 3)), i.setAttribute("uv", new $e(r, 2));
  const a = new st(i, t);
  return a.userData.model_type = Oe.WallMesh, a;
}
function eM(o) {
  let e = 0, t = 0, i = 0;
  for (const n of o)
    e++, t += n.x, i += n.y;
  return {
    x: t / e,
    y: i / e
  };
}
function Qu(o, e, t) {
  const i = o.distanceTo(e), n = i * t, s = o.clone().sub(e), r = e.x + s.x * (n / i - 1), a = e.y + s.y * (n / i - 1), l = e.z + s.z * (n / i - 1);
  return new b(r, a, l);
}
function tM(o, e) {
  return o.clone().sub(e);
}
function fl(o, e) {
  return o.traverse((t) => {
    t != null && t.isMesh && Ef(t, e);
  }), o;
}
function Ef(o, e) {
  const t = o.worldToLocal(e.clone()).negate();
  return o.geometry.translate(t.x, t.y, t.z), o;
}
class iM {
  constructor() {
    k(this, "_resolve");
    k(this, "_reject");
    k(this, "_promise");
    k(this, "status", "pending");
    this._promise = new Promise((e, t) => {
      this._resolve = e, this._reject = t;
    });
  }
  resolve(e) {
    this.status = "fulfilled", this._resolve(e);
  }
  reject(e) {
    this.status = "fulfilled", this._reject(e);
  }
  get promise() {
    return this._promise;
  }
  get isPending() {
    return this.status === "pending";
  }
}
function nM(o, e) {
  return o === void 0 && e === void 0 ? !0 : o === void 0 || e === void 0 || o.length !== e.length ? !1 : Cf(o, e);
}
function Cf(o, e) {
  const t = Object.keys(o), i = Object.keys(e);
  if (t.length !== i.length)
    return !1;
  for (const n of t)
    if (typeof o[n] == "object") {
      if (!Cf(o[n], e[n]))
        return !1;
    } else if (o[n] !== e[n])
      return !1;
  return !0;
}
function Pa(o) {
  return Object.entries(o.floor_list).length === 0;
}
class sM extends Pw {
  constructor(e) {
    super(e);
  }
  destroy() {
    this.element.parentNode !== null && this.element.parentNode.removeChild(this.element);
  }
}
const rM = "label", Lf = "id", Pf = "type", Rf = "extra";
function Mi(o, e) {
  const t = new sM(o);
  return t.position.copy(e), t;
}
function sn(o) {
  const e = document.createElement("div");
  if (e.classList.add(rM), o.text_class) {
    const t = Array.isArray(o.text_class) ? o.text_class : [o.text_class];
    e.classList.add(...t);
  }
  return e.innerHTML = o.text, e.dataset[Lf] = o.id.toString(), e.dataset[Pf] = o.type.toString(), o.extra && (e.dataset[Rf] = o.extra), e;
}
function ed(o) {
  const e = document.createElement("div");
  e.classList.add("sdk_label_container");
  const t = document.createElement("div");
  return e.appendChild(t), t.classList.add("hg_tooltip"), t.classList.add("hg_tooltip_static"), o === void 0 ? t.innerHTML = "起点" : t.innerHTML = `${o.toFixed(2)} m`, e;
}
function aM(o) {
  const e = document.createElement("div");
  e.classList.add("sdk_label_container");
  const t = document.createElement("div");
  return e.appendChild(t), t.classList.add("hg_tooltip"), t.classList.add("hg_tooltip_measure"), t.innerHTML = "起点", e;
}
function td(o) {
  return o.dataset[Lf];
}
function id(o) {
  const e = o.dataset[Pf];
  return e === void 0 ? null : parseInt(e);
}
function oM(o) {
  const e = o.dataset[Rf];
  return e === void 0 ? null : e;
}
const If = {
  uniforms: {
    tDiffuse: { value: null },
    opacity: { value: 1 }
  },
  vertexShader: (
    /* glsl */
    `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		uniform float opacity;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			gl_FragColor = texture2D( tDiffuse, vUv );
			gl_FragColor.a *= opacity;


		}`
  )
};
class kr {
  constructor() {
    this.enabled = !0, this.needsSwap = !0, this.clear = !1, this.renderToScreen = !1;
  }
  setSize() {
  }
  render() {
    console.error("THREE.Pass: .render() must be implemented in derived pass.");
  }
  dispose() {
  }
}
const lM = new pn(-1, 1, 1, -1, 0, 1), Ec = new Ue();
Ec.setAttribute("position", new Ee([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3));
Ec.setAttribute("uv", new Ee([0, 2, 0, 0, 2, 0], 2));
class Df {
  constructor(e) {
    this._mesh = new st(Ec, e);
  }
  dispose() {
    this._mesh.geometry.dispose();
  }
  render(e) {
    e.render(this._mesh, lM);
  }
  get material() {
    return this._mesh.material;
  }
  set material(e) {
    this._mesh.material = e;
  }
}
class Of extends kr {
  constructor(e, t) {
    super(), this.textureID = t !== void 0 ? t : "tDiffuse", e instanceof xt ? (this.uniforms = e.uniforms, this.material = e) : e && (this.uniforms = Lr.clone(e.uniforms), this.material = new xt({
      defines: Object.assign({}, e.defines),
      uniforms: this.uniforms,
      vertexShader: e.vertexShader,
      fragmentShader: e.fragmentShader
    })), this.fsQuad = new Df(this.material);
  }
  render(e, t, i) {
    this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = i.texture), this.fsQuad.material = this.material, this.renderToScreen ? (e.setRenderTarget(null), this.fsQuad.render(e)) : (e.setRenderTarget(t), this.clear && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), this.fsQuad.render(e));
  }
  dispose() {
    this.material.dispose(), this.fsQuad.dispose();
  }
}
class nd extends kr {
  constructor(e, t) {
    super(), this.scene = e, this.camera = t, this.clear = !0, this.needsSwap = !1, this.inverse = !1;
  }
  render(e, t, i) {
    const n = e.getContext(), s = e.state;
    s.buffers.color.setMask(!1), s.buffers.depth.setMask(!1), s.buffers.color.setLocked(!0), s.buffers.depth.setLocked(!0);
    let r, a;
    this.inverse ? (r = 0, a = 1) : (r = 1, a = 0), s.buffers.stencil.setTest(!0), s.buffers.stencil.setOp(n.REPLACE, n.REPLACE, n.REPLACE), s.buffers.stencil.setFunc(n.ALWAYS, r, 4294967295), s.buffers.stencil.setClear(a), s.buffers.stencil.setLocked(!0), e.setRenderTarget(i), this.clear && e.clear(), e.render(this.scene, this.camera), e.setRenderTarget(t), this.clear && e.clear(), e.render(this.scene, this.camera), s.buffers.color.setLocked(!1), s.buffers.depth.setLocked(!1), s.buffers.stencil.setLocked(!1), s.buffers.stencil.setFunc(n.EQUAL, 1, 4294967295), s.buffers.stencil.setOp(n.KEEP, n.KEEP, n.KEEP), s.buffers.stencil.setLocked(!0);
  }
}
class cM extends kr {
  constructor() {
    super(), this.needsSwap = !1;
  }
  render(e) {
    e.state.buffers.stencil.setLocked(!1), e.state.buffers.stencil.setTest(!1);
  }
}
class hM {
  constructor(e, t) {
    if (this.renderer = e, t === void 0) {
      const i = e.getSize(new G());
      this._pixelRatio = e.getPixelRatio(), this._width = i.width, this._height = i.height, t = new Ot(this._width * this._pixelRatio, this._height * this._pixelRatio), t.texture.name = "EffectComposer.rt1";
    } else
      this._pixelRatio = 1, this._width = t.width, this._height = t.height;
    this.renderTarget1 = t, this.renderTarget2 = t.clone(), this.renderTarget2.texture.name = "EffectComposer.rt2", this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2, this.renderToScreen = !0, this.passes = [], this.copyPass = new Of(If), this.clock = new Ml();
  }
  swapBuffers() {
    const e = this.readBuffer;
    this.readBuffer = this.writeBuffer, this.writeBuffer = e;
  }
  addPass(e) {
    this.passes.push(e), e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
  }
  insertPass(e, t) {
    this.passes.splice(t, 0, e), e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
  }
  removePass(e) {
    const t = this.passes.indexOf(e);
    t !== -1 && this.passes.splice(t, 1);
  }
  isLastEnabledPass(e) {
    for (let t = e + 1; t < this.passes.length; t++)
      if (this.passes[t].enabled)
        return !1;
    return !0;
  }
  render(e) {
    e === void 0 && (e = this.clock.getDelta());
    const t = this.renderer.getRenderTarget();
    let i = !1;
    for (let n = 0, s = this.passes.length; n < s; n++) {
      const r = this.passes[n];
      if (r.enabled !== !1) {
        if (r.renderToScreen = this.renderToScreen && this.isLastEnabledPass(n), r.render(this.renderer, this.writeBuffer, this.readBuffer, e, i), r.needsSwap) {
          if (i) {
            const a = this.renderer.getContext(), l = this.renderer.state.buffers.stencil;
            l.setFunc(a.NOTEQUAL, 1, 4294967295), this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, e), l.setFunc(a.EQUAL, 1, 4294967295);
          }
          this.swapBuffers();
        }
        nd !== void 0 && (r instanceof nd ? i = !0 : r instanceof cM && (i = !1));
      }
    }
    this.renderer.setRenderTarget(t);
  }
  reset(e) {
    if (e === void 0) {
      const t = this.renderer.getSize(new G());
      this._pixelRatio = this.renderer.getPixelRatio(), this._width = t.width, this._height = t.height, e = this.renderTarget1.clone(), e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
    }
    this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.renderTarget1 = e, this.renderTarget2 = e.clone(), this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2;
  }
  setSize(e, t) {
    this._width = e, this._height = t;
    const i = this._width * this._pixelRatio, n = this._height * this._pixelRatio;
    this.renderTarget1.setSize(i, n), this.renderTarget2.setSize(i, n);
    for (let s = 0; s < this.passes.length; s++)
      this.passes[s].setSize(i, n);
  }
  setPixelRatio(e) {
    this._pixelRatio = e, this.setSize(this._width, this._height);
  }
  dispose() {
    this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.copyPass.dispose();
  }
}
class uM extends kr {
  constructor(e, t, i, n, s) {
    super(), this.scene = e, this.camera = t, this.overrideMaterial = i, this.clearColor = n, this.clearAlpha = s !== void 0 ? s : 0, this.clear = !0, this.clearDepth = !1, this.needsSwap = !1, this._oldClearColor = new de();
  }
  render(e, t, i) {
    const n = e.autoClear;
    e.autoClear = !1;
    let s, r;
    this.overrideMaterial !== void 0 && (r = this.scene.overrideMaterial, this.scene.overrideMaterial = this.overrideMaterial), this.clearColor && (e.getClearColor(this._oldClearColor), s = e.getClearAlpha(), e.setClearColor(this.clearColor, this.clearAlpha)), this.clearDepth && e.clearDepth(), e.setRenderTarget(this.renderToScreen ? null : i), this.clear && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), e.render(this.scene, this.camera), this.clearColor && e.setClearColor(this._oldClearColor, s), this.overrideMaterial !== void 0 && (this.scene.overrideMaterial = r), e.autoClear = n;
  }
}
class un extends kr {
  constructor(e, t, i, n) {
    super(), this.renderScene = t, this.renderCamera = i, this.selectedObjects = n !== void 0 ? n : [], this.visibleEdgeColor = new de(1, 1, 1), this.hiddenEdgeColor = new de(0.1, 0.04, 0.02), this.edgeGlow = 0, this.usePatternTexture = !1, this.edgeThickness = 1, this.edgeStrength = 3, this.downSampleRatio = 2, this.pulsePeriod = 0, this._visibilityCache = /* @__PURE__ */ new Map(), this.resolution = e !== void 0 ? new G(e.x, e.y) : new G(256, 256);
    const s = Math.round(this.resolution.x / this.downSampleRatio), r = Math.round(this.resolution.y / this.downSampleRatio);
    this.renderTargetMaskBuffer = new Ot(this.resolution.x, this.resolution.y), this.renderTargetMaskBuffer.texture.name = "OutlinePass.mask", this.renderTargetMaskBuffer.texture.generateMipmaps = !1, this.depthMaterial = new Gl(), this.depthMaterial.side = ji, this.depthMaterial.depthPacking = hd, this.depthMaterial.blending = Ti, this.prepareMaskMaterial = this.getPrepareMaskMaterial(), this.prepareMaskMaterial.side = ji, this.prepareMaskMaterial.fragmentShader = h(this.prepareMaskMaterial.fragmentShader, this.renderCamera), this.renderTargetDepthBuffer = new Ot(this.resolution.x, this.resolution.y), this.renderTargetDepthBuffer.texture.name = "OutlinePass.depth", this.renderTargetDepthBuffer.texture.generateMipmaps = !1, this.renderTargetMaskDownSampleBuffer = new Ot(s, r), this.renderTargetMaskDownSampleBuffer.texture.name = "OutlinePass.depthDownSample", this.renderTargetMaskDownSampleBuffer.texture.generateMipmaps = !1, this.renderTargetBlurBuffer1 = new Ot(s, r), this.renderTargetBlurBuffer1.texture.name = "OutlinePass.blur1", this.renderTargetBlurBuffer1.texture.generateMipmaps = !1, this.renderTargetBlurBuffer2 = new Ot(Math.round(s / 2), Math.round(r / 2)), this.renderTargetBlurBuffer2.texture.name = "OutlinePass.blur2", this.renderTargetBlurBuffer2.texture.generateMipmaps = !1, this.edgeDetectionMaterial = this.getEdgeDetectionMaterial(), this.renderTargetEdgeBuffer1 = new Ot(s, r), this.renderTargetEdgeBuffer1.texture.name = "OutlinePass.edge1", this.renderTargetEdgeBuffer1.texture.generateMipmaps = !1, this.renderTargetEdgeBuffer2 = new Ot(Math.round(s / 2), Math.round(r / 2)), this.renderTargetEdgeBuffer2.texture.name = "OutlinePass.edge2", this.renderTargetEdgeBuffer2.texture.generateMipmaps = !1;
    const a = 4, l = 4;
    this.separableBlurMaterial1 = this.getSeperableBlurMaterial(a), this.separableBlurMaterial1.uniforms.texSize.value.set(s, r), this.separableBlurMaterial1.uniforms.kernelRadius.value = 1, this.separableBlurMaterial2 = this.getSeperableBlurMaterial(l), this.separableBlurMaterial2.uniforms.texSize.value.set(Math.round(s / 2), Math.round(r / 2)), this.separableBlurMaterial2.uniforms.kernelRadius.value = l, this.overlayMaterial = this.getOverlayMaterial();
    const c = If;
    this.copyUniforms = Lr.clone(c.uniforms), this.copyUniforms.opacity.value = 1, this.materialCopy = new xt({
      uniforms: this.copyUniforms,
      vertexShader: c.vertexShader,
      fragmentShader: c.fragmentShader,
      blending: Ti,
      depthTest: !1,
      depthWrite: !1,
      transparent: !0
    }), this.enabled = !0, this.needsSwap = !1, this._oldClearColor = new de(), this.oldClearAlpha = 1, this.fsQuad = new Df(null), this.tempPulseColor1 = new de(), this.tempPulseColor2 = new de(), this.textureMatrix = new ue();
    function h(u, d) {
      const f = d.isPerspectiveCamera ? "perspective" : "orthographic";
      return u.replace(/DEPTH_TO_VIEW_Z/g, f + "DepthToViewZ");
    }
  }
  dispose() {
    this.renderTargetMaskBuffer.dispose(), this.renderTargetDepthBuffer.dispose(), this.renderTargetMaskDownSampleBuffer.dispose(), this.renderTargetBlurBuffer1.dispose(), this.renderTargetBlurBuffer2.dispose(), this.renderTargetEdgeBuffer1.dispose(), this.renderTargetEdgeBuffer2.dispose(), this.depthMaterial.dispose(), this.prepareMaskMaterial.dispose(), this.edgeDetectionMaterial.dispose(), this.separableBlurMaterial1.dispose(), this.separableBlurMaterial2.dispose(), this.overlayMaterial.dispose(), this.materialCopy.dispose(), this.fsQuad.dispose();
  }
  setSize(e, t) {
    this.renderTargetMaskBuffer.setSize(e, t), this.renderTargetDepthBuffer.setSize(e, t);
    let i = Math.round(e / this.downSampleRatio), n = Math.round(t / this.downSampleRatio);
    this.renderTargetMaskDownSampleBuffer.setSize(i, n), this.renderTargetBlurBuffer1.setSize(i, n), this.renderTargetEdgeBuffer1.setSize(i, n), this.separableBlurMaterial1.uniforms.texSize.value.set(i, n), i = Math.round(i / 2), n = Math.round(n / 2), this.renderTargetBlurBuffer2.setSize(i, n), this.renderTargetEdgeBuffer2.setSize(i, n), this.separableBlurMaterial2.uniforms.texSize.value.set(i, n);
  }
  changeVisibilityOfSelectedObjects(e) {
    const t = this._visibilityCache;
    function i(n) {
      n.isMesh && (e === !0 ? n.visible = t.get(n) : (t.set(n, n.visible), n.visible = e));
    }
    for (let n = 0; n < this.selectedObjects.length; n++)
      this.selectedObjects[n].traverse(i);
  }
  changeVisibilityOfNonSelectedObjects(e) {
    const t = this._visibilityCache, i = [];
    function n(r) {
      r.isMesh && i.push(r);
    }
    for (let r = 0; r < this.selectedObjects.length; r++)
      this.selectedObjects[r].traverse(n);
    function s(r) {
      if (r.isMesh || r.isSprite) {
        let a = !1;
        for (let l = 0; l < i.length; l++)
          if (i[l].id === r.id) {
            a = !0;
            break;
          }
        if (a === !1) {
          const l = r.visible;
          (e === !1 || t.get(r) === !0) && (r.visible = e), t.set(r, l);
        }
      } else (r.isPoints || r.isLine) && (e === !0 ? r.visible = t.get(r) : (t.set(r, r.visible), r.visible = e));
    }
    this.renderScene.traverse(s);
  }
  updateTextureMatrix() {
    this.textureMatrix.set(
      0.5,
      0,
      0,
      0.5,
      0,
      0.5,
      0,
      0.5,
      0,
      0,
      0.5,
      0.5,
      0,
      0,
      0,
      1
    ), this.textureMatrix.multiply(this.renderCamera.projectionMatrix), this.textureMatrix.multiply(this.renderCamera.matrixWorldInverse);
  }
  render(e, t, i, n, s) {
    if (this.selectedObjects.length > 0) {
      e.getClearColor(this._oldClearColor), this.oldClearAlpha = e.getClearAlpha();
      const r = e.autoClear;
      e.autoClear = !1, s && e.state.buffers.stencil.setTest(!1), e.setClearColor(16777215, 1), this.changeVisibilityOfSelectedObjects(!1);
      const a = this.renderScene.background;
      if (this.renderScene.background = null, this.renderScene.overrideMaterial = this.depthMaterial, e.setRenderTarget(this.renderTargetDepthBuffer), e.clear(), e.render(this.renderScene, this.renderCamera), this.changeVisibilityOfSelectedObjects(!0), this._visibilityCache.clear(), this.updateTextureMatrix(), this.changeVisibilityOfNonSelectedObjects(!1), this.renderScene.overrideMaterial = this.prepareMaskMaterial, this.prepareMaskMaterial.uniforms.cameraNearFar.value.set(this.renderCamera.near, this.renderCamera.far), this.prepareMaskMaterial.uniforms.depthTexture.value = this.renderTargetDepthBuffer.texture, this.prepareMaskMaterial.uniforms.textureMatrix.value = this.textureMatrix, e.setRenderTarget(this.renderTargetMaskBuffer), e.clear(), e.render(this.renderScene, this.renderCamera), this.renderScene.overrideMaterial = null, this.changeVisibilityOfNonSelectedObjects(!0), this._visibilityCache.clear(), this.renderScene.background = a, this.fsQuad.material = this.materialCopy, this.copyUniforms.tDiffuse.value = this.renderTargetMaskBuffer.texture, e.setRenderTarget(this.renderTargetMaskDownSampleBuffer), e.clear(), this.fsQuad.render(e), this.tempPulseColor1.copy(this.visibleEdgeColor), this.tempPulseColor2.copy(this.hiddenEdgeColor), this.pulsePeriod > 0) {
        const l = 0.625 + Math.cos(performance.now() * 0.01 / this.pulsePeriod) * 0.75 / 2;
        this.tempPulseColor1.multiplyScalar(l), this.tempPulseColor2.multiplyScalar(l);
      }
      this.fsQuad.material = this.edgeDetectionMaterial, this.edgeDetectionMaterial.uniforms.maskTexture.value = this.renderTargetMaskDownSampleBuffer.texture, this.edgeDetectionMaterial.uniforms.texSize.value.set(this.renderTargetMaskDownSampleBuffer.width, this.renderTargetMaskDownSampleBuffer.height), this.edgeDetectionMaterial.uniforms.visibleEdgeColor.value = this.tempPulseColor1, this.edgeDetectionMaterial.uniforms.hiddenEdgeColor.value = this.tempPulseColor2, e.setRenderTarget(this.renderTargetEdgeBuffer1), e.clear(), this.fsQuad.render(e), this.fsQuad.material = this.separableBlurMaterial1, this.separableBlurMaterial1.uniforms.colorTexture.value = this.renderTargetEdgeBuffer1.texture, this.separableBlurMaterial1.uniforms.direction.value = un.BlurDirectionX, this.separableBlurMaterial1.uniforms.kernelRadius.value = this.edgeThickness, e.setRenderTarget(this.renderTargetBlurBuffer1), e.clear(), this.fsQuad.render(e), this.separableBlurMaterial1.uniforms.colorTexture.value = this.renderTargetBlurBuffer1.texture, this.separableBlurMaterial1.uniforms.direction.value = un.BlurDirectionY, e.setRenderTarget(this.renderTargetEdgeBuffer1), e.clear(), this.fsQuad.render(e), this.fsQuad.material = this.separableBlurMaterial2, this.separableBlurMaterial2.uniforms.colorTexture.value = this.renderTargetEdgeBuffer1.texture, this.separableBlurMaterial2.uniforms.direction.value = un.BlurDirectionX, e.setRenderTarget(this.renderTargetBlurBuffer2), e.clear(), this.fsQuad.render(e), this.separableBlurMaterial2.uniforms.colorTexture.value = this.renderTargetBlurBuffer2.texture, this.separableBlurMaterial2.uniforms.direction.value = un.BlurDirectionY, e.setRenderTarget(this.renderTargetEdgeBuffer2), e.clear(), this.fsQuad.render(e), this.fsQuad.material = this.overlayMaterial, this.overlayMaterial.uniforms.maskTexture.value = this.renderTargetMaskBuffer.texture, this.overlayMaterial.uniforms.edgeTexture1.value = this.renderTargetEdgeBuffer1.texture, this.overlayMaterial.uniforms.edgeTexture2.value = this.renderTargetEdgeBuffer2.texture, this.overlayMaterial.uniforms.patternTexture.value = this.patternTexture, this.overlayMaterial.uniforms.edgeStrength.value = this.edgeStrength, this.overlayMaterial.uniforms.edgeGlow.value = this.edgeGlow, this.overlayMaterial.uniforms.usePatternTexture.value = this.usePatternTexture, s && e.state.buffers.stencil.setTest(!0), e.setRenderTarget(i), this.fsQuad.render(e), e.setClearColor(this._oldClearColor, this.oldClearAlpha), e.autoClear = r;
    }
    this.renderToScreen && (this.fsQuad.material = this.materialCopy, this.copyUniforms.tDiffuse.value = i.texture, e.setRenderTarget(null), this.fsQuad.render(e));
  }
  getPrepareMaskMaterial() {
    return new xt({
      uniforms: {
        depthTexture: { value: null },
        cameraNearFar: { value: new G(0.5, 0.5) },
        textureMatrix: { value: null }
      },
      vertexShader: `#include <morphtarget_pars_vertex>
				#include <skinning_pars_vertex>

				varying vec4 projTexCoord;
				varying vec4 vPosition;
				uniform mat4 textureMatrix;

				void main() {

					#include <skinbase_vertex>
					#include <begin_vertex>
					#include <morphtarget_vertex>
					#include <skinning_vertex>
					#include <project_vertex>

					vPosition = mvPosition;

					vec4 worldPosition = vec4( transformed, 1.0 );

					#ifdef USE_INSTANCING

						worldPosition = instanceMatrix * worldPosition;

					#endif
					
					worldPosition = modelMatrix * worldPosition;

					projTexCoord = textureMatrix * worldPosition;

				}`,
      fragmentShader: `#include <packing>
				varying vec4 vPosition;
				varying vec4 projTexCoord;
				uniform sampler2D depthTexture;
				uniform vec2 cameraNearFar;

				void main() {

					float depth = unpackRGBAToDepth(texture2DProj( depthTexture, projTexCoord ));
					float viewZ = - DEPTH_TO_VIEW_Z( depth, cameraNearFar.x, cameraNearFar.y );
					float depthTest = (-vPosition.z > viewZ) ? 1.0 : 0.0;
					gl_FragColor = vec4(0.0, depthTest, 1.0, 1.0);

				}`
    });
  }
  getEdgeDetectionMaterial() {
    return new xt({
      uniforms: {
        maskTexture: { value: null },
        texSize: { value: new G(0.5, 0.5) },
        visibleEdgeColor: { value: new b(1, 1, 1) },
        hiddenEdgeColor: { value: new b(1, 1, 1) }
      },
      vertexShader: `varying vec2 vUv;

				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`,
      fragmentShader: `varying vec2 vUv;

				uniform sampler2D maskTexture;
				uniform vec2 texSize;
				uniform vec3 visibleEdgeColor;
				uniform vec3 hiddenEdgeColor;

				void main() {
					vec2 invSize = 1.0 / texSize;
					vec4 uvOffset = vec4(1.0, 0.0, 0.0, 1.0) * vec4(invSize, invSize);
					vec4 c1 = texture2D( maskTexture, vUv + uvOffset.xy);
					vec4 c2 = texture2D( maskTexture, vUv - uvOffset.xy);
					vec4 c3 = texture2D( maskTexture, vUv + uvOffset.yw);
					vec4 c4 = texture2D( maskTexture, vUv - uvOffset.yw);
					float diff1 = (c1.r - c2.r)*0.5;
					float diff2 = (c3.r - c4.r)*0.5;
					float d = length( vec2(diff1, diff2) );
					float a1 = min(c1.g, c2.g);
					float a2 = min(c3.g, c4.g);
					float visibilityFactor = min(a1, a2);
					vec3 edgeColor = 1.0 - visibilityFactor > 0.001 ? visibleEdgeColor : hiddenEdgeColor;
					gl_FragColor = vec4(edgeColor, 1.0) * vec4(d);
				}`
    });
  }
  getSeperableBlurMaterial(e) {
    return new xt({
      defines: {
        MAX_RADIUS: e
      },
      uniforms: {
        colorTexture: { value: null },
        texSize: { value: new G(0.5, 0.5) },
        direction: { value: new G(0.5, 0.5) },
        kernelRadius: { value: 1 }
      },
      vertexShader: `varying vec2 vUv;

				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`,
      fragmentShader: `#include <common>
				varying vec2 vUv;
				uniform sampler2D colorTexture;
				uniform vec2 texSize;
				uniform vec2 direction;
				uniform float kernelRadius;

				float gaussianPdf(in float x, in float sigma) {
					return 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;
				}

				void main() {
					vec2 invSize = 1.0 / texSize;
					float sigma = kernelRadius/2.0;
					float weightSum = gaussianPdf(0.0, sigma);
					vec4 diffuseSum = texture2D( colorTexture, vUv) * weightSum;
					vec2 delta = direction * invSize * kernelRadius/float(MAX_RADIUS);
					vec2 uvOffset = delta;
					for( int i = 1; i <= MAX_RADIUS; i ++ ) {
						float x = kernelRadius * float(i) / float(MAX_RADIUS);
						float w = gaussianPdf(x, sigma);
						vec4 sample1 = texture2D( colorTexture, vUv + uvOffset);
						vec4 sample2 = texture2D( colorTexture, vUv - uvOffset);
						diffuseSum += ((sample1 + sample2) * w);
						weightSum += (2.0 * w);
						uvOffset += delta;
					}
					gl_FragColor = diffuseSum/weightSum;
				}`
    });
  }
  getOverlayMaterial() {
    return new xt({
      uniforms: {
        maskTexture: { value: null },
        edgeTexture1: { value: null },
        edgeTexture2: { value: null },
        patternTexture: { value: null },
        edgeStrength: { value: 1 },
        edgeGlow: { value: 1 },
        usePatternTexture: { value: 0 }
      },
      vertexShader: `varying vec2 vUv;

				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`,
      fragmentShader: `varying vec2 vUv;

				uniform sampler2D maskTexture;
				uniform sampler2D edgeTexture1;
				uniform sampler2D edgeTexture2;
				uniform sampler2D patternTexture;
				uniform float edgeStrength;
				uniform float edgeGlow;
				uniform bool usePatternTexture;

				void main() {
					vec4 edgeValue1 = texture2D(edgeTexture1, vUv);
					vec4 edgeValue2 = texture2D(edgeTexture2, vUv);
					vec4 maskColor = texture2D(maskTexture, vUv);
					vec4 patternColor = texture2D(patternTexture, 6.0 * vUv);
					float visibilityFactor = 1.0 - maskColor.g > 0.0 ? 1.0 : 0.5;
					vec4 edgeValue = edgeValue1 + edgeValue2 * edgeGlow;
					vec4 finalColor = edgeStrength * maskColor.r * edgeValue;
					if(usePatternTexture)
						finalColor += + visibilityFactor * (1.0 - maskColor.r) * (1.0 - patternColor.r);
					gl_FragColor = finalColor;
				}`,
      blending: za,
      depthTest: !1,
      depthWrite: !1,
      transparent: !0
    });
  }
}
un.BlurDirectionX = new G(1, 0);
un.BlurDirectionY = new G(0, 1);
const dM = {
  uniforms: {
    tDiffuse: { value: null }
  },
  vertexShader: (
    /* glsl */
    `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			vec4 tex = texture2D( tDiffuse, vUv );

			gl_FragColor = LinearTosRGB( tex );

		}`
  )
};
class ni extends sd {
  constructor(t) {
    super();
    // 控制所有的 DOM 事件订阅取消
    k(this, "event_controller", new AbortController());
    // 渲染器
    k(this, "renderer");
    k(this, "outline_composer");
    k(this, "outline_pass");
    // 主场景
    k(this, "scene");
    // 主场景摄像机
    k(this, "camera");
    // 摄像头动画工具
    k(this, "camera_animation");
    // 文件加载器
    k(this, "file_loader");
    // json对象加载器
    k(this, "object_loader");
    // 场景地址
    k(this, "scene_url");
    // 状态统计对象
    k(this, "stats");
    // requestAnimationFrame返回的编号
    k(this, "next_frame_request");
    // dom对象
    k(this, "dom");
    // 摄像机控制插件
    k(this, "controls");
    // 存储所有的地图Mesh
    k(this, "map_group");
    // 主场景摄像机target
    k(this, "target", new b());
    // 鼠标触发mousedown时的屏幕坐标
    k(this, "mousedown_xy");
    // 鼠标触发mouseup时的屏幕坐标
    k(this, "mouseup_xy");
    // 点击对象
    k(this, "_click_select_obj");
    // 选中的标签卡号
    k(this, "_select_card_id");
    // 光线投射实例
    k(this, "raycaster");
    k(this, "uniforms", {});
    // 主场景中的所有模型
    k(this, "all_model_in_the_scene");
    // 所有被加载完成模型
    k(this, "all_model");
    // 存储最后一次鼠标点击的坐标
    k(this, "last_click_position");
    // 存储所有的标签号
    k(this, "all_card", []);
    // 场景中所有的区域对象
    k(this, "area_group");
    // camera的移动速度
    // private camera_speed = 1;
    // 用于标记的渲染
    k(this, "label_renderer");
    // 存储所有标签的坐标
    k(this, "all_card_animation_position");
    // 用于计算平均速度
    k(this, "all_card_position_cache", /* @__PURE__ */ new Map());
    k(this, "all_card_tween", /* @__PURE__ */ new Map());
    k(this, "tween_group", new bc());
    // 主摄像机坐标的初始坐标
    k(this, "init_camera_position", new b().addScalar(10));
    // 初始化时主摄像机看向的坐标
    k(this, "init_target_position", new b());
    // fbx的加载器
    k(this, "fbx_loader");
    // gltf的加载器
    k(this, "gltf_loader");
    // 图片纹理加载器
    k(this, "texture_loader");
    // 存储所有的用户添加的静态模型
    k(this, "all_user_custom_model");
    // fbx模型的动画合成器
    k(this, "mixers");
    // 存储用户初始化地图的参数
    k(this, "options");
    // 存储渲染的阴影
    k(this, "shadow_group");
    // 所有阴影的模型
    k(this, "all_shadow_model");
    // 所有轨迹状态的标签号
    k(this, "all_track_card", []);
    // 所有轨迹是否显示的标签号
    k(this, "all_track_card_is_show", []);
    // 所有标签轨迹的颜色
    k(this, "all_track_color", []);
    // 所有标签的轨迹超时截断时间
    k(this, "all_track_overtime", []);
    // 所有标签轨迹的坐标
    k(this, "all_track_card_position", {});
    // 所有标签轨迹的插值动画坐标
    k(this, "all_track_card_animation", {});
    // 现在巡视的标签号
    k(this, "now_patrol_card");
    // 摄像机的动画对象
    k(this, "camera_tween");
    // 所有闪烁的标签号
    k(this, "all_flash_card", []);
    // 所有区域的模型
    k(this, "all_zone_list", []);
    // 所有区域的label
    k(this, "all_zone_label", {});
    k(this, "zone_label_group", new nt());
    k(this, "zone_color_list", {});
    // 所有闪烁区域的模型
    k(this, "all_flash_zone_list", []);
    // 所有区域的材质
    k(this, "all_zone_material", []);
    // 所有区域轮廓线
    k(this, "all_zone_edge_line", []);
    // 所有区域和type对应关系
    k(this, "all_zone_id_type", {});
    // 所有区域中心点，看向区域时要用到
    k(this, "zone_center_list", {});
    // 区域闪烁的材质
    k(this, "flash_zone_material");
    // 闪烁计数
    k(this, "flash_count", 0);
    // 渲染计数
    k(this, "update_count", 0);
    // 存储所有轨迹线的数据
    k(this, "track_line_group");
    // 存储所有基站模型
    k(this, "all_base_station_model", {});
    // 摄像机旋转速度
    k(this, "camera_rotate_speed");
    k(this, "third_person_init_rotate");
    k(this, "third_person_camera_rotate");
    k(this, "third_person_card");
    k(this, "third_person_rotate_tween");
    // 轨迹的材质
    k(this, "track_material");
    k(this, "cluster_center_dict");
    k(this, "click_position_model");
    // 存储绘制线段的数据
    k(this, "line_path_dict", {});
    // 渲染绘制线段的对象
    k(this, "line_path_group");
    // 绘制线段的颜色
    k(this, "line_path_color", {});
    // 绘制线段的mesh
    k(this, "line_path_mesh");
    // 所有小地图中的标签卡模型
    k(this, "all_overview_card");
    // 渲染的小地图标签卡对象
    k(this, "overview_card_group");
    // 渲染的小地图中的对象
    k(this, "overview_map_group");
    // 渲染的小地图场景对象
    k(this, "overview_map_scene");
    // 渲染的小地图的canvas dom对象
    k(this, "overview_dom");
    // 小地图的WebGL Context对象
    k(this, "overview_map_renderer");
    k(this, "overview_map_renderer_texture");
    // 小地图的正交摄像机对象
    k(this, "overview_map_camera");
    // 小地图的标签的缩放系数
    k(this, "overview_map_card_scale");
    k(this, "target_tween");
    k(this, "buildings", {});
    k(this, "floors", {});
    k(this, "floor_building_mapping", {});
    k(this, "init_model_finish", 0);
    k(this, "init_model_count", 0);
    k(this, "tile_renderers", []);
    k(this, "dracoLoader", new ff());
    k(this, "loader", new Ns());
    // 因为3DTiles模型不管是场景还是建筑 都会涉及到要在小地图中加载 但是由于3DTiles是lod的形式加载的 所以不知道什么时候所有的tile才会全部加载到页面上 这里需要单独处理 为了应付场景中既有json模型又有3DTiles模型的情况下小地图的加载
    k(this, "overview_mesh_group", new nt());
    // 判断小地图是否进行更新
    k(this, "overview_need_update", !1);
    k(this, "overview_need_update_time", 0);
    // _animation脚本执行的时间 毫秒
    k(this, "renderer_time", 0);
    // 摄像机默认视角参数
    k(this, "camera_position");
    k(this, "target_position");
    k(this, "hover_target");
    k(this, "last_camera_rotation", 0);
    k(this, "measure_line");
    k(this, "measure_label_list", []);
    k(this, "measure_dash_line");
    k(this, "measure_dash_label");
    k(this, "measure_points", []);
    k(this, "_is_measure", !1);
    k(this, "measure_notify_element");
    k(this, "_is_measure_coordinates", !1);
    k(this, "_is_disable_building_mouse_event", !1);
    k(this, "all_cylinder_mesh_map", {});
    k(this, "all_cylinder_mesh_group", new nt());
    k(this, "all_cylinder_label_map", {});
    k(this, "large_coordinate_translate");
    /**
     * 在一张图中，使用的场景地图的平移量，但是场景地图的加载和建筑楼层等模型的加载是异步的，所以需要等待场景地图加载完成后再进行平移
     */
    k(this, "large_coordinate_translate_promise", new iM());
    k(this, "is_hide_all_card", !1);
    // 动画速度
    k(this, "_animation_speed", 1);
    // 处理鼠标点击label事件
    k(this, "_handleClickLabel", (t) => {
      const i = t.target;
      if (!i) return;
      const n = td(i), s = id(i), r = oM(i);
      if (n && s) {
        switch (s) {
          case Oe.Card:
            this.selectCard(parseInt(n));
            break;
          case Oe.BaseStation:
            this.selectModel(this.all_base_station_model[n]), this._click_select_obj = this.all_base_station_model[n];
            break;
          case Oe.Zone:
            if (r === 1) {
              this.dispatchEvent(Ae.CLICKZONE, {
                id: n,
                type: r
              });
              return;
            }
            return;
          case Oe.Cylinder:
            this._click_select_obj !== void 0 && this.unSelectModel(this._click_select_obj), this._click_select_obj = this.all_cylinder_mesh_map[n], this.highlightCylinder(n, !0), this.dispatchEvent(Ae.CLICKCYLINDER, {
              id: n
            });
            return;
          default:
            this._click_select_obj !== void 0 && this.unSelectModel(this._click_select_obj);
            const u = "model_" + n + "_" + s;
            this._click_select_obj = this.all_user_custom_model[u], this.selectModel(this._click_select_obj);
            break;
        }
        const a = this._click_select_obj, l = I(this._click_select_obj).getWorldPosition(new b()), c = {
          x: l == null ? void 0 : l.x,
          y: -1 * (l == null ? void 0 : l.z),
          z: l == null ? void 0 : l.y
        };
        l.y += a.model_height;
        const h = {
          name: "clickmodel",
          model_id: n,
          model_type: s,
          position: c,
          screen_coord: this.positionToScreenXY(l),
          is_sprite: i.classList.contains("label-icon") ? 1 : 0
        };
        this.dispatchEvent(Ae.SELECTEDMODEL, h);
      } else
        throw new Error(`unknow click element, with event: ${t}`);
    });
    k(this, "_checkIsClickCylinder", () => {
      var i, n;
      const t = this.raycaster.intersectObject(this.all_cylinder_mesh_group, !0);
      if (t.length > 0) {
        if (!t[0].object.visible) return !1;
        this._click_select_obj = I(t[0].object);
        const r = (i = this._click_select_obj) == null ? void 0 : i.userData.model_id;
        if (((n = this._click_select_obj) == null ? void 0 : n.userData.model_type) === Oe.Cylinder)
          this.highlightCylinder(r, !0), this.dispatchEvent(Ae.CLICKCYLINDER, {
            id: r
          });
        else
          return !1;
        return !0;
      }
      return !1;
    });
    k(this, "_checkIsClickZone", () => {
      var i, n, s;
      const t = this.raycaster.intersectObject(this.area_group, !0);
      if (t.length > 0) {
        if (!t[0].object.visible) return !1;
        this._click_select_obj = I(t[0].object);
        const a = (i = this._click_select_obj) == null ? void 0 : i.userData.model_id, l = (n = this._click_select_obj) == null ? void 0 : n.userData.model_type, c = (s = this._click_select_obj) == null ? void 0 : s.userData.type;
        if (l === Oe.Zone && c !== 1)
          return !1;
        if (l === Oe.Zone)
          this.highlightZone(a), this.dispatchEvent(Ae.CLICKZONE, { id: a, type: c });
        else if (l === Oe.Cylinder)
          this.highlightCylinder(a, !0), this.dispatchEvent(Ae.CLICKCYLINDER, {
            id: a
          });
        else
          return !1;
        return !0;
      }
      return !1;
    });
    k(this, "_checkIsClickAnything", (t) => {
      const i = new G();
      i.x = t.offsetX / this.dom.clientWidth * 2 - 1, i.y = -(t.offsetY / this.dom.clientHeight) * 2 + 1, this.raycaster.setFromCamera(i, this.camera);
      const n = this.raycaster.intersectObject(this.scene);
      n.length > 0 && n[0].object.visible && this.dispatchEvent(Ae.MEASUREPOSITION, {
        x: n[0].point.x,
        y: -n[0].point.z,
        z: n[0].point.y
      });
    });
    k(this, "scene_load_finish", !1);
    k(this, "_createMapFileLoadProgressHandler", (t) => {
      const i = t;
      return (n) => {
        if (i !== this.scene_url) return;
        const s = n.timeStamp / 1e3, r = n.total, a = n.loaded, l = r / s, c = n.loaded / n.total;
        this.dispatchEvent(Ae.SCENELOAD, { progress: c, speed: l, total: r, loaded: a });
      };
    });
    k(this, "_handleMapFileLoadErr", (t) => {
      this.dispatchEvent(Ae.MAPLOADFAILED), console.log(t);
    });
    // 计算模型的高度
    k(this, "_calculateModelHeight", (t) => {
      const i = new os(t);
      return i.update(), i.geometry.computeBoundingBox(), I(i.geometry.boundingBox).max.y - I(i.geometry.boundingBox).min.y;
    });
    if (this._initOptions(t), this.scene_url = t.scene_url, this.dom = document.getElementById(t.dom_element), !this.dom) throw new Error("dom对象不存在");
    this.dom.style.position = "relative", this.options.is_render_outline = t.is_render_outline, this.options.open_little_map && this.options.little_map_render_width !== void 0 && this.options.little_map_width_height_ratio !== void 0 && (this.all_overview_card = {}, this.overview_card_group = new nt(), this.overview_card_group.name = "overviewCardGroup", this.overview_map_group = new nt(), this.overview_map_group.name = "overviewMapGroup", this.overview_map_scene = new or(), this.overview_map_scene.add(this.overview_card_group), this.overview_map_scene.add(this.overview_map_group), this.overview_dom = I(document.getElementById(I(this.options.ex_dom_element))), this.overview_map_renderer = new Da({ antialias: !0, preserveDrawingBuffer: !0 }), this.overview_map_renderer.setClearColor(16777215), this.overview_map_renderer.setSize(this.options.little_map_render_width, this.options.little_map_render_width / this.options.little_map_width_height_ratio), this.overview_map_renderer.clearColor(), this.overview_dom.appendChild(this.overview_map_renderer.domElement), this.overview_map_renderer_texture = new Da({ antialias: !0 }), this.overview_map_renderer_texture.setClearColor(16777215)), this.options.open_fps && this.openFPS(), this.renderer = new Da({ antialias: !0, preserveDrawingBuffer: !0, alpha: !0 }), this.renderer.outputEncoding = He, this.renderer.setClearColor(16777215, 0), this.renderer.setPixelRatio(window.devicePixelRatio), this.renderer.setSize(this.dom.clientWidth, this.dom.clientHeight), this.renderer.setViewport(0, 0, this.dom.clientWidth, this.dom.clientHeight), this.renderer.clearColor(), this.label_renderer = new Rw(), this.label_renderer.setSize(this.dom.clientWidth, this.dom.clientHeight), this.label_renderer.domElement.style.position = "absolute", this.renderer.domElement.style.position = "absolute", this.label_renderer.domElement.style.top = "0px", this.dom.appendChild(this.label_renderer.domElement), this.dom.appendChild(this.renderer.domElement), this.scene = new or(), this.camera = new gt(45, this.dom.clientWidth / this.dom.clientHeight, 0.1, 1e5), this.camera.position.set(100, 100, 100), this.camera.lookAt(0, 0, 0), this.camera.updateProjectionMatrix(), this.controls = new vx(this.camera, this.renderer.domElement), this.controls.minDistance = 5, this.controls.maxPolarAngle = Math.PI / 2.2, this.camera_animation = new Lw(this.camera, this.controls), this._click_select_obj = void 0, this._select_card_id = void 0, this.raycaster = new mx(), this.all_model_in_the_scene = new nt(), this.all_model_in_the_scene.name = "modelGroup", this.area_group = new nt(), this.area_group.name = "areaGroup", this.all_user_custom_model = {}, this.all_model = {}, this.mixers = [], this.scene.add(this.all_model_in_the_scene), this.scene.add(this.area_group), this.scene.add(this.zone_label_group), this.line_path_group = new nt(), this.scene.add(this.line_path_group), this.track_line_group = new nt(), this.track_line_group.name = "trackLineGroup", this.track_material = new As({
      linewidth: 5,
      // in pixels
      vertexColors: !0,
      resolution: new G(this.dom.clientWidth, this.dom.clientHeight),
      dashed: !1,
      alphaToCoverage: !1
    }), this.scene.add(this.track_line_group), this.map_group = new nt(), this.map_group.name = "mapGroup", this.scene.add(this.map_group), this.object_loader = new Hd(), this.file_loader = new Ai(), this.scene.add(this.all_cylinder_mesh_group), this.options.open_shadow && this.options.shadow_model_url && (this.all_shadow_model = [], this.shadow_group = new nt(), this.shadow_group.name = "shadowGroup", this.scene.add(this.shadow_group), this._loadJsonModel(this.options.shadow_model_url, "shadow")), this.options.show_click_marker && this.options.marker_model_url && this._loadJsonModel(this.options.marker_model_url, "marker"), this._createOutlineComposer(), this._bindDefaultDomEvents(), this.dracoLoader.setDecoderPath("/three/libs/draco/gltf/"), this.loader.setDRACOLoader(this.dracoLoader), this._loadSceneMapFile(), this.options.buildings && this._initSceneRender();
  }
  // 初始化配置项
  _initOptions(t) {
    this.options = t, this.options.flash_speed === void 0 && (this.options.flash_speed = gb), this.options.open_fps === void 0 && (this.options.open_fps = _b), this.options.card_type === void 0 && (this.options.card_type = mb), this.options.open_little_map === void 0 && (this.options.open_little_map = fb), this.options.ex_dom_element === void 0 && (this.options.ex_dom_element = pb), this.options.offset_top === void 0 && (this.options.offset_top = vb), this.options.offset_left === void 0 && (this.options.offset_left = yb), this.options.track_height === void 0 && (this.options.track_height = xb), this.options.track_animation_length === void 0 && (this.options.track_animation_length = wb), this.options.track_position_length === void 0 && (this.options.track_position_length = bb), this.options.select_color === void 0 && (this.options.select_color = Tb), this.options.flash_color_1 === void 0 && (this.options.flash_color_1 = Ab), this.options.flash_color_2 === void 0 && (this.options.flash_color_2 = Eb), this.options.scale_dist === void 0 && (this.options.scale_dist = Cb), this.options.cache_time === void 0 && (this.options.cache_time = Lb), this.options.camera_tween_speed === void 0 && (this.options.camera_tween_speed = Ib), this.options.camera_speed === void 0 && (this.options.camera_speed = Db), this.options.camera_rotate_speed === void 0 && (this.options.camera_rotate_speed = Ob), this.options.camera_model_patrol_dist === void 0 && (this.options.camera_model_patrol_dist = kb), this.options.patrol_circle_number === void 0 && (this.options.patrol_circle_number = Nb), this.options.animation_enable === void 0 && (this.options.animation_enable = Pb), this.options.cluster_enable === void 0 && (this.options.cluster_enable = Rb), this.options.camera_dist === void 0 && (this.options.camera_dist = zb), this.options.third_person_target_height === void 0 && (this.options.third_person_target_height = Fb), this.options.third_person_dist === void 0 && (this.options.third_person_dist = Bb), this.options.third_person_camera_height === void 0 && (this.options.third_person_camera_height = Ub), this.options.animation_time === void 0 && (this.options.animation_time = Vb), this.options.card_texture_scale === void 0 && (this.options.card_texture_scale = sr), this.options.sprite_texture_scale === void 0 && (this.options.sprite_texture_scale = Gb), this.options.animation_speed_point === void 0 && (this.options.animation_speed_point = Hb), this.options.animation_delay_time_point === void 0 && (this.options.animation_delay_time_point = Wb), this.options.animation_delay_time === void 0 && (this.options.animation_delay_time = Xb), this.options.camera_position && (this.camera_position = t.camera_position), this.options.target_position && (this.target_position = t.target_position);
  }
  // 判断是否需要使用建筑或楼层的灯光
  _changeSceneLight() {
    if (!this.scene_url)
      for (const t in this.buildings)
        this.buildings[t] && (this.overview_mesh_group.add(this.buildings[t].light_group.clone()), this.map_group.add(this.buildings[t].light_group));
  }
  // 判断是否需要使用建筑或楼层的相机参数
  _changeSceneCamera() {
    if (!this.scene_url) {
      for (const t in this.buildings)
        if (this.buildings[t]) {
          const i = this.buildings[t].getUserData();
          if (i.camera) {
            this._setCameraFromJson(i.camera);
            return;
          }
        }
    }
  }
  // 根据user_data，设置相机的参数
  async _setCameraFromJson(t) {
    let i;
    if (t instanceof gt)
      i = t;
    else if (t instanceof Object)
      i = await this.object_loader.parseAsync(t);
    else
      throw new Error("camera_json type error");
    await this._setCameraFromObject(i);
  }
  _setCameraDefaultView() {
    !this.camera_position || !this.target_position || (this.camera.position.set(Number(this.camera_position.x), Number(this.camera_position.y), Number(this.camera_position.z)), this.camera.updateMatrixWorld(), this.camera.updateProjectionMatrix(), this.controls.target.set(Number(this.target_position.x), Number(this.target_position.y), Number(this.target_position.z)), this.controls.update(), this.controls.saveState());
  }
  async _setCameraFromObject(t) {
    await this.large_coordinate_translate_promise.promise, this.camera.copy(t), this.camera.aspect = I(this.dom).clientWidth / I(this.dom).clientHeight, this.camera_position && this.camera.position.set(Number(this.camera_position.x), Number(this.camera_position.y), Number(this.camera_position.z)), this.applyCoordinateTranslate(this.camera.position), this.camera.updateMatrixWorld(), this.camera.updateProjectionMatrix(), this.init_camera_position = this.camera.position.clone();
    const i = new os(this.map_group);
    i.geometry.computeBoundingBox();
    const n = this.target_position ? this.target_position : I(i.geometry.boundingBox).getCenter(new b());
    this.target_position ? (this.controls.target.set(Number(n.x), Number(n.y), Number(n.z)), this.applyCoordinateTranslate(this.controls.target)) : this.controls.target.copy(n), this.controls.update(), this.controls.saveState(), this.init_target_position = this.controls.target.clone();
  }
  // 判断整个场景、建筑和楼层模型是否都加载完了
  _checkInitModelIsFinish(t) {
    this.init_model_finish++, (this.init_model_count === this.init_model_finish && !this.scene_load_finish || t) && (this._changeSceneLight(), this._changeSceneCamera(), this.options.open_little_map && this._createOverviewMap(), this._animation(), this.dispatchEvent(Ae.SCENEPARSEFINISH), this.scene_load_finish = !0);
  }
  // 处理鼠标按键按下事件
  _handleDomMouseDown(t) {
    this.mousedown_xy = [t.clientX, t.clientY], this.controls.enabled && this.dispatchEvent(Ae.MOUSEDOWN, t);
  }
  // 处理鼠标按键松开事件
  _handleDomMouseUp(t) {
    this.mouseup_xy = [t.clientX, t.clientY], this.controls.enabled && this.dispatchEvent(Ae.MOUSEUP, t);
  }
  // 获得两点之间直线距离
  static _getTwoPointLineDistance(t, i) {
    return t.length === 2 ? Math.sqrt((t[0] - i[0]) * (t[0] - i[0]) + (t[1] - i[1]) * (t[1] - i[1])) : Math.sqrt((t[0] - i[0]) * (t[0] - i[0]) + (t[1] - i[1]) * (t[1] - i[1]) + (t[2] - i[2]) * (t[2] - i[2]));
  }
  // 选中模型
  selectModel(t) {
    return t === void 0 ? !1 : (t.isSprite || (t.independent_material === void 0 && (t.material = t.material.clone(), this.options.open_little_map && (t.model_type === Oe.Card && this.all_overview_card[t.model_id] && (this.all_overview_card[t.model_id].material = t.material), t.isSkinnedMesh && t.parent && t.parent.model_type === Oe.Card && this.all_overview_card[t.parent.model_id] && (this.all_overview_card[t.parent.model_id].material = t.material)), t.independent_material = !0), t.material.emissive.setHex(I(this.options.select_color))), !0);
  }
  // 取消选中模型
  unSelectModel(t) {
    var i, n;
    return t === void 0 ? !1 : (t.isSprite || (n = (i = t == null ? void 0 : t.material) == null ? void 0 : i.emissive) == null || n.setHex(t.init_emissive_color), !0);
  }
  // 地图点击显示定位模型
  _clickShowPosition(t, i, n) {
    if (this.all_model.marker !== void 0) {
      if (this.click_position_model === void 0) {
        const s = this.all_model.marker;
        s && s.type === At.JSON ? this.click_position_model = s.content : console.error("需要先加载marker_model_url模型，且marker_model_url模型需要为json格式"), this.scene.add(this.click_position_model);
      }
      this.click_position_model.position.set(t, i, n);
    }
  }
  // 转换坐标为屏幕像素坐标
  positionToScreenXY(t) {
    if (!this.dom) throw new Error("dom对象不存在");
    const i = this.dom.clientWidth, n = this.dom.clientHeight, s = t.clone().project(this.camera);
    return {
      x: (s.x + 1) * i / 2,
      y: (-s.y + 1) * n / 2,
      z: s.z
    };
  }
  getNewHoverTarget(t) {
    var i, n, s, r, a, l, c, h, u, d, f, m, _, p, g, x;
    ((t == null ? void 0 : t.type) !== ((i = this.hover_target) == null ? void 0 : i.type) || (t == null ? void 0 : t.id) !== ((n = this.hover_target) == null ? void 0 : n.id)) && (((s = this.hover_target) == null ? void 0 : s.type) === Wt.Building && (this.buildings[this.hover_target.id] ? this.buildings[this.hover_target.id].leaveHover() : this.hover_target = void 0), ((r = this.hover_target) == null ? void 0 : r.type) === Wt.Floor && (this.floors[(a = this.hover_target) == null ? void 0 : a.id] ? this.floors[(l = this.hover_target) == null ? void 0 : l.id].leaveHover() : this.hover_target = void 0), ((c = this.hover_target) == null ? void 0 : c.type) === Oe.Zone && (((h = this._click_select_obj) == null ? void 0 : h.userData.model_type) !== Oe.Zone || ((u = this._click_select_obj) == null ? void 0 : u.userData.model_id) !== this.hover_target.id) && this.removeHighlightZone((d = this.hover_target) == null ? void 0 : d.id), ((f = this.hover_target) == null ? void 0 : f.type) === Oe.Cylinder && (((m = this._click_select_obj) == null ? void 0 : m.userData.model_type) !== Oe.Cylinder || ((_ = this._click_select_obj) == null ? void 0 : _.userData.model_id) !== this.hover_target.id) && this.removeHighlightCylinder((p = this.hover_target) == null ? void 0 : p.id), (t == null ? void 0 : t.type) === Wt.Building && (this.buildings[t.id] ? this.buildings[t.id].onHover() : t = void 0), (t == null ? void 0 : t.type) === Wt.Floor && (this.floors[t == null ? void 0 : t.id] ? this.floors[t == null ? void 0 : t.id].onHover() : t = void 0), (t == null ? void 0 : t.type) === Oe.Zone && (this.all_zone_id_type[t == null ? void 0 : t.id] === 1 ? this.highlightZone(t == null ? void 0 : t.id) : t = void 0), (t == null ? void 0 : t.type) === Oe.Cylinder && (((g = this._click_select_obj) == null ? void 0 : g.userData.model_type) === Oe.Cylinder || ((x = this._click_select_obj) == null ? void 0 : x.userData.model_id) === t.id ? this.highlightCylinder(t == null ? void 0 : t.id, !0) : this.highlightCylinder(t == null ? void 0 : t.id)), this.hover_target = t);
  }
  // 场景渲染的鼠标移动事件
  _handleMoveSceneRender(t) {
    if (!this.controls.enabled || !this.dom) return;
    if (this._is_measure) {
      this.inMeasureMouseMove(this.getClickPointOnMap(t), t);
      return;
    }
    const i = t.target;
    if (!i) return;
    const n = td(i), s = id(i);
    if (n && s) {
      const c = {
        model: {
          type: s,
          id: n
        }
      }, h = { type: s, id: n };
      this.getNewHoverTarget(h), this.dispatchEvent(Ae.HOVER, c);
      return;
    }
    const r = new G();
    r.x = t.offsetX / this.dom.clientWidth * 2 - 1, r.y = -(t.offsetY / this.dom.clientHeight) * 2 + 1, this.raycaster.setFromCamera(r, this.camera);
    const a = this.raycaster.intersectObject(this.scene, !0);
    let l;
    if (a.length > 0) {
      l = a[0].object, l.userData.model_type === Oe.WallMesh && (a.length > 1 ? l = a[1].object : l = void 0);
      const c = this.getOriginalCoordinate(...a[0].point.toArray());
      this.dispatchEvent(Ae.MOUSEMOVE, c);
    }
    if (l !== void 0)
      if ("model_type" in l.userData) {
        const c = {
          model: {
            type: l.userData.model_type,
            id: l.userData.model_id
          }
        };
        if (c.model.type === Wt.Building && (this._is_disable_building_mouse_event || Pa(this.buildings[c.model.id]))) {
          this.dispatchEvent(Ae.HOVER);
          return;
        }
        const h = { type: c.model.type, id: c.model.id };
        this.getNewHoverTarget(h), this.dispatchEvent(Ae.HOVER, c);
      } else if ("model_type" in I(l.parent).userData) {
        const c = {
          model: {
            type: I(l.parent).userData.model_type,
            id: I(l.parent).userData.model_id
          }
        };
        if (c.model.type === Wt.Building && (this._is_disable_building_mouse_event || Pa(this.buildings[c.model.id]))) {
          this.dispatchEvent(Ae.HOVER);
          return;
        }
        const h = { type: c.model.type, id: c.model.id };
        this.getNewHoverTarget(h), this.dispatchEvent(Ae.HOVER, c);
      } else {
        let c = !1;
        l.traverseAncestors((h) => {
          if ("model_type" in h.userData) {
            const u = {
              model: {
                type: h.userData.model_type,
                id: h.userData.model_id
              }
            };
            if (u.model.type === Wt.Building && (this._is_disable_building_mouse_event || Pa(this.buildings[u.model.id]))) {
              this.dispatchEvent(Ae.HOVER);
              return;
            }
            const d = { type: u.model.type, id: u.model.id };
            this.getNewHoverTarget(d), this.dispatchEvent(Ae.HOVER, u), c = !0;
          }
        }), c || (this.getNewHoverTarget(), this.dispatchEvent(Ae.HOVER));
      }
    else
      this.getNewHoverTarget(), this.dispatchEvent(Ae.HOVER);
  }
  // 处理是否点击中了场景中的模型，包括定位卡，基站等j
  _checkIsClickModel() {
    const t = this.raycaster.intersectObject(this.all_model_in_the_scene, !0);
    if (t.length > 0) {
      const i = t[0].object;
      if (!i.visible || i.parent && !i.parent.visible) return;
      this._click_select_obj = I(t[0].object), this.selectModel(this._click_select_obj), this._clickShowPosition(t[0].point.x, t[0].point.y, t[0].point.z), this.last_click_position = { x: t[0].point.x, y: t[0].point.y, z: t[0].point.z };
      let n = I(this._click_select_obj).getWorldPosition(new b()), s = I(this._click_select_obj).model_height, r = I(this._click_select_obj).model_id, a = I(this._click_select_obj).model_type;
      (I(this._click_select_obj).isSkinnedMesh || I(this._click_select_obj).isMesh) && I(this._click_select_obj).parent && this.all_card[I(this._click_select_obj).parent.model_id] && (n = I(this._click_select_obj).parent.getWorldPosition(new b()), s = I(this._click_select_obj).parent.model_height, r = I(this._click_select_obj).parent.model_id, a = I(this._click_select_obj).parent.model_type), a === Oe.Card ? this._select_card_id = r : this._select_card_id = void 0;
      const l = {
        x: n.x,
        y: -1 * n.z,
        z: n.y
      };
      n.y += I(s);
      const c = {
        name: "clickmodel",
        model_id: r,
        model_type: a,
        position: l,
        screen_coord: this.positionToScreenXY(n),
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        is_sprite: this._click_select_obj.isSprite ? 1 : 0
      };
      return this.dispatchEvent(Ae.SELECTEDMODEL, c), !0;
    }
    return !1;
  }
  // 处理是否点击中了场景中的模型，包括定位卡，基站等j
  _checkIsClickMap() {
    const t = this.raycaster.intersectObject(this.map_group, !0);
    if (t.length > 0) {
      this._click_select_obj = void 0, this._select_card_id = void 0, this._clickShowPosition(t[0].point.x, t[0].point.y, t[0].point.z), this.last_click_position = { x: t[0].point.x, y: t[0].point.y, z: t[0].point.z };
      let i = t[0].object;
      if (i.userData.model_type === Oe.WallMesh)
        if (t.length > 1)
          i = t[1].object;
        else
          return !1;
      let n;
      return i.traverseAncestors((s) => {
        s && "model_type" in s.userData && (n = {
          model: {
            type: s.userData.model_type,
            id: s.userData.model_id
          }
        });
      }), i && "model_type" in i.userData && (n = {
        model: {
          type: i.userData.model_type,
          id: i.userData.model_id
        }
      }), n && (this.dispatchEvent(Ae.CLICK, n), n.model.type === Wt.Building && (this._is_disable_building_mouse_event || (this.unfoldBuilding(n.model.id), Object.entries(this.buildings).forEach(([, s]) => {
        !s.isNormal && s.id !== n.model.id && (this.foldBuilding(s.id), this.dispatchEvent(Ae.FOLDBUILDING, s.id));
      }))), n.model.type === Wt.Floor && !this._is_disable_building_mouse_event && this.selectFloor(n.model.id), n.model.type === Wt.Scene && !this._is_disable_building_mouse_event && Object.entries(this.buildings).forEach(([, s]) => {
        if (s.isSelectFloor) {
          this.unfoldBuilding(s.id);
          return;
        }
        if (s.isUnfold) {
          this.foldBuilding(s.id);
          return;
        }
      })), this.dispatchEvent(Ae.CLICKPOSITION, {
        point: {
          x: t[0].point.x,
          y: -t[0].point.z,
          z: t[0].point.y
        }
      }), !0;
    }
    return !1;
  }
  // 处理鼠标点击事件
  _handleDomClick(t) {
    var n, s, r, a, l, c, h, u, d;
    if (ni._getTwoPointLineDistance(this.mousedown_xy, this.mouseup_xy) > 0.1 || !this.controls.enabled || this.mousedown_xy === void 0 || this.mouseup_xy === void 0) return;
    if (this._is_measure_coordinates) {
      this._checkIsClickAnything(t);
      return;
    }
    if (this._is_measure) {
      this.inMeasureClick(this.getClickPointOnMap(t));
      return;
    }
    if ((n = t.target) != null && n.classList.contains("label")) {
      this._handleClickLabel(t);
      return;
    }
    if (!this.dom) return;
    this._click_select_obj !== void 0 && (((r = (s = this._click_select_obj) == null ? void 0 : s.userData) == null ? void 0 : r.model_type) === Oe.Zone ? this.removeHighlightZone((l = (a = this._click_select_obj) == null ? void 0 : a.userData) == null ? void 0 : l.model_id) : ((h = (c = this._click_select_obj) == null ? void 0 : c.userData) == null ? void 0 : h.model_type) === Oe.Cylinder ? this.removeHighlightCylinder((d = (u = this._click_select_obj) == null ? void 0 : u.userData) == null ? void 0 : d.model_id) : this.unSelectModel(this._click_select_obj), this._click_select_obj = void 0);
    const i = new G();
    i.x = t.offsetX / this.dom.clientWidth * 2 - 1, i.y = -(t.offsetY / this.dom.clientHeight) * 2 + 1, this.raycaster.setFromCamera(i, this.camera), !this._checkIsClickModel() && (this._checkIsClickZone() || this._checkIsClickCylinder() || this._checkIsClickMap() || (this.dispatchEvent(Ae.CLICK), this._is_disable_building_mouse_event || Object.entries(this.buildings).forEach(([, f]) => {
      if (f.isSelectFloor) {
        this.unfoldBuilding(f.id);
        return;
      }
      if (f.isUnfold) {
        this.foldBuilding(f.id);
        return;
      }
    }), this.last_click_position = void 0));
  }
  // 处理双击事件
  _handleDomDblClick(t) {
    if (this._is_measure) {
      this.inMeasureDBClick();
      return;
    }
    if (this.dispatchEvent(Ae.DBCLICK, t), this.last_click_position) {
      if (!this.controls.enabled) return;
      let i = (this.last_click_position.x - this.camera.position.x) * (this.last_click_position.x - this.camera.position.x);
      if (i = i + (this.last_click_position.y - this.camera.position.y) * (this.last_click_position.y - this.camera.position.y), i = i + (this.last_click_position.z - this.camera.position.z) * (this.last_click_position.z - this.camera.position.z), this.camera_animation.lookAt(new b(this.last_click_position.x, this.last_click_position.y, this.last_click_position.z)), i > 9) {
        i = Math.sqrt(i);
        const n = this.last_click_position.x + (this.camera.position.x - this.last_click_position.x) * 3 / i, s = this.last_click_position.y + (this.camera.position.y - this.last_click_position.y) * 3 / i, r = this.last_click_position.z + (this.camera.position.z - this.last_click_position.z) * 3 / i;
        this.camera_animation.moveTo(new b(n, s, r));
      }
    }
  }
  // 处理触摸开始事件
  _handleDomTouchStart(t) {
    this.dispatchEvent(Ae.TOUCHSTART, t), t.targetTouches && t.targetTouches.length === 1 && (this.mousedown_xy = [t.targetTouches[0].clientX, t.targetTouches[0].clientY]);
  }
  /*
   * 处理触摸结束事件
   *
   * 在MapControls中，阻止了touchstart的默认事件，所以没法触发点击事件，
   * 在移动端会出现没法点击的BUG，为了降低之后更新MapControls的难度，将touch有关事件
   * 放到这里来处理
   */
  _handleDomTouchEnd(t) {
    this.dispatchEvent(Ae.TOUCHEND, t), t.changedTouches && t.changedTouches.length === 1 && (this.mouseup_xy = [t.changedTouches[0].clientX, t.changedTouches[0].clientY], ni._getTwoPointLineDistance(this.mousedown_xy, this.mouseup_xy) < 0.1 && I(this.dom).dispatchEvent(new MouseEvent("click", {
      clientX: this.mouseup_xy[0],
      clientY: this.mouseup_xy[1]
    })));
  }
  // 处理触摸移动事件
  _handleDomTouchMove(t) {
    this.dispatchEvent(Ae.TOUCHMOVE, t);
  }
  // 设置地图的大小
  updateSize() {
    const t = I(this.dom).clientWidth, i = I(this.dom).clientHeight;
    this.camera.aspect = t / i, this.camera.updateProjectionMatrix(), this.renderer.setSize(t, i), this.label_renderer.setSize(t, i);
  }
  // 处理浏览器切换事件
  _handleVisibilityChange() {
    document.visibilityState === "hidden" ? (this.options.animation_enable = !1, this.endAllTween()) : this.options.animation_enable = !0;
  }
  // 处理浏览器暂停事件
  _handleAppPause() {
    this.options.animation_enable = !1;
    for (const t in this.all_card) {
      const i = parseInt(t);
      this.all_card_animation_position[i] = [];
    }
  }
  // 处理浏览器继续事件
  _handleAppResume() {
    this.options.animation_enable = !0;
  }
  _handleContextLost(t) {
    console.log("webgl context lost"), window.location.reload(), t.preventDefault(), cancelAnimationFrame(this.next_frame_request);
  }
  _handleContextRestored() {
    console.log("webgl context restored"), this.next_frame_request = requestAnimationFrame(() => {
      this._animation();
    });
  }
  // 给渲染容器绑定默认的事件
  _bindDefaultDomEvents() {
    this.dom && (this.dom.addEventListener("pointerdown", this._handleDomMouseDown.bind(this), { signal: this.event_controller.signal }), this.dom.addEventListener("pointerup", this._handleDomMouseUp.bind(this), { signal: this.event_controller.signal }), this.dom.addEventListener("click", this._handleDomClick.bind(this), { signal: this.event_controller.signal }), this.dom.addEventListener("mousemove", this._handleMoveSceneRender.bind(this), { signal: this.event_controller.signal }), this.dom.addEventListener("dblclick", this._handleDomDblClick.bind(this), !1), this.dom.addEventListener("touchstart", this._handleDomTouchStart.bind(this), { signal: this.event_controller.signal }), this.dom.addEventListener("touchend", this._handleDomTouchEnd.bind(this), { signal: this.event_controller.signal }), this.dom.addEventListener("touchmove", this._handleDomTouchMove.bind(this), { signal: this.event_controller.signal }), this.controls.addEventListener("change", () => {
      this.dispatchEvent(Ae.VIEWCHANGE);
    }), this.renderer.getContext().canvas.addEventListener("webglcontextlost", this._handleContextLost.bind(this), { signal: this.event_controller.signal }), this.renderer.getContext().canvas.addEventListener("webglcontextrestored", this._handleContextRestored.bind(this), { signal: this.event_controller.signal }), window.addEventListener("resize", () => {
      this.updateSize();
    }, { signal: this.event_controller.signal }), this.options.animation_enable && (this.all_card_animation_position = [], document.addEventListener("visibilitychange", this._handleVisibilityChange.bind(this), { signal: this.event_controller.signal }), document.addEventListener("pause", this._handleAppPause.bind(this), { signal: this.event_controller.signal }), document.addEventListener("resume", this._handleAppResume.bind(this), { signal: this.event_controller.signal })));
  }
  openFPS() {
    this.stats = new Vf(), this.dom !== null && this.dom.appendChild(this.stats.dom);
  }
  closeFPS() {
    this.dom !== null && this.dom.removeChild(this.stats.dom);
  }
  getCameraRotation() {
    const t = new b();
    this.camera.getWorldDirection(t);
    const i = Math.atan2(t.x, t.z), n = Math.PI - Math.abs(i);
    return i > 0 ? n : -n;
  }
  _animation(t) {
    t && (this.renderer_time = t), Wd(), this.controls.update(), this.camera.updateMatrixWorld();
    const i = this.getCameraRotation();
    i !== this.last_camera_rotation && (this.dispatchEvent(Ae.CAMERAROTATION, this.getCameraRotation()), this.last_camera_rotation = i), t && this.uniforms.time && (this.uniforms.time.value = t / 1e3), this.tile_renderers.forEach(
      (n) => {
        n.update();
      }
    );
    for (const n in this.mixers)
      this.mixers[n].update(this.mixers[n].clock.getDelta());
    if (this._updateSelectModelScreenCoordinates(), this.overview_need_update && this.options.open_little_map && t && t - this.overview_need_update_time >= 5e3 && (this._createOverviewMap(), this.overview_need_update = !1), this.options.open_little_map && this.overview_map_camera && (this.overview_map_camera.updateProjectionMatrix(), this.overview_map_renderer.render(this.overview_map_scene, this.overview_map_camera)), this.options.is_render_outline ? this.outline_composer.render() : this.renderer.render(this.scene, this.camera), this.label_renderer.render(this.scene, this.camera), this.stats && this.stats.update(), this.options.animation_enable && this.tween_group.update(), this.updateAllCylinderPositionWithCard(), this._updateCardTrack(), this.options.cluster_enable && this.update_count >= 20 && (this._updateCardCluster(), this.update_count = 0), this.options.cluster_enable && this._updateCardClusterLabel(), this.flash_count >= 60 / I(this.options.flash_speed)) {
      for (const n in this.all_flash_card) {
        const s = this.all_flash_card[n].material;
        "isSpriteMaterial" in s ? s.opacity = s.opacity === 1 ? 0 : 1 : this.all_flash_card[n].emissive === this.options.flash_color_1 ? (s.emissive.setHex(I(this.options.flash_color_2)), this.all_flash_card[n].emissive = this.options.flash_color_2) : (s.emissive.setHex(I(this.options.flash_color_1)), this.all_flash_card[n].emissive = this.options.flash_color_1);
      }
      this.all_flash_zone_list.length && (this.flash_zone_material.color.getHex() === this.options.flash_color_1 ? this.flash_zone_material.color.setHex(I(this.options.flash_color_2)) : this.flash_zone_material.color.setHex(I(this.options.flash_color_1))), this.flash_count = 0;
    }
    this.flash_count++, this.update_count++, this.third_person_card && this._updateThirdPersonCamera(), this.now_patrol_card && this._updateCamera(), this.next_frame_request = requestAnimationFrame(this._animation.bind(this)), this.dispatchEvent(Ae.FRAMERENDERFINISH);
  }
  _playCardAnimation(t, i = 1) {
    const n = this.mixers[t];
    n && (n.timeScale = i);
  }
  endAllTween() {
    for (const t in this.all_card_animation_position) {
      const i = Number(t);
      this.endTween(i);
    }
    this.all_card_animation_position = [], this.tween_group.removeAll(), this.all_card_tween.clear(), this.all_card_position_cache.clear();
  }
  endTween(t) {
    var r;
    const i = this.all_card_animation_position[t], n = this.all_card_tween.get(t), s = (r = this.all_card[t]) == null ? void 0 : r.model;
    for (n == null || n.stop(); i && i.length > 0; ) {
      const a = i[0];
      this._addTrackCardPositionData(t, a.x, a.y, a.z, !1, a.is_skip), s == null || s.position.set(a.x, a.y, a.z), i.shift();
    }
    this.all_card_tween.delete(t), delete this.all_card_animation_position[t], this.all_card_position_cache.delete(t), this._pauseCardAnimation(t);
  }
  _getCardNextTween(t) {
    const i = this.all_card_animation_position[t];
    if (!i || i.length < 2)
      return null;
    const [n, s] = i, r = s.time - n.time, a = { ...n }, l = { ...s };
    return {
      from: a,
      to: l,
      duration: r
    };
  }
  /**
   * 取最新的n个点，计算平均速度
   * @param card_id
   * @param n 点数
   * @returns 平均速度
   */
  _getCardAvgSpeed(t, i) {
    const n = this.all_card_position_cache.get(t);
    if (i < 1 || !n || n.length < 2)
      return console.warn("至少需要两个点计算平均速度"), 1 / 0;
    const s = n.slice(-i - 1), r = s[0].time, l = s[s.length - 1].time - r;
    if (l <= 0)
      return console.warn(`[SDK]: animation track point time interval is ${l}, must be greater than 0.`), 1 / 0;
    let c = 0;
    for (let h = 0; h < s.length - 1; h++) {
      const u = s[h], d = s[h + 1];
      c += ni._getTwoPointLineDistance(
        [u.x, u.y, u.z],
        [d.x, d.y, d.z]
      );
    }
    return c / l;
  }
  _getCardTotalDuration(t) {
    const i = this.all_card_animation_position[t];
    return !i || i.length <= 1 ? 0 : i[i.length - 1].time - i[0].time;
  }
  _shiftCachePoints(t) {
    const i = this.all_card_position_cache.get(t);
    i && i.length > I(this.options.animation_speed_point) + 1 && i.shift();
  }
  _cardPositionTween(t) {
    const i = this._getCardNextTween(t);
    if (!i)
      return;
    let n = this.all_card_tween.get(t);
    if ((this.all_card[t].is_start_animation || this._getCardTotalDuration(t) >= I(this.options.cache_time || 0) * 1e3) && !n) {
      let r = 0;
      const { from: a, to: l, duration: c } = i, h = I(this.options.animation_speed_point);
      if (h !== 1) {
        const f = this._getCardAvgSpeed(t, h);
        r = ni._getTwoPointLineDistance([a.x, a.y, a.z], [l.x, l.y, l.z]) / f;
      } else
        r = c;
      this.options.animation_delay_time_point && (r = r > this.options.animation_delay_time_point * 1e3 ? 500 : r);
      const u = this.all_card_animation_position[t][0].is_skip, d = I(this.all_card[t].model);
      n = new Bt(d.position, this.tween_group).to(l, r / this._animation_speed).onStart(() => {
        this._playCardAnimation(t, this._animation_speed), this.all_card[t].is_start_animation = !0;
        const f = ni._getNextPointRotate(a, l);
        d.rotation.y = f;
      }).easing(qi.Linear.None).onUpdate((f) => {
        this._addTrackCardPositionData(t, f.x, f.y, f.z, !0), this.options.open_shadow && !this.options.buildings && this.all_shadow_model[t].position.set(f.x, f.y, f.z), this.options.open_little_map && this.all_overview_card[t] && this.all_overview_card[t].position.set(f.x, f.y, f.z);
      }).onComplete(() => {
        var f;
        this.all_card_tween.delete(t), (f = this.all_card_animation_position[t]) == null || f.shift(), this._shiftCachePoints(t), this._addTrackCardPositionData(t, l.x, l.y, l.z, !1, u), this._pauseCardAnimation(t), this.options.animation_enable && this.all_card[t] && this._cardPositionTween(t);
      }).start(), this.all_card_tween.set(t, n);
    }
  }
  _pauseCardAnimation(t) {
    const i = this.mixers[t];
    i && (i.timeScale = 0.01);
  }
  // 更新摄像机位置
  _updateCamera() {
    if (this.now_patrol_card && this.all_card[this.now_patrol_card]) {
      const i = I(this.all_card[this.now_patrol_card].model).getWorldPosition(new b()), n = this.positionToScreenXY(i);
      if (ni._getTwoPointLineDistance([n.x, n.y], [I(this.dom).clientWidth / 2, I(this.dom).clientHeight / 2]) > 100 && !this.target_tween) {
        if (ni._getTwoPointLineDistance([i.x, i.y, i.z], [this.controls.target.x, this.controls.target.y, this.controls.target.z]) < 1) return;
        this.target_tween = new Bt(this.controls.target), this.target_tween.to({
          x: i.x,
          y: i.y,
          z: i.z
        }, 500), this.target_tween.onComplete(() => {
          mi(I(this.target_tween)), this.target_tween = void 0;
        }), this.target_tween.start();
      }
      const r = ni._getTwoPointLineDistance([i.x, i.y, i.z], [this.camera.position.x, this.camera.position.y, this.camera.position.z]);
      if ((r > I(this.options.camera_model_patrol_dist) * 1.25 || r < I(this.options.camera_model_patrol_dist) * 0.75) && !this.camera_tween) {
        const a = i.x + (this.camera.position.x - i.x) * I(this.options.camera_model_patrol_dist) / r, l = i.y + (this.camera.position.y - i.y) * I(this.options.camera_model_patrol_dist) / r, c = i.z + (this.camera.position.z - i.z) * I(this.options.camera_model_patrol_dist) / r;
        this.camera_tween = new Bt(this.camera.position), this.camera_tween.to({
          x: a,
          y: l,
          z: c
        }, 1e3 * I(this.options.camera_tween_speed)), this.camera_tween.onComplete(() => {
          mi(I(this.camera_tween)), this.camera_tween = void 0;
        }), this.camera_tween.start();
      }
    }
  }
  _updateLinePath() {
    if (this.line_path_group.clear(), this.line_path_group.traverse((t) => {
      t.type === "Mesh" && (I(t).geometry.dispose(), Array.isArray(I(t).material) ? I(t).material.forEach(
        (i) => {
          i.dispose();
        }
      ) : I(t).material.dispose());
    }), this.line_path_dict && this.line_path_color) {
      const t = [], i = [];
      for (const n in this.line_path_dict) {
        const s = [], r = [];
        for (const a in this.line_path_dict[n])
          s.push(this.line_path_dict[n][a].x), s.push(this.line_path_dict[n][a].y), s.push(this.line_path_dict[n][a].z), r.push(this.line_path_color[n].r), r.push(this.line_path_color[n].g), r.push(this.line_path_color[n].b);
        s && (t.push(s), i.push(r));
      }
      this.line_path_mesh = this._createLine2(t, i), this.line_path_group.add(this.line_path_mesh);
    }
  }
  // 更新被选中模型的屏幕坐标
  _updateSelectModelScreenCoordinates() {
    var r;
    if (!this._click_select_obj || ((r = this._click_select_obj) == null ? void 0 : r.userData.model_type) === Oe.Zone) return;
    let t = this._click_select_obj.getWorldPosition(new b()), i = this._click_select_obj.model_height;
    this._click_select_obj.isSkinnedMesh && this._click_select_obj.parent && this.all_card[I(this._click_select_obj.parent).model_id] && (t = this._click_select_obj.parent.getWorldPosition(new b()), i = I(this._click_select_obj.parent).model_height), this._click_select_obj.isSprite && (i = 1);
    const n = { x: t.x, y: -1 * t.z, z: t.y };
    i && (t.y += I(i));
    const s = {
      position: n,
      screen_coord: this.positionToScreenXY(t)
    };
    this.dispatchEvent(Ae.UPDATESELECTEDMODELPOSITION, s);
  }
  _isObjectShouldMoveToScene(t) {
    return t instanceof vi && t.isLight || t instanceof st && t.isMesh ? !0 : t instanceof nt && t.isGroup || t instanceof or && t.isScene ? t.children.length > 0 : !1;
  }
  getLargeCoordinateTranslate(t, i = 10 * 1e3) {
    var r;
    const n = new os(t);
    n.geometry.computeBoundingBox();
    const s = new b();
    return (r = n.geometry.boundingBox) == null || r.getCenter(s), s.distanceTo(new b(0, 0, 0)) > i ? s : new b(0, 0, 0);
  }
  // 移动地图文件中的灯光，场景等children
  _moveChildrenToScene(t, i) {
    var n;
    for (; t.children && t.children.length > 0; ) {
      const s = t.children[0];
      if (this._isObjectShouldMoveToScene(s)) {
        const r = new os(s);
        r.geometry.computeBoundingBox();
        const a = new b();
        (n = r.geometry.boundingBox) == null || n.getCenter(a), a.distanceTo(new b(0, 0, 0)) > 10 * 1e3 && (this.large_coordinate_translate = new b().copy(a), this.large_coordinate_translate_promise.resolve(this.large_coordinate_translate.clone()), console.debug("translate", this.large_coordinate_translate), s != null && s.isGroup ? fl(s, this.large_coordinate_translate) : s != null && s.isMesh && Ef(s, this.large_coordinate_translate)), i.add(s);
      } else
        s.removeFromParent();
    }
    this.large_coordinate_translate_promise.isPending && this.large_coordinate_translate_promise.resolve(new b(0, 0, 0));
  }
  async _loadSceneMapFile() {
    const t = new nt();
    if (t.userData.model_type = Wt.Scene, t.userData.model_id = 0, this.scene_url && this.options.type === Gi.Json) {
      let i;
      this.init_model_count++;
      let n;
      const s = this.scene_url;
      try {
        n = await this.file_loader.loadAsync(this.scene_url, this._createMapFileLoadProgressHandler(this.scene_url)), i = await this.object_loader.parseAsync(JSON.parse(n));
      } catch (r) {
        return this._handleMapFileLoadErr(r), !1;
      }
      if (this.scene_url !== s) return;
      i.userData.camera && this._setCameraFromJson(i.userData.camera), this._moveChildrenToScene(i, t), this.overview_mesh_group.add(t.clone()), this.map_group.add(t), this._setCameraDefaultView(), this._checkInitModelIsFinish(), this.dispatchEvent(Ae.JSONFILELOADED, n);
    } else if (this.scene_url && this.options.type === Gi.Tiles) {
      this.large_coordinate_translate_promise.resolve(new b(0, 0, 0)), this.large_coordinate_translate = new b(0, 0, 0), this.init_model_count++;
      const i = new df(this.scene_url);
      i.manager.addHandler(/\.gltf$/, this.loader), i.group.rotateX(-Math.PI / 2), i.setCamera(this.camera), i.setResolutionFromRenderer(this.camera, this.renderer), i.onLoadModel = (r) => {
        this.tile_renderers.indexOf(i) > -1 && (r.traverse(
          (l) => {
            l instanceof st && this.overview_mesh_group.add(l.clone());
          }
        ), this.overview_need_update = !0, this.overview_need_update_time = this.renderer_time);
      }, t.add(i.group);
      const n = this.scene_url.replace("tileset.json", "scene.json");
      let s;
      try {
        s = await this.object_loader.loadAsync(n, this._createMapFileLoadProgressHandler(this.scene_url));
      } catch (r) {
        return this._handleMapFileLoadErr(r), !1;
      }
      s.children.forEach(
        (r) => {
          r instanceof vi ? (this.overview_mesh_group.add(r.clone()), this.map_group.add(r.clone())) : r instanceof gt && this._setCameraFromObject(r);
        }
      ), this.tile_renderers.push(i), this.map_group.add(t), this._setCameraDefaultView(), this._checkInitModelIsFinish(!0);
    }
    return this.options.scene_background_images && (typeof this.options.scene_background_images == "object" ? this.scene.background = new qy().load(I(this.options.scene_background_images)) : this.scene.background = new fr().load(this.options.scene_background_images)), !0;
  }
  // 去除小地图场景中其它的mesh
  emptyScene(t) {
    for (let i = t.children.length - 1; i >= 0; i--) {
      const n = t.children[i];
      if (n.type === "Mesh") {
        if (n.removeFromParent(), I(n).geometry.dispose(), Array.isArray(I(n).material))
          for (const s in I(n).material)
            I(n).material[s].dispose();
        else
          I(n).material.dispose();
        continue;
      } else if (n.type === "Light") {
        n.removeFromParent();
        continue;
      }
      n.type === "Group" && this.emptyScene(I(n));
    }
    t.type === "Group" && t.children.length === 0 && t.removeFromParent();
  }
  // 根据加载的场景，生成小地图的顶视图图片，作为小地图的场景
  _createOverviewMap() {
    const t = I(this.options.little_map_render_width), i = I(this.options.little_map_width_height_ratio), n = t / i, s = new or();
    s.fog = this.scene.fog, s.overrideMaterial = this.scene.overrideMaterial, s.matrixWorldNeedsUpdate = this.scene.matrixWorldNeedsUpdate, s.background = new de(0.6, 0.6, 0.6), s.add(this.overview_mesh_group.clone());
    const r = new os(s);
    r.geometry.computeBoundingBox();
    const a = I(r.geometry.boundingBox).max.x - I(r.geometry.boundingBox).min.x, l = I(r.geometry.boundingBox).max.z - I(r.geometry.boundingBox).min.z, c = (I(r.geometry.boundingBox).max.x + I(r.geometry.boundingBox).min.x) / 2, h = (I(r.geometry.boundingBox).max.z + I(r.geometry.boundingBox).min.z) / 2, u = l * i > a ? l * i : a, d = u / i, f = u / 30 > 0 ? u / 30 : 1;
    f !== 1 ? (this.overview_map_card_scale = f, this.overview_card_group.traverse(
      (y) => y instanceof st && y.scale.set(f, f, f)
    )) : this.overview_map_card_scale = void 0;
    const m = Math.pow(2, Math.log(n) / Math.log(2));
    this.overview_map_renderer_texture.setSize(m * 2, m);
    const _ = new pn(-u / 2, u / 2, d / 2, -d / 2, -1e4, 1e4);
    _.position.set(c, this.target.y + 40, h), _.updateProjectionMatrix(), _.lookAt(new b(c, this.target.y, h)), this.overview_map_renderer_texture.render(s, _);
    const p = this.overview_map_renderer_texture.getContext().canvas.toDataURL("image/png"), g = new fr().load(p);
    this.overview_map_renderer_texture.resetState(), this.overview_map_renderer_texture.clear(), this.overview_map_renderer_texture.dispose(), this.emptyScene(s), this.removeGroupChildren(this.overview_map_group), this.overview_map_renderer.setSize(t, n), this.overview_map_camera = new pn(-u / 2, u / 2, d / 2, -d / 2, -1e4, 1e4), this.overview_map_camera.position.set(c, this.target.y + 40, h), this.overview_map_camera.lookAt(new b(c, this.target.y, h)), this.overview_map_camera.updateProjectionMatrix();
    const x = new st(new Pr(u, d), new gi({
      color: 16777215,
      depthTest: !1,
      map: g
    }));
    x.rotation.x = -Math.PI / 2, x.position.set(c, 0, h), this.overview_map_group.add(x);
  }
  // 清空Group的Children，如果是mesh还需要dispose操作
  removeGroupChildren(t) {
    for (; t.children.length > 0; ) {
      const i = t.children[0];
      if (i instanceof st)
        if (i.geometry.dispose(), Array.isArray(i.material))
          for (const n in i.material)
            i.material[n].map && i.material[n].map.dispose(), i.material[n].lightMap && i.material[n].lightMap.dispose(), i.material[n].bumpMap && i.material[n].bumpMap.dispose(), i.material[n].normalMap && i.material[n].normalMap.dispose(), i.material[n].specularMap && i.material[n].specularMap.dispose(), i.material[n].envMap && i.material[n].envMap.dispose(), i.material[n].dispose();
        else
          i.material.dispose();
      else i instanceof nt && i.children.length > 0 && this.removeGroupChildren(i);
      i.clear(), i.removeFromParent();
    }
    t.clear();
  }
  // 加载JSON模型,根据key保存在all_model之中
  _loadJsonModel(t, i) {
    return this.all_model[i] ? (console.error("已经存在key相同的模型"), !1) : (this.object_loader.loadAsync(
      t,
      (n) => {
        this.dispatchEvent(Ae.LOADMODEL, { progress: n.loaded / n.total * 100 });
      }
    ).then(
      (n) => {
        n.model_type = "json", n.model_height = this._calculateModelHeight(n), this.all_model[i] = Yb(n), this.dispatchEvent(Ae.LOADMODELFINISH, { key: i, data: n });
      }
    ).catch(
      (n) => {
        console.error(n);
      }
    ), !0);
  }
  // 加载FBX模型,根据key保存在all_model之中
  _loadFBXModel(t, i) {
    return this.all_model[i] ? (console.error("已经存在key相同的模型"), !1) : (this.fbx_loader === void 0 && (this.fbx_loader = new db()), this.fbx_loader.load(
      t,
      (n) => {
        I(n).model_format = "fbx", I(n).model_height = this._calculateModelHeight(n), this.all_model[i] = Zb(I(n)), this.dispatchEvent(Ae.LOADMODELFINISH, { key: i, data: n });
      },
      (n) => {
        this.dispatchEvent(Ae.LOADMODEL, { progress: n.loaded / n.total * 100 });
      },
      (n) => {
        console.error(n);
      }
    ), !0);
  }
  // 加载GLTF模型,根据key保存在all_model之中
  _loadGLTFModel(t, i) {
    return this.all_model[i] ? (console.error("已经存在key相同的模型"), !1) : (this.gltf_loader === void 0 && (this.gltf_loader = new Ns()), this.gltf_loader.load(
      t,
      (n) => {
        n.model_format = "gltf", n.model_height = this._calculateModelHeight(n), this.all_model[i] = n;
      },
      (n) => {
        this.dispatchEvent(Ae.LOADMODEL, { progress: n.loaded / n.total * 100 });
      },
      function(n) {
        console.error(n);
      }
    ), !0);
  }
  // 加载Texture，一般作为精灵的贴图
  _loadTexture(t, i) {
    return this.all_model[i] ? (console.error("已经存在key相同的模型"), !1) : (this.texture_loader === void 0 && (this.texture_loader = new fr()), this.texture_loader.load(
      t,
      (n) => {
        n.encoding = He, this.all_model[i] = Jb(n), this.dispatchEvent(Ae.LOADMODELFINISH, { key: i, data: n });
      },
      (n) => {
        this.dispatchEvent(Ae.LOADMODEL, { progress: n.loaded / n.total * 100 });
      },
      (n) => {
        console.error(n);
      }
    ), !0);
  }
  // 兼容之前的接口
  loadModel(t, i, n) {
    if (this.all_model[i])
      return console.error("已经存在key相同的模型"), !1;
    switch (n) {
      case "json":
        this._loadJsonModel(t, i);
        break;
      case "fbx":
        this._loadFBXModel(t, i);
        break;
      case "glb":
      case "gltf":
        this._loadGLTFModel(t, i);
        break;
      case "png":
      case "jpg":
      case "texture":
        this._loadTexture(t, i);
        break;
      default:
        console.error("暂不支持该格式的模型");
        break;
    }
    return !0;
  }
  // 往地图上添加静态模型
  addStaticModel(t, i, n, s, r, a, l, c) {
    if (typeof t != "string" && typeof t != "number" && console.error("参数错误，model_id必须为数字或者字符串"), isNaN(s) || isNaN(r) || isNaN(a))
      return console.error("参数错误，model_x，model_y，model_z必须为数字"), !1;
    const h = "model_" + t + "_" + n, u = this.all_model[i];
    if (u === void 0) {
      console.error(`模型${i}未加载`);
      return;
    }
    if (this.all_user_custom_model[h])
      return console.error("模型已经添加"), !1;
    let d;
    if (u.type === At.Texture) {
      let p = this.options.sprite_texture_scale ? this.options.sprite_texture_scale : sr;
      p = (l == null ? void 0 : l.texture_scale) ?? p;
      const g = (l == null ? void 0 : l.texture_center) ?? [0.5, 0], x = new G(g[0], g[1]);
      d = this._createSprite(u.content, p, x), d.model_height = 0;
    } else
      d = u.content.clone(), d.model_height = u.content.model_height;
    d.name = h, d.model_type = n, d.model_id = t;
    const { x: f, y: m, z: _ } = this.getTransformedCoordinate(s, r, a);
    if (d.position.set(f, m, _), this.options.buildings && c !== void 0 && (d.floor_id = c), l && l.text) {
      const p = sn({
        text: l.text,
        type: n,
        id: t,
        text_class: l.text_class
      });
      u.type === At.Texture && p.classList.add("label-icon");
      const g = Mi(p, new b(0, I(d.model_height), 0));
      d.add(g), d.label = g;
    }
    if (this.options.buildings && c) {
      if (!this.floors[c]) {
        console.error("没有该楼层");
        return;
      }
      this.floors[c].tag_group.add(d), this.floors[c].tag_group.layers.test(this.camera.layers) ? this.floors[c].setTagGroupVisible(!0) : this.floors[c].setTagGroupVisible(
        !1
      );
    } else
      this.all_model_in_the_scene.add(d);
    return this.all_user_custom_model[h] = d, !0;
  }
  updateStaticModelIcon(t, i, n) {
    const s = "model_" + t + "_" + i, r = this.all_model[n], a = this.all_user_custom_model[s];
    if (!a)
      return console.error("该模型还未添加"), !1;
    if (!a.isSprite)
      return console.error("该模型不是图标显示类型"), !1;
    if (r === void 0)
      return console.error("模型还未加载"), !1;
    if (r.type === At.Texture)
      this._updateSpriteTexture(a, r.content);
    else
      return console.error("仅支持图片类型的模型"), !1;
    return !0;
  }
  // 设置指定静态模型的文字label
  setStaticModelText(t, i, n, s) {
    if (s = s || {}, !i)
      return console.error("参数错误，model_type必填参数"), !1;
    const r = "model_" + t + "_" + i;
    if (this.all_user_custom_model[r]) {
      const a = this.all_user_custom_model[r];
      if (a.label)
        n !== void 0 && (a.label.element.innerHTML = n), s.remove_text_class && a.label.element.classList.remove(s.remove_text_class), s.add_text_class && a.label.element.classList.add(s.add_text_class);
      else {
        const l = sn({
          text: n,
          type: i,
          id: t,
          text_class: s.add_text_class
        });
        a.isSprite && l.classList.add("label-icon");
        const c = Mi(l, new b(0, a.model_height, 0));
        a.add(c), a.label = c;
      }
      return !0;
    }
    return console.error("不存在该静态模型"), !1;
  }
  // 删除添加的静态模型
  removeStaticModel(t, i) {
    if (!i)
      return console.error("参数错误，model_type必填参数"), !1;
    const n = "model_" + t + "_" + i;
    if (this.all_user_custom_model[n]) {
      const s = this.all_user_custom_model[n];
      return s.removeFromParent(), delete this.all_user_custom_model[n], s.label && s.label.destroy(), s.material.dispose(), s.geometry.dispose(), !0;
    }
    return console.error("不存在该静态模型"), !1;
  }
  // 删除所有添加的静态模型
  removeAllStaticModel() {
    let t = !0;
    return Object.entries(this.all_user_custom_model).forEach(
      ([i, n]) => {
        this.removeStaticModel(Number(i), I(n.model_type)) || (t = !1);
      }
    ), t;
  }
  resetAll() {
    this.reset(), this.map_group && this.removeGroupChildren(this.map_group), this.overview_mesh_group && this.removeGroupChildren(this.overview_mesh_group), this.camera.clear(), this.init_model_count = 0, this.init_model_finish = 0;
    for (const t in this.buildings)
      this.buildings[t].status = Dl.Removed;
    this.buildings = {};
    for (const t in this.floors)
      this.floors[t].status = Dl.Removed;
    this.floors = {}, this.renderer.clearColor(), this.overview_need_update = !0, this.overview_need_update_time = this.renderer_time, this.tile_renderers.forEach(
      (t) => {
        t.dispose();
      }
    ), this.tile_renderers = [], this.scene_load_finish = !1, this.scene_url = void 0;
  }
  // 重置地图
  reset() {
    this.removeGroupChildren(this.all_model_in_the_scene);
    for (const t in this.floors)
      this.all_model_in_the_scene.add(this.floors[t].tag_group);
    this.removeGroupChildren(this.area_group);
    for (const t in this.floors)
      this.area_group.add(this.floors[t].area_group);
    for (const t in this.all_zone_label)
      this.all_zone_label[t].label.removeFromParent(), this.all_zone_label[t].label.destroy();
    this.options.open_little_map && this.overview_card_group && this.removeGroupChildren(this.overview_card_group), this.options.open_shadow && this.shadow_group && this.removeGroupChildren(this.shadow_group), this.track_line_group && this.removeGroupChildren(this.track_line_group);
    for (const t in this.all_card)
      this.all_card[t].label && I(this.all_card[t].label).destroy();
    for (const t in this.all_user_custom_model)
      this.all_user_custom_model[t].label && I(this.all_user_custom_model[t].label).destroy();
    this.stopPatrol(), this.stopThirdPersonFollow(), this.stopFollowCard(), this.disableMeasureTool(), this.removeAllCylinder(), this.all_zone_list = [], this.all_zone_edge_line = [], this.all_zone_id_type = {}, this.mixers = [], this.all_shadow_model = [], this.all_overview_card = {}, this.all_card = [], this.all_flash_card = [], this.all_card_animation_position = [], this.all_track_card = [], this.all_track_card_is_show = [], this.all_track_color = [], this.all_track_card_position = {}, this.all_base_station_model = [], this.all_user_custom_model = [], this.options.animation_enable && (this.all_card_animation_position = []), this.options.cluster_enable && (this.cluster_center_dict = {}), this.all_cylinder_mesh_group.clear(), this.all_cylinder_mesh_map = {}, this.all_cylinder_label_map = {}, this.line_path_dict = {}, this.line_path_mesh = void 0, this.removeGroupChildren(this.line_path_group);
  }
  // 停止跟随定位卡
  stopFollowCard() {
    this.camera_tween && (this.camera_tween.stop(), mi(this.camera_tween), this.camera_tween = void 0), this.target_tween && (this.target_tween.stop(), mi(this.target_tween), this.target_tween = void 0), this.now_patrol_card = void 0, this.controls.enabled = !0;
  }
  // 切换地图
  changeScene(t, i, n, s = { is_always_show_floor_data: !1 }) {
    return t === void 0 ? (console.error("需要指定场景文件路径"), !1) : t === this.scene_url && nM(n, this.options.buildings) ? (this.dispatchEvent(Ae.SCENEPARSEFINISH), !0) : (n !== void 0 ? this.options.buildings = n : this.options.buildings = void 0, s.is_always_show_floor_data !== void 0 && (this.options.is_always_show_floor_data = s.is_always_show_floor_data), this.endAllTween(), this.renderer.clear(), this.renderer.resetState(), this.renderer.dispose(), cancelAnimationFrame(this.next_frame_request), this.resetAll(), this.scene_url = t, this.options.type = i, this.camera_position = s.camera_position, this.target_position = s.target_position, this.outline_pass.selectedObjects = [], this._loadSceneMapFile(), this.options.buildings && this._initSceneRender(), !0);
  }
  // 初始化场景里面的建筑和楼层模型
  _initSceneRender() {
    if (!this.options.buildings) throw new Error("options.buildings is undefined");
    this.uniforms.time = { value: 0 }, this.uniforms.uWall = { value: new de(65535) }, this.uniforms.uRing = { value: new de(255) }, this.options.buildings.forEach((t) => {
      var a;
      const i = t.id, n = t.floors, s = (a = this.options.building_distance) == null ? void 0 : a[i], r = new jb(i, t.url, t.matrix, t.type, { animation_time: this.options.animation_time });
      this.init_model_count++, r.addEventListener(Ae.MODELLOADEDFINISH, async (l) => {
        if (l.model_file_type === Gi.Tiles)
          this.scene_url || (this.large_coordinate_translate_promise.resolve(new b(0, 0, 0)), this.large_coordinate_translate = new b(0, 0, 0)), l.tile_render.setCamera(this.camera), l.tile_render.setResolutionFromRenderer(this.camera, this.renderer), l.tile_render.onLoadModel = (c) => {
            this.tile_renderers.indexOf(l.tile_render) > -1 && (c.traverse(
              (u) => {
                u instanceof st && this.overview_mesh_group.add(u.clone());
              }
            ), this.overview_need_update = !0, this.overview_need_update_time = this.renderer_time);
          }, l.mesh_group.add(l.tile_render.group), this.tile_renderers.push(l.tile_render), setTimeout(() => {
            const c = new Ht();
            l.tile_render.getBounds(c);
            const h = new ue();
            h.extractRotation(l.tile_render.group.matrixWorld), c.applyMatrix4(h).applyMatrix4(l.matrix);
            const u = $u(c, {
              time: this.uniforms.time,
              uWall: this.uniforms.uWall,
              uRing: this.uniforms.uRing
            });
            u.layers.set(1), l.setWallRingMesh(u), this.map_group.add(u);
          }, 3e3);
        else if (l.model_file_type === Gi.Json) {
          l.mesh_group.name = "building_" + i, this.scene_url ? await this.large_coordinate_translate_promise.promise : (this.large_coordinate_translate = this.getLargeCoordinateTranslate(l.mesh_group), this.large_coordinate_translate_promise.resolve(
            this.large_coordinate_translate.clone()
          )), fl(l.mesh_group, await this.large_coordinate_translate_promise.promise);
          const c = $u(new Ht().setFromObject(l.mesh_group), {
            time: this.uniforms.time,
            uWall: this.uniforms.uWall,
            uRing: this.uniforms.uRing
          });
          c.layers.set(1), l.setWallRingMesh(c), this.map_group.add(c), this.overview_mesh_group.add(l.mesh_group.clone());
        }
        l.mesh_group.userData.model_type = Wt.Building, l.mesh_group.userData.model_id = i, this.map_group.add(l.mesh_group), this._checkInitModelIsFinish();
      }), this.buildings[i] = r, n.forEach((l, c) => {
        const h = l.id, u = l.url, d = l.matrix, f = new qb(h, c, u, d, l.type, {
          animation_time: this.options.animation_time,
          is_always_show_floor_data: this.options.is_always_show_floor_data,
          floor_distance: s
        });
        this.init_model_count++, r.addFloor(h, f), this.floors[h] = f, this.floor_building_mapping[h] = r, f.addEventListener(Ae.MODELLOADEDFINISH, async (m) => {
          m.model_file_type === Gi.Tiles ? (m.tile_render.setCamera(this.camera), m.tile_render.setResolutionFromRenderer(this.camera, this.renderer), m.mesh_group.add(m.tile_render.group), this.tile_renderers.push(m.tile_render)) : m.model_file_type === Gi.Json && (fl(m.mesh_group, await this.large_coordinate_translate_promise.promise), this.overview_mesh_group.add(m.mesh_group.clone())), m.mesh_group.userData.model_type = Wt.Floor, m.mesh_group.userData.model_id = h, m.setMeshLayers(!1), this.options.is_always_show_floor_data ? m.setTagGroupVisible(!0) : m.setTagGroupVisible(!1), this.area_group.add(f.area_group), this.all_model_in_the_scene.add(f.tag_group), this.map_group.add(m.mesh_group), this._checkInitModelIsFinish();
        });
      });
    });
  }
  _parallelTraverse(t, i, n) {
    n(t, i);
    for (let s = 0; s < t.children.length; s++)
      this._parallelTraverse(t.children[s], i.children[s], n);
  }
  // 克隆FBX模型
  FbxClone(t) {
    const i = /* @__PURE__ */ new Map(), n = t.clone();
    return this._parallelTraverse(t, n, function(s, r) {
      i.set(s, r);
    }), t.traverse(function(s) {
      if (!s.isSkinnedMesh) return;
      const r = s.skeleton.bones, a = i.get(s);
      a.skeleton = s.skeleton.clone(), a.skeleton.bones = r.map(function(l) {
        if (!i.has(l))
          throw new Error("AnimationUtils: Required bones are not descendants of the given object.");
        return i.get(l);
      }), a.bind(a.skeleton, s.bindMatrix);
    }), n.animations = t.animations, I(n).model_height = I(t).model_height, n;
  }
  // 获得fbx模型的SkinnedMesh
  getFBXModelSkinnedMesh(t) {
    for (let i = 0; i < t.children.length; i++)
      if (t.children[i].type === "SkinnedMesh" || t.children[i].type === "Mesh")
        return t.children[i];
  }
  // 添加定位卡信息
  addCardInfo(t, i, n, s, r, a, l, c, h) {
    var y;
    const u = t, d = r || "card", f = this.all_model[d];
    if (isNaN(u) || isNaN(i) || isNaN(n) || isNaN(s))
      return console.error("addCardInfo 参数类型错误"), !1;
    const {
      x: m,
      y: _,
      z: p
    } = this.getTransformedCoordinate(i, n, s);
    if (f === void 0)
      return console.error("该模型还未加载，请先加载模型"), !1;
    if (this.all_card[u] !== void 0)
      return console.error("该卡已经添加"), !1;
    const g = {
      card_id: u,
      card_x: m,
      card_y: _,
      card_z: p,
      is_clustered: ii.Null
    };
    h !== void 0 && (g.floor_id = h);
    let x;
    if (f.type === At.FBX) {
      const v = I(this.FbxClone(f.content));
      v.mixer = new fu(v), v.mixer.clock = new Ml(), this.mixers[u] = v.mixer, this.mixers[u].timeScale = 0.01;
      let M = 0;
      v.animations.forEach(
        (A, w) => {
          A.name.search("walk") !== -1 && (M = w);
        }
      ), v.animations[M] && v.mixer.clipAction(v.animations[M]).play();
      const S = this.getFBXModelSkinnedMesh(v);
      if (x = S.material, v.position.set(m, _, p), v.model_id = u, S.model_id = u, v.model_type = Oe.Card, S.model_type = Oe.Card, h !== void 0 && (v.floor_id = h), l && l.scale && (v.scale.x = l.scale, v.scale.y = l.scale, v.scale.z = l.scale), S.init_emissive_color = S.material.emissive.getHex(), v.model_height = f.content.model_height, S.model_height = f.content.model_height, this.options.buildings && h) {
        if (!this.floors[h]) {
          console.error("没有该楼层");
          return;
        }
        this.floors[h].tag_group.add(v);
      } else
        this.all_model_in_the_scene.add(v);
      g.model = v, g.model_format = "fbx", g.model_height = v.model_height, this.outline_pass.selectedObjects.push(v);
    } else if (f.type === At.JSON) {
      const v = I(f.content.clone());
      if (x = v.material, v.position.set(m, _, p), v.model_id = u, v.model_type = Oe.Card, h !== void 0 && (v.floor_id = h), l && l.scale && (v.scale.x = l.scale, v.scale.y = l.scale, v.scale.z = l.scale), v.init_emissive_color = v.material.emissive.getHex(), v.model_height = f.content.model_height, this.options.buildings && h) {
        if (!this.floors[h]) {
          console.error("没有该楼层");
          return;
        }
        this.floors[h].tag_group.add(v);
      } else
        this.all_model_in_the_scene.add(v);
      g.model = v, g.model_format = "json", g.model_height = v.model_height, this.outline_pass.selectedObjects.push(v);
    } else if (f.type === At.Texture) {
      const v = this.options.card_texture_scale ? this.options.card_texture_scale : sr, M = this._createSprite(f.content, v);
      if (M.position.set(m, _, p), M.model_id = u, M.model_type = Oe.Card, M.model_height = 0, h !== void 0 && (M.floor_id = h), this.options.buildings && h) {
        if (!this.floors[h]) {
          console.error("没有该楼层");
          return;
        }
        this.floors[h].tag_group.add(M);
      } else
        this.all_model_in_the_scene.add(M);
      g.model = M, g.model_format = "sprite", g.model_height = 0;
    } else
      return console.error(`模型${d}格式错误，模型格式只能是json、fbx、texture`), !1;
    if (l && l.text) {
      const v = sn({
        text: l.text,
        type: Oe.Card,
        id: u,
        text_class: l.text_class
      });
      f.type === At.Texture && v.classList.add("label-icon");
      const M = Mi(v, new b(0, I(g).model_height, 0));
      (y = g.model) == null || y.add(M), g.label = M;
    }
    if (this.options.buildings && h && (this.floors[h].tag_group.layers.test(this.camera.layers) ? this.floors[h].setTagGroupVisible(!0) : this.floors[h].setTagGroupVisible(!1)), this.all_card[u] = g, this.options.animation_enable) {
      g.start_time = (/* @__PURE__ */ new Date()).getTime(), g.is_start_animation = !1, g.is_need_update_rotation = !0;
      const v = {
        x: m,
        y: _,
        z: p,
        time: a,
        is_skip: !1
      };
      this.all_card_animation_position[u] = [v], this.all_card_position_cache.set(u, [v]);
    }
    if (g.diff_time = Date.now(), this.options.open_little_map) {
      const v = new Ue(), M = new Float32Array([
        -0.5,
        0,
        0,
        0,
        0,
        Math.sqrt(0.75),
        0.5,
        0,
        0
      ]);
      v.setAttribute("position", new $e(M, 3));
      const S = new st(v, x);
      S.position.set(i, 0.01, -n), this.overview_map_card_scale && S.scale.set(this.overview_map_card_scale, this.overview_map_card_scale, this.overview_map_card_scale), this.overview_card_group.add(S), this.all_overview_card[u] = S;
    }
    if (c && (this.addTrack(t), this.all_track_card[u] && this._addTrackCardPositionData(u, m, _, p, !1)), this.options.open_shadow && !this.options.buildings) {
      const v = this.all_model.shadow;
      if (v === void 0) {
        console.error("shadow模型未指定，或未加载成功");
        return;
      }
      if (v.type !== At.JSON && v.type !== At.FBX && v.type !== At.GLTF) {
        console.error("shadow模型格式错误，只能是json、fbx、gltf格式");
        return;
      }
      const M = v.content.clone();
      M.position.set(i, 1e-3, -n), this.shadow_group.add(M), this.all_shadow_model[u] = M;
    }
    return this.is_hide_all_card && this.hideCard(u), !0;
  }
  _createOutlineComposer() {
    const t = this.renderer.getDrawingBufferSize(new G()), i = new Ot(t.width, t.height, { samples: 4 });
    this.outline_composer = new hM(this.renderer, i), this.outline_pass = new un(this.renderer.getDrawingBufferSize(new G()), this.scene, this.camera);
    const n = new uM(this.scene, this.camera), s = new Of(dM);
    this.outline_pass.downSampleRatio = 2, this.outline_pass.visibleEdgeColor = new de(0, 0, 0), this.outline_composer.addPass(n), this.outline_composer.addPass(s), this.outline_composer.addPass(this.outline_pass);
  }
  // 创建精灵
  _createSprite(t, i, n = new G(0.5, 0)) {
    const s = new Xl({ map: t, sizeAttenuation: !1 });
    s.depthTest = !1;
    const r = new Ad(s);
    return r.center.copy(n), r.scale.set(0.05 * i, 0.05 * i, 0), r;
  }
  _updateSpriteTexture(t, i) {
    const n = t.material.map;
    t.material.map = i, t.material.needsUpdate = !0, n == null || n.dispose();
  }
  // 计算定位卡移动到下一个点的旋转角度
  static _getNextPointRotate(t, i) {
    const n = (t.x - i.x) * (t.x - i.x) + (t.z - i.z) * (t.z - i.z);
    let s = 1;
    return i.x - t.x < 0 && (s = -1), n > 0 ? s * Math.acos((i.z - t.z) / Math.sqrt(n)) : 0;
  }
  // 轨迹数据增加一个点
  _addTrackCardPositionData(t, i, n, s, r, a = !1) {
    var l;
    if (this.options.buildings && ((l = this.all_card[t]) != null && l.floor_id)) {
      const c = new b(i, n, s);
      c.applyMatrix4(this.floors[I(this.all_card[t].floor_id)].matrix), i = c.x, s = c.z;
    }
    r || (this.all_track_card_position[t] === void 0 ? this.all_track_card_position[t] = [{ x: i, y: n, z: s, is_skip: a }] : (I(this.all_track_card_position[t]).push({ x: i, y: n, z: s, is_skip: a }), I(this.all_track_card_position[t]).length > I(this.options.track_position_length) && I(this.all_track_card_position[t]).shift())), this.all_track_card_animation[t] === void 0 ? this.all_track_card_animation[t] = [{ x: i, y: n, z: s, is_skip: a }] : (I(this.all_track_card_animation[t]).push({ x: i, y: n, z: s, is_skip: a }), this.options.animation_enable && I(this.all_track_card_animation[t]).length > I(this.options.track_animation_length) ? I(this.all_track_card_animation[t]).shift() : !this.options.animation_enable && I(this.all_track_card_animation[t]).length > I(this.options.track_position_length) && I(this.all_track_card_animation[t]).shift());
  }
  // 更新定位卡坐标
  updateCardCoordinate(t, i, n, s, r) {
    var d;
    const a = t, l = i, c = n, h = s;
    if (isNaN(a) || isNaN(l) || isNaN(c) || isNaN(h))
      return console.error("updateCardCoordinate 参数类型错误"), !1;
    const u = this.getTransformedCoordinate(l, c, h);
    if (this.all_card[a]) {
      this.all_card[a].diff_time_value = (r - I(this.all_card[a]).diff_time) / 1e3, this.all_card[a].diff_time = r;
      const f = this.all_track_overtime[a];
      if (this.options.animation_enable) {
        if (this.all_card_animation_position[a] || (this.all_card_animation_position[a] = []), this.all_card_position_cache.has(a) || this.all_card_position_cache.set(a, []), ni._getTwoPointLineDistance([this.all_card[a].card_x, this.all_card[a].card_y, this.all_card[a].card_z], u.toArray()) < 1e-3) {
          const p = this.all_card_animation_position[a].length;
          return p > 0 ? (this.all_card_animation_position[a][p - 1].time = r, !0) : (this.all_card[a].start_time = (/* @__PURE__ */ new Date()).getTime(), !0);
        }
        const _ = {
          x: u.x,
          y: u.y,
          z: u.z,
          time: r,
          is_skip: f === void 0 ? !1 : I(this.all_card[a]).diff_time_value >= f
        };
        if (this.all_card_animation_position[a].push(_), (d = this.all_card_position_cache.get(a)) == null || d.push(_), this.all_card[a].card_x = u.x, this.all_card[a].card_y = u.y, this.all_card[a].card_z = u.z, this._cardPositionTween(a), this.options.animation_delay_time && this.all_card_animation_position[a].length > 1) {
          const p = this.all_card_animation_position[a][0];
          r - p.time > this.options.animation_delay_time * 1e3 && this.endTween(a);
        }
        return !0;
      }
      const m = ni._getNextPointRotate(I(this.all_card[a].model).position, {
        x: u.x,
        y: u.y,
        z: u.z
      });
      return m && (I(this.all_card[a].model).rotation.y = m), I(this.all_card[a].model).position.set(...u.toArray()), this.all_card[a].card_x = u.x, this.all_card[a].card_y = u.y, this.all_card[a].card_z = u.z, this.all_card[a].start_time = (/* @__PURE__ */ new Date()).getTime(), this.options.open_shadow && !this.options.buildings && this.all_shadow_model[a].position.set(...this.getTransformedCoordinate(l, c, 0).toArray()), this.options.open_little_map && this.all_overview_card[a] && this.all_overview_card[a].position.set(...u.toArray()), this.all_track_card[a] && this._addTrackCardPositionData(a, ...u.toArray(), !1, f === void 0 ? !1 : I(this.all_card[a]).diff_time_value >= f), !0;
    }
    return console.error("该卡尚未添加到地图中"), !1;
  }
  // 设置定位卡的文字信息
  setCardText(t, i, n) {
    var r;
    n = n || {};
    const s = t;
    if (isNaN(s))
      return console.error("setCardText 参数错误"), !1;
    if (this.all_card[s]) {
      if (this.all_card[s].label && !(n != null && n.text_class))
        i !== void 0 && (I(this.all_card[s].label).element.innerHTML = i), n.remove_text_class && I(this.all_card[s].label).element.classList.remove(n.remove_text_class), n.add_text_class && I(this.all_card[s].label).element.classList.add(n.add_text_class);
      else {
        const a = this.all_card[s].label;
        if (a && (I(this.all_card[s].model).remove(a), a.destroy(), this.all_card[s].label = void 0), i) {
          const l = sn({
            text: i,
            type: Oe.Card,
            id: s,
            text_class: n.text_class || n.add_text_class
          });
          (r = this.all_card[s].model) != null && r.isSprite && l.classList.add("label-icon");
          const c = Mi(l, new b(0, I(this.all_card[s].model_height), 0));
          I(this.all_card[s].model).add(c), this.all_card[s].label = c;
        }
      }
      return !0;
    }
    return console.error("该卡尚未添加到地图中"), !1;
  }
  // 停止巡视
  stopPatrol() {
    this.now_patrol_card = void 0, this.camera_tween && (this.camera_tween.stop(), mi(this.camera_tween), this.camera_tween = void 0), this.target_tween && (this.target_tween.stop(), mi(this.target_tween), this.target_tween = void 0), this.controls.enabled = !0, this.controls.autoRotate = !1, this.controls.update();
  }
  // 删除指定定位卡
  removeCard(t) {
    var n, s;
    const i = t;
    if (isNaN(i))
      return console.error("错误的卡号"), !1;
    if (this.all_card[i]) {
      if ((n = this.all_card[i].model) == null || n.removeFromParent(), this.all_card[i].label && ((s = this.all_card[i].label) == null || s.destroy()), this.all_card[i].model_format === "fbx") {
        const r = this.getFBXModelSkinnedMesh(this.all_card[i].model);
        r.material.dispose(), r.geometry.dispose();
      } else this.all_card[i].model_format === "json" && (I(this.all_card[i].model).material.dispose(), I(this.all_card[i].model).geometry.dispose());
      return this.mixers[i] && delete this.mixers[i], this.options.open_little_map && this.all_overview_card[i] && (this.all_overview_card[i].removeFromParent(), this.all_overview_card[i].material.dispose(), this.all_overview_card[i].geometry.dispose(), delete this.all_overview_card[i]), this.all_shadow_model && this.all_shadow_model[i] && (this.all_shadow_model[i].removeFromParent(), I(this.all_shadow_model[i].material).dispose(), I(this.all_shadow_model[i].geometry).dispose(), delete this.all_shadow_model[i]), this.all_track_card && this.all_track_card[i] && (this.endTween(t), this.removeTrack(i)), this.now_patrol_card === i && this.stopPatrol(), this.outline_pass.selectedObjects = this.outline_pass.selectedObjects.filter((r) => r.model_id !== i), delete this.all_card[i], !0;
    }
    return console.error("该卡尚未添加到地图中"), !1;
  }
  // 删除全部定位卡
  removeAllCard() {
    for (const t in this.all_card)
      this.removeCard(parseInt(t));
    this.outline_pass.selectedObjects = [];
  }
  // 隐藏指定定位卡
  hideCard(t) {
    const i = t;
    return isNaN(i) ? (console.error("错误的卡号"), !1) : this.all_card[i] ? (I(this.all_card[i].model).visible = !1, this.all_card[i].label && (I(this.all_card[i].label).visible = !1), this.options.open_little_map && this.all_overview_card[i] && (this.all_overview_card[i].visible = !1), this.all_shadow_model && this.all_shadow_model[i] && (this.all_shadow_model[i].visible = !1), this.all_track_card_is_show && this.all_track_card_is_show[i] && (this.all_track_card_is_show[i] = !1), !0) : (console.error("该卡尚未添加到地图中"), !1);
  }
  // 显示指定定位卡
  showCard(t) {
    const i = t;
    return isNaN(i) ? (console.error("错误的卡号"), !1) : this.all_card[i] ? (I(this.all_card[i].model).visible = !0, this.all_card[i].label && (I(this.all_card[i].label).visible = !0), this.options.open_little_map && this.all_overview_card[i] && (this.all_overview_card[i].visible = !0), this.all_shadow_model && this.all_shadow_model[i] && (this.all_shadow_model[i].visible = !0), this.all_track_card_is_show && !this.all_track_card_is_show[i] && (this.all_track_card_is_show[i] = !0), !0) : (console.error("该卡尚未添加到地图中"), !1);
  }
  // 显示全部定位卡
  showAllCard() {
    for (const t in this.all_card)
      I(this.all_card[t].model).visible = !0, this.all_card[t].label && (I(this.all_card[t].label).visible = !0), this.options.open_little_map && this.all_overview_card[t] && (this.all_overview_card[t].visible = !0), this.all_shadow_model && this.all_shadow_model[t] && (this.all_shadow_model[t].visible = !0), this.all_track_card_is_show && !this.all_track_card_is_show[t] && (this.all_track_card_is_show[t] = !0);
    this.is_hide_all_card = !1;
  }
  // 显示全部场景中的定位卡
  showSceneCard() {
    for (const t in this.all_card)
      this.all_card[t].floor_id === void 0 && (I(this.all_card[t].model).visible = !0, this.all_card[t].label && (I(this.all_card[t].label).visible = !0), this.options.open_little_map && this.all_overview_card[t] && (this.all_overview_card[t].visible = !0), this.all_shadow_model && this.all_shadow_model[t] && (this.all_shadow_model[t].visible = !0), this.all_track_card_is_show && !this.all_track_card_is_show[t] && (this.all_track_card_is_show[t] = !0));
  }
  // 隐藏全部定位卡
  hideAllCard() {
    for (const t in this.all_card)
      I(this.all_card[t].model).visible = !1, this.all_card[t].is_clustered = ii.Null, this.all_card[t].label && (I(this.all_card[t].label).visible = !1), this.options.open_little_map && this.all_overview_card[t] && (this.all_overview_card[t].visible = !1), this.all_shadow_model && this.all_shadow_model[t] && (this.all_shadow_model[t].visible = !1), this.all_track_card_is_show && this.all_track_card_is_show[t] && (this.all_track_card_is_show[t] = !1);
    this.is_hide_all_card = !0;
  }
  // 隐藏全部场景中定位卡
  hideSceneCard() {
    for (const t in this.all_card)
      this.all_card[t].floor_id === void 0 && (I(this.all_card[t].model).visible = !1, this.all_card[t].label && (I(this.all_card[t].label).visible = !1), this.options.open_little_map && this.all_overview_card[t] && (this.all_overview_card[t].visible = !1), this.all_shadow_model && this.all_shadow_model[t] && (this.all_shadow_model[t].visible = !1), this.all_track_card_is_show && this.all_track_card_is_show[t] && (this.all_track_card_is_show[t] = !1));
  }
  // 开始闪烁定位卡，兼容之前的接口
  addCardTwinkle(t) {
    return this.startCardFlash(t);
  }
  // 开始闪烁定位卡
  startCardFlash(t) {
    const i = t;
    if (isNaN(i))
      return console.error("错误的卡号"), !1;
    if (this.all_flash_card[i])
      return !0;
    if (this.all_card[i]) {
      let n;
      return this.all_card[i].model_format === "fbx" ? n = this.getFBXModelSkinnedMesh(this.all_card[i].model) : this.all_card[i].model_format === "json" ? n = this.all_card[i].model : this.all_card[i].model_format === "sprite" && (n = this.all_card[i].model), n.independent_material === void 0 && (n.material = n.material.clone(), this.options.open_little_map && (this.all_overview_card[i].material = n.material), n.independent_material = !0), this._select_card_id !== i && (n.material.isSpriteMaterial ? n.material.opacity = 0 : n.material.emissive.setHex(I(this.options.flash_color_1))), this.all_flash_card[i] = {
        emissive: this.options.flash_color_1,
        material: n.material
      }, !0;
    }
    return console.error("该卡尚未添加到地图中"), !1;
  }
  // 停止闪烁定位卡
  clearCardTwinkle(t) {
    return this.stopCardFlash(t);
  }
  // 停止闪烁定位卡
  stopCardFlash(t) {
    const i = t;
    if (isNaN(i))
      return console.error("错误的卡号"), !1;
    if (!this.all_flash_card[i])
      return !0;
    if (!this.all_card[i])
      return console.error("该卡尚未添加到地图中"), !1;
    let n;
    switch (this.all_card[i].model_format) {
      case "fbx":
        n = this.getFBXModelSkinnedMesh(this.all_card[i].model), n.material.emissive.setHex(n.init_emissive_color);
        break;
      case "json":
        n = this.all_card[i].model, n.material.emissive.setHex(n.init_emissive_color);
        break;
      case "sprite":
        n = this.all_card[i].model, n.material.opacity = 1;
        break;
    }
    return delete this.all_flash_card[i], this._select_card_id === i && (n.material.isSpriteMaterial || n.material.emissive.setHex(I(this.options.flash_color_2))), !0;
  }
  // 更新定位卡模型
  updateCardModel(t, i, n) {
    const s = parseInt(t), r = this.all_model[i];
    if (isNaN(s))
      return console.error("错误的卡号"), !1;
    if (r === void 0)
      return console.error("该模型还未加载"), !1;
    if (!this.all_card[s])
      return console.error("该卡尚未添加到地图中"), !1;
    let a;
    const l = this.all_card[s], c = I(this.all_card[s].model), h = c.visible, u = c.floor_id;
    if (this.outline_pass.selectedObjects = this.outline_pass.selectedObjects.filter((d) => d.model_id !== s), l.model_format === "fbx") {
      const d = this.getFBXModelSkinnedMesh(c);
      d.material.dispose(), d.geometry.dispose();
    } else l.model_format === "json" && (c.material.dispose(), c.geometry.dispose());
    if (c.removeFromParent(), this.mixers[s] && this.mixers[s].uncacheAction(), r.type === At.FBX) {
      const d = I(this.FbxClone(r.content));
      d.mixer = new fu(d), d.mixer.clock = new Ml(), this.mixers[s] = d.mixer, this.mixers[s].timeScale = 0.01;
      let f = 0;
      d.animations.forEach(
        (_, p) => {
          _.name.search("walk") !== -1 && (f = p);
        }
      ), d.animations[f] && d.mixer.clipAction(d.animations[f]).play();
      const m = this.getFBXModelSkinnedMesh(d);
      if (a = m.material, d.model_id = s, d.model_type = Oe.Card, d.floor_id = u, d.visible = h, n && n.scale && (d.scale.x = n.scale, d.scale.y = n.scale, d.scale.z = n.scale), m.init_emissive_color = m.material.emissive.getHex(), this.options.buildings && u) {
        if (!this.floors[u]) {
          console.error("没有该楼层");
          return;
        }
        this.floors[u].tag_group.add(d);
      } else
        this.all_model_in_the_scene.add(d);
      l.model = d, l.model_format = "fbx", l.model_height = d.model_height, this.outline_pass.selectedObjects.push(d);
    } else if (r.type === At.JSON) {
      const d = I(r.content.clone());
      if (a = d.material, d.model_id = s, d.model_type = Oe.Card, d.floor_id = u, d.visible = h, n && n.scale && (d.scale.x = n.scale, d.scale.y = n.scale, d.scale.z = n.scale), d.init_emissive_color = d.material.emissive.getHex(), d.model_height = r.content.model_height, this.options.buildings && u) {
        if (!this.floors[u]) {
          console.error("没有该楼层");
          return;
        }
        this.floors[u].tag_group.add(d);
      } else
        this.all_model_in_the_scene.add(d);
      l.model = d, l.model_format = "json", l.model_height = d.model_height, this.outline_pass.selectedObjects.push(d);
    } else if (r.type === At.Texture) {
      const d = this.options.card_texture_scale ? this.options.card_texture_scale : sr, f = this._createSprite(r.content, d);
      if (f.model_id = s, f.model_type = Oe.Card, f.floor_id = u, f.model_height = 0, f.visible = h, this.options.buildings && u) {
        if (!this.floors[u]) {
          console.error("没有该楼层");
          return;
        }
        this.floors[u].tag_group.add(f);
      } else
        this.all_model_in_the_scene.add(f);
      l.model = f, l.model_format = "sprite", l.model_height = 0;
    }
    return l.label && (l.label.removeFromParent(), I(l.model).add(l.label), l.label.position.set(0, I(l.model_height), 0)), this.options.buildings && u && (this.floors[u].tag_group.layers.test(this.camera.layers) ? this.floors[u].setTagGroupVisible(!0) : this.floors[u].setTagGroupVisible(!1)), I(l.model).position.set(c.position.x, c.position.y, c.position.z), I(l.model).rotation.y = c.rotation.y, this.options.open_little_map && (this.all_overview_card[s].material = a), this._select_card_id === s && this.selectCard(s), !0;
  }
  // 选中定位卡
  selectCard(t) {
    const i = t;
    if (isNaN(i))
      return console.error("错误的卡号"), !1;
    if (!this.all_card[i])
      return console.error("该卡尚未添加到地图中"), !1;
    let n;
    return this.all_card[i].model_format === "fbx" ? n = this.getFBXModelSkinnedMesh(this.all_card[i].model) : n = this.all_card[i].model, this._click_select_obj !== void 0 && this.unSelectModel(this._click_select_obj), this.selectModel(n), this._click_select_obj = n, this._select_card_id = i, !0;
  }
  // 取消选中定位卡
  unSelectCard() {
    this._click_select_obj && (this._click_select_obj.model_type === Oe.Card ? (this.unSelectModel(this._click_select_obj), this._click_select_obj = void 0) : this._click_select_obj.isSkinnedMesh && this._click_select_obj.parent && I(this._click_select_obj.parent).model_type === Oe.Card && (this.unSelectModel(this._click_select_obj), this._click_select_obj = void 0)), this._select_card_id = void 0;
  }
  applyZoneTransform(t) {
    const { x: i, y: n, z: s } = this.large_coordinate_translate ?? new b(0, 0, 0);
    for (const r of t.area_list)
      for (const a of r.area)
        a.x -= i, a.y -= -s;
    t.z_start -= n, t.z_end -= n;
  }
  // 添加区域
  addZone(t, i) {
    var c, h;
    const n = t;
    let s = Mb, r = Sb;
    n.zone_color !== void 0 && (s = n.zone_color), n.zone_opacity !== void 0 && (r = n.zone_opacity);
    const a = n.id;
    if (this.zone_color_list[a] = s, !this.all_zone_list[a])
      this.all_zone_list[a] = [], this.all_zone_material[a] = [], this.all_zone_edge_line[a] = [];
    else
      return console.error("该区域已经添加"), !1;
    n.z_start = parseFloat(n.z_start), n.z_end = parseFloat(n.z_end), this.applyZoneTransform(n);
    const l = n.area_list;
    for (let u = 0; u < l.length; u++) {
      if (this.all_zone_list[a][u]) {
        this.all_zone_list[a][u].removeFromParent(), this.all_zone_list[a][u].geometry.dispose(), I(this.all_zone_list[a][u].material).dispose();
        for (const v in this.all_zone_edge_line[a][u])
          this.all_zone_edge_line[a][u][v].removeFromParent();
        delete this.all_zone_list[a][u];
      }
      this.all_zone_edge_line[a][u] = [];
      const d = l[u].area, f = [], m = [], _ = new Ue();
      for (let v = 0; v < d.length; v++) {
        const M = (v + 1) % d.length, S = d[v], A = d[M];
        f.push(S.x, n.z_start, -S.y), f.push(A.x, n.z_start, -A.y), f.push(A.x, n.z_end, -A.y), f.push(S.x, n.z_end, -S.y);
        let w = S, E = S;
        const P = I(this._createZoneEdgeLine(w, n.z_start, E, n.z_end, s));
        P.userData.key = a, P.userData.model_type = Oe.Zone, P.userData.model_id = a, P.userData.type = n.type, this.options.buildings && i ? (P.floor_id = i, this.floors[i].area_group.add(P)) : this.area_group.add(P), this.all_zone_edge_line[a][u].push(P), w = S, E = A;
        const z = this._createZoneEdgeLine(w, n.z_start, E, n.z_start, s);
        z.userData.key = a, z.userData.model_type = Oe.Zone, z.userData.model_id = a, z.userData.type = n.type, this.options.buildings && i ? (P.floor_id = i, this.floors[i].area_group.add(z)) : this.area_group.add(z), this.all_zone_edge_line[a][u].push(z), w = A, E = A;
        const V = this._createZoneEdgeLine(w, n.z_start, E, n.z_end, s);
        V.userData.key = a, V.userData.model_type = Oe.Zone, V.userData.model_id = a, V.userData.type = n.type, this.options.buildings && i ? (P.floor_id = i, this.floors[i].area_group.add(V)) : this.area_group.add(V), this.all_zone_edge_line[a][u].push(V), w = S, E = A;
        const O = this._createZoneEdgeLine(w, n.z_end, E, n.z_end, s);
        O.userData.key = a, O.userData.model_type = Oe.Zone, O.userData.model_id = a, O.userData.type = n.type, this.options.buildings && i ? (P.floor_id = i, this.floors[i].area_group.add(O)) : this.area_group.add(O), this.all_zone_edge_line[a][u].push(O);
      }
      for (let v = 0; v < d.length; v++)
        f.push(d[v].x, n.z_end, -d[v].y);
      for (let v = 0; v < d.length; v++) {
        const M = v * 4;
        m.push(M, M + 1, M + 2), m.push(M, M + 2, M + 3);
      }
      const p = [];
      for (const v in d)
        p.push(new G(d[v].x, d[v].y));
      Xi.triangulateShape(p, []).map((v) => v.map((M) => M + d.length * 4)).forEach((v) => {
        m.push(v[0], v[1], v[2]);
      }), _.setIndex(m), _.setAttribute("position", new $e(new Float32Array(f), 3));
      const y = new st(_, new gi({
        color: s,
        side: ji,
        transparent: !0,
        opacity: r,
        depthTest: !0,
        depthWrite: !this.options.buildings
      }));
      if (y.name = a, y.userData.key = a, y.userData.model_type = Oe.Zone, y.userData.model_id = a, y.userData.type = n.type, this.options.buildings && i) {
        if (!this.floors[i]) {
          console.error("没有该楼层");
          return;
        }
        I(y).floor_id = i, this.floors[i].area_group.add(y);
      } else
        this.area_group.add(y);
      this.all_zone_list[a][u] = y, this.all_zone_material[a][u] = y.material;
    }
    if (n.name) {
      const u = sn({
        text: n.name,
        type: Oe.Zone,
        id: n.id,
        text_class: n != null && n.text_class ? ["zone-label", n.text_class] : "zone-label",
        // 区域特殊处理，因为区域不同类型，id可能相同，需要一个type字段区分
        extra: n.type
      }), d = eM((c = n == null ? void 0 : n.area_list) == null ? void 0 : c[0].area), f = Mi(u, new b(d.x, n.z_end, -d.y));
      this.all_zone_label[n.id] = { label: f, floor_id: i }, this.options.buildings && i ? this.floors[i].area_group.add(f) : this.zone_label_group.add(f);
    }
    if (this.zone_center_list[n.id] = this._calculateZoneCenter((h = n == null ? void 0 : n.area_list) == null ? void 0 : h[0].area, n.z_start, n.z_end), this.options.buildings && i) {
      if (!this.floors[i]) {
        console.error("没有该楼层");
        return;
      }
      this.floors[i].mesh_group.layers.test(this.camera.layers) ? this.floors[i].setMeshLayers(!0) : this.floors[i].setMeshLayers(!1);
    }
    return this.all_zone_id_type[n.id] = n.type, !0;
  }
  _calculateZoneCenter(t, i, n) {
    const s = (i + n) / 2, r = t.reduce((l, c) => l + c.x, 0) / t.length, a = t.reduce((l, c) => l + -c.y, 0) / t.length;
    return new b(r, s, a);
  }
  // 生成区域的边线
  _createZoneEdgeLine(t, i, n, s, r) {
    const a = new Ue(), l = new mn({
      color: new de(r)
    }), c = new Float32Array([
      t.x,
      i,
      -t.y,
      n.x,
      s,
      -n.y
    ]);
    return a.setAttribute("position", new $e(c, 3)), new Bn(a, l);
  }
  // 获得当前是否有该区域
  getZoneStatus(t) {
    if (t !== void 0) {
      const n = t;
      return isNaN(n) ? (console.error("错误的区域ID"), !1) : !!this.all_zone_list[n];
    }
    const i = [];
    for (const n in this.all_zone_list)
      i.push(parseInt(n));
    return i;
  }
  removeZone(t) {
    const i = t;
    if (isNaN(i))
      return console.error("removeZone 参数类型错误"), !1;
    const n = i, s = this.all_zone_list[n];
    if (s !== void 0) {
      for (let r = 0; r < s.length; r++)
        if (s[r]) {
          s[r].removeFromParent(), s[r].geometry.dispose(), I(s[r].material).dispose(), delete s[r];
          for (let a = 0; a < this.all_zone_edge_line[n][r].length; a++)
            this.all_zone_edge_line[n][r][a].removeFromParent(), this.all_zone_edge_line[n][r][a].geometry.dispose(), I(this.all_zone_edge_line[n][r][a].material).dispose(), delete this.all_zone_edge_line[n][r][a];
        }
      delete this.all_zone_list[n], delete this.all_zone_material[n], delete this.all_zone_edge_line[n];
    }
    return this.all_zone_label[i] && (this.all_zone_label[i].label.removeFromParent(), this.all_zone_label[i].label.destroy()), delete this.all_zone_id_type[i], !0;
  }
  // 删除全部区域
  removeAllZone() {
    for (const t in this.all_zone_list)
      this.removeZone(parseInt(t));
  }
  // 显示所有区域
  showAllZone() {
    for (const t in this.all_zone_list) {
      for (let i = 0; i < this.all_zone_list[t].length; i++) {
        const n = this.all_zone_list[t][i];
        n && (n.visible = !0);
        for (let s = 0; s < this.all_zone_edge_line[t][i].length; s++)
          this.all_zone_edge_line[t][i][s].visible = !0;
      }
      this.all_zone_label[t] && (this.all_zone_label[t].label.visible = !0);
    }
    return !0;
  }
  // 显示场景中所有区域
  showSceneZone() {
    for (const t in this.all_zone_list) {
      for (let i = 0; i < this.all_zone_list[t].length; i++) {
        const n = this.all_zone_list[t][i];
        if (n.floor_id === void 0) {
          n && (n.visible = !0);
          for (let s = 0; s < this.all_zone_edge_line[t][i].length; s++)
            this.all_zone_edge_line[t][i][s].visible = !0;
        }
      }
      this.all_zone_label[t] && this.all_zone_label[t].floor_id === void 0 && (this.all_zone_label[t].label.visible = !0);
    }
    return !0;
  }
  // 隐藏所有区域
  hideAllZone() {
    for (const t in this.all_zone_list) {
      for (let i = 0; i < this.all_zone_list[t].length; i++) {
        const n = this.all_zone_list[t][i];
        n && (n.visible = !1);
        for (let s = 0; s < this.all_zone_edge_line[t][i].length; s++)
          this.all_zone_edge_line[t][i][s].visible = !1;
      }
      this.all_zone_label[t] && (this.all_zone_label[t].label.visible = !1);
    }
    return !0;
  }
  // 隐藏场景中所有区域
  hideSceneZone() {
    for (const t in this.all_zone_list) {
      for (let i = 0; i < this.all_zone_list[t].length; i++) {
        const n = this.all_zone_list[t][i];
        if (n.floor_id === void 0) {
          n && (n.visible = !1);
          for (let s = 0; s < this.all_zone_edge_line[t][i].length; s++)
            this.all_zone_edge_line[t][i][s].visible = !1;
        }
      }
      this.all_zone_label[t] && this.all_zone_label[t].floor_id === void 0 && (this.all_zone_label[t].label.visible = !1);
    }
    return !0;
  }
  // 显示指定区域
  showZone(t) {
    const i = t;
    if (isNaN(i))
      return console.error("showZone 参数类型错误"), !1;
    if (this.all_zone_list[i]) {
      for (let n = 0; n < this.all_zone_list[i].length; n++) {
        const s = this.all_zone_list[i][n];
        s && (s.visible = !0);
        for (let r = 0; r < this.all_zone_edge_line[i][n].length; r++)
          this.all_zone_edge_line[i][n][r].visible = !0;
      }
      this.all_zone_label[i] && (this.all_zone_label[i].label.visible = !0);
    } else
      return console.error("该区域还未添加"), !1;
    return !0;
  }
  // 隐藏指定区域
  hideZone(t) {
    const i = t;
    if (isNaN(i))
      return console.error("hideZone 参数类型错误"), !1;
    if (this.all_zone_list[i]) {
      const n = this.all_zone_list[i];
      for (let s = 0; s < n.length; s += 1) {
        n[s] && (n[s].visible = !1);
        for (let r = 0; r < this.all_zone_edge_line[i][s].length; r++)
          this.all_zone_edge_line[i][s][r].visible = !1;
      }
      this.all_zone_label[i] && (this.all_zone_label[i].label.visible = !1);
    } else
      return console.error("该区域还未添加"), !1;
    return !0;
  }
  highlightZone(t) {
    const i = t;
    if (isNaN(i))
      return console.error("highlightZone 参数类型错误"), !1;
    if (this.all_zone_edge_line[i])
      for (const n in this.all_zone_edge_line[i])
        for (const s in this.all_zone_edge_line[i][n])
          this.all_zone_edge_line[i][n][s].material.color = new de(65534), this.all_zone_edge_line[i][n][s].material.needsUpdate = !0;
    else
      return console.error("该区域还未添加"), !1;
    return this.all_zone_label[i] && this.all_zone_label[i].label.element.classList.add("zone-label-highlight"), !0;
  }
  removeHighlightZone(t) {
    const i = t;
    if (isNaN(i))
      return console.error("removeHighlightZone 参数类型错误"), !1;
    if (this.all_zone_edge_line[i])
      for (const n in this.all_zone_edge_line[i])
        for (const s in this.all_zone_edge_line[i][n])
          this.all_zone_edge_line[i][n][s].material.color = new de(this.zone_color_list[i]), this.all_zone_edge_line[i][n][s].material.needsUpdate = !0;
    else
      return console.error("该区域还未添加"), !1;
    return this.all_zone_label[i] && this.all_zone_label[i].label.element.classList.remove("zone-label-highlight"), !0;
  }
  // 开始区域闪烁
  startZoneFlash(t) {
    const i = t;
    if (isNaN(i))
      return console.error("hideZone 参数类型错误"), !1;
    if (this.flash_zone_material || (this.flash_zone_material = new gi({
      color: this.options.flash_color_1,
      side: ji,
      transparent: !0,
      opacity: 0.2
    })), this.all_zone_list[i]) {
      for (const n in this.all_zone_list[i])
        this.all_zone_list[i][n].material = this.flash_zone_material;
      this.all_flash_zone_list[i] = !0;
    } else
      return console.error("该区域还未添加"), !1;
    return !0;
  }
  // 停止区域闪烁
  stopZoneFlash(t) {
    const i = t;
    if (isNaN(i))
      return console.error("stopZoneFlash 参数类型错误"), !1;
    if (this.all_zone_list[i]) {
      for (const n in this.all_zone_list[i])
        this.all_zone_list[i][n].material = this.all_zone_material[i][n];
      delete this.all_flash_zone_list[i];
    } else
      return console.error("该区域还未添加"), !1;
    return !0;
  }
  // 添加轨迹追踪
  addTrack(t, i, n) {
    const s = t;
    if (isNaN(s))
      return console.error("错误的卡号"), !1;
    if (!this.all_track_card[s]) {
      this.all_track_card[s] = !0, this.all_track_color[s] = i || Math.random() * 16777215, n ? this.all_track_overtime[s] = n : this.options.track_overtime && (this.all_track_overtime[s] = this.options.track_overtime), this.all_track_card_is_show[s] = !0;
      const r = I(this.all_card[s].model).position;
      return this.all_track_card_animation[s] = [{
        x: r.x,
        y: r.y,
        z: r.z,
        is_skip: !1
      }], !0;
    }
    return console.error("已经添加了该轨迹，不能重复添加"), !1;
  }
  // 查询定位卡是否处于轨迹追踪状态
  getTrackStatus(t) {
    if (t !== void 0) {
      const n = t;
      return isNaN(n) ? (console.error("错误的卡号"), !1) : !!this.all_track_card[n];
    }
    const i = [];
    for (const n in this.all_track_card)
      i.push(parseInt(n));
    return i;
  }
  // 清除指定的轨迹
  clearTrack(t) {
    const i = t;
    if (isNaN(i))
      return console.error("错误的卡号"), !1;
    this.all_track_card_position[i] = void 0, this.all_track_card_animation[i] = void 0;
    const n = I(this.all_card[i].model).position;
    return this.all_track_card_animation[i] = [{
      x: n.x,
      y: n.y,
      z: n.z,
      is_skip: !1
    }], !0;
  }
  // 清除全部的轨迹
  clearAllTrack() {
    this.removeGroupChildren(this.track_line_group);
    for (const t in this.all_track_card) {
      const i = parseInt(t);
      this.all_track_card_position[i] = void 0, this.all_track_card_animation[i] = void 0;
      const n = I(this.all_card[i].model).position;
      this.all_track_card_animation[i] = [{
        x: n.x,
        y: n.y,
        z: n.z,
        is_skip: !1
      }];
    }
    return !0;
  }
  // 删除一张卡的轨迹追踪状态
  removeTrack(t) {
    const i = t;
    return isNaN(i) ? (console.error("错误的卡号"), !1) : (delete this.all_track_card[i], delete this.all_track_card_position[i], delete this.all_track_card_animation[i], delete this.all_track_color[i], delete this.all_track_card_is_show[i], !0);
  }
  // 删除全部卡的轨迹追踪状态
  removeAllTrack() {
    return this.removeGroupChildren(this.track_line_group), this.all_track_card = [], this.all_track_card_is_show = [], this.all_track_color = [], this.all_track_card_position = [], this.all_track_card_animation = [], !0;
  }
  // 根据点，生成一条轨迹（针对坐标点的is_skip属性进行分段）
  static _createHGLine(t, i, n, s = !1) {
    const r = [];
    for (let h = 0; h < t.length; h++)
      r.push({
        is_skip: t[h].is_skip,
        vec3: new b(t[h].x, t[h].y + n, t[h].z)
      });
    let a = [], l = [];
    const c = new de(i);
    if (s) {
      let h = 0;
      a = r.reduce((u, d) => (d.is_skip ? h++ : Array.isArray(u[h]) ? (u[h].push(d.vec3.x, d.vec3.y, d.vec3.z), l[h].push(c.r, c.g, c.b)) : (u[h] = [d.vec3.x, d.vec3.y, d.vec3.z], l[h] = [c.r, c.g, c.b]), u), []), a = a.filter((u) => u), l = l.filter((u) => u);
    } else
      for (let h = 0; h < r.length; h++)
        if (h + 1 < r.length) {
          const u = r[h], d = r[h + 1];
          d.is_skip || (a.push([u.vec3.x, u.vec3.y, u.vec3.z, d.vec3.x, d.vec3.y, d.vec3.z]), l.push([c.r, c.g, c.b, c.r, c.g, c.b]));
        }
    return [a, l];
  }
  // 处理轨迹绘制
  _updateCardTrack() {
    this.removeGroupChildren(this.track_line_group);
    const t = [], i = [];
    for (const n in this.all_track_card) {
      const s = parseInt(n);
      if (this.all_track_card_is_show[s] && this.all_track_card_animation[s] && I(this.all_track_card_animation[s]).length > 1) {
        let r;
        if (this.options.buildings && s in this.all_card && this.all_card[s].floor_id !== void 0 && this.all_card[s].model !== void 0)
          if (this.floors[I(this.all_card[s].floor_id)].tag_group.layers.test(this.camera.layers)) {
            const c = this.all_card[s].model;
            if (!this.all_card[s] || !c) continue;
            r = (this.options.track_height ? this.options.track_height : 0.7) + c.getWorldPosition(new b()).y, r -= c.position.y;
          } else
            continue;
        else
          r = I(this.options.track_height);
        const [a, l] = ni._createHGLine(I(this.all_track_card_animation[s]), this.all_track_color[s], r, this.options.animation_enable);
        t.push(...a), i.push(...l);
      }
      if (t.length === i.length && t.length > 0) {
        const r = this._createLine2(t, i);
        this.track_line_group.add(r);
      }
    }
  }
  _createLine2(t, i) {
    const n = new ja();
    n.setPositions(t), n.setColors(i);
    const s = new Il(n, this.track_material);
    return s.scale.set(1, 1, 1), s;
  }
  applyCoordinateTransform(t) {
    t.set(t.x, t.z, -t.y);
  }
  applyCoordinateTransformInverse(t) {
    t.set(t.x, -t.z, t.y);
  }
  applyCoordinateTranslate(t) {
    this.large_coordinate_translate && t.sub(this.large_coordinate_translate);
  }
  applyCoordinateTranslateInverse(t) {
    this.large_coordinate_translate && t.add(this.large_coordinate_translate);
  }
  getTransformedCoordinate(t, i, n) {
    const s = new b(t, i, n);
    return this.applyCoordinateTransform(s), this.applyCoordinateTranslate(s), s;
  }
  getOriginalCoordinate(t, i, n) {
    const s = new b(t, i, n);
    return this.applyCoordinateTranslateInverse(s), this.applyCoordinateTransformInverse(s), s;
  }
  // 添加基站
  addBaseStation(t, i, n, s, r, a, l) {
    const c = t;
    let h = i, u = n, d = s;
    const f = r || "base_station", m = this.all_model[f];
    if (isNaN(c) || isNaN(h) || isNaN(u) || isNaN(d))
      return console.error("错误的参数"), !1;
    if ({
      x: h,
      y: u,
      z: d
    } = this.getTransformedCoordinate(h, u, d), this.all_base_station_model[c])
      return console.error("该基站已经添加"), !1;
    if (m === void 0)
      return console.error("基站模型还未加载"), !1;
    let _;
    if (m.type === At.Texture) {
      const p = this.options.sprite_texture_scale ? this.options.sprite_texture_scale : sr;
      _ = this._createSprite(m.content, p), _.model_height = 0;
    } else
      _ = m.content.clone(), _.model_height = m.content.model_height;
    if (_.model_id = t, _.model_type = Oe.BaseStation, _.position.set(h, u, d), l !== void 0 && (_.floor_id = l), a && a.text) {
      const p = sn({
        text: a.text,
        type: Oe.BaseStation,
        id: t,
        text_class: a.text_class
      });
      m.type === At.Texture && p.classList.add("label-icon");
      const g = Mi(p, new b(0, I(_.model_height), 0));
      _.add(g), _.label = g;
    }
    if (this.options.buildings && l) {
      if (!this.floors[l]) {
        console.error("没有该楼层");
        return;
      }
      this.floors[l].tag_group.add(_), this.floors[l].tag_group.layers.test(this.camera.layers) ? this.floors[l].setTagGroupVisible(!0) : this.floors[l].setTagGroupVisible(!1);
    } else
      this.all_model_in_the_scene.add(_);
    return this.all_base_station_model[c] = _, !0;
  }
  updateBaseStationIcon(t, i) {
    const n = t, s = i || "base_station", r = this.all_model[s], a = this.all_base_station_model[n];
    if (!a)
      return console.error("该基站还未添加"), !1;
    if (!a.isSprite)
      return console.error("该基站不是图标显示类型"), !1;
    if (r === void 0)
      return console.error("基站模型还未加载"), !1;
    if (r.type === At.Texture)
      this._updateSpriteTexture(a, r.content);
    else
      return console.error("仅支持图片类型的基站模型"), !1;
    return !0;
  }
  // 设置指定静态模型的文字label
  setBaseStationText(t, i, n) {
    n = n || {};
    const s = t;
    if (this.all_base_station_model[s]) {
      const r = this.all_base_station_model[s];
      if (r.label)
        i !== void 0 && (r.label.element.innerHTML = i), n.remove_text_class && r.label.element.classList.remove(n.remove_text_class), n.add_text_class && r.label.element.classList.add(n.add_text_class);
      else {
        const a = sn({
          text: i,
          type: Oe.BaseStation,
          id: s,
          text_class: n.add_text_class
        });
        r.isSprite && a.classList.add("label-icon");
        const l = Mi(a, new b(0, r.model_height, 0));
        r.add(l), r.label = l;
      }
      return !0;
    }
    return console.error("该基站还未添加"), !1;
  }
  // 删除指定基站
  removeBaseStation(t) {
    var n, s, r, a;
    const i = t;
    return this.all_base_station_model[i] ? (this.all_base_station_model[i].removeFromParent(), (s = (n = this.all_base_station_model[i]) == null ? void 0 : n.material) == null || s.dispose(), (a = (r = this.all_base_station_model[i]) == null ? void 0 : r.geometry) == null || a.dispose(), this.all_base_station_model[i].label && this.all_base_station_model[i].label.destroy(), delete this.all_base_station_model[i], !0) : (console.error("该基站还未添加"), !1);
  }
  // 删除全部基站
  removeAllBaseStation() {
    let t = !0;
    return Object.entries(this.all_base_station_model).forEach(
      ([i]) => {
        this.removeBaseStation(i) || (t = !1);
      }
    ), t;
  }
  // 隐藏指定基站
  hideBaseStation(t) {
    const i = t;
    return isNaN(i) ? (console.error("错误的参数"), !1) : this.all_base_station_model[i] ? (this.all_base_station_model[i].visible = !1, !0) : (console.error("该基站还未添加"), !1);
  }
  // 隐藏全部基站
  hideAllBaseStation() {
    for (const t in this.all_base_station_model)
      this.all_base_station_model[t].visible = !1;
    return !0;
  }
  // 隐藏场景中全部基站
  hideSceneBaseStation() {
    for (const t in this.all_base_station_model)
      this.all_base_station_model[t].floor_id === void 0 && (this.all_base_station_model[t].visible = !1);
    return !0;
  }
  // 显示指定基站
  showBaseStation(t) {
    const i = t;
    return isNaN(i) ? (console.error("错误的参数"), !1) : this.all_base_station_model[i] ? (this.all_base_station_model[i].visible = !0, !0) : (console.error("该基站还未添加"), !1);
  }
  // 显示全部基站
  showAllBaseStation() {
    for (const t in this.all_base_station_model)
      this.all_base_station_model[t].visible = !0;
  }
  // 显示全部场景中的基站
  showSceneBaseStation() {
    for (const t in this.all_base_station_model)
      this.all_base_station_model[t].floor_id === void 0 && (this.all_base_station_model[t].visible = !0);
  }
  // 巡视场景
  patrolScene(t, i) {
    const n = this.options.camera_model_patrol_dist;
    this.controls.target = this.init_target_position, this.controls.enabled = !1, this.controls.autoRotate = !1, this.controls.update(), this.camera_rotate_speed = I(this.options.camera_rotate_speed), i && !isNaN(i) && (this.camera_rotate_speed = i);
    const s = this.init_camera_position.x + Math.sqrt(I(n) * I(n) / 3), r = this.init_camera_position.y + Math.sqrt(I(n) * I(n) / 3), a = this.init_camera_position.z + Math.sqrt(I(n) * I(n) / 3);
    let l = (this.camera.position.x - s) * (this.camera.position.x - s) + (this.camera.position.y - r) * (this.camera.position.y - r) + (this.camera.position.z - a) * (this.camera.position.z - a);
    l = Math.sqrt(l);
    let c = this.options.camera_speed;
    isNaN(t) || (c = t), this.camera_tween = new Bt(this.camera.position), this.camera_tween.to({ x: s, y: r, z: a }, 1e3 * l / I(c)), this.camera_tween.onComplete(() => {
      mi(I(this.camera_tween)), this.camera_tween = void 0, this.controls.autoRotate = !0, this.controls.autoRotateSpeed = this.camera_rotate_speed, this.controls.update();
    }), this.camera_tween.start();
  }
  // 巡视定位卡
  patrolCard(t, i, n) {
    const s = t;
    if (isNaN(s))
      return console.error("错误的卡号"), !1;
    if (!this.all_card[s])
      return console.error("该卡尚未添加到地图中"), !1;
    this.now_patrol_card = s, this.showCard(s);
    const r = I(this.all_card[s].model), a = this.options.camera_model_patrol_dist;
    this.controls.target = r.position.clone(), this.controls.enabled = !1, this.controls.autoRotate = !1, this.controls.update(), this.camera_rotate_speed = I(this.options.camera_rotate_speed), n && !isNaN(n) && (this.camera_rotate_speed = n);
    const l = r.position.x + Math.sqrt(I(a) * I(a) / 3), c = r.position.y + Math.sqrt(I(a) * I(a) / 3), h = r.position.z + Math.sqrt(I(a) * I(a) / 3);
    let u = (this.camera.position.x - l) * (this.camera.position.x - l) + (this.camera.position.y - c) * (this.camera.position.y - c) + (this.camera.position.z - h) * (this.camera.position.z - h);
    u = Math.sqrt(u);
    let d = this.options.camera_speed;
    return isNaN(i) || (d = i), this.camera_tween = new Bt(this.camera.position), this.camera_tween.to({ x: l, y: c, z: h }, 1e3 * u / I(d)), this.camera_tween.onComplete(() => {
      mi(I(this.camera_tween)), this.camera_tween = void 0, this.controls.autoRotate = !0, this.controls.autoRotateSpeed = this.camera_rotate_speed, this.controls.update();
    }), this.camera_tween.start(), !0;
  }
  // 巡视指定坐标的
  patrolCoordinate(t, i, n, s, r) {
    if (isNaN(t) || isNaN(i) || isNaN(n))
      return console.error("参数类型错误"), !1;
    const a = this.options.camera_model_patrol_dist;
    this.controls.target = new b(t, n, -i), this.controls.enabled = !1, this.controls.autoRotate = !1, this.controls.update(), this.camera_rotate_speed = I(this.options.camera_rotate_speed), r && !isNaN(r) && (this.camera_rotate_speed = r);
    const l = t + Math.sqrt(I(a) * I(a) / 3), c = -n + Math.sqrt(I(a) * I(a) / 3), h = i + Math.sqrt(I(a) * I(a) / 3);
    let u = (this.camera.position.x - l) * (this.camera.position.x - l) + (this.camera.position.y - c) * (this.camera.position.y - c) + (this.camera.position.z - h) * (this.camera.position.z - h);
    u = Math.sqrt(u);
    let d = this.options.camera_speed;
    return isNaN(s) || (d = s), this.camera_tween = new Bt(this.camera.position), this.camera_tween.to({ x: l, y: c, z: h }, 1e3 * u / I(d)), this.camera_tween.onComplete(() => {
      mi(I(this.camera_tween)), this.camera_tween = void 0, this.controls.autoRotate = !0, this.controls.autoRotateSpeed = this.camera_rotate_speed, this.controls.update();
    }), this.camera_tween.start(), !0;
  }
  // 开始第三人称跟随定位卡
  startThirdPersonFollow(t) {
    const i = t;
    if (isNaN(i))
      return console.error("错误的卡号"), !1;
    if (!this.all_card[i])
      return console.error("该卡尚未添加到地图中"), !1;
    const n = I(this.all_card[i].model);
    this.third_person_init_rotate = n.rotation.y, this.third_person_camera_rotate = { y: this.third_person_init_rotate };
    const s = this._getThirdPersonCameraPosition(n);
    return this.camera.position.copy(s), this.controls.target = n.getWorldPosition(new b()), this.controls.target.y += I(this.options.third_person_target_height), this.third_person_card = i, this.controls.enabled = !1, !0;
  }
  // 结束第三人称跟随定位卡
  stopThirdPersonFollow() {
    return this.third_person_card = void 0, this.controls.enabled = !0, !0;
  }
  // 更新第三人称跟随时相机的坐标
  _updateThirdPersonCamera() {
    const t = I(this.all_card[I(this.third_person_card)].model), i = this._getThirdPersonCameraPosition(t);
    this.camera.position.copy(i), this.controls.target = t.getWorldPosition(new b()), this.controls.target.y += I(this.options.third_person_target_height);
  }
  _getThirdPersonCameraPosition(t) {
    const i = t.rotation.y, n = t.getWorldPosition(new b());
    if (this.third_person_init_rotate !== i) {
      this.third_person_init_rotate = i, this.third_person_rotate_tween && this.third_person_rotate_tween.stop(), this.third_person_rotate_tween = new Bt(this.third_person_camera_rotate);
      const l = Math.abs(this.third_person_camera_rotate.y - this.third_person_init_rotate) / Math.PI * 1e3;
      this.third_person_rotate_tween.to({ y: this.third_person_init_rotate }, l), this.third_person_rotate_tween.start();
    }
    const s = n.x - I(this.options.third_person_dist) * Math.sin(this.third_person_camera_rotate.y), r = n.y + I(this.options.third_person_camera_height), a = n.z - I(this.options.third_person_dist) * Math.cos(this.third_person_camera_rotate.y);
    return new b(s, r, a);
  }
  // 场景开启聚类
  enableCluster() {
    this.options.cluster_enable = !0;
  }
  // 场景关闭聚类
  disableCluster() {
    this.options.cluster_enable = !1, this.all_card.forEach((t) => {
      this.all_card[t.card_id].is_clustered === ii.In ? (this.all_card[t.card_id].is_clustered = ii.Null, this.showCard(t.card_id)) : this.all_card[t.card_id].is_clustered === ii.Out && (this.all_card[t.card_id].is_clustered = ii.Null);
    });
  }
  // 更新聚类
  _updateCardCluster() {
    const t = {}, i = {}, n = {};
    let s;
    this.all_card.forEach((r) => {
      this.all_card[r.card_id].is_clustered === ii.In && (this.all_card[r.card_id].is_clustered = ii.Out);
    }), this._changeClusterCardVisible();
    for (const r in this.all_card) {
      if (I(this.all_card[r].model).visible === !1) continue;
      const a = I(this.all_card[r].model).getWorldPosition(new b()), l = this.camera.position, c = [];
      c.push(parseInt(r)), s = (a.x - l.x) * (a.x - l.x), s = s + (a.y - l.y) * (a.y - l.y), s = s + (a.z - l.z) * (a.z - l.z), s = Math.sqrt(s);
      for (const h in this.all_card) {
        if (r === h || I(this.all_card[h].model).visible === !1) continue;
        const u = I(this.all_card[h].model).getWorldPosition(new b());
        let d = (a.x - u.x) * (a.x - u.x);
        d = d + (a.y - u.y) * (a.y - u.y), d = d + (a.z - u.z) * (a.z - u.z), d = Math.sqrt(d), d < 0.5 + s / I(this.options.scale_dist) && c.push(parseInt(h));
      }
      i[r] = c;
    }
    for (const r in i) {
      if (n[r] !== void 0)
        continue;
      const a = [];
      for (let g = 0; g < i[r].length; g++)
        n[i[r][g]] === void 0 && (a.push(i[r][g]), n[i[r][g]] = 1);
      let l = 0;
      for (; a.length > l; ) {
        const g = a[l];
        for (let x = 0; x < i[g].length; x++)
          n[i[g][x]] === void 0 && a.push(i[g][x]), n[i[g][x]] = 1;
        l++;
      }
      let c, h, u, d, f, m;
      c = h = this.all_card[r].model.getWorldPosition(new b()).x, u = d = this.all_card[r].model.getWorldPosition(new b()).y, f = m = this.all_card[r].model.getWorldPosition(new b()).z;
      for (let g = 0; g < a.length; g++) {
        const x = a[g];
        c > I(this.all_card[x].model).getWorldPosition(new b()).x && (c = I(this.all_card[x].model).getWorldPosition(new b()).x), h < I(this.all_card[x].model).getWorldPosition(new b()).x && (h = I(this.all_card[x].model).getWorldPosition(new b()).x), u > I(this.all_card[x].model).getWorldPosition(new b()).y && (u = I(this.all_card[x].model).getWorldPosition(new b()).y), d < I(this.all_card[x].model).getWorldPosition(new b()).y && (d = I(this.all_card[x].model).getWorldPosition(new b()).y), f > I(this.all_card[x].model).getWorldPosition(new b()).z && (f = I(this.all_card[x].model).getWorldPosition(new b()).z), m < I(this.all_card[x].model).getWorldPosition(new b()).z && (m = I(this.all_card[x].model).getWorldPosition(new b()).z);
      }
      if (a.length < 2) continue;
      const _ = new b((c + h) / 2, (u + d) / 2 + this.all_card[r].model_height, (f + m) / 2), p = {};
      p.cluster_center_point = _, p.card_list = a, p.camera_dist = _.distanceTo(this.camera.position), t[r] = p, a.forEach((g) => {
        this.all_card[g].is_clustered = ii.In;
      });
    }
    this.cluster_center_dict = t, console.debug("聚类完成", t), this._changeClusterCardVisible();
  }
  // 更新聚类的标签
  _updateCardClusterLabel() {
    this.cluster_center_dict && Object.entries(this.cluster_center_dict).forEach(
      ([t, i]) => {
        this.options.buildings && this.all_card[t] && "floor_id" in this.all_card[t] && this.all_card[t].floor_id ? this.floors[this.all_card[t].floor_id].tag_group.layers.test(this.camera.layers) ? i.cluster_center = this.positionToScreenXY(i.cluster_center_point) : delete this.cluster_center_dict[t] : i.cluster_center = this.positionToScreenXY(i.cluster_center_point);
      }
    ), this.dispatchEvent(Ae.UPDATECLUSTERCARDLABEL, this.cluster_center_dict);
  }
  _changeClusterCardVisible() {
    this.all_card.forEach((t) => {
      t.is_clustered === ii.In ? this.hideCard(t.card_id) : t.is_clustered === ii.Out && this.showCard(t.card_id);
    });
  }
  // 设置摄像机中心点
  setCameraPosition(t, i, n, s, r, a, l) {
    if (isNaN(t) || isNaN(i) || isNaN(n) || isNaN(s) || isNaN(r) || isNaN(a))
      return console.error("错误的参数"), !1;
    const c = this.camera.position.clone();
    c.x = t, this.options.buildings && l !== void 0 ? c.y = n + this.floors[l].mesh_group.getWorldPosition(new b()).y : c.y = n, c.z = -i, this.controls.target = c;
    const h = t + s, u = n + a, d = -i - r;
    return this.camera.position.set(h, u, d), !0;
  }
  lookAtCard(t, i, n, s) {
    if (isNaN(t) || isNaN(i) || isNaN(n) || isNaN(s))
      return console.error("错误的参数"), !1;
    const r = I(this.all_card[t].model).getWorldPosition(new b()), a = r.x + i, l = r.y + s, c = r.z + n;
    return this.camera_animation.moveTo(new b(a, l, c)), this.camera_animation.lookAt(new b(r.x, r.y, r.z)), !0;
  }
  lookAtStaticModel(t, i, n, s, r) {
    if (!t)
      return console.error("参数错误，model_type必填参数"), !1;
    if (isNaN(n) || isNaN(s) || isNaN(r))
      return console.error("x_offset_number,y_offset_number,z_offset_number错误的参数"), !1;
    const a = "model_" + i + "_" + t;
    if (this.all_user_custom_model[a]) {
      const l = this.all_user_custom_model[a], c = I(l).getWorldPosition(new b()), h = c.x + n, u = c.y + r, d = c.z + s;
      return this.camera_animation.moveTo(new b(h, u, d)), this.camera_animation.lookAt(new b(c.x, c.y, c.z)), !0;
    }
    return console.error("不存在该静态模型"), !1;
  }
  lookAtBaseStation(t, i, n, s) {
    if (this.all_base_station_model[t]) {
      const r = this.all_base_station_model[t], a = I(r).getWorldPosition(new b()), l = a.x + i, c = a.y + s, h = a.z + n;
      return this.camera_animation.moveTo(new b(l, c, h)), this.camera_animation.lookAt(new b(a.x, a.y, a.z)), !0;
    }
    return console.error("该基站还未添加"), !1;
  }
  lookAtZone(t, i, n, s) {
    if (isNaN(t) || isNaN(i) || isNaN(n) || isNaN(s) || !(t in this.all_zone_list))
      return console.error("错误的参数"), !1;
    const r = I(this.all_zone_list[t][0]).floor_id;
    let a = 0;
    r && (a += this.floors[r].unfoldPosition.y);
    const l = this.zone_center_list[t], c = l.x + i, h = l.y + s, u = l.z + n;
    return this.camera_animation.moveTo(new b(c, h, u)), this.camera_animation.lookAt(new b(l.x, l.y + a, l.z)), !0;
  }
  // 跟随定位卡
  followCard(t, i) {
    const n = t;
    if (isNaN(n))
      return console.error("错误的卡号"), !1;
    if (!this.all_card[n])
      return console.error("该卡尚未添加到地图中"), !1;
    this.now_patrol_card = n, this.showCard(n);
    const s = I(this.all_card[n].model), r = this.options.camera_model_patrol_dist;
    this.controls.target = s.getWorldPosition(new b()), this.controls.enabled = !1;
    const a = this.controls.target.x + Math.sqrt(I(r) * I(r) / 3), l = this.controls.target.y + Math.sqrt(I(r) * I(r) / 3), c = this.controls.target.z + Math.sqrt(I(r) * I(r) / 3);
    let h = (this.camera.position.x - a) * (this.camera.position.x - a) + (this.camera.position.y - l) * (this.camera.position.y - l) + (this.camera.position.z - c) * (this.camera.position.z - c);
    h = Math.sqrt(h);
    let u = this.options.camera_speed;
    return isNaN(i) || (u = i), this.camera_tween = new Bt(this.camera.position), this.camera_tween.to({ x: a, y: l, z: c }, 1e3 * h / I(u)), this.camera_tween.onComplete(() => {
      mi(I(this.camera_tween)), this.camera_tween = void 0;
    }), this.camera_tween.start(), !0;
  }
  hideCardTrack(t) {
    if (typeof t == "number") {
      if (this.all_track_card_is_show && t in this.all_track_card_is_show)
        return this.all_track_card_is_show[t] = !1, !0;
    } else {
      for (const i in t)
        this.all_track_card_is_show && t[i] in this.all_track_card_is_show && (this.all_track_card_is_show[t[i]] = !1);
      return !0;
    }
    return !1;
  }
  showCardTrack(t) {
    if (typeof t == "number") {
      if (this.all_track_card_is_show && t in this.all_track_card_is_show)
        return this.all_track_card_is_show[t] = !0, !0;
    } else {
      for (const i in t)
        this.all_track_card_is_show && t[i] in this.all_track_card_is_show && (this.all_track_card_is_show[t[i]] = !0);
      return !0;
    }
    return !1;
  }
  drawPathLine(t, i, n) {
    const s = [];
    if (!this.line_path_dict[t] && !this.line_path_color[t]) {
      n = n || Math.random() * 16777215, this.line_path_color[t] = new de(n);
      for (const r in i)
        s.push({ x: i[r].x, y: i[r].z, z: -i[r].y });
      return this.line_path_dict[t] = s, this._updateLinePath(), !0;
    }
    return !1;
  }
  removePathLine(t) {
    return this.line_path_dict[t] && this.line_path_color ? (delete this.line_path_dict[t], delete this.line_path_color[t], this._updateLinePath(), !0) : !1;
  }
  closeOverview() {
    return this.options.open_little_map = !1, !0;
  }
  openOverview() {
    return this.options.open_little_map = !0, !0;
  }
  // 回到地图中心点
  goBackToCenter() {
    return this.controls.reset(), !0;
  }
  _clearSelectModel() {
    this.unSelectModel(this._click_select_obj), this.click_position_model && this.click_position_model.removeFromParent();
  }
  foldBuilding(t) {
    if (t in this.buildings) {
      if (Object.keys(this.buildings[t].floor_list).length === 0) {
        console.error(`建筑id为${t}的建筑，楼层数量为0`);
        return;
      }
    } else {
      console.error(`建筑id为${t}的建筑不存在`);
      return;
    }
    this.buildings[t].foldBuildingFloors(), this.buildings[t].show(), this.dispatchEvent(Ae.FOLDBUILDING, t);
  }
  unfoldBuilding(t, i) {
    if (t in this.buildings) {
      if (Pa(this.buildings[t]))
        return;
    } else {
      console.error(`建筑id为${t}的建筑不存在`);
      return;
    }
    if (this.options.building_default_view && this.options.building_default_view[t] && !i) {
      const n = this.options.building_default_view[t], s = this.buildings[t].matrix, r = new b(n.camera_position.x, n.camera_position.y, n.camera_position.z);
      r.applyMatrix4(s);
      const a = new b(n.target_position.x, n.target_position.y, n.target_position.z);
      a.applyMatrix4(s), Promise.all([this.camera_animation.lookAt(a), this.camera_animation.moveTo(r)]).then(() => {
        this.buildings[t].unfoldBuildingFloors(), this.buildings[t].hide(), this.dispatchEvent(Ae.UNFOLDBUILDING, t);
      });
    } else
      console.debug("没有获取到建筑的默认视角或immediate为true，不进行视角切换"), console.debug("immediate:", i), this.buildings[t].unfoldBuildingFloors(), this.buildings[t].hide(), this.dispatchEvent(Ae.UNFOLDBUILDING, t);
    this._clearSelectModel();
  }
  selectFloor(t) {
    var l, c;
    if (!(t in this.floors)) {
      console.error(`楼层id为${t}的楼层不存在`);
      return;
    }
    this._clearSelectModel();
    const i = this.floor_building_mapping[t].id;
    this.floor_building_mapping[t].selectFloor(t);
    const n = (c = (l = this.options) == null ? void 0 : l.building_default_view) == null ? void 0 : c[i], s = new Ht().setFromObject(this.floor_building_mapping[t].mesh_group), r = this.floors[t].unfold_position.y;
    let a;
    if (n) {
      const h = new b(n.target_position.x, n.target_position.y, n.target_position.z), u = new b(n.camera_position.x, n.camera_position.y, n.camera_position.z);
      a = tM(h, u);
    }
    this.camera_animation.lookDownToBox(s, a, r), this.dispatchEvent(Ae.SELECTFLOOR, t);
  }
  // 设置建筑物的的平移
  setBuildingTranslation(t, i) {
    return t in this.buildings ? this.buildings[t].setUserDataTranslation(i) : (console.error(`建筑id为${t}的建筑不存在`), !1);
  }
  // 设置楼层的平移
  setFloorTranslation(t, i) {
    return t in this.floors ? this.floors[t].setUserDataTranslation(i) : (console.error(`楼层id为${t}的楼层不存在`), !1);
  }
  // 获取建筑的平移
  getBuildingTranslation(t) {
    return t in this.buildings ? this.buildings[t].getUserDataTranslation() : (console.error(`建筑id为${t}的建筑不存在`), !1);
  }
  // 获取楼层的平移
  getFloorTranslation(t) {
    return t in this.floors ? this.floors[t].getUserDataTranslation() : (console.error(`楼层id为${t}的楼层不存在`), !1);
  }
  getBuildingLabelPosition() {
    const t = {};
    return Object.entries(this.buildings).forEach(([i, n]) => {
      if (Object.keys(n.floor_list).length > 0) {
        const s = new os(n.mesh_group);
        s.geometry.computeBoundingBox();
        const r = I(s.geometry.boundingBox).max.y, a = (I(s.geometry.boundingBox).max.x + I(s.geometry.boundingBox).min.x) / 2, l = (I(s.geometry.boundingBox).max.z + I(s.geometry.boundingBox).min.z) / 2;
        if (!r && !a && !l) return;
        t[i] = this.positionToScreenXY(new b(a, r, l));
      }
    }), t;
  }
  setFloorDistance(t) {
    Object.values(this.buildings).forEach((i) => {
      i.setFloorDistance(t);
    });
  }
  getMapBoundingBox() {
    const t = new Ht();
    return t.setFromObject(this.map_group), console.log(t), {
      max: {
        x: t.max.x,
        y: t.max.z,
        z: t.max.y
      },
      min: {
        x: t.min.x,
        y: t.min.z,
        z: t.min.y
      }
    };
  }
  hideSceneResources() {
    this.hideSceneBaseStation(), this.hideSceneCard(), this.hideSceneZone();
  }
  showSceneResources() {
    this.showSceneBaseStation(), this.showSceneCard(), this.showSceneZone();
  }
  setCardSpriteMapScale(t) {
    this.options.card_texture_scale = t;
  }
  setSpriteMapScale(t) {
    this.options.sprite_texture_scale = t;
  }
  // 获取当前场景摄像机的位置和视点
  getCameraParams() {
    const t = this.camera.position.clone(), i = this.controls.target.clone();
    return this.applyCoordinateTranslateInverse(t), this.applyCoordinateTranslateInverse(i), {
      camera_position: t,
      target_position: i
    };
  }
  setCameraParams(t, i) {
    const n = new b(t.x, t.y, t.z), s = new b(i.x, i.y, i.z);
    this.applyCoordinateTranslate(n), this.applyCoordinateTranslate(s), this.camera_animation.moveTo(n), this.camera_animation.lookAt(s);
  }
  getClickPointOnMap(t) {
    const i = new G();
    i.x = t.offsetX / this.dom.clientWidth * 2 - 1, i.y = -(t.offsetY / this.dom.clientHeight) * 2 + 1, this.raycaster.setFromCamera(i, this.camera);
    const n = this.raycaster.intersectObject(this.map_group, !0);
    if (n.length > 0)
      return n[0].point;
  }
  disposeLine2(t) {
    t.traverse((i) => {
      i.type === "Mesh" && (I(i).geometry.dispose(), Array.isArray(I(i).material) ? I(i).material.forEach(
        (n) => {
          n.dispose();
        }
      ) : I(i).material.dispose());
    });
  }
  createMeasureLineMesh(t, i, n) {
    const s = [], r = [];
    t.forEach((c) => {
      s.push(c.x, c.y + 0.5, c.z), r.push(...n);
    });
    const a = new ja();
    a.setPositions([s]), a.setColors([r]);
    const l = new Il(a, i);
    return l.computeLineDistances(), l.scale.set(1, 1, 1), l;
  }
  renderMeasureLine() {
    this.measure_line && (this.measure_line.removeFromParent(), this.disposeLine2(this.measure_line));
    const t = new As({
      linewidth: 5,
      // in pixels
      vertexColors: !0,
      resolution: new G(this.dom.clientWidth, this.dom.clientHeight),
      dashed: !1,
      alphaToCoverage: !1
    });
    this.measure_line = this.createMeasureLineMesh(this.measure_points, t, [0.98, 0.78, 0.25]), this.scene.add(this.measure_line);
  }
  createDashMeasureLine(t, i) {
    const n = new As({
      linewidth: 3,
      // in pixels
      vertexColors: !0,
      resolution: new G(this.dom.clientWidth, this.dom.clientHeight),
      dashed: !0,
      dashScale: 0.5,
      alphaToCoverage: !1
    });
    return this.createMeasureLineMesh([t, i], n, [0.2, 0.2, 0.2]);
  }
  addMeasureLabel(t) {
    let i;
    if (this.measure_points.length > 1) {
      const s = this.getPointsDistance(this.measure_points);
      i = ed(s);
    } else
      i = ed(void 0);
    const n = Mi(i, t);
    this.measure_label_list.push(n), this.scene.add(n);
  }
  getPointsDistance(t) {
    let i = 0;
    return t.reduce((n, s) => (n && (i += n.distanceTo(s)), s)), i;
  }
  createDashMeasureLabel(t) {
    const i = aM();
    return Mi(i, t);
  }
  createMeasureNotifyLabel() {
    const t = document.createElement("p");
    return t.innerHTML = "点击开始绘制", t.classList.add("measure-tool-notify"), t;
  }
  inMeasureClick(t) {
    t && (this.measure_points.push(t), this.addMeasureLabel(t), this.renderMeasureLine());
  }
  inMeasureMouseMove(t, i) {
    if (this.measure_notify_element || (this.measure_notify_element = this.createMeasureNotifyLabel(), this.dom.appendChild(this.measure_notify_element)), this.measure_notify_element.style.top = `${i.offsetY - 25}px`, this.measure_notify_element.style.left = `${i.offsetX + 10}px`, t) {
      if (this.dom.style.cursor = "crosshair", this.measure_points.length > 0)
        if (this.measure_notify_element.innerHTML = "点击继续，双击结束测量", this.measure_dash_line && (this.measure_dash_line.removeFromParent(), this.disposeLine2(this.measure_dash_line)), this.measure_dash_line = this.createDashMeasureLine(t, this.measure_points[this.measure_points.length - 1]), this.scene.add(this.measure_dash_line), this.measure_dash_label) {
          this.measure_dash_label.position.copy(t);
          let n = this.getPointsDistance(this.measure_points);
          n += t.distanceTo(this.measure_points[this.measure_points.length - 1]), this.measure_dash_label.element.firstChild.innerHTML = `${n.toFixed(2)} m`;
        } else
          this.measure_dash_label = this.createDashMeasureLabel(t), this.scene.add(this.measure_dash_label);
    } else
      this.dom.style.cursor = "default";
  }
  inMeasureDBClick() {
    this.measure_dash_label && (this.measure_dash_label.removeFromParent(), this.measure_dash_label.destroy()), this.measure_notify_element && this.dom.removeChild(this.measure_notify_element), this.measure_notify_element = void 0, this.measure_dash_line && (this.measure_dash_line.removeFromParent(), this.disposeLine2(this.measure_dash_line)), this._is_measure = !1, this.dom.style.cursor = "default";
  }
  enableMeasureTool() {
    this._is_measure = !0;
  }
  clearMeasureTool() {
    this.measure_label_list.forEach((t) => {
      t.removeFromParent(), t.destroy();
    }), this.measure_line && (this.measure_line.removeFromParent(), this.disposeLine2(this.measure_line)), this.measure_dash_line && (this.measure_dash_line.removeFromParent(), this.disposeLine2(this.measure_dash_line)), this.measure_dash_label && (this.measure_dash_label.removeFromParent(), this.measure_dash_label.destroy()), this.measure_dash_line = void 0, this.measure_line = void 0, this.measure_dash_label = void 0, this.measure_label_list = [], this.measure_points = [];
  }
  disableMeasureTool() {
    this._is_measure = !1, this.measure_notify_element && this.dom.removeChild(this.measure_notify_element), this.measure_notify_element = void 0, this.clearMeasureTool();
  }
  zoomOut() {
    const t = this.controls.target, i = this.camera.position, n = Qu(t, i, 0.8);
    this.camera_animation.moveTo(n, 500);
  }
  zoomIn() {
    const t = this.controls.target, i = this.camera.position, n = Qu(t, i, 1.2);
    this.camera_animation.moveTo(n, 500);
  }
  enableMeasureCoordinate() {
    this._is_measure_coordinates = !0;
  }
  disableMeasureCoordinate() {
    this._is_measure_coordinates = !1;
  }
  disableBuildingMouseEvents() {
    this._is_disable_building_mouse_event = !0;
  }
  enableBuildingMouseEvents() {
    this._is_disable_building_mouse_event = !1;
  }
  updateAllCylinderPositionWithCard() {
    var t, i, n;
    for (const s in this.all_cylinder_mesh_map) {
      const r = (t = this.all_cylinder_mesh_map[s]) == null ? void 0 : t.userData.model_card_id, a = (i = this.all_card[r]) == null ? void 0 : i.model;
      a && ((n = this.all_cylinder_mesh_map[s]) == null || n.position.copy(a.position.clone()));
    }
  }
  createCylinderEdge(t, i, n, s) {
    const r = new Ue(), a = [], l = 50;
    for (let d = 0; d <= l; d++) {
      const f = d * 2 * Math.PI / l, m = i * Math.cos(f), _ = i * Math.sin(f);
      a.push(m, t.y, _);
    }
    const c = new Float32Array(a);
    r.setAttribute("position", new $e(c, 3));
    const h = new mn({ color: n, opacity: s, transparent: !0, depthTest: !1 }), u = new Bn(r, h);
    return u.userData.origin_color = n, u;
  }
  addCylinder(t, i, n, s, r, a, l, c, h, u, d) {
    const f = `
    varying vec3 vPosition;
    void main() {
      vPosition = position;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `, m = `
    uniform float uRadius;
    varying vec3 vPosition;
    uniform vec3 uColor;
		uniform float uAlpha;
    void main() {
      float distanceFromCenter = length(vPosition.zx);
      float alpha = 1.0 - (distanceFromCenter / uRadius);
			alpha = 0.3 + alpha * (0.9 - 0.3);
      alpha = clamp(alpha, 0.3, 0.9);
			alpha *= uAlpha;
      gl_FragColor = vec4(uColor, alpha);
			gl_FragColor = linearToOutputTexel( gl_FragColor );
    }
  `, _ = new xt({
      vertexShader: f,
      fragmentShader: m,
      uniforms: {
        uColor: { value: new de(r).convertSRGBToLinear() },
        uRadius: { value: n },
        uAlpha: { value: a }
      },
      transparent: !0,
      depthTest: !1
    });
    if (this.all_cylinder_mesh_map[i]) {
      console.error("该圆柱体已经存在");
      return;
    }
    const p = new Ir(n, n, s, 50), g = new st(p, _);
    if (g.visible = !d, g.userData.model_id = i, g.userData.model_card_id = l, g.userData.model_type = Oe.Cylinder, c) {
      const v = sn({
        text: c,
        type: Oe.Cylinder,
        id: i,
        text_class: "cylinder-label"
      });
      u && v.classList.add(u);
      const M = Mi(v, new b(0, s / 2, 0));
      g.add(M), M.userData.model_card_id = l, this.all_cylinder_label_map[i] = M;
    }
    const x = this.getTransformedCoordinate(t.x, t.y, s / 2), y = this.getTransformedCoordinate(t.x, t.y, -s / 2);
    if (x.y = s / 2, y.y = -s / 2, g.add(this.createCylinderEdge(x, n, r, a)), g.add(this.createCylinderEdge(y, n, r, a)), g.position.set(...this.getTransformedCoordinate(t.x, t.y, t.z).toArray()), h ? this.floors[h].tag_group.add(g) : this.all_cylinder_mesh_group.add(g), this.all_cylinder_mesh_map[i] = g, this.options.buildings && h) {
      if (!this.floors[h]) {
        console.error("没有该楼层");
        return;
      }
      this.floors[h].tag_group.layers.test(this.camera.layers) ? this.floors[h].setTagGroupVisible(!0) : this.floors[h].setTagGroupVisible(!1);
    }
  }
  removeCylinder(t) {
    if (this.all_cylinder_mesh_map[t]) {
      const i = this.all_cylinder_mesh_map[t], n = this.all_cylinder_label_map[t];
      n && (n.destroy(), delete this.all_cylinder_label_map[t]), i && (i.removeFromParent(), delete this.all_cylinder_mesh_map[t]);
    } else
      console.error("该圆柱体不存在");
  }
  removeAllCylinder() {
    for (const t in this.all_cylinder_mesh_map)
      this.removeCylinder(t);
  }
  highlightCylinder(t, i = !1) {
    var r, a, l, c, h, u;
    const n = this.all_cylinder_mesh_map[t].children[0];
    n && ((a = (r = n == null ? void 0 : n.element) == null ? void 0 : r.classList) == null || a.add("highlight-cylinder-label")), i ? (c = (l = n == null ? void 0 : n.element) == null ? void 0 : l.classList) == null || c.add("click-highlight-cylinder-label") : (u = (h = n == null ? void 0 : n.element) == null ? void 0 : h.classList) == null || u.remove("click-highlight-cylinder-label"), this.all_cylinder_mesh_map[t].children.forEach((d) => {
      if (d.type === "Line") {
        const f = d.material;
        f.color.set("#00ffee"), f.transparent = !1;
      }
    });
  }
  removeHighlightCylinder(t) {
    var s, r, a, l;
    const i = this.all_cylinder_mesh_map[t].children[0];
    i && ((r = (s = i == null ? void 0 : i.element) == null ? void 0 : s.classList) == null || r.remove("highlight-cylinder-label")), i && ((l = (a = i == null ? void 0 : i.element) == null ? void 0 : a.classList) == null || l.remove("click-highlight-cylinder-label")), this.all_cylinder_mesh_map[t].children.forEach((c) => {
      if (c.type === "Line") {
        const h = c.material;
        h.color.set(c.userData.origin_color), h.transparent = !0;
      }
    });
  }
  setCylinderText(t, i, n, s) {
    var r, a, l, c;
    if (this.all_cylinder_label_map[t]) {
      const h = this.all_cylinder_label_map[t];
      h.element.innerHTML = i, n && ((a = (r = h == null ? void 0 : h.element) == null ? void 0 : r.classList) == null || a.remove(n)), s && ((c = (l = h == null ? void 0 : h.element) == null ? void 0 : l.classList) == null || c.add(s));
    } else
      console.log("该圆柱体不存在");
  }
  setAnimationSpeed(t) {
    if (t <= 0) {
      console.error("动画速度必须大于0");
      return;
    }
    this._animation_speed = Number(t);
  }
  destroy() {
    var t;
    this.event_controller.abort(), cancelAnimationFrame(this.next_frame_request), this.endAllTween(), this.stopPatrol(), this.stopThirdPersonFollow(), this.stopFollowCard(), this.resetAll(), this.scene.clear(), (t = this.controls) == null || t.dispose(), this.renderer.dispose(), this.renderer.forceContextLoss(), this.renderer.domElement.remove(), this.overview_map_renderer && (this.overview_map_renderer.dispose(), this.overview_map_renderer.forceContextLoss(), this.overview_map_renderer.domElement.remove()), this.overview_map_renderer_texture && (this.overview_map_renderer_texture.dispose(), this.overview_map_renderer_texture.domElement.remove()), this.label_renderer.domElement.remove(), this.outline_composer && this.outline_composer.dispose(), this.tile_renderers.forEach((i) => {
      i.dispose();
    }), this.scene.traverse((i) => {
      i instanceof st && (i.geometry.dispose(), Array.isArray(i.material) ? i.material.forEach((n) => n.dispose()) : i.material.dispose());
    }), Object.values(this.uniforms).forEach((i) => {
      i.value instanceof dt && i.value.dispose();
    }), this.stats && this.stats.dom.remove(), this.measure_notify_element && this.measure_notify_element.remove(), this.scene.clear();
  }
}
export {
  ni as Map,
  Gi as ModelFileType,
  Wt as ModelType
};
//# sourceMappingURL=HG3DMap.es.js.map
